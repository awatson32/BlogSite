(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var platypus_1 = require('platypus');
var home_vc_1 = require('../viewcontrols/home/home.vc');
var newentry_vc_1 = require('../viewcontrols/newentry/newentry.vc');
var MyApp = (function (_super) {
    __extends(MyApp, _super);
    function MyApp(router, config) {
        _super.call(this);
        config.routingType = config.STATE;
        router.configure([
            { pattern: '', view: home_vc_1.default },
            { pattern: 'newentry', view: newentry_vc_1.default }
        ]);
    }
    MyApp.prototype.error = function (ev) {
        console.log(ev.error);
    };
    return MyApp;
}(platypus_1.App));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = MyApp;
platypus_1.register.app('app', MyApp, [
    platypus_1.routing.Router,
    platypus_1.web.IBrowserConfig
]);

},{"../viewcontrols/home/home.vc":9,"../viewcontrols/newentry/newentry.vc":11,"platypus":14}],2:[function(require,module,exports){
"use strict";
require('platypus');
require('platypusui');
require('./app/app');

},{"./app/app":1,"platypus":14,"platypusui":15}],3:[function(require,module,exports){
"use strict";
var platypus_1 = require('platypus');
var BaseRepository = (function () {
    function BaseRepository() {
    }
    BaseRepository._inject = {
        utils: platypus_1.Utils
    };
    return BaseRepository;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BaseRepository;

},{"platypus":14}],4:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var platypus_1 = require('platypus');
var base_repo_1 = require('../base/base.repo');
var entries_svc_1 = require('../../services/entries/entries.svc');
var PostsRepository = (function (_super) {
    __extends(PostsRepository, _super);
    function PostsRepository(entriesService) {
        _super.call(this);
        this.entriesService = entriesService;
    }
    PostsRepository.prototype.getPosts = function () {
        return this.entriesService.getPosts();
    };
    PostsRepository.prototype.submitPost = function (post) {
        return this.entriesService.submitPost(post);
    };
    PostsRepository.prototype.getPost = function (postId) {
        return this.entriesService.getPost(postId);
    };
    return PostsRepository;
}(base_repo_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = PostsRepository;
platypus_1.register.injectable('posts-repo', PostsRepository, [entries_svc_1.default]);

},{"../../services/entries/entries.svc":6,"../base/base.repo":3,"platypus":14}],5:[function(require,module,exports){
"use strict";
var platypus_1 = require('platypus');
var BaseService = (function () {
    function BaseService() {
        this.host = 'http://localhost:4000/api';
    }
    BaseService._inject = {
        http: platypus_1.async.Http,
        Promise: platypus_1.async.IPromise,
        utils: platypus_1.Utils
    };
    return BaseService;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BaseService;

},{"platypus":14}],6:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var platypus_1 = require('platypus');
var base_svc_1 = require('../base/base.svc');
var EntriesService = (function (_super) {
    __extends(EntriesService, _super);
    function EntriesService() {
        _super.apply(this, arguments);
    }
    EntriesService.prototype.getPosts = function () {
        return this.http.json({
            method: 'GET',
            url: this.host + '/posts',
        }).then(function (success) {
            return success.response;
        }, function (err) {
            console.log(err);
            throw err;
        });
    };
    EntriesService.prototype.submitPost = function (blogPost) {
        return this.http.json({
            method: 'POST',
            url: this.host + '/posts',
            data: blogPost
        }).then(function (success) {
            return success.response;
        }, function (err) {
            console.log(err);
            throw err;
        });
    };
    EntriesService.prototype.getPost = function (postId) {
        return this.http.json({
            method: 'GET',
            url: this.host + '/posts/' + postId
        }).then(function (success) {
            return success.response;
        }, function (err) {
            console.log(err);
            throw err;
        });
    };
    return EntriesService;
}(base_svc_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = EntriesService;
platypus_1.register.injectable('entries-svc', EntriesService);

},{"../base/base.svc":5,"platypus":14}],7:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var platypus_1 = require('platypus');
var BaseViewControl = (function (_super) {
    __extends(BaseViewControl, _super);
    function BaseViewControl() {
        _super.apply(this, arguments);
        this.context = {};
    }
    return BaseViewControl;
}(platypus_1.ui.ViewControl));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BaseViewControl;

},{"platypus":14}],8:[function(require,module,exports){
module.exports = "<span class=\"button-container\">\n    <plat-button class=\"button-primary button-outline\" plat-tap=\"newPost()\">New Post</plat-button>\n</span>\n<plat-foreach plat-context=\"posts\" class=\"post-list\">\n    <div class=\"post\">\n        <h1>{{title}}</h1>\n        <h3>{{author}}</h3>\n        <h3>{{createdAt}}</h3>\n        <plat-button class=\"button-primary button-outline\" plat-tap=\"singlePost()\">Read More</plat-button>\n    </div>\n</plat-foreach>\n";

},{}],9:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var platypus_1 = require('platypus');
var base_vc_1 = require('../base/base.vc');
var posts_repo_1 = require('../../repositories/posts/posts.repo');
var newentry_vc_1 = require('../newentry/newentry.vc');
var singlepost_vc_1 = require('../singlepost/singlepost.vc');
var HomeViewControl = (function (_super) {
    __extends(HomeViewControl, _super);
    function HomeViewControl(postRepo) {
        _super.call(this);
        this.postRepo = postRepo;
        this.templateString = require('./home.vc.html');
        this.context = {
            posts: [],
            composeView: newentry_vc_1.default
        };
    }
    ;
    HomeViewControl.prototype.navigatedTo = function () {
        var _this = this;
        this.postRepo.getPosts().then(function (posts) {
            console.log(posts);
            _this.context.posts = posts;
        }, function (err) {
            console.log(err);
        });
    };
    HomeViewControl.prototype.newPost = function () {
        this.navigator.navigate(newentry_vc_1.default);
    };
    HomeViewControl.prototype.singlePost = function (postId) {
        console.log('This is working');
        this.navigator.navigate(singlepost_vc_1.default, {
            parameters: {
                someId: postId
            }
        });
    };
    return HomeViewControl;
}(base_vc_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HomeViewControl;
platypus_1.register.viewControl('home-vc', HomeViewControl, [posts_repo_1.default]);

},{"../../repositories/posts/posts.repo":4,"../base/base.vc":7,"../newentry/newentry.vc":11,"../singlepost/singlepost.vc":13,"./home.vc.html":8,"platypus":14}],10:[function(require,module,exports){
module.exports = "<div class=\"input-group-container\" id=\"post-container\">\n    <div class=\"input-group\" id=\"new-blog\">\n        <plat-input type=\"text\" placeholder=\"Title\" plat-bind=\"title\"></plat-input>\n        <plat-input type=\"text\" placeholder=\"Author\" plat-bind=\"author\"></plat-input>\n        <plat-input type=\"text\" placeholder=\"What's happening?\" plat-bind=\"content\"></plat-input>\n        <plat-button plat-tap=\"submit()\" class=\"button-primary button-outline\">Submit</plat-button>\n    </div>\n</div>\n";

},{}],11:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var platypus_1 = require('platypus');
var base_vc_1 = require('../base/base.vc');
var posts_repo_1 = require('../../repositories/posts/posts.repo');
var home_vc_1 = require('../home/home.vc');
var NewentryViewControl = (function (_super) {
    __extends(NewentryViewControl, _super);
    function NewentryViewControl(postRepo) {
        _super.call(this);
        this.postRepo = postRepo;
        this.templateString = require('./newentry.vc.html');
        this.context = {
            title: '',
            author: '',
            content: ''
        };
    }
    NewentryViewControl.prototype.submit = function () {
        var _this = this;
        console.log('We are posting!');
        var blogPost = {
            title: this.context.title,
            author: this.context.author,
            content: this.context.content
        };
        this.postRepo.submitPost(blogPost).then(function (success) {
            console.log(success);
            _this.navigator.navigate(home_vc_1.default);
        }, function (err) {
            console.log(err);
        });
    };
    return NewentryViewControl;
}(base_vc_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = NewentryViewControl;
platypus_1.register.viewControl('newentry-vc', NewentryViewControl, [posts_repo_1.default]);

},{"../../repositories/posts/posts.repo":4,"../base/base.vc":7,"../home/home.vc":9,"./newentry.vc.html":10,"platypus":14}],12:[function(require,module,exports){
module.exports = "<h1>{{post.title}}</h1>\n<h2>{{post.author}}</h2>\n<h3>{{post.createdAt}}</h3>\n<p>{{post.content}}</p>";

},{}],13:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var platypus_1 = require('platypus');
var base_vc_1 = require('../base/base.vc');
var posts_repo_1 = require('../../repositories/posts/posts.repo');
var SinglepostViewControl = (function (_super) {
    __extends(SinglepostViewControl, _super);
    function SinglepostViewControl(postRepo) {
        _super.call(this);
        this.postRepo = postRepo;
        this.templateString = require('./singlepost.vc.html');
        this.context = {
            post: {}
        };
    }
    SinglepostViewControl.prototype.navigatedTo = function (parameters) {
        var _this = this;
        var idValue = parameters.someid;
        this.postRepo.getPost(idValue).then(function (success) {
            _this.context.post = success;
        }, function (err) {
            console.log(err);
        });
    };
    return SinglepostViewControl;
}(base_vc_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = SinglepostViewControl;
platypus_1.register.viewControl('singlepost-vc', SinglepostViewControl, [posts_repo_1.default]);

},{"../../repositories/posts/posts.repo":4,"../base/base.vc":7,"./singlepost.vc.html":12,"platypus":14}],14:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/* tslint:disable */
/**
 * PlatypusTS v0.20.4 (https://platypi.io)
 * Copyright 2015 Platypi, LLC. All rights reserved.
 *
 * PlatypusTS is licensed under the MIT license found at
 * https://github.com/Platypi/platypusts/blob/master/LICENSE
 *
 */
/**
 * The entry point into the platypus library.
 */
var plat;
(function (plat_1) {
    'use strict;';
    /* tslint:disable:no-unused-variable */
    /*
     */
    var __prefix = '$', __CONTEXT = 'context', __AppStatic = __prefix + 'AppStatic', __App = __prefix + 'App', __Http = __prefix + 'Http', __HttpRequestInstance = __prefix + 'HttpRequestInstance', __HttpConfig = __prefix + 'HttpConfig', __Promise = __prefix + 'Promise', __Compat = __prefix + 'Compat', __ControlFactory = __prefix + 'ControlFactory', __AttributeControlFactory = __prefix + 'AttributeControlFactory', __Document = __prefix + 'Document', __DispatchEventInstance = __prefix + 'DispatchEventInstance', __ErrorEventStatic = __prefix + 'ErrorEventStatic', __EventManagerStatic = __prefix + 'EventManagerStatic', __LifecycleEventStatic = __prefix + 'LifecycleEventStatic', __LifecycleEventInstance = __prefix + 'LifecycleEventInstance', __Log = __prefix + 'Log', __Parser = __prefix + 'Parser', __Regex = __prefix + 'Regex', __Tokenizer = __prefix + 'Tokenizer', __NavigatorInstance = __prefix + 'NavigatorInstance', __ContextManagerStatic = __prefix + 'ContextManagerStatic', __ContextManagerInstance = __prefix + 'ContextManagerInstance', __Compiler = __prefix + 'Compiler', __CommentManagerFactory = __prefix + 'CommentManagerFactory', __CommentManagerInstance = __prefix + 'CommentManagerInstance', __ElementManagerFactory = __prefix + 'ElementManagerFactory', __ElementManagerInstance = __prefix + 'ElementManagerInstance', __NodeManagerStatic = __prefix + 'NodeManagerStatic', __TextManagerFactory = __prefix + 'TextManagerFactory', __TextManagerInstance = __prefix + 'TextManagerInstance', __CacheFactory = __prefix + 'CacheFactory', __ManagerCache = __prefix + 'ManagerCache', __TemplateCache = __prefix + 'TemplateCache', __Animator = __prefix + 'Animator', __AttributesFactory = __prefix + 'AttributesFactory', __AttributesInstance = __prefix + 'AttributesInstance', __BindableTemplatesFactory = __prefix + 'BindableTemplatesFactory', __Dom = __prefix + 'Dom', __DomEvents = __prefix + 'DomEvents', __IDomEventsConfig = __prefix + 'IDomEventsConfig', __DomEventInstance = __prefix + 'DomEventInstance', __ResourcesFactory = __prefix + 'ResourcesFactory', __ResourcesInstance = __prefix + 'ResourcesInstance', __TemplateControlFactory = __prefix + 'TemplateControlFactory', __TemplateControlInstance = __prefix + 'TemplateControlInstance', __Utils = __prefix + 'Utils', __Browser = __prefix + 'Browser', __BrowserConfig = __prefix + 'BrowserConfig', __Router = __prefix + 'Router', __RouterStatic = __prefix + 'RouterStatic', __UrlUtilsInstance = __prefix + 'UrlUtilsInstance', __Window = __prefix + 'Window', __LocalStorage = __prefix + 'LocalStorage', __SessionStorage = __prefix + 'SessionStorage', __Geolocation = __prefix + 'Geolocation', __BaseSegmentFactory = __prefix + 'BaseSegmentFactory', __BaseSegmentInstance = __prefix + 'BaseSegmentInstance', __StaticSegmentInstance = __prefix + 'StaticSegmentInstance', __VariableSegmentInstance = __prefix + 'VariableSegmentInstance', __DynamicSegmentInstance = __prefix + 'DynamicSegmentInstance', __SplatSegmentInstance = __prefix + 'SplatSegmentInstance', __StateStatic = __prefix + 'StateStatic', __StateInstance = __prefix + 'StateInstance', __RouteRecognizerInstance = __prefix + 'RouteRecognizerInstance', __InjectorStatic = __prefix + 'InjectorStatic', __History = __prefix + 'History', __Location = __prefix + 'Location', 
    /**
     */
    __Plat = 'plat-', __Bind = __Plat + 'bind', __Href = __Plat + 'href', __Src = __Plat + 'src', __KeyDown = __Plat + 'keydown', __KeyPress = __Plat + 'keypress', __KeyUp = __Plat + 'keyup', __CharPress = __Plat + 'charpress', __Name = __Plat + 'name', __Options = __Plat + 'options', __Checked = __Plat + 'checked', __Disabled = __Plat + 'disabled', __Selected = __Plat + 'selected', __ReadOnly = __Plat + 'readonly', __Visible = __Plat + 'visible', __Style = __Plat + 'style', __Tap = __Plat + 'tap', __Blur = __Plat + 'blur', __Change = __Plat + 'change', __Copy = __Plat + 'copy', __Cut = __Plat + 'cut', __Paste = __Plat + 'paste', __DblTap = __Plat + 'dbltap', __Focus = __Plat + 'focus', __Submit = __Plat + 'submit', __TouchStart = __Plat + 'touchstart', __TouchEnd = __Plat + 'touchend', __TouchMove = __Plat + 'touchmove', __TouchCancel = __Plat + 'touchcancel', __Hold = __Plat + 'hold', __Release = __Plat + 'release', __Swipe = __Plat + 'swipe', __SwipeLeft = __Plat + 'swipeleft', __SwipeRight = __Plat + 'swiperight', __SwipeUp = __Plat + 'swipeup', __SwipeDown = __Plat + 'swipedown', __Track = __Plat + 'track', __TrackLeft = __Plat + 'trackleft', __TrackRight = __Plat + 'trackright', __TrackUp = __Plat + 'trackup', __TrackDown = __Plat + 'trackdown', __TrackEnd = __Plat + 'trackend', __React = __Plat + 'react', __Link = __Plat + 'link', __ForEach = __Plat + 'foreach', __Html = __Plat + 'html', __If = __Plat + 'if', __Ignore = __Plat + 'ignore', __Select = __Plat + 'select', __Template = __Plat + 'template', __Routeport = __Plat + 'routeport', __Viewport = __Plat + 'viewport', __Control = __Plat + 'control', __ViewControl = __Plat + 'viewcontrol', __Resources = __Plat + 'resources', __Context = __Plat + __CONTEXT, __TemplateContext = __Template + '-' + __CONTEXT, __Callback = __Plat + 'callback', __AttributePrefix = 'data-', 
    /**
     */
    __TemplateControlCache = '__templateControlCache', __Head = 'head', __Meta = 'meta', __Title = 'title', __Description = 'description', __Author = 'author', __Creator = 'creator', __MetaLink = 'link', __MetaHref = 'href', __MetaName = 'name', __MetaProperty = 'property', __MetaImage = 'image', __MetaVideo = 'video', __MetaType = 'type', __Rel = 'rel', __Url = 'url', __Article = 'article:', __OpenGraph = 'og:', __Twitter = 'twitter:', __Content = 'content', 
    /**
     */
    __ready = 'ready', __suspend = 'suspend', __resume = 'resume', __online = 'online', __offline = 'offline', __error = 'error', __shutdown = 'shutdown', __exiting = 'exiting', __beforeLoad = 'beforeLoad', 
    /**
     */
    __beforeNavigate = 'beforeNavigate', __navigated = 'navigated', __navigating = 'navigating', __beforeRouteChange = 'beforeRouteChange', __routeChanged = 'routeChanged', __urlChanged = 'urlChanged', 
    /**
     */
    __pause = 'pause', __deviceReady = 'deviceReady', __backButton = 'backbutton', __backClick = 'backclick', __backButtonPressed = 'backButtonPressed', 
    /**
     */
    __Hide = __Plat + 'hide', __Animating = __Plat + 'animating', __SimpleAnimation = __Plat + 'animation', __SimpleTransition = __Plat + 'transition', __Enter = __Plat + 'enter', __Leave = __Plat + 'leave', __Move = __Plat + 'move', __FadeIn = __Plat + 'fadein', __FadeOut = __Plat + 'fadeout', __NavigatingBack = __Plat + 'back-nav', 
    /**
     */
    __event_prefix = '$', __tap = __event_prefix + 'tap', __dbltap = __event_prefix + 'dbltap', __touchstart = __event_prefix + 'touchstart', __touchend = __event_prefix + 'touchend', __touchmove = __event_prefix + 'touchmove', __touchcancel = __event_prefix + 'touchcancel', __hold = __event_prefix + 'hold', __release = __event_prefix + 'release', __swipe = __event_prefix + 'swipe', __swipeleft = __event_prefix + 'swipeleft', __swiperight = __event_prefix + 'swiperight', __swipeup = __event_prefix + 'swipeup', __swipedown = __event_prefix + 'swipedown', __track = __event_prefix + 'track', __trackleft = __event_prefix + 'trackleft', __trackright = __event_prefix + 'trackright', __trackup = __event_prefix + 'trackup', __trackdown = __event_prefix + 'trackdown', __trackend = __event_prefix + 'trackend', 
    /**
     */
    __errorSuffix = 'Error', __platError = 'Plat' + __errorSuffix, __parseError = 'Parsing' + __errorSuffix, __bindError = 'Binding' + __errorSuffix, __compileError = 'Compiling' + __errorSuffix, __nameError = 'PlatName' + __errorSuffix, __navigationError = 'Navigating' + __errorSuffix, __templateError = 'Templating' + __errorSuffix, __contextError = 'Context' + __errorSuffix, __eventError = 'DispatchEvent' + __errorSuffix, __injectableError = 'Injectable' + __errorSuffix, __CompatError = 'Compatibility' + __errorSuffix, 
    /**
     */
    __forEachAliasOptions = {
        index: 'index',
        even: 'even',
        odd: 'odd',
        first: 'first',
        last: 'last'
    }, 
    /**
     */
    __BASE_SEGMENT_TYPE = 'base', __VARIABLE_SEGMENT_TYPE = 'variable', __STATIC_SEGMENT_TYPE = 'static', __SPLAT_SEGMENT_TYPE = 'splat', __DYNAMIC_SEGMENT_TYPE = 'dynamic', 
    /**
     */
    __CONTEXT_CHANGED_PRIORITY = 1000, __startSymbol = '{{', __endSymbol = '}}', __STATIC = 'static', __SINGLETON = 'singleton', __INSTANCE = 'instance', __FACTORY = 'factory', __CLASS = 'class', __CSS = 'css', __COMPILED = '-compiled', __BOUND_PREFIX = '-@', __INIT_SUFFIX = '-init', __START_NODE = ': start node', __END_NODE = ': end node', __POPSTATE = 'popstate', __HASHCHANGE = 'hashchange', __WRAPPED_INJECTOR = 'wrapped', __JSONP_CALLBACK = 'plat_callback', __JS = 'js', __NOOP_INJECTOR = 'noop', __APP = '__app__', __RESOURCE = 'resource', __RESOURCES = __RESOURCE + 's', __ALIAS = 'alias', __ALIASES = __ALIAS + 'es', __OBSERVABLE_RESOURCE = 'observable', __INJECTABLE_RESOURCE = 'injectable', __OBJECT_RESOURCE = 'object', __FUNCTION_RESOURCE = 'function', __LITERAL_RESOURCE = 'literal', __ROOT_RESOURCE = 'root', __ROOT_CONTEXT_RESOURCE = 'rootContext', __CONTROL_RESOURCE = 'control', __CONTEXT_RESOURCE = __CONTEXT;
    /* tslint:disable:no-unused-variable */
    var ___Promise, ___compat, __camelCaseRegex, __capitalCaseRegex, __nativeIsArray = !!Array.isArray;
    var __uids = {}, __objToString = Object.prototype.toString, __toStringClass = '[object ', __errorClass = __toStringClass + 'Error]', __fileClass = __toStringClass + 'File]', __arrayClass = __toStringClass + 'Array]', __boolClass = __toStringClass + 'Boolean]', __dateClass = __toStringClass + 'Date]', __funcClass = __toStringClass + 'Function]', __numberClass = __toStringClass + 'Number]', __objectClass = __toStringClass + 'Object]', __regexpClass = __toStringClass + 'RegExp]', __stringClass = __toStringClass + 'String]', __promiseClass = __toStringClass + 'Promise]', __objectTypes = {
        'boolean': false,
        'function': true,
        'object': true,
        'number': false,
        'string': false,
        'undefined': false
    };
    function noop() { }
    function _defineProperty(obj, key, value, enumerable, configurable, writable) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: enumerable === true,
            configurable: configurable === true,
            writable: writable === true
        });
    }
    function _defineGetter(obj, key, value, enumerable, configurable) {
        Object.defineProperty(obj, key, {
            get: function () { return value; },
            enumerable: enumerable === true,
            configurable: configurable === true
        });
    }
    function _extend(deep, redefine, destination) {
        var sources = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            sources[_i - 3] = arguments[_i];
        }
        if (isNull(destination)) {
            return destination;
        }
        var keys, property, define;
        if (isFunction(redefine)) {
            define = redefine;
        }
        else if (redefine) {
            define = function (obj, key, value) {
                _defineProperty(obj, key, value, true, true, true);
            };
        }
        else {
            define = function (obj, key, value) {
                obj[key] = value;
            };
        }
        if (isEmpty(sources)) {
            sources.push(destination);
        }
        forEach(function (source, k) {
            if (!isObject(source)) {
                return;
            }
            keys = Object.keys(source);
            forEach(function (key) {
                property = source[key];
                if (deep) {
                    if (isArray(property)) {
                        _extend(deep, define, destination[key] || (destination[key] = []), property);
                        return;
                    }
                    else if (isDate(property)) {
                        define(destination, key, new Date(property.getTime()));
                        return;
                    }
                    else if (isRegExp(property)) {
                        define(destination, key, new RegExp(property));
                        return;
                    }
                    else if (isNode(property)) {
                        define(destination, key, property.cloneNode(true));
                        return;
                    }
                    else if (isFile(property)) {
                        define(destination, key, property);
                        return;
                    }
                    else if (isObject(property)) {
                        _extend(deep, define, destination[key] || (destination[key] = {}), property);
                        return;
                    }
                }
                define(destination, key, property);
            }, keys);
        }, sources);
        return destination;
    }
    function _clone(obj, deep) {
        if (!isObject(obj)) {
            return obj;
        }
        else if (isDate(obj)) {
            return new Date(obj.getTime());
        }
        else if (isRegExp(obj)) {
            return new RegExp(obj);
        }
        else if (isNode(obj)) {
            return obj.cloneNode(deep);
        }
        else if (isFile(obj)) {
            return obj;
        }
        else if (isError(obj)) {
            return new obj.constructor(obj.message);
        }
        var type = {};
        if (isArray(obj)) {
            type = [];
        }
        if (isBoolean(deep) && deep) {
            return _extend(true, false, type, obj);
        }
        return _extend(false, false, type, obj);
    }
    function isError(obj) {
        return __objToString.call(obj) === __errorClass;
    }
    function isObject(obj) {
        return obj != null && typeof obj === 'object';
    }
    function isWindow(obj) {
        return !!(obj && obj.document && obj.setInterval);
    }
    function isDocument(obj) {
        return !!(obj && obj.nodeType === Node.DOCUMENT_NODE);
    }
    function isNode(obj) {
        return !!(obj && typeof obj.nodeType === 'number');
    }
    function isDocumentFragment(obj) {
        return !!(obj && obj.nodeType === Node.DOCUMENT_FRAGMENT_NODE);
    }
    function isFile(obj) {
        return isObject(obj) && __objToString.call(obj) === __fileClass;
    }
    function isString(obj) {
        return typeof obj === 'string' || isObject(obj) && __objToString.call(obj) === __stringClass;
    }
    function isRegExp(obj) {
        return isObject(obj) && __objToString.call(obj) === __regexpClass;
    }
    function isPromise(obj) {
        return isObject(obj) && (__objToString.call(obj) === __promiseClass || isFunction(obj.then));
    }
    function isEmpty(obj) {
        if (isNull(obj)) {
            return true;
        }
        if (isString(obj) || isArray(obj)) {
            return obj.length === 0;
        }
        if (!isObject(obj)) {
            return false;
        }
        return Object.keys(obj).length === 0;
    }
    function isBoolean(obj) {
        return obj === true || obj === false || isObject(obj) && __objToString.call(obj) === __boolClass;
    }
    function isNumber(obj) {
        return (typeof obj === 'number' || isObject(obj) && __objToString.call(obj) === __numberClass) && !isNaN(obj);
    }
    function isFunction(obj) {
        return typeof obj === 'function';
    }
    function isNull(obj) {
        return obj === null || obj === undefined;
    }
    function isUndefined(obj) {
        return obj === undefined;
    }
    function isArray(obj) {
        if (__nativeIsArray) {
            return Array.isArray(obj);
        }
        return __objToString.call(obj) === __arrayClass;
    }
    function isArrayLike(obj) {
        if (isNull(obj) || isWindow(obj) || isFunction(obj)) {
            return false;
        }
        return isString(obj) || obj.length >= 0;
    }
    function isDate(obj) {
        return typeof obj === 'object' && __objToString.call(obj) === __dateClass;
    }
    function filter(iterator, obj, context) {
        var arr = [];
        if (isNull(obj)) {
            return arr;
        }
        if (isFunction(obj.filter)) {
            return obj.filter(iterator, context);
        }
        forEach(function (value, key, obj) {
            if (iterator(value, key, obj)) {
                arr.push(value);
            }
        }, obj);
        return arr;
    }
    function where(properties, obj) {
        return filter(function (value) {
            return !some(function (property, key) {
                return value[key] !== property;
            }, properties);
        }, obj);
    }
    function forEach(iterator, obj, context) {
        if (isNull(obj) || !(isObject(obj) || isArrayLike(obj))) {
            return obj;
        }
        var i, key, length;
        if (isFunction(obj.forEach)) {
            return obj.forEach(iterator, context);
        }
        else if (isArrayLike(obj)) {
            for (i = 0, length = obj.length; i < length; ++i) {
                iterator.call(context, obj[i], i, obj);
            }
        }
        else {
            var keys = Object.keys(obj);
            length = keys.length;
            while (keys.length > 0) {
                key = keys.shift();
                iterator.call(context, obj[key], key, obj);
            }
        }
        return obj;
    }
    function map(iterator, obj, context) {
        var arr = [];
        if (isNull(obj)) {
            return arr;
        }
        if (isFunction(obj.map)) {
            return obj.map(iterator, context);
        }
        forEach(function (value, key) {
            arr.push(iterator.call(context, value, key, obj));
        }, obj);
        return arr;
    }
    function mapAsync(iterator, obj, context) {
        ___Promise = ___Promise || plat.acquire(__Promise);
        return ___Promise.all(map(iterator, obj, context));
    }
    function mapAsyncWithOrder(iterator, array, context, descending) {
        ___Promise = ___Promise || plat.acquire(__Promise);
        var initialValue = ___Promise.resolve([]);
        if (!isArray(array)) {
            return initialValue;
        }
        iterator = iterator.bind(context);
        var inOrder = function (previousValue, nextValue, nextIndex, array) {
            return previousValue.then(function (items) {
                return iterator(nextValue, nextIndex, array).then(function (moreItems) {
                    return items.concat(moreItems);
                });
            });
        };
        if (descending === true) {
            return array.reduceRight(inOrder, initialValue);
        }
        return array.reduce(inOrder, initialValue);
    }
    function mapAsyncInOrder(iterator, array, context) {
        return mapAsyncWithOrder(iterator, array, context);
    }
    function mapAsyncInDescendingOrder(iterator, array, context) {
        return mapAsyncWithOrder(iterator, array, context, true);
    }
    function pluck(key, obj) {
        return map(function (value) { return value[key]; }, obj);
    }
    function some(iterator, obj, context) {
        if (isNull(obj) || isFunction(obj)) {
            return false;
        }
        var i, key, length, ret;
        if (isFunction(obj.some)) {
            return obj.some(iterator, context);
        }
        else if (isArrayLike(obj)) {
            for (i = 0, length = obj.length; i < length; ++i) {
                ret = iterator.call(context, obj[i], i, obj);
                if (ret === true) {
                    return true;
                }
            }
        }
        else {
            var keys = Object.keys(obj);
            length = keys.length;
            while (keys.length > 0) {
                key = keys.shift();
                ret = iterator.call(context, obj[key], key, obj);
                if (ret === true) {
                    return true;
                }
            }
        }
        return false;
    }
    function postpone(method, args, context) {
        return defer(method, 0, args, context);
    }
    function defer(method, timeout, args, context) {
        function execDefer() {
            method.apply(context, args);
        }
        var timeoutId = setTimeout(execDefer, timeout);
        return function () {
            clearTimeout(timeoutId);
        };
    }
    function setIntervalGlobal(method, interval, args, context) {
        function execInterval() {
            method.apply(context, args);
        }
        var intervalId = setInterval(execInterval, interval);
        return function () {
            clearInterval(intervalId);
        };
    }
    function requestAnimationFrameGlobal(method, context) {
        ___compat = ___compat || (plat.acquire(__Compat));
        var requestAnimFrame = ___compat.requestAnimationFrame;
        if (isUndefined(requestAnimFrame)) {
            return postpone(function () {
                method.call(context, Date.now());
            });
        }
        var animationId = requestAnimFrame(method.bind(context)), cancelAnimFrame = ___compat.cancelAnimationFrame || noop;
        return function () {
            cancelAnimFrame(animationId);
        };
    }
    function uniqueId(prefix) {
        if (isNull(prefix)) {
            prefix = '';
        }
        var puid = __uids[prefix];
        if (isNull(puid)) {
            puid = __uids[prefix] = ['0', '/'];
        }
        var index = puid.length, charCode;
        while (index--) {
            charCode = puid[index].charCodeAt(0);
            // '9' 
            if (charCode === 57) {
                puid[index] = 'A';
                return join();
            }
            // 'Z' 
            if (charCode === 90) {
                puid[index] = 'a';
                return join();
            }
            // 'z' 
            if (charCode === 122) {
                puid[index] = '0';
            }
            else {
                puid[index] = String.fromCharCode(charCode + 1);
                return join();
            }
        }
        puid.unshift('0');
        function join() {
            return prefix + puid.join('');
        }
        return join();
    }
    function camelCase(str) {
        if (!isString(str) || isEmpty(str)) {
            return str;
        }
        str = str.charAt(0).toLowerCase() + str.slice(1);
        __camelCaseRegex = __camelCaseRegex || plat.acquire(__Regex).camelCaseRegex;
        return str.replace(__camelCaseRegex, function (match, delimiter, char, index) {
            return index ? char.toUpperCase() : char;
        });
    }
    function delimit(str, delimiter) {
        if (!isString(str) || isEmpty(str)) {
            return str;
        }
        else if (isNull(delimiter)) {
            delimiter = '';
        }
        __capitalCaseRegex = __capitalCaseRegex || plat.acquire(__Regex).capitalCaseRegex;
        return str.replace(__capitalCaseRegex, function (match, index) {
            return index ? delimiter + match.toLowerCase() : match.toLowerCase();
        });
    }
    function deleteProperty(obj, property) {
        if (!isNull(obj)) {
            /* tslint:disable:no-unused-expression */
            delete obj[property];
        }
        return obj;
    }
    function access(obj, property) {
        if (isNull(obj)) {
            return obj;
        }
        return obj[property];
    }
    function deserializeQuery(search) {
        if (isEmpty(search)) {
            return;
        }
        var split = search.split('&'), query = {}, length = split.length, item;
        for (var i = 0; i < length; ++i) {
            item = split[i].split('=');
            query[item[0]] = item[1];
        }
        return query;
    }
    function serializeQuery(query) {
        var q = '';
        q += map(function (value, key) {
            return key + '=' + value;
        }, query).join('&');
        if (!isEmpty(q)) {
            q = '?' + q;
        }
        return q;
    }
    function booleanReduce(values) {
        if (!isArray(values)) {
            return isBoolean(values) ? values : true;
        }
        return values.reduce(function (prev, current) {
            return prev && current !== false;
        }, true);
    }
    /* tslint:enable:no-unused-variable */
    /* tslint:disable:no-unused-variable */
    var ___document, ___templateCache, ___http, ___log;
    var __nodeNameRegex = /<([\w:]+)/, __whiteSpaceRegex = /\s+/g, __option = [1, '<select multiple="multiple">', '</select>'], __table = [1, '<table>', '</table>'], __tableData = [3, '<table><tbody><tr>', '</tr></tbody></table>'], __svg = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">', '</svg>'], __innerTableWrappers = {
        thead: __table,
        tbody: __table,
        tfoot: __table,
        colgroup: __table,
        caption: __table,
        tr: [2, '<table><tbody>', '</tbody></table>'],
        col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
        td: __tableData,
        th: __tableData
    }, __innerHtmlWrappers = _extend(false, false, {}, __innerTableWrappers, {
        option: __option,
        optgroup: __option,
        legend: [1, '<fieldset>', '</fieldset>'],
        area: [1, '<map>', '</map>'],
        param: [1, '<object>', '</object>'],
        text: __svg,
        circle: __svg,
        ellipse: __svg,
        line: __svg,
        path: __svg,
        polygon: __svg,
        polyline: __svg,
        rect: __svg,
        _default: [0, '', '']
    });
    function appendChildren(nodeList, root, clone) {
        var isFragment = isDocumentFragment(root), nullRoot = !isNode(root), fragment = isFragment ?
            root :
            (___document || (___document = plat.acquire(__Document))).createDocumentFragment();
        if (nullRoot) {
            root = fragment;
        }
        var list = isArray(nodeList) ? nodeList : Array.prototype.slice.call(nodeList), length = list.length, i;
        if (clone === true) {
            var item = void 0;
            for (i = 0; i < length; ++i) {
                item = list[i].cloneNode(true);
                fragment.insertBefore(item, null);
            }
        }
        else {
            for (i = 0; i < length; ++i) {
                fragment.insertBefore(list[i], null);
            }
        }
        if (!(isFragment || nullRoot)) {
            root.appendChild(fragment);
        }
        return root;
    }
    function clearNode(node) {
        var childNodes = Array.prototype.slice.call(node.childNodes);
        while (childNodes.length > 0) {
            node.removeChild(childNodes.pop());
        }
    }
    function clearNodeBlock(nodeList, parent) {
        if (!isFunction(nodeList.push)) {
            nodeList = Array.prototype.slice.call(nodeList);
        }
        if (!isNull(parent)) {
            clearNodeBlockWithParent(nodeList, parent);
            return;
        }
        var node;
        while (nodeList.length > 0) {
            node = nodeList.pop();
            parent = node.parentNode;
            if (isNull(parent)) {
                continue;
            }
            parent.removeChild(node);
        }
    }
    function clearNodeBlockWithParent(nodeList, parent) {
        while (nodeList.length > 0) {
            parent.removeChild(nodeList.pop());
        }
    }
    function stringToNode(html) {
        // ___compat is a global variable in utilsglobal 
        ___compat = ___compat || (___compat = plat.acquire(__Compat));
        ___document = ___document || (___document = plat.acquire(__Document));
        var nodeName = __nodeNameRegex.exec(html), element = ___document.createElement('div');
        if (isNull(nodeName)) {
            element = innerHtml(element, html);
            return element.removeChild(element.lastChild);
        }
        // trim html string 
        html = html.trim();
        var mapTag = nodeName[1];
        if (___compat.pushState && isUndefined(__innerTableWrappers[mapTag])) {
            return innerHtml(element, html);
        }
        else if (mapTag === 'body') {
            element = innerHtml(___document.createElement('html'), html);
            return element.removeChild(element.lastChild);
        }
        var wrapper = __innerHtmlWrappers[mapTag] || __innerHtmlWrappers._default, depth = wrapper[0], parentStart = wrapper[1], parentEnd = wrapper[2];
        element = innerHtml(element, parentStart + html + parentEnd);
        while (depth-- > 0) {
            element = element.lastChild;
        }
        return element;
    }
    function setInnerHtml(node, html) {
        clearNode(node);
        if (isEmpty(html)) {
            return;
        }
        var element = stringToNode(html);
        if (element.childNodes.length > 0) {
            appendChildren(element.childNodes, node);
        }
        else {
            node.insertBefore(element, null);
        }
        return node;
    }
    function insertBefore(parent, nodes, endNode) {
        if (isNull(parent) || !isObject(nodes)) {
            return;
        }
        else if (isUndefined(endNode)) {
            endNode = null;
        }
        var fragment;
        if (isNode(nodes)) {
            fragment = nodes;
            nodes = Array.prototype.slice.call(fragment.childNodes);
            parent.insertBefore(fragment, endNode);
            return nodes;
        }
        if (!isFunction(nodes.push)) {
            nodes = Array.prototype.slice.call(nodes);
        }
        ___document = ___document || (___document = plat.acquire(__Document));
        var length = nodes.length;
        fragment = ___document.createDocumentFragment();
        for (var i = 0; i < length; ++i) {
            fragment.insertBefore(nodes[i], null);
        }
        parent.insertBefore(fragment, endNode);
        return nodes;
    }
    function replace(node) {
        var parent = node.parentNode, nodes = insertBefore(parent, node.childNodes, node);
        parent.removeChild(node);
        return nodes;
    }
    function replaceWith(node, newNode) {
        if (isNull(newNode)) {
            return newNode;
        }
        if (node.nodeType === Node.ELEMENT_NODE) {
            var attributes = node.attributes, length_1 = attributes.length, attribute = void 0;
            for (var i = 0; i < length_1; ++i) {
                attribute = attributes[i];
                newNode.setAttribute(attribute.name, attribute.value);
            }
        }
        var parent = node.parentNode;
        insertBefore(newNode, node.childNodes);
        parent.replaceChild(newNode, node);
        return newNode;
    }
    function serializeHtml(html) {
        ___document = ___document || (___document = plat.acquire(__Document));
        var templateElement = ___document.createDocumentFragment();
        if (!isEmpty(html)) {
            setInnerHtml(templateElement, html);
        }
        return templateElement;
    }
    function removeBetween(startNode, endNode) {
        if (isNull(startNode)) {
            return;
        }
        var currentNode = startNode.nextSibling, parentNode = startNode.parentNode, tempNode;
        if (isNull(endNode)) {
            endNode = null;
        }
        if (isNull(parentNode) || (!isNull(endNode) && endNode.parentNode !== parentNode)) {
            return;
        }
        while (currentNode !== endNode) {
            tempNode = currentNode.nextSibling;
            parentNode.removeChild(currentNode);
            currentNode = tempNode;
        }
    }
    function removeAll(startNode, endNode) {
        if (isNull(startNode)) {
            return;
        }
        removeBetween(startNode, endNode);
        removeNode(startNode);
        removeNode(endNode);
    }
    /**
     */
    function innerHtml(element, html) {
        ___compat = ___compat || (___compat = plat.acquire(__Compat));
        if (___compat.msApp) {
            MSApp.execUnsafeLocalFunction(function () {
                element.innerHTML = html;
            });
        }
        else {
            element.innerHTML = html;
        }
        return element;
    }
    function removeNode(node) {
        if (!isNode(node)) {
            return;
        }
        var parentNode = node.parentNode;
        if (!isNull(parentNode)) {
            parentNode.removeChild(node);
        }
    }
    function addClass(element, className) {
        var cName = (element || {}).className;
        if (!isString(cName) || !isString(className) || className === '') {
            return;
        }
        var split = className.split(__whiteSpaceRegex), name, classNameRegex;
        if (isUndefined(element.classList)) {
            if (isEmpty(cName)) {
                element.className = className;
                return;
            }
            while (split.length > 0) {
                name = split.shift();
                if (name !== '') {
                    classNameRegex = new RegExp('^' + name + '\\s+|\\s+' + name + '$|\\s+' + name + '\\s+', 'g');
                    if (!classNameRegex.test(cName)) {
                        element.className += ' ' + name;
                    }
                }
            }
            return;
        }
        while (split.length > 0) {
            name = split.shift();
            if (name !== '') {
                element.classList.add(name);
            }
        }
    }
    function removeClass(element, className) {
        var cName = (element || {}).className;
        if (!isString(cName) || !isString(className) || className === '') {
            return;
        }
        var split = className.split(__whiteSpaceRegex), name;
        if (isUndefined(element.classList)) {
            if (cName === className) {
                element.className = '';
                return;
            }
            while (split.length > 0) {
                name = split.shift();
                if (name !== '') {
                    element.className = cName = cName
                        .replace(new RegExp('^' + name + '\\s+|\\s+' + name + '$|\\s+' + name + '\\s+', 'g'), '');
                }
            }
            return;
        }
        while (split.length > 0) {
            name = split.shift();
            if (name !== '') {
                element.classList.remove(name);
            }
        }
    }
    function toggleClass(element, className) {
        var cName = (element || {}).className;
        if (!isString(cName) || !isString(className) || className === '') {
            return;
        }
        var split = className.split(__whiteSpaceRegex), name;
        if (isUndefined(element.classList)) {
            var classNameRegex = void 0;
            if (cName === '') {
                element.className = className;
            }
            else if (cName === className) {
                element.className = '';
                return;
            }
            while (split.length > 0) {
                name = split.shift();
                if (name !== '') {
                    classNameRegex = new RegExp('^' + name + '\\s+|\\s+' + name + '$|\\s+' + name + '\\s+', 'g');
                    if (classNameRegex.test(cName)) {
                        element.className = cName = cName.replace(classNameRegex, '');
                        continue;
                    }
                    element.className += ' ' + name;
                }
            }
            return;
        }
        while (split.length > 0) {
            name = split.shift();
            if (name !== '') {
                element.classList.toggle(name);
            }
        }
    }
    function replaceClass(element, oldClass, newClass) {
        var cName = (element || {}).className;
        if (!isString(cName) || !isString(newClass) || newClass === '') {
            return;
        }
        if (isUndefined(element.classList)) {
            var startRegex = new RegExp('^' + oldClass + '\\s+', 'g'), midRegex = new RegExp('\\s+' + oldClass + '\\s+', 'g'), endRegex = new RegExp('\\s+' + oldClass + '$', 'g');
            element.className = cName.replace(startRegex, newClass + ' ')
                .replace(midRegex, ' ' + newClass + ' ')
                .replace(endRegex, ' ' + newClass);
            return;
        }
        element.classList.add(newClass);
        element.classList.remove(oldClass);
    }
    function hasClass(element, className) {
        var cName = (element || {}).className;
        if (!isString(cName) || !isString(className) || className === '') {
            return false;
        }
        var split = className.split(__whiteSpaceRegex);
        if (isUndefined(element.classList)) {
            if (cName === '') {
                return false;
            }
            else if (cName === className) {
                return true;
            }
            var name_1;
            while (split.length > 0) {
                name_1 = split.shift();
                if (!(name_1 === '' || new RegExp('^' + name_1 + '\\s|\\s' + name_1 + '$|\\s' + name_1 + '\\s', 'g').test(cName))) {
                    return false;
                }
            }
            return true;
        }
        while (split.length > 0) {
            name = split.shift();
            if (!(name === '' || element.classList.contains(name))) {
                return false;
            }
        }
        return true;
    }
    function getTemplate(templateUrl) {
        ___templateCache = ___templateCache || (___templateCache = plat.acquire(__TemplateCache));
        ___http = ___http || (___http = plat.acquire(__Http));
        return ___templateCache.put(templateUrl, ___templateCache.read(templateUrl)
            .catch(function (error) {
            if (isNull(error)) {
                return ___http.ajax({ url: templateUrl });
            }
        }).then(function (success) {
            if (isDocumentFragment(success)) {
                return ___templateCache.put(templateUrl, success);
            }
            else if (!isObject(success) || !isString(success.response)) {
                ___log = ___log || (___log = plat.acquire(__Log));
                ___log.warn('No template found at ' + templateUrl);
                return ___templateCache.put(templateUrl);
            }
            var templateString = success.response;
            if (isEmpty(templateString.trim())) {
                return ___templateCache.put(templateUrl);
            }
            return ___templateCache.put(templateUrl, templateString);
        }).catch(function (error) {
            postpone(function () {
                ___log = ___log || (___log = plat.acquire(__Log));
                ___log.error(new Error('Failure to get template from ' + templateUrl + '.'));
            });
            return error;
        }));
    }
    function whenPresent(cb, element) {
        if (!isNode(element)) {
            ___log = ___log || (___log = plat.acquire(__Log));
            ___log.error(new Error('Attempting to check DOM presence of something that isn\'t a Node.'));
            return noop;
        }
        ___document = ___document || (___document = plat.acquire(__Document));
        var body = ___document.body;
        if (isNode(element.parentElement) && body.contains(element)) {
            cb();
            return noop;
        }
        var remove = setIntervalGlobal(function () {
            if (isNode(element.parentElement) && body.contains(element)) {
                remove();
                cb();
            }
        }, 100);
        return remove;
    }
    function whenVisible(cb, element) {
        if (!isNode(element)) {
            ___log = ___log || (___log = plat.acquire(__Log));
            ___log.error(new Error('Attempting to check visibility of something that isn\'t a Node.'));
            return noop;
        }
        var clientWidth = element.clientWidth, clientHeight = element.clientHeight;
        if (!(isNumber(clientWidth) && isNumber(clientHeight))) {
            ___log = ___log || (___log = plat.acquire(__Log));
            ___log.error(new Error('Attempting to check visibility of something that isn\'t an Element.'));
            return noop;
        }
        if (clientWidth > 0 && clientHeight > 0) {
            cb();
            return noop;
        }
        var remove = setIntervalGlobal(function () {
            if (element.clientWidth > 0 && element.clientHeight > 0) {
                remove();
                cb();
            }
        }, 100);
        return remove;
    }
    /* tslint:enable:no-unused-variable */
    var controlInjectors = {}, viewControlInjectors = {}, instanceInjectorDependencies = {}, injectableInjectors = {}, unregisteredInjectors = {}, staticInjectors = {}, animationInjectors = {}, jsAnimationInjectors = {};
    /**
     * Holds all the classes and interfaces related to registering components for platypus.
     */
    var register;
    (function (register) {
        /**
         * Generic function for creating an Injector and
         * adding it to an InjectorObject.
         * @param {plat.dependency.InjectorObject<any>} obj The InjectorObject
         * to which to add an Injector.
         * @param {string} name The name used to set/get the Injector from the
         * InjectorObject.
         * @param {any} Type The constructor or function definition for the Injector.
         * @param {Array<any>} dependencies? An array of strings representing the dependencies needed for the
         * Injector.
         * @param {string} injectableType? The injectable type.
         * @param {boolean} isStatic The injectable type is a static type.
         */
        function add(obj, name, Type, dependencies, injectableType, isStatic) {
            var injector = obj[name] = new dependency.Injector(name, Type, dependencies, injectableType);
            if (isStatic === true) {
                staticInjectors[name] = injector;
            }
            return register;
        }
        /**
         * Registers the IApp with the framework. The framework will instantiate the IApp
         * when needed, and wire up the Application Lifecycle events. The dependencies array corresponds to injectables that will be
         * passed into the Constructor of the app.
         * @param {string} name The name of your app.
         * @param {new (...args: any[]) => plat.App} Type The constructor for the IApp.
         * @param {Array<any>} dependencies? An array of strings representing the dependencies needed for the app injector.
         */
        function app(name, Type, dependencies) {
            var _Injector = acquire(__InjectorStatic), _AppStatic = acquire(__AppStatic);
            _AppStatic.registerApp(new _Injector(name, Type, dependencies));
            return register;
        }
        register.app = app;
        /**
         * Registers an Control with the framework. The framework will instantiate the
         * Control when needed. The dependencies array corresponds to injectables that
         * will be passed into the Constructor of the control.
         * @param {string} name The control type, corresponding to the HTML notation for creating a new Control (e.g. 'plat-foreach').
         * @param {new (...args: any[]) => plat.Control} Type The constructor for the Control.
         * @param {Array<any>} dependencies? An array of strings representing the dependencies needed for the Control
         * injector.
         */
        function control(name, Type, dependencies, isStatic) {
            if (isString(name)) {
                name = name.toLowerCase();
            }
            else {
                throw new Error('A Control must be registered with a string name');
            }
            if (name === 'head') {
                isStatic = true;
            }
            return add(controlInjectors, name, Type, dependencies, isStatic ? __STATIC : undefined);
        }
        register.control = control;
        /**
         * Registers an ViewControl with the framework. The framework will
         * instantiate the control when needed. The dependencies array corresponds to injectables that will be
         * passed into the Constructor of the control.
         * @param {string} name The control type, corresponding to the HTML notation for creating a new
         * ViewControl. Used for navigation to the specified ViewControl.
         * @param {new (...args: any[]) => plat.ui.ViewControl} Type The constructor for the ViewControl.
         * @param {Array<any>} dependencies? An optional array of strings representing the dependencies needed for the
         * ViewControl injector.
         */
        function viewControl(name, Type, dependencies) {
            if (isString(name)) {
                name = name.toLowerCase();
            }
            else {
                throw new Error('A ViewControl must be registered with a string name');
            }
            return add(viewControlInjectors, name, Type, dependencies);
        }
        register.viewControl = viewControl;
        function injectable(name, Type, dependencies, injectableType) {
            if (!isString(injectableType)) {
                injectableType = __SINGLETON;
            }
            else {
                injectableType = injectableType.toLowerCase();
                if (injectableType === __FACTORY || injectableType === __STATIC || injectableType === __CLASS) {
                    return add(injectableInjectors, name, Type, dependencies, injectableType, true);
                }
                else if (!(injectableType === __SINGLETON || injectableType === __INSTANCE)) {
                    throw new Error('Invalid injectable type ' + injectableType + ' during injectable registration.');
                }
            }
            return add(injectableInjectors, name, Type, dependencies, injectableType, false);
        }
        register.injectable = injectable;
        /**
         * Contains constants for injectable type.
         */
        var injectable;
        (function (injectable) {
            /**
             * Static injectables will be injected before the application loads. This provides a way to create
             * a static constructor and load dependencies into static class properties.
             */
            injectable.STATIC = __STATIC;
            /**
             * Singleton injectables will contain a constructor. A Singleton injectable will be instantiated once and
             * used throughout the application lifetime. It will be instantiated when another component is injected
             * and lists it as a dependency.
             */
            injectable.SINGLETON = __SINGLETON;
            /**
             * Instance injectables will contain a constructor. An Instance injectable will be instantiated multiple times
             * throughout the application lifetime. It will be instantiated whenever another component is injected
             * and lists it as a dependency.
             */
            injectable.INSTANCE = __INSTANCE;
            /**
             * Factory injectables will not contain a constructor but will instead contain a method for obtaining an
             * instance, such as getInstance() or create(). It will be injected before the application loads, similar to a Static
             * injectable.
             */
            injectable.FACTORY = __FACTORY;
            /**
             * Class injectables are essentially a direct reference to a class's constructor. It may contain both
             * static and instance methods as well as a constructor for creating a new instance.
             */
            injectable.CLASS = __CLASS;
        })(injectable = register.injectable || (register.injectable = {}));
        function animation(name, Type, dependencies, animationType) {
            if (isString(animationType)) {
                animationType = animationType.toLowerCase();
                if (!(animationType === __CSS || animationType === __JS)) {
                    throw new Error('Invalid animationType "' + animationType + '" during animation registration.');
                }
            }
            return add((animationType === __JS ? jsAnimationInjectors : animationInjectors), name, Type, dependencies, register.injectable.INSTANCE);
        }
        register.animation = animation;
        /**
         * Contains constants for animation type.
         */
        var animation;
        (function (animation) {
            /**
             * A CSS animation.
             */
            animation.CSS = __CSS;
            /**
             * A JavaScript animation.
             */
            animation.JS = __JS;
        })(animation = register.animation || (register.animation = {}));
    })(register = plat_1.register || (plat_1.register = {}));
    /**
     * Holds classes and interfaces related to dependency injection components in platypus.
     */
    var dependency;
    (function (dependency_1) {
        /**
         * The Injector class is used for dependency injection. You can create an injector object,
         * specify dependencies and a constructor for your component. When the injector object is
         * 'injected' it will create a new instance of your component and pass in the dependencies
         * to the constructor.
         */
        var Injector = (function () {
            /**
             * The constructor for an injector. Converts any non-string dependencies to strings to support mocking Injectors during runtime.
             * @param {string} name The name of the injected type.
             * @param {new () => T} Constructor The constructor method for the component requiring the dependency
             * injection.
             * @param {Array<any>} dependencies An array of strings specifying the injectable dependencies for the
             * associated constructor.
             * @param {string} type The type of injector, used for injectables specifying a injectableType of
             * STATIC, SINGLETON, FACTORY, INSTANCE, or CLASS. The default is SINGLETON.
             */
            function Injector(name, Constructor, dependencies, type) {
                if (type === void 0) { type = null; }
                this.name = name;
                this.Constructor = Constructor;
                this.type = type;
                var deps = this.dependencies = Injector.convertDependencies(dependencies), index = deps.indexOf(__NOOP_INJECTOR), circularReference;
                Object.defineProperty(Constructor, '__injectorName', {
                    value: name,
                    enumerable: false,
                    configurable: true,
                    writable: true
                });
                Object.defineProperty(Constructor, '__injectorDependencies', {
                    value: deps.slice(0),
                    enumerable: false,
                    configurable: true,
                    writable: true
                });
                if (index > -1) {
                    var dependency_2 = dependencies[index];
                    if (isNull(dependency_2)) {
                        throw new TypeError('The dependency for ' +
                            name + ' at index ' +
                            index + ' is undefined, did you forget to include a file?');
                    }
                    throw new TypeError('Could not resolve dependency ' +
                        dependency_2.slice(9, dependency_2.indexOf('(')) +
                        ' for ' +
                        name +
                        '. Are you using a static injectable Type?');
                }
                circularReference = Injector.__findCircularReferences(this);
                if (isString(circularReference)) {
                    throw new Error('Circular dependency detected from ' + this.name + ' to ' + circularReference + '.');
                }
                if (name === __AppStatic) {
                    var App_1 = this.inject();
                    this.dependencies = deps;
                    App_1.start();
                }
            }
            /**
             * Initializes all static injectors.
             */
            Injector.initialize = function () {
                var injectors = staticInjectors, keys = Object.keys(injectors), length = keys.length;
                for (var i = 0; i < length; ++i) {
                    injectors[keys[i]].inject();
                }
                staticInjectors = {};
            };
            /**
             * Gathers and returns the array of listed dependencies.
             * @param {Array<any>} dependencies The array of dependencies specified
             * by either their Constructor or their registered name.
             */
            Injector.getDependencies = function (dependencies) {
                if (isNull(dependencies) || isEmpty(dependencies)) {
                    return [];
                }
                var deps = [], length = dependencies.length;
                for (var i = 0; i < length; ++i) {
                    deps.push(Injector.getDependency(dependencies[i]));
                }
                return deps;
            };
            /**
             * Finds and returns the dependency.
             * @param {any} dependency an object/string used to find the dependency.
             */
            Injector.getDependency = function (dependency) {
                if (isNull(dependency) || dependency === __NOOP_INJECTOR) {
                    return Injector.__noop();
                }
                else if (Injector.isInjector(dependency)) {
                    return dependency;
                }
                return Injector.__locateInjector(dependency);
            };
            /**
             * Converts dependencies specified by their Constructors into
             * equivalent dependencies specified by their registered string
             * name.
             * @param {Array<any>} dependencies The array of dependencies specified
             * by either their Constructor or their registered name.
             */
            Injector.convertDependencies = function (dependencies) {
                if (!isArray(dependencies)) {
                    return [];
                }
                var convert = Injector.convertDependency, deps = [], length = dependencies.length;
                for (var i = 0; i < length; ++i) {
                    deps.push(convert(dependencies[i]));
                }
                return deps;
            };
            /**
             * Converts a dependency specified by its Constructors into an
             * equivalent dependency specified by its registered string
             * name.
             * @param {any} dependency The dependency specified
             * by either a Constructor or a registered name.
             */
            Injector.convertDependency = function (dependency) {
                if (isNull(dependency)) {
                    return __NOOP_INJECTOR;
                }
                return Injector.__getInjectorName(dependency);
            };
            /**
             * Checks if the object being passed in fulfills the requirements for being an Injector.
             * @param {plat.dependency.Injector<any>} dependency The object to check.
             */
            Injector.isInjector = function (dependency) {
                return isFunction(dependency.inject) &&
                    !isUndefined(dependency.type) &&
                    !isUndefined(dependency.name) &&
                    !isUndefined(dependency.Constructor);
            };
            /**
             * Gets the string name related to an injector.
             * @param {any} dependency The object to search for.
             */
            Injector.__getInjectorName = function (dependency) {
                if (isNull(dependency)) {
                    return __NOOP_INJECTOR;
                }
                else if (isString(dependency)) {
                    return dependency;
                }
                var Constructor = dependency, _inject = isObject(Constructor._inject) ? Constructor._inject : {};
                if (isString(Constructor.__injectorName)) {
                    dependency = Constructor.__injectorName;
                }
                if (!isString(dependency)) {
                    return new Injector(dependency, Constructor, _inject.dependencies);
                }
                var find = Injector.__findInjector.bind(Injector, dependency), injector = find(injectableInjectors) ||
                    find(unregisteredInjectors) ||
                    find(staticInjectors) ||
                    find(viewControlInjectors) ||
                    find(controlInjectors) ||
                    find(animationInjectors) ||
                    find(jsAnimationInjectors);
                if (!isObject(injector) && isString(dependency)) {
                    injector = unregisteredInjectors[dependency] = new Injector(dependency, Constructor, Constructor._inject.dependencies);
                }
                if (isObject(injector)) {
                    return injector.name;
                }
                return __NOOP_INJECTOR;
            };
            /**
             * Calls the injector's constructor with the associated dependencies.
             * @param {any} Constructor The Constructor to call.
             * @param {Array<any>} args The arguments to pass to the constructor.
             */
            Injector.__construct = function (Constructor, args, type) {
                if (isNull(Constructor) || isNull(Constructor.prototype)) {
                    return Constructor;
                }
                var obj = Object.create(Constructor.prototype), isInstance = type === __INSTANCE, toInject;
                if (isInstance) {
                    toInject = instanceInjectorDependencies[Constructor.__injectorName];
                }
                if (!isObject(toInject)) {
                    toInject = Injector.__walk(obj, Object.getPrototypeOf(obj), {});
                    if (isInstance) {
                        instanceInjectorDependencies[Constructor.__injectorName] = toInject;
                    }
                }
                var dependencies = acquire(map(function (value) { return value; }, toInject)), keys = Object.keys(toInject), length = keys.length;
                for (var i = 0; i < length; ++i) {
                    obj[keys[i]] = dependencies[i];
                }
                var ret = obj.constructor.apply(obj, args);
                if (!isUndefined(ret)) {
                    return ret;
                }
                return obj;
            };
            /**
             * Walks up an object's prototype, injecting dependencies if they are
             * registered on static '_inject' objects.
             * @param {any} obj The object to walk.
             * @param {any} proto the prototype of the object.
             */
            Injector.__walk = function (obj, proto, extendWith) {
                var Constructor = proto.constructor, parentInject = {};
                if (isObject(Constructor._inject) && Constructor !== Object) {
                    parentInject = Injector.__walk(obj, Object.getPrototypeOf(proto), extendWith);
                }
                var toInject = _clone(Constructor._inject, true);
                return _extend(false, false, {}, extendWith, parentInject, toInject);
            };
            /**
             * Finds an injector object with the associated constructor.
             * @param {any} Constructor The Constructor to locate.
             */
            Injector.__locateInjector = function (Constructor) {
                if (isNull(Constructor)) {
                    return;
                }
                var dependency = Constructor;
                if (isString(Constructor.__injectorName)) {
                    dependency = Constructor.__injectorName;
                }
                var find = Injector.__findInjector.bind(Injector, dependency), injector = find(injectableInjectors) ||
                    find(unregisteredInjectors) ||
                    find(staticInjectors) ||
                    find(controlInjectors) ||
                    find(viewControlInjectors) ||
                    find(animationInjectors) ||
                    find(jsAnimationInjectors);
                if (!isObject(injector)) {
                    if (isFunction(Constructor)) {
                        if (!isString(dependency)) {
                            dependency = uniqueId(__Plat);
                        }
                        injector = new Injector(dependency, Constructor, isObject(Constructor._inject) ? Constructor._injectorDependencies : []);
                        unregisteredInjectors[dependency] = injector;
                    }
                    else {
                        injector = Injector.__wrap(Constructor);
                    }
                }
                return injector;
            };
            /**
             * Finds an injector object with the associated constructor in the given InjectorObject.
             * @param {Function} Constructor The Function
             */
            Injector.__findInjector = function (Constructor, injectors) {
                if (isNull(Constructor)) {
                    return;
                }
                else if (Constructor === Injector || Constructor === __InjectorStatic) {
                    var ret = Injector.__wrap(Injector);
                    ret.name = __InjectorStatic;
                    return ret;
                }
                else if (isString(Constructor)) {
                    return injectors[Constructor] || injectors[Constructor.toLowerCase()];
                }
            };
            /**
             * Once an injector is injected, it is wrapped to prevent further injection.
             * @param {any} value The injected value.
             */
            Injector.__wrap = function (value) {
                return {
                    inject: function () { return value; },
                    name: __WRAPPED_INJECTOR,
                    dependencies: [],
                    Constructor: value
                };
            };
            /**
             * Returns an empty injector object.
             */
            Injector.__noop = function () {
                return {
                    inject: noop,
                    type: __NOOP_INJECTOR,
                    name: __NOOP_INJECTOR,
                    dependencies: [],
                    Constructor: noop
                };
            };
            /**
             * Determines if there is a circular dependency in a dependency tree.
             * @param {plat.dependency.Injector<any>} injector The starting point for the dependency tree search.
             */
            Injector.__findCircularReferences = function (injector) {
                if (!(isObject(injector) && isArray(injector.dependencies))) {
                    return;
                }
                var source = injector.name, dependencies = injector.dependencies, node, stack = [{
                        name: source,
                        dependencies: dependencies.slice(0)
                    }], dependency, locate = Injector.__locateInjector, length;
                while (stack.length > 0) {
                    node = stack.pop();
                    dependencies = node.dependencies;
                    length = dependencies.length;
                    for (var i = 0; i < length; ++i) {
                        dependency = dependencies[i];
                        if (dependency === source) {
                            return node.name;
                        }
                        injector = locate(dependency);
                        if (!(isObject(injector) && isArray(injector.dependencies))) {
                            continue;
                        }
                        stack.push({
                            name: injector.name,
                            dependencies: injector.dependencies.slice(0)
                        });
                    }
                }
            };
            /**
             * Gathers the dependencies for the Injector object and creates a new instance of the
             * Constructor, passing in the dependencies in the order they were specified. If the
             * Injector contains a Constructor for an injectable and the Constructor is registered
             * as a SINGLE type it will only inject that injectable once.
             */
            Injector.prototype.inject = function () {
                var toInject = [], type = this.type;
                var dependencies = this.dependencies, length = dependencies.length, dependency, injectable;
                for (var i = 0; i < length; ++i) {
                    dependency = Injector.getDependency(dependencies[i]);
                    toInject.push(dependency.inject());
                }
                injectable = Injector.__construct(this.Constructor, toInject, type);
                if (isString(type) && type !== __INSTANCE) {
                    this._wrapInjector(injectable);
                }
                injectable.__injectable__type = type;
                return injectable;
            };
            /**
             * Wraps the injector with the instantiated value in the case of a
             * SINGLE or STATIC type so that it does not re-instantiate.
             * @param {any} value The value to wrap
             */
            Injector.prototype._wrapInjector = function (value) {
                this.inject = function () {
                    return value;
                };
                return this;
            };
            return Injector;
        }());
        dependency_1.Injector = Injector;
        /**
         * Publically exposes all the dependency injector objects.
         */
        var injectors;
        (function (injectors) {
            /**
             * An InjectorObject of Controls.
             * Contains all the registered controls for an application.
             */
            injectors.control = controlInjectors;
            /**
             * An InjectorObject of IBaseViewControls.
             * Contains all the registered view controls for an application.
             */
            injectors.viewControl = viewControlInjectors;
            /**
             * An InjectorObject of objects. Contains all the registered
             * injectables for an application.
             */
            injectors.injectable = injectableInjectors;
            /**
             * An InjectorObject of static objects. Contains all the registered
             * static injectables for an application. Once the injectables have been injected, they are removed from this object.
             */
            injectors.staticInjectable = staticInjectors;
            /**
             * An InjectorObject of animations. Can be either CSS or JS implementations.
             */
            injectors.animation = animationInjectors;
            /**
             * An InjectorObject  of animations. Should only contain JS implementations.
             */
            injectors.jsAnimation = jsAnimationInjectors;
        })(injectors = dependency_1.injectors || (dependency_1.injectors = {}));
    })(dependency = plat_1.dependency || (plat_1.dependency = {}));
    if (!isUndefined(window)) {
        if (isUndefined(window.plat)) {
            window.plat = plat;
        }
        if (isUndefined(window.module)) {
            window.module = {};
        }
    }
    function acquire(dependencies) {
        var deps, array = isArray(dependencies);
        if (array) {
            deps = dependency.Injector.getDependencies(dependencies);
        }
        else {
            deps = dependency.Injector.getDependencies([dependencies]);
        }
        var length = deps.length, output = [];
        for (var i = 0; i < length; ++i) {
            output.push(deps[i].inject());
        }
        if (!array) {
            return output[0];
        }
        return output;
    }
    plat_1.acquire = acquire;
    /**
     * Holds all classes and interfaces related to debugging components in platypus.
     */
    var debug;
    (function (debug) {
        /**
         * Handles all logging/debugging for the framework. All logs will be bubbled up to the
         * App.error event to allow for easy debugging.
         */
        var Log = (function () {
            function Log() {
                /**
                 * The ERROR log level
                 */
                this.ERROR = 5;
                /**
                 * The WARN log level
                 */
                this.WARN = 4;
                /**
                 * The INFO log level
                 */
                this.INFO = 3;
                /**
                 * The DEBUG log level
                 */
                this.DEBUG = 2;
                /**
                 * The TRACE log level
                 */
                this.TRACE = 1;
                /**
                 * A configurable log level (defaults to INFO). Any logs sent below this
                 * will be silent.
                 */
                this._level = this.INFO;
            }
            /**
             * Logs fatal errors. This will throw the error after it is logged.
             * @param {Error} error The error to log.
             */
            Log.prototype.error = function (error) {
                this._log(error, this.ERROR);
                throw error;
            };
            Log.prototype.warn = function (message) {
                this._log(message, this.WARN);
            };
            Log.prototype.info = function (message) {
                this._log(message, this.INFO);
            };
            Log.prototype.debug = function (message) {
                this._log(message, this.DEBUG);
            };
            Log.prototype.trace = function (message) {
                this._log(message, this.TRACE);
            };
            Log.prototype.setLogLevel = function (level) {
                if (isString(level)) {
                    level = this[level.toUpperCase()];
                }
                switch (level) {
                    case this.ERROR:
                    case this.WARN:
                    case this.INFO:
                    case this.DEBUG:
                    case this.TRACE:
                        this._level = level;
                        break;
                    default:
                        this._level = this.INFO;
                }
            };
            Log.prototype._log = function (message, level) {
                if (!this._shouldLog(level)) {
                    return;
                }
                if (isString(message)) {
                    message = new Error(message);
                }
                var _ErrorEvent = this._ErrorEvent;
                if (isNull(_ErrorEvent)) {
                    _ErrorEvent = this._ErrorEvent = acquire(__ErrorEventStatic);
                }
                _ErrorEvent.dispatch(__error, Log, message, level);
            };
            /**
             * Detemines whether or not a log level is at or above the current minimum log level.
             * @param {number} level The log level to check against the current minimum log level.
             */
            Log.prototype._shouldLog = function (level) {
                if (!isNumber(level)) {
                    level = this.INFO;
                }
                return this._level < level;
            };
            return Log;
        }());
        debug.Log = Log;
        register.injectable(__Log, Log);
    })(debug = plat_1.debug || (plat_1.debug = {}));
    /**
     * A class containing boolean values signifying browser
     * and/or platform compatibilities.
     */
    var Compat = (function () {
        /**
         * Define everything.
         */
        function Compat() {
            /**
             * An object containing all event lookups.
             */
            this.__events = {};
            this.__defineBooleans();
            this.__defineMappedEvents();
            this.__defineVendorDependencies();
            this.__determineCss();
        }
        /**
         * Check whether or not an event exists.
         * @param {string} event The event to check the existence of.
         */
        Compat.prototype.hasEvent = function (event) {
            var events = this.__events, eventExists = events[event];
            if (isUndefined(eventExists)) {
                var element = this._document.createElement('div');
                if (event === 'input' && this.IE === 9) {
                    eventExists = events[event] = false;
                }
                else {
                    eventExists = events[event] = !isUndefined(element[('on' + event)]);
                }
            }
            return eventExists;
        };
        /**
         * Define booleans.
         */
        Compat.prototype.__defineBooleans = function () {
            var _window = this._window, navigator = _window.navigator || {}, userAgent = (navigator.userAgent || '').toLowerCase(), history = this._history, def = _window.define, msA = _window.MSApp, winJs = _window.WinJS, android = (/android ((?:\d|\.)+)/.exec(userAgent) || [])[1];
            if (isString(android) && !/iemobile/i.test(userAgent)) {
                android = parseInt(android.replace(/\./g, ''), 10);
            }
            this.isCompatible = isFunction(Object.defineProperty) && isFunction(this._document.querySelector);
            this.cordova = !isNull(_window.cordova);
            this.pushState = !(isNull(history) || isNull(history.pushState));
            this.fileSupported = !(isUndefined(_window.File) || isUndefined(_window.FormData));
            this.amd = isFunction(def) && !isNull(def.amd);
            this.msApp = isObject(msA) && isFunction(msA.execUnsafeLocalFunction);
            this.winJs = isObject(winJs) && isObject(winJs.Application);
            this.indexedDb = !isNull(_window.indexedDB);
            this.proto = isObject({}.__proto__);
            this.getProto = isFunction(Object.getPrototypeOf);
            this.setProto = isFunction(Object.setPrototypeOf);
            this.hasTouchEvents = !isUndefined(_window.ontouchstart);
            this.hasPointerEvents = !!navigator.pointerEnabled;
            this.hasMsPointerEvents = !!navigator.msPointerEnabled;
            if (isNumber(android)) {
                this.ANDROID = android;
                return;
            }
            var ie = parseInt((/msie (\d+)/.exec(userAgent) || [])[1], 10) ||
                parseInt((/trident\/.*; rv:(\d+)/.exec(userAgent) || [])[1], 10);
            if (isNumber(ie)) {
                this.IE = ie;
            }
        };
        /**
         * Define mapped events
         */
        Compat.prototype.__defineMappedEvents = function () {
            if (this.hasPointerEvents) {
                this.mappedEvents = {
                    $touchstart: 'pointerdown',
                    $touchend: 'pointerup',
                    $touchmove: 'pointermove',
                    $touchcancel: 'pointercancel'
                };
            }
            else if (this.hasMsPointerEvents) {
                this.mappedEvents = {
                    $touchstart: 'MSPointerDown',
                    $touchend: 'MSPointerUp',
                    $touchmove: 'MSPointerMove',
                    $touchcancel: 'MSPointerCancel'
                };
            }
            else if (this.hasTouchEvents) {
                this.mappedEvents = {
                    $touchstart: 'touchstart',
                    $touchend: 'touchend',
                    $touchmove: 'touchmove',
                    $touchcancel: 'touchcancel'
                };
            }
            else {
                this.mappedEvents = {
                    $touchstart: 'mousedown',
                    $touchend: 'mouseup',
                    $touchmove: 'mousemove',
                    $touchcancel: null
                };
            }
        };
        /**
         * Define animation events and other vendor prefix
         * dependencies.
         */
        Compat.prototype.__defineVendorDependencies = function () {
            var _window = this._window, documentElement = this._document.documentElement, styles = _window.getComputedStyle(documentElement, ''), matches = Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/), prefix, dom, css, jsSyntax;
            if ((isArray(matches) && matches.length > 1)) {
                prefix = (isArray(matches) && matches.length > 1) ? matches[1] : '';
                jsSyntax = prefix[0].toUpperCase() + prefix.slice(1);
                dom = ('WebKit|Moz|MS').match(new RegExp('(' + prefix + ')', 'i'))[1];
                css = '-' + prefix + '-';
            }
            else if (!isUndefined(styles.OLink)) {
                prefix = 'o';
                jsSyntax = dom = 'O';
                css = '-o-';
            }
            else {
                prefix = jsSyntax = dom = css = '';
            }
            this.vendorPrefix = {
                dom: dom,
                lowerCase: prefix,
                css: css,
                upperCase: jsSyntax
            };
            this.requestAnimationFrame = _window.requestAnimationFrame || _window[prefix + 'RequestAnimationFrame'];
            this.cancelAnimationFrame = _window.cancelAnimationFrame ||
                _window[prefix + 'CancelRequestAnimationFrame'] ||
                _window[prefix + 'CancelAnimationFrame'];
            var style = documentElement.style;
            // handle Android issue where style.transition exists but transition events still need vendor prefix 
            // should only affect version 4.1 but we will handle for < 4.4. 
            if ((isUndefined(this.ANDROID) || Math.floor(this.ANDROID / 10) >= 44) &&
                !(isUndefined(style.animation) || isUndefined(style.transition))) {
                this.animationSupported = true;
                this.animationEvents = {
                    $animation: 'animation',
                    $animationStart: 'animationstart',
                    $animationEnd: 'animationend',
                    $animationIteration: 'animationiteration',
                    $transition: 'transition',
                    $transitionStart: 'transitionstart',
                    $transitionEnd: 'transitionend'
                };
            }
            else if (!(isUndefined(style[jsSyntax + 'Animation']) || isUndefined(style[jsSyntax + 'Transition'])) ||
                !(isUndefined(style[prefix + 'Animation']) || isUndefined(style[prefix + 'Transition'])) ||
                !(isUndefined(style[dom + 'Animation']) || isUndefined(style[dom + 'Transition']))) {
                this.animationSupported = true;
                this.animationEvents = {
                    $animation: prefix + 'Animation',
                    $animationStart: prefix + 'AnimationStart',
                    $animationEnd: prefix + 'AnimationEnd',
                    $animationIteration: prefix + 'AnimationIteration',
                    $transition: prefix + 'Transition',
                    $transitionStart: prefix + 'TransitionStart',
                    $transitionEnd: prefix + 'TransitionEnd'
                };
            }
        };
        /**
         * Determines whether or not platypus css styles exist.
         */
        Compat.prototype.__determineCss = function () {
            var _document = this._document, head = _document.head, element = _document.createElement('div');
            element.setAttribute(__Hide, '');
            head.insertBefore(element, null);
            var computedStyle = this._window.getComputedStyle(element), display = computedStyle.display, visibility = computedStyle.visibility;
            this.platCss = display === 'none' || visibility === 'hidden';
            head.removeChild(element);
        };
        Compat._inject = {
            _window: __Window,
            _history: __History,
            _document: __Document
        };
        return Compat;
    }());
    plat_1.Compat = Compat;
    register.injectable(__Compat, Compat);
    /**
     * An extensible class defining common utilities and helper functions.
     */
    var Utils = (function () {
        function Utils() {
        }
        /**
         * An empty method for quickly creating dummy objects.
         */
        Utils.prototype.noop = function () { };
        /**
         * Allows you to extend the properties of an object with any number
         * of other objects. If objects share properties, the last object in the
         * arguments will take precedence. This method is only a shallow copy of
         * all the source objects to the destination object.
         * @param {any} destination The destination object to extend.
         * @param {Array<any>} ...sources Any number of objects with which to extend the
         * destination object.
         */
        Utils.prototype.extend = function (destination) {
            var sources = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                sources[_i - 1] = arguments[_i];
            }
            return _extend.apply(null, [false, false, destination].concat(sources));
        };
        /**
         * Allows you to extend the properties of an object with any number
         * of other objects. If objects share properties, the last object in the
         * arguments will take precedence. This method is a deep copy of
         * all the source objects to the destination object.
         * @param {any} destination The destination object to extend.
         * @param {Array<any>} ...sources Any number of objects with which to extend the
         * destination object.
         */
        Utils.prototype.deepExtend = function (destination) {
            var sources = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                sources[_i - 1] = arguments[_i];
            }
            return _extend.apply(null, [true, false, destination].concat(sources));
        };
        /**
         * Creates a copy of the passed-in object. If deep is true it will
         * be a deep copy (duplicate), else nested objects/arrays will be copied by reference
         * and not duplicated.
         * @param {T} obj The object to clone.
         * @param {boolean} deep? Whether or not it is a deep clone.
         */
        Utils.prototype.clone = function (obj, deep) {
            return _clone(obj, deep);
        };
        /**
         * Takes in anything and determines if it is a type of Object.
         * @param {any} obj Anything.
         */
        Utils.prototype.isObject = function (obj) {
            return isObject(obj);
        };
        /**
         * Takes in anything and determines if it is a window object.
         * @param {any} obj Anything.
         */
        Utils.prototype.isWindow = function (obj) {
            return isWindow(obj);
        };
        /**
         * Takes in anything and determines if it is a document object.
         * @param {any} obj Anything.
         */
        Utils.prototype.isDocument = function (obj) {
            return isDocument(obj);
        };
        /**
         * Takes in anything and determines if it is a Node.
         * @param {any} obj Anything.
         */
        Utils.prototype.isNode = function (obj) {
            return isNode(obj);
        };
        /**
         * Takes in anything and determines if it is a DocumentFragment.
         * @param {any} obj Anything.
         */
        Utils.prototype.isDocumentFragment = function (obj) {
            return isDocumentFragment(obj);
        };
        /**
         * Takes in anything and determines if it is a string.
         * @param {any} obj Anything.
         */
        Utils.prototype.isString = function (obj) {
            return isString(obj);
        };
        /**
         * Takes in anything and determines if it is a RegExp object.
         * @param {any} obj Anything.
         */
        Utils.prototype.isRegExp = function (obj) {
            return isRegExp(obj);
        };
        /**
         * Takes in anything and determines if it is a Promise object.
         * @param {any} obj Anything.
         */
        Utils.prototype.isPromise = function (obj) {
            return isPromise(obj);
        };
        /**
         * Takes in anything and determines if it is empty. Useful for
         * checking for empty strings, arrays, or objects without keys.
         * @param {any} obj Anything.
         */
        Utils.prototype.isEmpty = function (obj) {
            return isEmpty(obj);
        };
        /**
         * Takes in anything and determines if it is a boolean.
         * @param {any} obj Anything.
         */
        Utils.prototype.isBoolean = function (obj) {
            return isBoolean(obj);
        };
        /**
         * Takes in anything and determines if it is a number.
         * @param {any} obj Anything.
         */
        Utils.prototype.isNumber = function (obj) {
            return isNumber(obj);
        };
        /**
         * Takes in anything and determines if it is a File.
         * @param {any} obj Anything.
         */
        Utils.prototype.isFile = function (obj) {
            return isFile(obj);
        };
        /**
         * Takes in anything and determines if it is a function.
         * @param {any} obj Anything.
         */
        Utils.prototype.isFunction = function (obj) {
            return isFunction(obj);
        };
        /**
         * Takes in anything and determines if it is null or undefined.
         * @param {any} obj Anything.
         */
        Utils.prototype.isNull = function (obj) {
            return isNull(obj);
        };
        /**
         * Takes in anything and determines if it is undefined.
         * @param {any} obj Anything.
         */
        Utils.prototype.isUndefined = function (obj) {
            return isUndefined(obj);
        };
        /**
         * Takes in anything and determines if it is an Array.
         * @param {any} obj Anything.
         */
        Utils.prototype.isArray = function (obj) {
            return isArray(obj);
        };
        /**
         * Takes in anything and determines if it has array-like qualities.
         * @param {any} obj Anything.
         */
        Utils.prototype.isArrayLike = function (obj) {
            return isArrayLike(obj);
        };
        /**
         * Takes in anything and determines if it is a Date object.
         * @param {any} obj Anything.
         */
        Utils.prototype.isDate = function (obj) {
            return isDate(obj);
        };
        Utils.prototype.filter = function (iterator, obj, context) {
            return filter(iterator, obj, context);
        };
        /**
         * Takes in a list and object containing key/value pairs to search for in the list.
         * @param {Object} properties An object containing key/value pairs to match with obj's values.
         * @param {Array<T>} array The list used for searching for properties.
         */
        Utils.prototype.where = function (properties, array) {
            return where(properties, array);
        };
        Utils.prototype.forEach = function (iterator, obj, context) {
            return forEach(iterator, obj, context);
        };
        Utils.prototype.map = function (iterator, obj, context) {
            return map(iterator, obj, context);
        };
        Utils.prototype.mapAsync = function (iterator, obj, context) {
            return mapAsync(iterator, obj, context);
        };
        /**
         * Takes in an array and an iterator function. Calls the iterator with all the values in the array. The
         * iterator can return a promise the will resolve with the mapped value. The next value in the array will not be passed to
         * the iterator until the previous promise fulfills.
         * @param {plat.IListIterator<T, plat.async.IThenable<R>>} iterator The transformation function.
         * @param {Array<T>} array An Array.
         * @param {any} context? An optional context to bind to the iterator.
         */
        Utils.prototype.mapAsyncInOrder = function (iterator, array, context) {
            return mapAsyncInOrder(iterator, array, context);
        };
        /**
         * Takes in an array and an iterator function. Calls the iterator with all the values in the array in descending order. The
         * iterator can return a promise the will resolve with the mapped value. The next value in the array will not be passed to
         * the iterator until the previous promise fulfills.
         * @param {plat.IListIterator<T, plat.async.IThenable<R>>} iterator The transformation function.
         * @param {Array<T>} array An Array.
         * @param {any} context? An optional context to bind to the iterator.
         */
        Utils.prototype.mapAsyncInDescendingOrder = function (iterator, array, context) {
            return mapAsyncInDescendingOrder(iterator, array, context);
        };
        /**
         * Takes in an object and a property to extract from all of the object's values. Returns an array of
         * the 'plucked' values.
         * @param {string} key The property to 'pluck' from each value in the array.
         * @param {Array<T>} array The array to pluck the key from
         */
        Utils.prototype.pluck = function (key, array) {
            return pluck(key, array);
        };
        Utils.prototype.some = function (iterator, obj, context) {
            return some(iterator, obj, context);
        };
        /**
         * Takes in a method and array of arguments to pass to that method. Delays calling the method until
         * after the current call stack is clear. Equivalent to a setTimeout with a timeout of 0.
         * @param {(...args: Array<any>) => void} method The method to call.
         * @param {Array<any>} args? The arguments to apply to the method.
         * @param {any} context? An optional context to bind to the method.
         */
        Utils.prototype.postpone = function (method, args, context) {
            return defer(method, 0, args, context);
        };
        /**
         * Takes in a method and array of arguments to pass to that method. Delays calling the method until
         * after the current call stack is clear. Equivalent to a setTimeout with the specified timeout value.
         * @param {(...args: Array<any>) => void} method The method to call.
         * @param {number} timeout The time (in milliseconds) to delay before calling the provided method.
         * @param {Array<any>} args? The arguments to apply to the method.
         * @param {any} context? An optional context to bind to the method.
         */
        Utils.prototype.defer = function (method, timeout, args, context) {
            return defer(method, timeout, args, context);
        };
        /**
         * Takes in a method and array of arguments to pass to that method. Adds the method to the call stack every
         * interval amount of time. Equivalent to a setInterval with the specified interval value.
         * @param {(...args: Array<any>) => void} method The method to call.
         * @param {number} interval The time (in milliseconds) between each consecutive call of the provided method.
         * @param {Array<any>} args? The arguments to apply to the method.
         * @param {any} context? An optional context to bind to the method.
         */
        Utils.prototype.setInterval = function (method, interval, args, context) {
            return setIntervalGlobal(method, interval, args, context);
        };
        /**
         * Uses requestAnimationFrame if it is available, else it does a setTimeout.
         * @param {FrameRequestCallback} method The method to call when the request is fulfilled.
         * @param {any} context? An optional context to bind to the method.
         */
        Utils.prototype.requestAnimationFrame = function (method, context) {
            return requestAnimationFrameGlobal(method, context);
        };
        /**
         * Takes in a prefix and returns a unique identifier string with the prefix preprended. If no prefix
         * is specified, none will be prepended.
         * @param {string} prefix? A string prefix to prepend tothe unique ID.
         */
        Utils.prototype.uniqueId = function (prefix) {
            return uniqueId(prefix);
        };
        /**
         * Takes in a spinal-case, dot.case, or snake_case string and returns
         * a camelCase string. Also can turn a string into camelCase with space
         * as a delimeter.
         * @param {string} str The spinal-case, dot.case, or snake_case string.
         */
        Utils.prototype.camelCase = function (str) {
            return camelCase(str);
        };
        /**
         * Takes a camelCase string and delimits it using the specified delimiter.
         * @param {string} str The camelCased string.
         * @param {string} delimiter The delimiter to add.
         */
        Utils.prototype.delimit = function (str, delimiter) {
            return delimit(str, delimiter);
        };
        return Utils;
    }());
    plat_1.Utils = Utils;
    register.injectable(__Utils, Utils);
    /**
     */
    function Window() {
        return window;
    }
    plat_1.Window = Window;
    register.injectable(__Window, Window);
    /**
     */
    function Document(_window) {
        return _window.document;
    }
    plat_1.Document = Document;
    register.injectable(__Document, Document, [__Window]);
    /**
     * Holds classes and interfaces related to expression handling in platypus.
     */
    var expressions;
    (function (expressions) {
        /**
         * A class for keeping track of commonly used regular expressions.
         */
        var Regex = (function () {
            function Regex() {
                /**
                 * A regular expression for finding markup in a string.
                 */
                this.markupRegex = new RegExp(__startSymbol + '[\\S\\s]*' + __endSymbol);
                /**
                 * Finds the arguments in a method expression.
                 */
                this.argumentRegex = /\((.*)\)/;
                /**
                 * Finds '/*.html' or '/*.htm' in a url. Useful for removing
                 * the html file out of the url.
                 */
                this.initialUrlRegex = /\/[^\/]*\.(?:html|htm)/;
                /**
                 * Finds a protocol delimeter in a string (e.g. ://).
                 */
                this.protocolRegex = /:\/\//;
                /**
                 * Looks for any invalid variable syntax.
                 */
                this.invalidVariableRegex = /[^a-zA-Z0-9@_$]/;
                /**
                 * Grabs the file name from a file path.
                 */
                this.fileNameRegex = /.*(?:\/|\\)/;
                /**
                 * Determines if a character is correlated with a shifted key code.
                 */
                this.shiftedKeyRegex = /[A-Z!@#$%^&*()_+}{":?><|~]/;
                /**
                 * Determines if a url is relative or absolute.
                 */
                this.fullUrlRegex = /^(?:[a-z0-9\-]+:)(?:\/\/)?|(?:\/\/)/i;
                /**
                 * Determines if an email address is valid.
                 */
                this.validateEmail = new RegExp('^(([^<>()[\\]\\\.,;:\\s@\\"]+(\\.[^<>()[\\]\\\.,;:\\s@\\"]+)*)|' +
                    '(\\".+\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|' +
                    '(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$');
                /**
                 * Determines if a telephone number is valid.
                 */
                this.validateTelephone = /^\+?[0-9\.\(\)\s-]*$/;
                /**
                 * A regular expression for matching dynamic segments in a route.
                 */
                this.dynamicSegmentsRegex = /^:([^\/]+)$/;
                /**
                 * A regular expression for matching splat segments in a route.
                 */
                this.splatSegmentRegex = /^\*([^\/]+)$/;
            }
            Object.defineProperty(Regex.prototype, "newLineRegex", {
                /**
                 * A regular expression for matching or removing all newline characters.
                 */
                get: function () {
                    return /\r|\n/g;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Regex.prototype, "optionalRouteRegex", {
                /**
                 * Finds optional parameters in a route string.
                 */
                get: function () {
                    return /\((.*?)\)/g;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Regex.prototype, "namedParameterRouteRegex", {
                /**
                 * Finds named parameters in a route string.
                 */
                get: function () {
                    return /(\(\?)?:\w+/g;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Regex.prototype, "wildcardRouteRegex", {
                /**
                 * Finds an alphanumeric wildcard match in a route string.
                 * exec('/foo/*bar/baz');
                 */
                get: function () {
                    return /\*\w*/g;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Regex.prototype, "escapeRouteRegex", {
                /**
                 * Finds invalid characters in a route string.
                 */
                get: function () {
                    return /[\-{}\[\]+?.,\\\^$|#\s]/g;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Regex.prototype, "camelCaseRegex", {
                /**
                 * Finds delimeters for spinal-case, snake_case, and dot.case.
                 * useful for converting to camelCase. Also can turn a string
                 * into camelCase with space as a delimeter.
                 */
                get: function () {
                    return /([\-_\.\s])(\w+?)/g;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Regex.prototype, "capitalCaseRegex", {
                /**
                 * Finds all capital letters.
                 */
                get: function () {
                    return /[A-Z]/g;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Regex.prototype, "whiteSpaceRegex", {
                /**
                 * Finds all whitespace and newline characters
                 * not in string literals. Needs to be combined
                 * with string replace function using $1 argument.
                 */
                get: function () {
                    return /("[^"]*?"|'[^']*?')|[\s\r\n\t\v]/g;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Regex.prototype, "quotationRegex", {
                /**
                 * Finds all single and double quotes.
                 */
                get: function () {
                    return /'|"/g;
                },
                enumerable: true,
                configurable: true
            });
            return Regex;
        }());
        expressions.Regex = Regex;
        register.injectable(__Regex, Regex);
        /**
         * A class that is responsible for taking in a JavaScript expression string and
         * finding all of its tokens (i.e. delimiters, operators, etc).
         */
        var Tokenizer = (function () {
            function Tokenizer() {
                /**
                 * The previous character during tokenization.
                 */
                this.__previousChar = '';
                /**
                 * A regular expression for determining if a potential variable is valid syntax.
                 */
                this.__variableRegex = acquire(__Regex).invalidVariableRegex;
                /**
                 * A queue used for determining the output of the tokenization.
                 */
                this.__outputQueue = [];
                /**
                 * A stack used for determining operator precedence and aiding with the evaluation
                 * operands.
                 */
                this.__operatorStack = [];
                /**
                 * A collection used for determining argument count for certain operations.
                 */
                this.__argCount = [];
                /**
                 * A collection used for determining argument count for certain object literal operations.
                 */
                this.__objArgCount = [];
                /**
                 * The last character encountered while in an operation dealing with the colon operator.
                 * Needs to be an array due to the possibility of nested colon operations.
                 */
                this.__lastColonChar = [];
                /**
                 * The last character encountered while in an operation dealing with commas.
                 * Needs to be an array due to the possibility of nested comma operations.
                 */
                this.__lastCommaChar = [];
            }
            /**
             * Takes in an expression string and outputs a tokenized collection of
             * ITokens.
             * @param {string} input The JavaScript expression string to tokenize.
             */
            Tokenizer.prototype.createTokens = function (input) {
                if (isNull(input)) {
                    return [];
                }
                this._input = input;
                var char, length = input.length, ternary = 0, ternaryFound = false, isSpace = this._isSpace, isAlphaNumeric = this._isAlphaNumeric;
                for (var index = 0; index < length; index++) {
                    char = input[index];
                    // space 
                    if (isSpace(char)) {
                        continue;
                    }
                    else if (isAlphaNumeric(char)) {
                        index = this.__handleAplhaNumeric(index, char);
                    }
                    else if (isDelimiter(char)) {
                        switch (char) {
                            case '.':
                                index = this.__handlePeriod(index, char);
                                break;
                            case '{':
                                this.__handleLeftBrace(char);
                                break;
                            case '}':
                                this.__handleRightBrace(char);
                                break;
                            case '[':
                                this.__handleLeftBracket(char);
                                break;
                            case ']':
                                this.__handleRightBracket(char);
                                break;
                            case '(':
                                this.__handleLeftParenthesis(char);
                                break;
                            case ')':
                                this.__handleRightParenthesis(char);
                                break;
                            case ',':
                                this.__handleComma(char);
                                break;
                            case '\'':
                            case '"':
                                index = this.__handleStringLiteral(index, char);
                                break;
                        }
                    }
                    else if (isOperator(char)) {
                        switch (char) {
                            case '?':
                                ternaryFound = true;
                                ternary++;
                                this.__handleQuestion(char);
                                break;
                            case ':':
                                ternary = this.__handleColon(char, ternary);
                                break;
                            default:
                                index = this.__handleOtherOperator(index, char);
                        }
                    }
                    else if (char === ';') {
                        this._throwError('Unexpected semicolon');
                        return [];
                    }
                    this.__previousChar = char;
                }
                if (ternaryFound && (ternary > 0)) {
                    this._throwError('Improper ternary expression');
                    return [];
                }
                else if (this.__objArgCount.length > 0) {
                    this._throwError('Improper object literal');
                    return [];
                }
                this.__popRemainingOperators();
                var output = this.__outputQueue;
                this._resetTokenizer();
                return output;
            };
            /**
             * Determines character type.
             * @param {string} char The character to check.
             * @param {boolean} isNumberLike Whether or not the character resembles a number.
             */
            Tokenizer.prototype._checkType = function (char, isNumberLike) {
                if (isNumberLike) {
                    return this._isNumeric(char);
                }
                return this._isAlphaNumeric(char);
            };
            /**
             * Looks ahead in the expression to group similar character types.
             * @param {string} char The current character in the expression string.
             * @param {number} index The current index in the expression string.
             * @param {boolean} isNumberLike Whether or not the character resembles a number.
             */
            Tokenizer.prototype._lookAhead = function (char, index, isNumberLike) {
                var ch, input = this._input, maxLength = input.length;
                while (++index < maxLength) {
                    ch = input[index];
                    if (this._checkType(ch, isNumberLike)) {
                        char += ch;
                    }
                    else {
                        break;
                    }
                }
                return char;
            };
            /**
             * Looks ahead in the expression to try and complete the
             * current operator.
             * @param {string} char The operator to find.
             * @param {number} index The current index in the expression string.
             */
            Tokenizer.prototype._lookAheadForOperatorFn = function (char, index) {
                var ch, fn = char, input = this._input, maxLength = input.length;
                while (++index < maxLength) {
                    ch = input[index];
                    fn += ch;
                    if (isOperator(fn)) {
                        char = fn;
                    }
                    else {
                        break;
                    }
                }
                return char;
            };
            /**
             * Looks ahead in the expression until it comes to the ending
             * character to try and complete a particular sequence
             * (e.g. - a string literal). Also strips the first and last
             * characters of the result (i.e. removes the delimiters).
             * @param {string} endChar The ending character.
             * @param {number} index The current index in the expression string.
             */
            Tokenizer.prototype._lookAheadForDelimiter = function (endChar, index) {
                var char = '', ch, input = this._input, maxLength = input.length;
                while ((++index < maxLength) && (ch = input[index]) !== endChar) {
                    char += ch;
                }
                return char;
            };
            /**
             * Pops the operator stack onto the output queue until a particular
             * operator value is reached.
             * @param {plat.expressions.IToken} topOperator The top of the operator stack.
             * @param {string} char The operator value being searched for.
             * @param {string} error The error to throw in the case that the expression
             * is invalid.
             */
            Tokenizer.prototype._popStackForVal = function (topOperator, char, error) {
                var outputQueue = this.__outputQueue, operatorStack = this.__operatorStack;
                while (topOperator.val !== char) {
                    outputQueue.push(operatorStack.shift());
                    topOperator = operatorStack[0];
                    if (operatorStack.length === 0) {
                        return this._throwError(error);
                    }
                }
            };
            /**
             * Check if the "val" property on an IToken
             * is present in a particular character string.
             * @param {plat.expressions.IToken} obj The IToken
             * with the "val" property to compare.
             * @param {string} char The char to compare with.
             */
            Tokenizer.prototype._isValEqual = function (obj, char) {
                if (isNull(obj) || isNull(obj.val)) {
                    return isNull(char);
                }
                else if (obj.val === '') {
                    return char === '';
                }
                return char.indexOf(obj.val) !== -1;
            };
            /**
             * Check if the "val" property on an IToken
             * is not present in a particular character string.
             * @param {plat.expressions.IToken} obj The IToken
             * with the "val" property to compare.
             * @param {string} char The char to compare with.
             */
            Tokenizer.prototype._isValUnequal = function (obj, char) {
                if (isNull(obj) || isNull(obj.val)) {
                    return !isNull(char);
                }
                else if (obj.val === '') {
                    return char !== '';
                }
                return char.indexOf(obj.val) === -1;
            };
            /**
             * Resets all the tokenizer's properties.
             */
            Tokenizer.prototype._resetTokenizer = function () {
                this._input = null;
                this.__previousChar = '';
                this.__outputQueue = [];
                this.__operatorStack = [];
                this.__argCount = [];
                this.__objArgCount = [];
                this.__lastColonChar = [];
                this.__lastCommaChar = [];
            };
            /**
             * Throws a fatal exception in the case of an error.
             * @param {string} error The error message to throw.
             */
            Tokenizer.prototype._throwError = function (error) {
                this._log.error(new Error(error + ' in ' + this._input));
            };
            /**
             * Checks if a single character is numeric.
             * @param {string} char The character to check.
             */
            Tokenizer.prototype._isNumeric = function (char) {
                return ('0' <= char && char <= '9');
            };
            /**
             * Checks if a single character is a space.
             * @param {string} char The character to check.
             */
            Tokenizer.prototype._isSpace = function (char) {
                return (char === ' ' ||
                    char === '\r' ||
                    char === '\n' ||
                    char === '\t' ||
                    char === '\v' ||
                    char === '\u00A0');
            };
            /**
             * Checks if a single character is alphanumeric.
             * @param {string} char The character to check.
             */
            Tokenizer.prototype._isAlphaNumeric = function (char) {
                return ('a' <= char && char <= 'z' ||
                    'A' <= char && char <= 'Z' ||
                    '0' <= char && char <= '9' ||
                    '@' === char ||
                    '_' === char ||
                    '$' === char);
            };
            /**
             * Checks if a string has proper JavaScript variable syntax.
             * @param {string} input The string to check.
             */
            Tokenizer.prototype._isStringValidVariable = function (input) {
                return !this.__variableRegex.test(input);
            };
            /**
             * Handles tokenizing an alphanumeric character.
             * @param {number} index The current index in the string being tokenized.
             * @param {string} char The current char.
             */
            Tokenizer.prototype.__handleAplhaNumeric = function (index, char) {
                var isNumberLike = this._isNumeric(char), lookAhead = this._lookAhead(char, index, isNumberLike);
                this.__outputQueue.push(isNumberLike ? ({ val: Number(lookAhead), args: 0 }) :
                    ({ val: lookAhead, args: -1 }));
                return index + lookAhead.length - 1;
            };
            /**
             * Handles tokenizing a "." character.
             * @param {number} index The current index in the string being tokenized.
             * @param {string} char The current char.
             */
            Tokenizer.prototype.__handlePeriod = function (index, char) {
                var outputQueue = this.__outputQueue, operatorStack = this.__operatorStack, topOutputLength = outputQueue.length - 1, previousChar = this.__previousChar, lookAhead;
                // if output queue is null OR space or operator or ( or , before . 
                if (topOutputLength < 0 ||
                    this._isSpace(previousChar) ||
                    !isNull(OPERATORS[previousChar]) ||
                    previousChar === '(' ||
                    previousChar === ',') {
                    lookAhead = this._lookAhead(char, index, true);
                    index += lookAhead.length - 1;
                    outputQueue.push({ val: parseFloat(lookAhead), args: 0 });
                }
                else if (this._isValEqual(operatorStack[0], char)) {
                    outputQueue.push({ val: char, args: 0 });
                }
                else if (!(isNull(outputQueue[topOutputLength]) ||
                    !isNumber(Number(outputQueue[topOutputLength].val)) ||
                    this._isValEqual(outputQueue[topOutputLength - 1], char))) {
                    lookAhead = this._lookAhead(char, index, true);
                    index += lookAhead.length - 1;
                    outputQueue[topOutputLength].val += parseFloat(lookAhead);
                }
                else {
                    operatorStack.unshift({ val: char, args: 0 });
                }
                return index;
            };
            /**
             * Handles tokenizing a "{" character.
             * @param {string} char The current char.
             */
            Tokenizer.prototype.__handleLeftBrace = function (char) {
                this.__operatorStack.unshift({ val: char, args: 0 });
                this.__objArgCount.push(0);
                this.__lastColonChar.push(char);
                this.__lastCommaChar.push(char);
            };
            /**
             * Handles tokenizing a "}" character.
             * @param {string} char The current char.
             */
            Tokenizer.prototype.__handleRightBrace = function (char) {
                var operatorStack = this.__operatorStack, topOperator = operatorStack[0], lastArgCount = this.__objArgCount.pop();
                if (isNull(topOperator)) {
                    return this._throwError('Improper object literal');
                }
                this._popStackForVal(topOperator, '{', 'Improper object literal');
                // pop left brace off stack 
                operatorStack.shift();
                this.__lastColonChar.pop();
                this.__lastCommaChar.pop();
                this.__outputQueue.push({ val: '{}', args: lastArgCount });
            };
            /**
             * Handles tokenizing a "[" character.
             * @param {string} char The current char.
             */
            Tokenizer.prototype.__handleLeftBracket = function (char) {
                var previousChar = this.__previousChar, operatorStack = this.__operatorStack;
                if (this._isValEqual(operatorStack[0], '.')) {
                    this.__outputQueue.push(operatorStack.shift());
                }
                operatorStack.unshift({ val: char, args: 0 });
                this.__argCount.push({
                    num: 0,
                    isArray: !(previousChar === ']' ||
                        previousChar === ')' ||
                        this._isAlphaNumeric(previousChar))
                });
                this.__lastCommaChar.push(char);
            };
            /**
             * Handles tokenizing a "]" character.
             * @param {string} char The current char.
             */
            Tokenizer.prototype.__handleRightBracket = function (char) {
                var operatorStack = this.__operatorStack, topOperator = operatorStack[0], lastArgCountObj = this.__argCount.pop();
                if (isNull(topOperator) || isNull(lastArgCountObj)) {
                    return this._throwError('Brackets mismatch');
                }
                if (!lastArgCountObj.isArray) {
                    lastArgCountObj.num--;
                }
                this._popStackForVal(topOperator, '[', 'Brackets mismatch');
                // pop left bracket off stack 
                operatorStack.shift();
                this.__lastCommaChar.pop();
                // check if function on top of stack 
                this.__outputQueue.push({
                    val: '[]',
                    args: (this.__previousChar === '[') ? -1 : lastArgCountObj.num + 1
                });
            };
            /**
             * Handles tokenizing a "(" character.
             * @param {string} char The current char.
             */
            Tokenizer.prototype.__handleLeftParenthesis = function (char) {
                var previousChar = this.__previousChar, operatorStack = this.__operatorStack, args;
                if (this._isAlphaNumeric(previousChar) || previousChar === ']' || previousChar === ')') {
                    var outputQueue = this.__outputQueue, topOutput = outputQueue[outputQueue.length - 1], val = isNull(topOutput) ? undefined : topOutput.val;
                    if (val === '[]') {
                        operatorStack.unshift(outputQueue.pop());
                        operatorStack.unshift(outputQueue.pop());
                    }
                    else if (!(val === '()' || this._isNumeric(val))) {
                        operatorStack.unshift(outputQueue.pop());
                    }
                    args = 0;
                }
                else {
                    args = -1;
                }
                this.__argCount.push({ num: args });
                operatorStack.unshift({ val: char, args: args });
                this.__lastCommaChar.push(char);
            };
            /**
             * Handles tokenizing a ")" character.
             * @param {string} char The current char.
             */
            Tokenizer.prototype.__handleRightParenthesis = function (char) {
                var operatorStack = this.__operatorStack, topOperator = operatorStack[0], localArgCountObj = this.__argCount.pop();
                if (isNull(topOperator)) {
                    return this._throwError('Parentheses mismatch');
                }
                this._popStackForVal(topOperator, '(', 'Parentheses mismatch');
                // pop left parenthesis off stack 
                operatorStack.shift();
                this.__lastCommaChar.pop();
                // check if function on top of stack 
                if (!isNull(localArgCountObj) && localArgCountObj.num >= 0) {
                    var localArgNum = localArgCountObj.num;
                    if (this.__previousChar === '(') {
                        if (this.__removeFnFromStack(localArgNum)) {
                            this.__outputQueue.push({
                                val: '()',
                                args: 0
                            });
                        }
                    }
                    else if (this.__removeFnFromStack(localArgNum + 1)) {
                        this.__outputQueue.push({
                            val: '()',
                            args: (localArgNum + 1)
                        });
                    }
                }
            };
            /**
             * Handles tokenizing a "," character.
             * @param {string} char The current char.
             */
            Tokenizer.prototype.__handleComma = function (char) {
                var lastCommaArray = this.__lastCommaChar, lastCommaArg = lastCommaArray[lastCommaArray.length - 1];
                if (lastCommaArg === '(' || lastCommaArg === '[') {
                    var argCountArray = this.__argCount, length_2 = argCountArray.length;
                    if (length_2 > 0) {
                        // increment deepest fn count (don't need to increment obj count because we increment with colon) 
                        argCountArray[length_2 - 1].num++;
                    }
                    else {
                        return this._throwError('Mismatch with ' + lastCommaArg);
                    }
                }
                var topOperator = this.__operatorStack[0];
                if (isNull(topOperator)) {
                    return this._throwError('Unexpected comma');
                }
                this._popStackForVal(topOperator, lastCommaArg, 'Unexpected comma');
            };
            /**
             * Handles tokenizing a string literal.
             * @param {number} index The current index in the string being tokenized.
             * @param {string} char The current char.
             */
            Tokenizer.prototype.__handleStringLiteral = function (index, char) {
                var lookAhead = this._lookAheadForDelimiter(char, index), operatorStack = this.__operatorStack, topOperator = operatorStack[0];
                if (!isNull(topOperator) && (topOperator.val === '[' || (topOperator.val === '(' && topOperator.args >= 0))) {
                    operatorStack.unshift({ val: lookAhead, args: 0 });
                }
                else {
                    this.__outputQueue.push({ val: lookAhead, args: 0 });
                }
                return index + lookAhead.length + 1;
            };
            /**
             * Handles tokenizing a "?" character.
             * @param {string} char The current char.
             */
            Tokenizer.prototype.__handleQuestion = function (char) {
                this.__lastColonChar.push(char);
                this.__determinePrecedence(char);
            };
            /**
             * Handles tokenizing a ":" character.
             * @param {string} char The current char.
             * @param {number} ternary The current ternary counter. Increments when a ternary is found,
             * decrements when a ternary is completed. It can be very useful when there is nested ternaries.
             */
            Tokenizer.prototype.__handleColon = function (char, ternary) {
                var lastColonCharArray = this.__lastColonChar, lastColonCharacter = lastColonCharArray[lastColonCharArray.length - 1], outputQueue = this.__outputQueue;
                if (lastColonCharacter === '?') {
                    var operatorStack = this.__operatorStack, topOperator = operatorStack[0];
                    if (isNull(topOperator)) {
                        this._throwError('Ternary mismatch');
                        return;
                    }
                    ternary--;
                    // pop latest colon char off queue 
                    lastColonCharArray.pop();
                    this._popStackForVal(topOperator, '?', 'Ternary mismatch');
                    outputQueue.push(operatorStack.shift());
                    operatorStack.unshift({ val: char, args: -2 });
                }
                else if (lastColonCharacter === '{') {
                    var objArgCount = this.__objArgCount, outputLast = outputQueue.length - 1;
                    objArgCount[objArgCount.length - 1]++;
                    if (outputLast < 0) {
                        this._throwError('Unexpected colon');
                        return;
                    }
                    outputQueue[outputLast].args = 1;
                }
                else {
                    this._throwError('Unexpected colon');
                    return;
                }
                return ternary;
            };
            /**
             * Handles tokenizing all other operators.
             * @param {number} index The current index in the string being tokenized.
             * @param {string} char The current char.
             */
            Tokenizer.prototype.__handleOtherOperator = function (index, char) {
                var lookAhead = this._lookAheadForOperatorFn(char, index);
                this.__determinePrecedence(lookAhead);
                return index + lookAhead.length - 1;
            };
            /**
             * Pops operators left on the operator stack onto the output queue
             * checking for mismatches.
             */
            Tokenizer.prototype.__popRemainingOperators = function () {
                var outputQueue = this.__outputQueue, operatorStack = this.__operatorStack, topOperator, topOperatorVal;
                while (operatorStack.length > 0) {
                    topOperator = operatorStack.shift();
                    topOperatorVal = topOperator.val;
                    if (topOperatorVal === '(' || topOperatorVal === ')') {
                        return this._throwError('Parentheses mismatch');
                    }
                    outputQueue.push(topOperator);
                }
            };
            /**
             * Grabs essential token details for a given operator.
             * @param {string} operator The operator whose details are being requested.
             */
            Tokenizer.prototype.__determineOperator = function (operator) {
                switch (operator) {
                    case '+':
                    case '-':
                        if (this.__outputQueue.length === 0 || isOperator(this.__previousChar)) {
                            return OPERATORS['u' + operator];
                        }
                    default:
                        return OPERATORS[operator];
                }
            };
            /**
             * Determines the precedence of a given operator in relation to other operators
             * in the operator stack and places it in the operator stack.
             * @param {string} operator The operator whose precedence is being determined.
             */
            Tokenizer.prototype.__determinePrecedence = function (operator) {
                var operatorFn = this.__determineOperator(operator), operatorPrecedence = operatorFn.precedence, isLtR = operatorFn.associativity === 'ltr', operatorStack = this.__operatorStack, outputQueue = this.__outputQueue, firstArrayOperator, firstArrayVal;
                if (operatorStack.length === 0) {
                    operatorStack.unshift({ val: operator, args: operatorFn.fn.length - 2 });
                    return;
                }
                do {
                    firstArrayVal = operatorStack[0].val;
                    if (firstArrayVal === '.') {
                        outputQueue.push(operatorStack.shift());
                        continue;
                    }
                    firstArrayOperator = OPERATORS[firstArrayVal];
                    if (!(isNull(firstArrayOperator) ||
                        !(firstArrayOperator.precedence < operatorPrecedence ||
                            (isLtR && firstArrayOperator.precedence === operatorPrecedence)))) {
                        outputQueue.push(operatorStack.shift());
                    }
                    else {
                        operatorStack.unshift({ val: operator, args: operatorFn.fn.length - 2 });
                        return;
                    }
                } while (operatorStack.length > 0);
                operatorStack.unshift({ val: operator, args: operatorFn.fn.length - 2 });
            };
            /**
             * Removes a reference to a function that is present in the operator stack and places
             * it in the output queue.
             * @param {number} argCount The current local argument count used with functions,
             * arrays, and object literals.
             */
            Tokenizer.prototype.__removeFnFromStack = function (argCount) {
                var outputQueue = this.__outputQueue, operatorStack = this.__operatorStack, topOperator = operatorStack[0], isValEqual = this._isValEqual, isValUnequal = this._isValUnequal, fnToken, atLeastOne = false;
                while (!isNull(topOperator) &&
                    isValUnequal(topOperator, '([') &&
                    (this._isStringValidVariable(topOperator.val) ||
                        isValEqual(topOperator.val, '.[]') ||
                        isAccessor(topOperator.val))) {
                    fnToken = operatorStack.shift();
                    if (!(fnToken.args !== -1 || isValEqual(fnToken, '.[]'))) {
                        fnToken.args = -2;
                    }
                    outputQueue.push(fnToken);
                    topOperator = operatorStack[0];
                    atLeastOne = true;
                }
                if (!(atLeastOne || isValUnequal(outputQueue[outputQueue.length - argCount - 1], '()'))) {
                    atLeastOne = true;
                }
                return atLeastOne;
            };
            Tokenizer._inject = {
                _log: __Log
            };
            return Tokenizer;
        }());
        expressions.Tokenizer = Tokenizer;
        register.injectable(__Tokenizer, Tokenizer);
        /**
         * A class for parsing JavaScript expression strings and creating
         * IParsedExpressions.
         */
        var Parser = (function () {
            function Parser() {
                /**
                 * A single expression's token representation created by a Tokenizer.
                 */
                this._tokens = [];
                /**
                 * An expression cache. Used so that a JavaScript expression is only ever parsed once.
                 */
                this.__cache = {};
                /**
                 * A dynamically built string array that represents the evaluation function.
                 */
                this.__codeArray = [];
                /**
                 * A list of all the identifiers discovered in the JavaScript expression string.
                 */
                this.__identifiers = [];
                /**
                 * A temporary list of identifiers found used to build and evaluate each actual identifier.
                 */
                this.__tempIdentifiers = [];
                /**
                 * An object whose keys represent a list of all unique aliases found in the JavaScript expression string.
                 */
                this.__aliases = {};
                /**
                 * The constant that needs to be prepended to every dyanmic eval function.
                 */
                this.__fnEvalConstant = 'var initialContext;return ';
            }
            /**
             * Parses a JavaScript expression string.
             * @param {string} expression The JavaScript expression string to parse.
             */
            Parser.prototype.parse = function (expression) {
                var parsedObject = this.__cache[expression];
                if (!isNull(parsedObject)) {
                    return {
                        expression: parsedObject.expression,
                        identifiers: parsedObject.identifiers.slice(0),
                        aliases: parsedObject.aliases.slice(0),
                        evaluate: parsedObject.evaluate
                    };
                }
                this._tokens = this._tokenizer.createTokens(expression);
                parsedObject = this._evaluate(expression);
                var identifiers = parsedObject.identifiers;
                if (identifiers.length === 0) {
                    var noModel_1 = parsedObject.evaluate(null);
                    parsedObject.evaluate = function () { return noModel_1; };
                }
                this.__cache[expression] = parsedObject;
                return parsedObject;
            };
            /**
             * If a key is passed in, it clears that single value in the expression cache. If no
             * key is present, the entire expression cache will be cleared.
             * @param {string} key? An optional key that will clear its stored value in the expression
             * cache if passed in.
             */
            Parser.prototype.clearCache = function (key) {
                if (isString(key)) {
                    deleteProperty(this.__cache, key);
                    return;
                }
                this.__cache = {};
            };
            /**
             * Evaluate the current IToken array.
             * @param {string} expression The JavaScript expression to evaluate.
             */
            Parser.prototype._evaluate = function (expression) {
                var tokens = this._tokens, length = tokens.length, tempIdentifiers = this.__tempIdentifiers, codeArray = this.__codeArray, useLocalContext = false, tokenObj, token, args;
                for (var index = 0; index < length; index++) {
                    tokenObj = tokens[index];
                    token = tokenObj.val;
                    args = tokenObj.args;
                    // check if its an accessor 
                    if (isAccessor(token)) {
                        switch (token) {
                            case '()':
                                useLocalContext = this.__handleFunction(index, args, useLocalContext);
                                break;
                            case '{}':
                                codeArray.push(this.__convertObject(args));
                                tempIdentifiers.push('.');
                                break;
                            default:
                                // handle empty array 
                                if (args < 0) {
                                    codeArray.push('[]');
                                    tempIdentifiers.push('.');
                                }
                                else if (args > 0) {
                                    codeArray.push(this.__convertArrayLiteral(args));
                                    tempIdentifiers.push('.');
                                }
                                else {
                                    useLocalContext = this.__indexIntoObject(index, token, useLocalContext);
                                }
                                break;
                        }
                    }
                    else if (isOperator(token)) {
                        // check if string literal 
                        if (args === 0) {
                            codeArray.push(this.__convertPrimitive(index, token, args));
                        }
                        else {
                            switch (token) {
                                case '?':
                                    this.__handleQuestion();
                                    break;
                                case ':':
                                    this.__handleColon();
                                    break;
                                case '+':
                                case '-':
                                    if (args === 1) {
                                        token = 'u' + token;
                                    }
                                default:
                                    this.__handleOperator(token, args);
                                    break;
                            }
                        }
                    }
                    else {
                        // potential function or object to index into 
                        if (args < 0) {
                            codeArray.push(this.__convertFunction(index, token, useLocalContext));
                        }
                        else {
                            codeArray.push(this.__convertPrimitive(index, token, args));
                        }
                    }
                }
                // move the rest of the tempIdentifiers to the identifiers 
                this._popRemainingIdentifiers();
                // make the identifiers array unqiue entries only 
                this._makeIdentifiersUnique();
                var parsedExpression = {
                    evaluate: new Function(__CONTEXT, __ALIASES, this.__fnEvalConstant + (codeArray.length === 0 ? ('"' + expression + '"') : codeArray.join('')) + ';'),
                    expression: expression,
                    identifiers: this.__identifiers.slice(0),
                    aliases: Object.keys(this.__aliases)
                };
                // reset parser's properties 
                this._resetParser();
                return parsedExpression;
            };
            /**
             * Peek at the next IToken.
             * @param {number} index The index before the desired IToken
             * in the array.
             */
            Parser.prototype._peek = function (index) {
                return this._tokens[index + 1];
            };
            /**
             * Look back at the previous IToken.
             * @param {number} index The index after the desired IToken
             * in the array.
             */
            Parser.prototype._lookBack = function (index) {
                return this._tokens[index - 1];
            };
            /**
             * Evaluate and remove the leftover identifiers.
             */
            Parser.prototype._popRemainingIdentifiers = function () {
                var identifiers = this.__identifiers, tempIdentifiers = this.__tempIdentifiers, last;
                while (tempIdentifiers.length > 0) {
                    last = tempIdentifiers.pop();
                    if (last !== '.') {
                        identifiers.push(last);
                    }
                }
            };
            /**
             * Remove duplicate identifiers.
             */
            Parser.prototype._makeIdentifiersUnique = function () {
                var identifiers = this.__identifiers, uniqueIdentifiers = [], uniqueIdentifierObject = {}, identifier;
                while (identifiers.length > 0) {
                    identifier = identifiers.pop();
                    if (!uniqueIdentifierObject[identifier]) {
                        uniqueIdentifierObject[identifier] = true;
                        uniqueIdentifiers.push(identifier);
                    }
                }
                this.__identifiers = uniqueIdentifiers;
            };
            /**
             * Check if the "val" property on an IToken
             * is present in a particular character string.
             * @param {plat.expressions.IToken} obj The IToken
             * with the "val" property to compare.
             * @param {string} char The char to compare with.
             */
            Parser.prototype._isValEqual = function (obj, char) {
                if (isNull(obj) || isNull(obj.val)) {
                    return isNull(char);
                }
                else if (obj.val === '') {
                    return char === '';
                }
                return char.indexOf(obj.val) !== -1;
            };
            /**
             * Check if the "val" property on an IToken
             * is not present in a particular character string.
             * @param {plat.expressions.IToken} obj The IToken
             * with the "val" property to compare.
             * @param {string} char The char to compare with.
             */
            Parser.prototype._isValUnequal = function (obj, char) {
                if (isNull(obj) || isNull(obj.val)) {
                    return !isNull(char);
                }
                else if (obj.val === '') {
                    return char !== '';
                }
                return char.indexOf(obj.val) === -1;
            };
            /**
             * Resets all the parser's properties.
             */
            Parser.prototype._resetParser = function () {
                this._tokens = [];
                this.__codeArray = [];
                this.__identifiers = [];
                this.__tempIdentifiers = [];
                this.__aliases = {};
            };
            /**
             * Throws a fatal exception in the case of an error.
             * @param {string} error The error message to throw.
             */
            Parser.prototype._throwError = function (error) {
                this._log.error(new Error(error));
            };
            /**
             * Handles a token that is a primitive value.
             * @param {number} index The current index in the IToken array.
             * @param {string} token The current IToken value.
             * @param {number} args The current IToken args.
             */
            Parser.prototype.__convertPrimitive = function (index, token, args) {
                if (args > 0) {
                    this.__tempIdentifiers.push('.');
                    return token;
                }
                var castTokenIsNumberLike = isNumber(Number(token)), peek = this._peek(index), isPeekIndexer = !(isNull(peek) || peek.args >= 1), isValEqual = this._isValEqual;
                if (isKeyword(token) ||
                    (isString(token) &&
                        (castTokenIsNumberLike ||
                            this._isValUnequal(peek, '[]()') ||
                            (isValEqual(peek, '[]') &&
                                !isPeekIndexer)))) {
                    this.__tempIdentifiers.push('.');
                    return '"' + token + '"';
                }
                else {
                    if (!castTokenIsNumberLike ||
                        (isValEqual(peek, '.[]') &&
                            isPeekIndexer)) {
                        this.__tempIdentifiers.push(token);
                    }
                    else {
                        this.__tempIdentifiers.push('.');
                    }
                    return token;
                }
            };
            /**
             * Handles a potential function or object that needs to be indexed into.
             * @param {number} index The current index in the IToken array.
             * @param {string} token The current IToken value.
             * @param {boolean} useLocalContext Whether or not we need to use an already parsed object as the current context.
             */
            Parser.prototype.__convertFunction = function (index, token, useLocalContext) {
                if (token[0] === '@') {
                    this.__aliases[token.slice(1)] = true;
                }
                else if (isKeyword(token)) {
                    this.__tempIdentifiers.push('.');
                    return token;
                }
                var nextToken = this._peek(index), isValEqual = this._isValEqual;
                if (isValEqual(this._tokens[index - 1], '()') && isValEqual(nextToken, '.[]')) {
                    this.__tempIdentifiers.push('.');
                }
                else {
                    this.__tempIdentifiers.push(token);
                }
                if (!isNull(nextToken)) {
                    switch (nextToken.val) {
                        case '.':
                        case '()':
                            return token;
                        default:
                            if (!useLocalContext) {
                                return '(initialContext = (' + this.__findInitialContext.toString() + ')(context,aliases,"' + token + '"))';
                            }
                            break;
                    }
                }
                else {
                    return '(initialContext = (' + this.__findInitialContext.toString() + ')(context,aliases,"' + token + '"))';
                }
            };
            /**
             * Handles an object literal.
             * @param {number} args The current IToken args.
             */
            Parser.prototype.__convertObject = function (args) {
                var identifiers = this.__identifiers, tempIdentifiers = this.__tempIdentifiers, codeArray = this.__codeArray, j = 0, key, codeStr = '{', tempIdentifier, temp;
                while (j++ < args) {
                    temp = codeArray.pop();
                    key = codeArray.pop();
                    codeStr += ',"' + key + '":' + temp;
                    if (tempIdentifiers.length > 1) {
                        tempIdentifier = tempIdentifiers.pop();
                        // pop the key's tempIdentifier 
                        tempIdentifiers.pop();
                        if (tempIdentifier !== '.') {
                            identifiers.push(tempIdentifier);
                        }
                    }
                }
                return codeStr.replace(',', '') + '}';
            };
            /**
             * Handles an Array literal.
             * @param {number} args The current IToken args.
             */
            Parser.prototype.__convertArrayLiteral = function (args) {
                var identifiers = this.__identifiers, tempIdentifiers = this.__tempIdentifiers, codeArray = this.__codeArray, j = 0, tempStr = '', tempIdentifier;
                while (j++ < args) {
                    tempStr = codeArray.pop() + ',' + tempStr;
                    if (tempIdentifiers.length > 0) {
                        tempIdentifier = tempIdentifiers.pop();
                        if (tempIdentifier !== '.') {
                            identifiers.push(tempIdentifier);
                        }
                    }
                }
                return '[' + tempStr.slice(0, -1) + ']';
            };
            /**
             * Handles an accessor type function token "()".
             * @param {number} index The current index in the IToken array.
             * @param {number} args The current IToken args.
             * @param {boolean} useLocalContext Whether or not we need to use an already parsed object as the current context.
             */
            Parser.prototype.__handleFunction = function (index, args, useLocalContext) {
                var identifiers = this.__identifiers, tempIdentifiers = this.__tempIdentifiers, codeArray = this.__codeArray, j = 0, previousToken = this._lookBack(index), grabFnName = !isNull(previousToken) && (previousToken.args === -2 || this._isValEqual(previousToken, '.[]')), tempStr = '', tempIdentifier, fnName = '', identifierFnName = '', codeStr, pushedIdentifier = false;
                if (grabFnName) {
                    fnName = codeArray.pop();
                    identifierFnName = tempIdentifiers.pop();
                }
                while (j++ < args) {
                    tempStr = codeArray.pop() + ',' + tempStr;
                    if (tempIdentifiers.length > 0) {
                        tempIdentifier = tempIdentifiers.pop();
                        if (tempIdentifier !== '.') {
                            identifiers.push(tempIdentifier);
                            pushedIdentifier = true;
                        }
                    }
                }
                if (args > 0) {
                    codeStr = '.call(initialContext || context,' + tempStr.slice(0, tempStr.length - 1) + ')';
                }
                else {
                    codeStr = '.call(initialContext || context)';
                }
                if (useLocalContext) {
                    useLocalContext = false;
                    if (codeArray.length > 0) {
                        var context = codeArray.pop(), lastIndex = tempIdentifiers.length - 1;
                        if (!(lastIndex < 0 || tempIdentifiers[lastIndex] === '.' || identifierFnName === '')) {
                            tempIdentifiers[lastIndex] += '.' + identifierFnName;
                            identifiers.push(tempIdentifiers.pop());
                        }
                        else if (!(identifierFnName === '' ||
                            !pushedIdentifier ||
                            context[0] === '[' ||
                            context[context.length - 1] === ']')) {
                            identifiers[identifiers.length - 1] += '.' + identifierFnName;
                        }
                        if (isEmpty(fnName)) {
                            codeStr = context + codeStr;
                        }
                        else {
                            codeStr = '((' + this.__indexIntoContext.toString() + ')(' + context + ',"' +
                                fnName + '") || (function () {}))' + codeStr;
                        }
                    }
                    else {
                        this._throwError('Improper expression or context');
                    }
                }
                else {
                    if (grabFnName) {
                        codeStr = '(initialContext = ((' + this.__findInitialContext.toString() + ')(context,aliases,"' +
                            fnName + '") || (function () {}))' + codeStr + ')';
                        identifiers.push(fnName);
                    }
                    else {
                        codeStr = codeArray.pop() + codeStr;
                    }
                }
                codeArray.push(codeStr);
                var length = tempIdentifiers.length;
                if (this._isValEqual(this._peek(index), '[]') && length > 0 && tempIdentifiers[length - 1] !== '.') {
                    identifiers.push(tempIdentifiers.pop());
                }
                return useLocalContext;
            };
            /**
             * Handles an accessor type token that is for indexing (i.e. "." or "[]").
             * @param {number} index The current index in the IToken array.
             * @param {string} token The current IToken value.
             * @param {boolean} useLocalContext Whether or not we need to use an already parsed object as the current context.
             */
            Parser.prototype.__indexIntoObject = function (index, token, useLocalContext) {
                var isValEqual = this._isValEqual;
                if (isValEqual(this._peek(index), '()')) {
                    return true;
                }
                var codeArray = this.__codeArray, codeStr = codeArray.pop(), identifiers = this.__identifiers, tempIdentifiers = this.__tempIdentifiers, previousToken = this._lookBack(index), identifierIndexer = tempIdentifiers.pop(), hasIdentifierIndexer = !isNull(identifierIndexer), lastIndex;
                if (hasIdentifierIndexer && identifierIndexer[0] === '@') {
                    codeStr = '(' + this.__indexIntoContext.toString() + ')(' + codeArray.pop() + ',' + codeStr + ')';
                    identifiers.push(identifierIndexer);
                    if (tempIdentifiers.length > 0) {
                        identifiers.push(tempIdentifiers.pop());
                    }
                }
                else if (isValEqual(previousToken, '++--()[]*/%?:>=<=&&||!===')) {
                    codeStr = '(' + this.__indexIntoContext.toString() + ')(' + codeArray.pop() + ',' + codeStr + ')';
                    tempIdentifiers.push('.');
                }
                else if (token === '[]' && !(isNull(previousToken) || previousToken.args >= 0)) {
                    codeStr = '(' + this.__indexIntoContext.toString() + ')(' + codeArray.pop() + ',' + codeStr + ')';
                    lastIndex = tempIdentifiers.length - 1;
                    if (lastIndex >= 0) {
                        if (tempIdentifiers[lastIndex] !== '.') {
                            identifiers.push(tempIdentifiers.pop());
                        }
                    }
                    identifiers.push(identifierIndexer);
                }
                else {
                    codeStr = '(' + this.__indexIntoContext.toString() + ')(' + codeArray.pop() + ',"' + codeStr + '")';
                    lastIndex = tempIdentifiers.length - 1;
                    if (lastIndex >= 0) {
                        if (tempIdentifiers[lastIndex] !== '.') {
                            tempIdentifiers[lastIndex] += '.' + identifierIndexer;
                        }
                    }
                    else if (hasIdentifierIndexer && identifierIndexer !== '.' && token !== '.') {
                        identifiers.push(identifierIndexer);
                    }
                }
                codeArray.push(codeStr);
                return useLocalContext;
            };
            /**
             * Handles the "?" operator.
             */
            Parser.prototype.__handleQuestion = function () {
                var identifiers = this.__identifiers, tempIdentifiers = this.__tempIdentifiers, codeArray = this.__codeArray, temp = codeArray.pop(), tempIdentifier;
                for (var i = 0; i < 2; i++) {
                    if (tempIdentifiers.length > 0) {
                        tempIdentifier = tempIdentifiers.pop();
                        if (tempIdentifier !== '.') {
                            identifiers.push(tempIdentifier);
                        }
                    }
                    else {
                        break;
                    }
                }
                codeArray.push(codeArray.pop() + '?' + temp);
            };
            /**
             * Handles the ":" operator.
             */
            Parser.prototype.__handleColon = function () {
                var identifiers = this.__identifiers, tempIdentifiers = this.__tempIdentifiers, codeArray = this.__codeArray, temp = codeArray.pop(), tempIdentifier;
                for (var i = 0; i < 2; i++) {
                    if (tempIdentifiers.length > 0) {
                        tempIdentifier = tempIdentifiers.pop();
                        if (tempIdentifier !== '.') {
                            identifiers.push(tempIdentifier);
                        }
                    }
                    else {
                        break;
                    }
                }
                codeArray.push(codeArray.pop() + ':' + temp);
            };
            /**
             * Handles all other operators.
             * @param {string} token The current IToken value.
             * @param {number} args The current IToken args.
             */
            Parser.prototype.__handleOperator = function (token, args) {
                var identifiers = this.__identifiers, tempIdentifiers = this.__tempIdentifiers, codeArray = this.__codeArray, j = 0, tempStr = '', tempIdentifier;
                while (j++ < args) {
                    tempStr = 'function (context, aliases) { return ' + codeArray.pop() + '; }' + ',' + tempStr;
                    if (tempIdentifiers.length > 0) {
                        tempIdentifier = tempIdentifiers.pop();
                        if (tempIdentifier !== '.') {
                            identifiers.push(tempIdentifier);
                        }
                    }
                }
                // push identifier for new result of operator 
                tempIdentifiers.push('.');
                codeArray.push('(' + OPERATORS[token].fn.toString() + ')(context, aliases,' + tempStr.slice(0, tempStr.length - 1) + ')');
            };
            /**
             * Safely finds an initial context.
             * @param {any} context The context object.
             * @param {any} aliases Any aliases that may exist.
             * @param {string} token The property used to find the initial context.
             */
            Parser.prototype.__findInitialContext = function (context, aliases, token) {
                if (token[0] === '@' && aliases !== null && typeof aliases === 'object') {
                    return aliases[token.slice(1)];
                }
                else if (context !== null && typeof context === 'object') {
                    return context[token];
                }
            };
            /**
             * Safely drills down into a specified context with a given token.
             * @param {any} context The context object.
             * @param {string} token The property used to drill into the context.
             */
            Parser.prototype.__indexIntoContext = function (context, token) {
                if (context !== null && typeof context === 'object') {
                    return context[token];
                }
            };
            Parser._inject = {
                _tokenizer: __Tokenizer,
                _log: __Log
            };
            return Parser;
        }());
        expressions.Parser = Parser;
        register.injectable(__Parser, Parser);
    })(expressions = plat_1.expressions || (plat_1.expressions = {}));
    /**
     * Holds classes and interfaces related to web components in platypus.
     */
    var web;
    (function (web) {
        /**
         */
        function Location(_window) {
            return _window.location;
        }
        web.Location = Location;
        register.injectable(__Location, Location, [__Window]);
        /**
         * The class that handles all interaction with the browser.
         */
        var Browser = (function () {
            /**
             * The constructor for a Browser. Assigns a uid and subscribes to the 'beforeLoad' event.
             */
            function Browser() {
                /**
                 * A unique string identifier.
                 */
                this.uid = uniqueId(__Plat);
                /**
                 * The browser's last URL.
                 */
                this.__lastUrl = this._location.href;
                /**
                 * Whether or not the browser is in an initialization state.
                 */
                this.__initializing = false;
                this._EventManager.on(this.uid, __beforeLoad, this.initialize, this);
                if (this._compat.msApp) {
                    this._stack = [];
                }
            }
            /**
             * Initializes the Browser instance, trims the url, and
             * adds events for popstate and hashchange.
             */
            Browser.prototype.initialize = function () {
                var _compat = this._compat;
                this._EventManager.dispose(this.uid);
                this.__initializing = true;
                acquire(__UrlUtilsInstance);
                var url = this.url(), trimmedUrl = url, changed = this._urlChanged.bind(this), _dom = this._dom, _window = this._window;
                if (trimmedUrl !== url) {
                    this.url(trimmedUrl, true);
                }
                if (_compat.pushState) {
                    _dom.addEventListener(_window, __POPSTATE, changed, false);
                }
                _dom.addEventListener(_window, __HASHCHANGE, changed, false);
                this.__initializing = false;
            };
            /**
             * Sets or gets the current _window.location
             * @param {string} url? The URL to set the location to.
             * @param {boolean} replace? Whether or not to replace the current URL in
             * the history.
             */
            Browser.prototype.url = function (url, replace) {
                var location = this._location;
                if (isString(url) && !this._isLastUrl(url)) {
                    if (!replace && isArray(this._stack)) {
                        this._stack.push(location.href);
                    }
                    this._setUrl(url, replace);
                }
                return this.__currentUrl || location.href;
            };
            /**
             * Navigates back in the browser history
             * @param {number} length=1 The length to go back
             */
            Browser.prototype.back = function (length) {
                if (!isNumber(length)) {
                    length = 1;
                }
                var _stack = this._stack;
                if (isArray(_stack) && _stack.length > 1) {
                    this._stack = _stack = _stack.slice(0, _stack.length - (length - 1));
                    this.url(_stack.pop());
                    _stack.pop();
                    return;
                }
                this._history.go(-length);
            };
            /**
             * Navigates forward in the browser history
             * @param {number} length=1 The length to go forward
             */
            Browser.prototype.forward = function (length) {
                if (!isNumber(length)) {
                    length = 1;
                }
                this._history.go(length);
            };
            /**
             * Creates a new UrlUtils object.
             * @param url? The URL to associate with the new UrlUtils
             * instance.
             */
            Browser.prototype.urlUtils = function (url) {
                url = url || this.url();
                var _urlUtils = acquire(__UrlUtilsInstance), _config = Browser.config;
                if (_config.routingType === _config.HASH) {
                    url = url.replace(new RegExp('#' + (_config.hashPrefix || '') + '/?'), '');
                }
                _urlUtils.initialize(url);
                return _urlUtils;
            };
            /**
             * Checks to see if the requested URL is cross domain.
             * @param url The URL to verify whether or not it's cross domain.
             */
            Browser.prototype.isCrossDomain = function (url) {
                if (!isString(url)) {
                    return false;
                }
                var urlUtils = this.urlUtils(url), locationUtils = this.urlUtils();
                // check for protocol:host:port mismatch 
                return urlUtils.protocol !== locationUtils.protocol ||
                    urlUtils.hostname !== locationUtils.hostname ||
                    urlUtils.port !== locationUtils.port;
            };
            /**
             * Formats the URL in the case of HASH routing.
             * @param url The URL to format.
             */
            Browser.prototype.formatUrl = function (url) {
                var config = Browser.config, baseUrl = config.baseUrl, isLocal = !this._regex.fullUrlRegex.test(url) || url.indexOf(baseUrl) > -1;
                if (!isString(url)) {
                    return '';
                }
                if (url === baseUrl) {
                    return url;
                }
                if (url[0] === '/') {
                    url = url.slice(1);
                }
                if (isLocal && config.routingType === config.HASH) {
                    var hasProtocol = url.indexOf(this.urlUtils().protocol) !== -1, prefix = config.hashPrefix || '', append = '#' + prefix, hashRegex = new RegExp(append + '|#/');
                    if (url[url.length - 1] !== '/' && url.indexOf('?') === -1) {
                        url += '/';
                    }
                    if (hasProtocol && !hashRegex.test(url)) {
                        url = url + append + '/';
                    }
                    else if (!hashRegex.test(url)) {
                        url = append + ((url[0] !== '/') ? '/' : '') + url;
                    }
                }
                if (isLocal && url.indexOf(baseUrl) === -1) {
                    url = baseUrl + url;
                }
                return url;
            };
            /**
             * The event to fire in the case of a URL change. It kicks
             * off a 'urlChanged' direct event notification.
             * @param url The URL to verify whether or not it's cross domain.
             */
            Browser.prototype._urlChanged = function () {
                var _this = this;
                if (this.__initializing) {
                    return;
                }
                this.__currentUrl = null;
                var utils = this.urlUtils(), $config = Browser.config, url = this._trimSlashes(utils.href);
                if (this.__lastUrl === url) {
                    return;
                }
                this.__lastUrl = url;
                var $manager = this._EventManager;
                postpone(function () {
                    $manager.dispatch(__urlChanged, _this, $manager.DIRECT, [utils]);
                });
            };
            /**
             * Checks for the existence of pushState and
             * sets the browser URL accordingly.
             * @param {string} url The URL to set.
             * @param {boolean} replace? Whether or not to replace the
             * current URL in the history.
             */
            Browser.prototype._setUrl = function (url, replace) {
                url = this.formatUrl(url);
                var utils = this.urlUtils(url), baseUrl = Browser.config.baseUrl, _history = this._history, _location = this._location;
                if (utils.href.indexOf(baseUrl) === -1) {
                    _location.href = url;
                    return;
                }
                // make sure URL is absolute 
                if (!this._regex.fullUrlRegex.test(url) && url[0] !== '/') {
                    url = baseUrl + url;
                }
                if (this._compat.pushState) {
                    if (replace) {
                        var state = _history.state;
                        if (!isObject(state)) {
                            state = {};
                        }
                        _history.replaceState({
                            previousLocation: state.previousLocation
                        }, '', url);
                    }
                    else {
                        _history.pushState({
                            previousLocation: this.urlUtils().pathname
                        }, '', url);
                    }
                    if (!this.__initializing) {
                        this._urlChanged();
                    }
                }
                else {
                    this.__currentUrl = url;
                    if (replace) {
                        _location.replace(url);
                    }
                    else {
                        _location.href = url;
                    }
                }
            };
            /**
             * Determines if the url is equal to the last url
             * @param {string} url The URL to match
             */
            Browser.prototype._isLastUrl = function (url) {
                var last = this.__lastUrl;
                if (isString(url)) {
                    if (isEmpty(url)) {
                        url = '/';
                    }
                    url = this._trimSlashes(this.urlUtils(url).href);
                }
                return url === last;
            };
            /**
             * Trims trailing slashes from a url.
             * @param {string} url The URL to trim
             */
            Browser.prototype._trimSlashes = function (url) {
                if (!isString(url) || url[url.length - 1] !== '/') {
                    return url;
                }
                return url.slice(0, -1);
            };
            Browser._inject = {
                _EventManager: __EventManagerStatic,
                _compat: __Compat,
                _regex: __Regex,
                _window: __Window,
                _location: __Location,
                _history: __History,
                _dom: __Dom
            };
            /**
             * The IBrowserConfig injectable object.
             */
            Browser.config = {
                HASH: 'hash',
                STATE: 'state',
                routingType: 'hash',
                hashPrefix: '!',
                baseUrl: ''
            };
            return Browser;
        }());
        web.Browser = Browser;
        register.injectable(__Browser, Browser);
        /**
         */
        function IBrowserConfig() {
            return Browser.config;
        }
        web.IBrowserConfig = IBrowserConfig;
        register.injectable(__BrowserConfig, IBrowserConfig);
        /**
         * Deals with obtaining detailed information about an
         * associated URL.
         */
        var UrlUtils = (function () {
            /**
             * The constructor for a UrlUtils instance.
             * Handles parsing the initial URL and obtain the base URL if necessary.
             */
            function UrlUtils() {
                var config = this._browserConfig, baseUrl = config.baseUrl;
                if (isEmpty(baseUrl) || !this._regex.fullUrlRegex.test(baseUrl)) {
                    var url = this._window.location.href, trimmedUrl = url.replace(this._regex.initialUrlRegex, '/');
                    if (isString(baseUrl)) {
                        if (baseUrl.indexOf('/') === 0) {
                            baseUrl = baseUrl.slice(1);
                        }
                    }
                    else {
                        baseUrl = '';
                    }
                    baseUrl = UrlUtils.__getBaseUrl(trimmedUrl) + baseUrl;
                    while (baseUrl[baseUrl.length - 1] === '/') {
                        baseUrl = baseUrl.slice(0, -1);
                    }
                    config.baseUrl = baseUrl + '/';
                }
            }
            /**
             * Creates a query object out of the URL's query search string.
             * @param {string} search The URL's query search string.
             */
            UrlUtils.__getQuery = function (search) {
                return deserializeQuery(search);
            };
            /**
             * Obtains the base URL for the app/site for doing STATE type routing.
             * @param {string} url The initial URL passed into the Browser.
             */
            UrlUtils.__getBaseUrl = function (url) {
                var _regex = acquire(__Regex), _location = acquire(__Location), origin = _location.origin, protocol = _location.protocol, host = _location.host;
                if (protocol === 'file:' || protocol.indexOf('wmapp') > -1 || protocol.indexOf('ms-appx') > -1) {
                    origin = _location.href;
                }
                else if (isUndefined(origin)) {
                    origin = _location.protocol + '//' + _location.host;
                }
                origin = origin.replace(_regex.initialUrlRegex, '');
                return origin.split('?')[0].split('#')[0] + '/';
            };
            /**
             * Initializes and defines properties using
             * the input url.
             * @param {string} url The input to associate with this UrlUtils instance.
             */
            UrlUtils.prototype.initialize = function (url) {
                url = url || '';
                var element = UrlUtils.__urlUtilsElement ||
                    (UrlUtils.__urlUtilsElement = this._document.createElement('a')), _browserConfig = this._browserConfig;
                // always make local urls relative to start page. 
                if (url[0] === '/' && url.indexOf('//') !== 0) {
                    url = url.slice(1);
                }
                // Always append the baseUrl if this is not a full-url 
                if (!this._regex.fullUrlRegex.test(url)) {
                    url = _browserConfig.baseUrl + url;
                }
                element.setAttribute('href', url);
                url = element.href;
                // we need to do this twice for cerain browsers (e.g. win8) 
                element.setAttribute('href', url);
                url = element.href;
                this.href = url;
                this.protocol = element.protocol ? element.protocol.replace(/:$/, '') : '';
                this.host = element.host;
                this.search = element.search ? element.search.replace(/^\?/, '') : '';
                this.hash = element.hash ? element.hash.replace(/^#/, '') : '';
                this.hostname = element.hostname;
                this.port = element.port;
                var path;
                if (!isEmpty(_browserConfig.baseUrl)) {
                    path = url.replace(_browserConfig.baseUrl, '/');
                }
                else {
                    path = (element.pathname.charAt(0) === '/')
                        ? element.pathname
                        : '/' + element.pathname;
                }
                path = path.replace(this._regex.initialUrlRegex, '/');
                this.pathname = path.split('?')[0].split('#')[0];
                this.query = UrlUtils.__getQuery(this.search);
            };
            /**
             * A toString function implementation for the UrlUtils class.
             */
            UrlUtils.prototype.toString = function () {
                return this.href;
            };
            UrlUtils._inject = {
                _EventManager: __EventManagerStatic,
                _document: __Document,
                _window: __Window,
                _compat: __Compat,
                _regex: __Regex,
                _browserConfig: __BrowserConfig
            };
            return UrlUtils;
        }());
        web.UrlUtils = UrlUtils;
        register.injectable(__UrlUtilsInstance, UrlUtils, null, __INSTANCE);
    })(web = plat_1.web || (plat_1.web = {}));
    /**
     * Holds all classes and interfaces related to async components in platypus.
     */
    var async;
    (function (async) {
        var __promiseQueue = [], browserGlobal = (typeof window !== 'undefined') ? window : {}, BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver, scheduleFlush;
        var process = process;
        // decide what async method to use to triggering processing of queued callbacks: 
        if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
            scheduleFlush = useNextTick();
        }
        else if (BrowserMutationObserver) {
            scheduleFlush = useMutationObserver();
        }
        else {
            scheduleFlush = useSetTimeout();
        }
        /**
         * Takes in a generic type corresponding to the fullfilled success type.
         */
        var Promise = (function () {
            /**
             * An ES6 implementation of the Promise API. Useful for asynchronous programming.
             * Takes in 2 generic types corresponding to the fullfilled success and error types.
             * The error type (U) should extend Error in order to get proper stack tracing.
             * @param {plat.async.IResolveFunction<R>} resolveFunction A IResolveFunction for fulfilling/rejecting the Promise.
             */
            function Promise(resolveFunction) {
                if (!isFunction(resolveFunction)) {
                    throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
                }
                if (!(this instanceof Promise)) {
                    throw new TypeError('Failed to construct "Promise": ' +
                        'Please use the "new" operator, this object constructor cannot be called as a function.');
                }
                this.__subscribers = [];
                Promise.__invokeResolveFunction(resolveFunction, this);
            }
            Promise.all = function (promises) {
                if (!isArray(promises)) {
                    return Promise.all([promises]);
                }
                return new Promise(function (resolve, reject) {
                    var results = [], remaining = promises.length, promise;
                    if (remaining === 0) {
                        resolve([]);
                    }
                    function resolver(index) {
                        return function (value) { return resolveAll(index, value); };
                    }
                    function resolveAll(index, value) {
                        results[index] = value;
                        if (--remaining === 0) {
                            resolve(results);
                        }
                    }
                    for (var i = 0; i < promises.length; i++) {
                        promise = promises[i];
                        if (isPromise(promise)) {
                            promise.then(resolver(i), reject);
                        }
                        else {
                            resolveAll(i, promise);
                        }
                    }
                });
            };
            Promise.race = function (promises) {
                if (!isArray(promises)) {
                    return Promise.race([promises]);
                }
                return new Promise(function (resolve, reject) {
                    var promise;
                    for (var i = 0; i < promises.length; i++) {
                        promise = promises[i];
                        if (promise && typeof promise.then === 'function') {
                            promise.then(resolve, reject);
                        }
                        else {
                            resolve(promise);
                        }
                    }
                });
            };
            Promise.resolve = function (value) {
                return new Promise(function (resolve, reject) {
                    resolve(value);
                });
            };
            /**
             * Returns a promise that rejects with the input value.
             * @param {any} error The value to reject.
             */
            Promise.reject = function (error) {
                return new Promise(function (resolve, reject) {
                    reject(error);
                });
            };
            /**
             * Invokes the resolve function for a promise. Handles error catching.
             * @param {plat.async.IResolveFunction<R>} resolveFunction The resolve function to invoke.
             * @param {plat.async.Promise<R>} promise The promise on which to invoke the resolve function.
             */
            Promise.__invokeResolveFunction = function (resolveFunction, promise) {
                function resolvePromise(value) {
                    Promise.__resolve(promise, value);
                }
                function rejectPromise(reason) {
                    Promise.__reject(promise, reason);
                }
                try {
                    resolveFunction(resolvePromise, rejectPromise);
                }
                catch (e) {
                    rejectPromise(e);
                }
            };
            /**
             * Invokes a callback for a promise with the specified detail.
             * @param {plat.async.State} settled The state of the promise.
             * @param {any} promise The promise object.
             * @param {(response: any) => void} callback The callback to invoke.
             * @param {any} detail The details to pass to the callback.
             */
            Promise.__invokeCallback = function (settled, promise, callback, detail) {
                var hasCallback = isFunction(callback), value, error, succeeded, failed;
                if (hasCallback) {
                    try {
                        value = callback(detail);
                        succeeded = true;
                    }
                    catch (e) {
                        failed = true;
                        error = e;
                    }
                }
                else {
                    value = detail;
                    succeeded = true;
                }
                if (Promise.__handleThenable(promise, value)) {
                    return;
                }
                else if (hasCallback && succeeded) {
                    Promise.__resolve(promise, value);
                }
                else if (failed) {
                    Promise.__reject(promise, error);
                }
                else if (settled === State.FULFILLED) {
                    Promise.__resolve(promise, value);
                }
                else if (settled === State.REJECTED) {
                    Promise.__reject(promise, value);
                }
            };
            /**
             * Publishes the promise details to all the subscribers for a promise.
             * @param {any} promise The promise object.
             * @param {plat.async.State} settled The state of the promise.
             */
            Promise.__publish = function (promise, settled) {
                var subscribers = promise.__subscribers, detail = promise.__detail, child, callback;
                for (var i = 0; i < subscribers.length; i += 3) {
                    child = subscribers[i];
                    callback = subscribers[i + settled];
                    Promise.__invokeCallback(settled, child, callback, detail);
                }
                promise.__subscribers = null;
            };
            /**
             * Publishes a promises that has been fulfilled.
             * @param {any} promise The promise object.
             */
            Promise.__publishFulfillment = function (promise) {
                Promise.__publish(promise, promise.__state = State.FULFILLED);
            };
            /**
             * Publishes a promises that has been rejected.
             * @param {any} promise The promise object.
             */
            Promise.__publishRejection = function (promise) {
                Promise.__publish(promise, promise.__state = State.REJECTED);
            };
            /**
             * Asynchronously rejects a promise
             * @param {any} promise The promise object.
             * @param {any} reason The detail of the rejected promise.
             */
            Promise.__reject = function (promise, reason) {
                if (promise.__state !== State.PENDING) {
                    return;
                }
                promise.__state = State.SEALED;
                promise.__detail = reason;
                Promise.config.async(Promise.__publishRejection, promise);
            };
            /**
             * Asynchronously fulfills a promise
             * @param {plat.async.Promise<R>} promise The promise object.
             * @param {any} value The detail of the fulfilled promise.
             */
            Promise.__fulfill = function (promise, value) {
                if (promise.__state !== State.PENDING) {
                    return;
                }
                promise.__state = State.SEALED;
                promise.__detail = value;
                Promise.config.async(Promise.__publishFulfillment, promise);
            };
            /**
             * Asynchronously fulfills a promise, allowing for promise chaining.
             * @param {plat.async.Promise<R>} promise The promise object.
             * @param {any} value The detail of the fulfilled promise.
             */
            Promise.__resolve = function (promise, value) {
                if (promise === value) {
                    Promise.__fulfill(promise, value);
                }
                else if (!Promise.__handleThenable(promise, value)) {
                    Promise.__fulfill(promise, value);
                }
            };
            /**
             * Handles chaining promises together, when a promise is returned from within a then handler.
             * @param {plat.async.Promise<R>} promise The promise object.
             * @param {plat.async.Promise<R>} value The next promise to await.
             */
            Promise.__handleThenable = function (promise, value) {
                var resolved;
                if (promise === value) {
                    Promise.__reject(promise, new TypeError('A promises callback cannot return the same promise.'));
                    return true;
                }
                if (isPromise(value)) {
                    try {
                        value.then.call(value, function (val) {
                            if (resolved) {
                                return true;
                            }
                            resolved = true;
                            if (value !== val) {
                                Promise.__resolve(promise, val);
                            }
                            else {
                                Promise.__fulfill(promise, val);
                            }
                        }, function (val) {
                            if (resolved) {
                                return true;
                            }
                            resolved = true;
                            Promise.__reject(promise, val);
                        });
                        return true;
                    }
                    catch (error) {
                        if (resolved) {
                            return true;
                        }
                        Promise.__reject(promise, error);
                        return true;
                    }
                }
                return false;
            };
            /**
             * Adds a child promise to the parent's subscribers.
             * @param {plat.async.Promise<any>} parent The parent promise.
             * @param {plat.async.Promise<any>} value The child promise.
             * @param {(success: any) => any} onFullfilled The fulfilled method for the child.
             * @param {(error: any) => any} onRejected The rejected method for the child.
             */
            Promise.__subscribe = function (parent, child, onFulfilled, onRejected) {
                var subscribers = parent.__subscribers;
                var length = subscribers.length;
                subscribers[length] = child;
                subscribers[length + State.FULFILLED] = onFulfilled;
                subscribers[length + State.REJECTED] = onRejected;
            };
            Promise.prototype.then = function (onFulfilled, onRejected) {
                var promise = this;
                var thenPromise = new this.constructor(noop, this);
                if (this.__state) {
                    var callbacks_1 = arguments;
                    Promise.config.async(function () {
                        Promise.__invokeCallback(promise.__state, thenPromise, callbacks_1[promise.__state - 1], promise.__detail);
                    });
                }
                else {
                    Promise.__subscribe(this, thenPromise, onFulfilled, onRejected);
                }
                return thenPromise;
            };
            Promise.prototype.catch = function (onRejected) {
                return this.then(null, onRejected);
            };
            /**
             * Outputs the Promise as a readable string.
             */
            Promise.prototype.toString = function () {
                return '[object Promise]';
            };
            /**
             * The configuration for creating asynchronous promise flushing.
             */
            Promise.config = {
                /**
                 */
                async: function (callback, arg) {
                    var length = __promiseQueue.push([callback, arg]);
                    if (length === 1) {
                        scheduleFlush();
                    }
                }
            };
            return Promise;
        }());
        async.Promise = Promise;
        var State;
        (function (State) {
            State[State["PENDING"] = (void 0)] = "PENDING";
            State[State["SEALED"] = 0] = "SEALED";
            State[State["FULFILLED"] = 1] = "FULFILLED";
            State[State["REJECTED"] = 2] = "REJECTED";
        })(State || (State = {}));
        ;
        // node 
        function useNextTick() {
            return function () {
                process.nextTick(flush);
            };
        }
        function useMutationObserver() {
            var observer = new BrowserMutationObserver(flush), _document = acquire(__Document), _window = acquire(__Window), element = _document.createElement('div');
            observer.observe(element, { attributes: true });
            _window.addEventListener('unload', function () {
                observer.disconnect();
                observer = null;
            }, false);
            return function () {
                element.setAttribute('drainQueue', 'drainQueue');
            };
        }
        function useSetTimeout() {
            return function () {
                postpone(flush);
            };
        }
        function flush() {
            var tuple, callback, arg;
            for (var i = 0; i < __promiseQueue.length; i++) {
                tuple = __promiseQueue[i];
                callback = tuple[0];
                arg = tuple[1];
                callback(arg);
            }
            __promiseQueue = [];
        }
        /**
         */
        function IPromise(_window) {
            if (!isNull(_window.Promise) &&
                isFunction(_window.Promise.all) &&
                isFunction(_window.Promise.race) &&
                isFunction(_window.Promise.resolve) &&
                isFunction(_window.Promise.reject)) {
                return _window.Promise;
            }
            return Promise;
        }
        async.IPromise = IPromise;
        register.injectable(__Promise, IPromise, [__Window], __CLASS);
        /**
         * HttpRequest provides a wrapper for the XMLHttpRequest object. Allows for
         * sending AJAX requests to a server. This class does not support
         * synchronous requests.
         */
        var HttpRequest = (function () {
            /**
             * The constructor for a HttpRequest.
             */
            function HttpRequest() {
                var compat = acquire(__Compat);
                this.__fileSupported = compat.fileSupported;
            }
            /**
             * Initializes the HttpRequest with options.
             * @param {plat.async.IHttpConfig} options The IHttpConfigStatic used to customize this HttpRequest.
             */
            HttpRequest.prototype.initialize = function (options) {
                this.__options = _extend(false, false, {}, this._config, options);
            };
            /**
             * Executes an XMLHttpRequest and resolves an IAjaxPromise upon completion.
             */
            HttpRequest.prototype.execute = function () {
                var options = this.__options, url = options.url;
                if (!isString(url) || isEmpty(url.trim())) {
                    return this._invalidOptions();
                }
                options.url = this._browser.urlUtils(url).toString();
                var isCrossDomain = options.isCrossDomain || false, xDomain = false;
                // check if forced cross domain call or cors is not supported (IE9) 
                if (isCrossDomain) {
                    xDomain = true;
                }
                else {
                    this.xhr = new XMLHttpRequest();
                    if (isUndefined(this.xhr.withCredentials)) {
                        xDomain = this._browser.isCrossDomain(url);
                    }
                }
                if (xDomain) {
                    this.xhr = null;
                    this.jsonpCallback = options.jsonpCallback || uniqueId(__JSONP_CALLBACK);
                    return this.executeJsonp();
                }
                return this._sendXhrRequest();
            };
            /**
             * Executes an JSONP request and resolves an IAjaxPromise upon completion.
             */
            HttpRequest.prototype.executeJsonp = function () {
                var _this = this;
                var options = this.__options, url = options.url;
                if (!isString(url) || isEmpty(url.trim())) {
                    return this._invalidOptions();
                }
                options.url = this._browser.urlUtils(url).toString();
                if (isNull(this.jsonpCallback)) {
                    this.jsonpCallback = options.jsonpCallback || uniqueId(__Callback);
                }
                var promise = new AjaxPromise(function (resolve, reject) {
                    var _window = _this._window, _document = _this._document, scriptTag = _document.createElement('script'), jsonpCallback = _this.jsonpCallback, jsonpIdentifier = options.jsonpIdentifier || 'callback';
                    scriptTag.src = url + ((url.indexOf('?') > -1) ? '&' : '?') + jsonpIdentifier + '=' + jsonpCallback;
                    var oldValue = _window[jsonpCallback];
                    _window[jsonpCallback] = function (response) {
                        // clean up 
                        if (isFunction(_this.clearTimeout)) {
                            _this.clearTimeout();
                        }
                        _document.head.removeChild(scriptTag);
                        if (isUndefined(oldValue)) {
                            deleteProperty(_window, jsonpCallback);
                        }
                        else {
                            _window[jsonpCallback] = oldValue;
                        }
                        // call callback 
                        resolve({
                            response: response,
                            // ok 
                            status: 200
                        });
                    };
                    _document.head.appendChild(scriptTag);
                    var timeout = options.timeout;
                    if (isNumber(timeout) && timeout > 0) {
                        // we first postpone to avoid always timing out when debugging, though this is not 
                        // a foolproof method. 
                        _this.clearTimeout = postpone(function () {
                            _this.clearTimeout = defer(function () {
                                reject(new AjaxError({
                                    response: 'Request timed out in ' + timeout + 'ms for ' + url,
                                    // request timeout 
                                    status: 408
                                }));
                                _window[jsonpCallback] = noop;
                            }, timeout - 1);
                        });
                    }
                });
                promise.initialize(this);
                return promise;
            };
            /**
             * A wrapper for the XMLHttpRequest's onReadyStateChanged callback.
             */
            HttpRequest.prototype._xhrOnReadyStateChange = function () {
                var xhr = this.xhr;
                if (xhr.readyState === 4) {
                    var status_1 = xhr.status;
                    if (status_1 === 0) {
                        var response = xhr.response;
                        if (isNull(response)) {
                            try {
                                response = xhr.responseText;
                            }
                            catch (e) { }
                        }
                        // file protocol issue **Needs to be tested more thoroughly** 
                        // ok if response is not empty, Not Found otherwise 
                        if (!isEmpty(response)) {
                            return true;
                        }
                        return false;
                    }
                    // 304 is not modified 
                    if ((status_1 >= 200 && status_1 < 300) || status_1 === 304) {
                        return true;
                    }
                    else {
                        return false;
                    }
                }
                // else {} TODO: add progress for xhr if we choose to add progress to AjaxPromise 
            };
            /**
             * The function that initializes and sends the XMLHttpRequest.
             */
            HttpRequest.prototype._sendXhrRequest = function () {
                var _this = this;
                var xhr = this.xhr, options = this.__options, method = options.method, url = options.url, promise = new AjaxPromise(function (resolve, reject) {
                    xhr.onreadystatechange = function () {
                        var success = _this._xhrOnReadyStateChange();
                        if (isNull(success)) {
                            return;
                        }
                        var response = _this._formatResponse(options.responseType, success);
                        if (success) {
                            resolve(response);
                        }
                        else {
                            reject(new AjaxError(response));
                        }
                        _this.xhr = options = null;
                    };
                    if (!isString(method)) {
                        _this._log.info('AjaxOptions method was not of type string. Defaulting to "GET".');
                        method = 'GET';
                    }
                    xhr.open(method.toUpperCase(), url, 
                    // synchronous XHR not supported 
                    true, options.user, options.password);
                    var responseType = options.responseType;
                    if (!(_this.__fileSupported || responseType === '' || responseType === 'text')) {
                        responseType = '';
                    }
                    // Android < 4.4 will throw a DOM Exception 12 if responseType is set to json. 
                    // The only way to do feature detection is with try/catch. 
                    if (responseType === 'json') {
                        try {
                            xhr.responseType = responseType;
                        }
                        catch (e) {
                            xhr.responseType = '';
                        }
                    }
                    xhr.withCredentials = options.withCredentials;
                    var mimeType = options.overrideMimeType, data = options.data;
                    if (isString(mimeType) && !isEmpty(mimeType)) {
                        xhr.overrideMimeType(mimeType);
                    }
                    if (isNull(data) || data === '') {
                        // no data exists so set headers and send request 
                        _this.__setHeaders();
                        xhr.send();
                    }
                    else {
                        var transforms = options.transforms || [], length_3 = transforms.length, contentType = options.contentType, contentTypeExists = isString(contentType) && !isEmpty(contentType);
                        if (length_3 > 0) {
                            // if data transforms defined, assume they're going to take care of 
                            // any and all transformations. 
                            for (var i = 0; i < length_3; ++i) {
                                data = transforms[i](data, xhr);
                            }
                            // if contentType exists, assume they did not set it in 
                            // their headers as well 
                            if (contentTypeExists) {
                                xhr.setRequestHeader('Content-Type', contentType);
                            }
                            _this.__setHeaders();
                            xhr.send(data);
                        }
                        else if (isObject(data)) {
                            // if isObject and contentType exists we want to transform the data 
                            if (contentTypeExists) {
                                var contentTypeLower = contentType.toLowerCase();
                                if (contentTypeLower.indexOf('x-www-form-urlencoded') !== -1) {
                                    // perform an encoded form transformation 
                                    data = _this.__serializeFormData();
                                    // set Content-Type header because we're assuming they didn't set it 
                                    // in their headers object 
                                    xhr.setRequestHeader('Content-Type', contentType);
                                    _this.__setHeaders();
                                    xhr.send(data);
                                }
                                else if (contentTypeLower.indexOf('multipart/form-data') !== -1) {
                                    // need to check if File is a supported object 
                                    if (_this.__fileSupported) {
                                        // use FormData 
                                        data = _this.__appendFormData();
                                        // do not set the Content-Type header due to modern browsers 
                                        // setting special headers for multipart/form-data 
                                        _this.__setHeaders();
                                        xhr.send(data);
                                    }
                                    else {
                                        // use iframe trick for older browsers (do not send a request) 
                                        // this case is the reason for this giant, terrible, nested if-else statement 
                                        _this.__submitFramedFormData().then(function (response) {
                                            resolve(response);
                                        }, function () {
                                            _this.xhr = null;
                                        });
                                    }
                                }
                                else {
                                    // assume stringification is possible 
                                    data = JSON.stringify(data);
                                    // set Content-Type header because we're assuming they didn't set it 
                                    // in their headers object 
                                    xhr.setRequestHeader('Content-Type', contentType);
                                    _this.__setHeaders();
                                    xhr.send(data);
                                }
                            }
                            else {
                                // contentType does not exist so simply set defined headers and send raw data 
                                _this.__setHeaders();
                                xhr.send(data);
                            }
                        }
                        else {
                            // if contentType exists set Content-Type header because we're assuming they didn't set it 
                            // in their headers object 
                            if (contentTypeExists) {
                                xhr.setRequestHeader('Content-Type', contentType);
                            }
                            _this.__setHeaders();
                            xhr.send(data);
                        }
                    }
                    var timeout = options.timeout;
                    if (isNumber(timeout) && timeout > 0) {
                        // we first postpone to avoid always timing out when debugging, though this is not 
                        // a foolproof method. 
                        _this.clearTimeout = postpone(function () {
                            _this.clearTimeout = defer(function () {
                                reject(new AjaxError({
                                    response: 'Request timed out in ' + timeout + 'ms for ' + options.url,
                                    status: xhr.status,
                                    getAllResponseHeaders: function () { return xhr.getAllResponseHeaders(); },
                                    xhr: xhr
                                }));
                                xhr.onreadystatechange = null;
                                xhr.abort();
                                _this.xhr = null;
                            }, timeout - 1);
                        });
                    }
                });
                promise.initialize(this);
                return promise;
            };
            /**
             * Returns a promise that is immediately rejected due to an error.
             */
            HttpRequest.prototype._invalidOptions = function () {
                var _this = this;
                return new AjaxPromise(function (resolve, reject) {
                    _this._log.warn('Attempting a request without specifying a url');
                    reject(new AjaxError({
                        response: 'Attempting a request without specifying a url',
                        status: null,
                        getAllResponseHeaders: null,
                        xhr: null
                    }));
                });
            };
            /**
             * The function that formats the response from the XMLHttpRequest.
             * @param {string} responseType The user designated responseType
             * @param {boolean} success Signifies if the response was a success
             */
            HttpRequest.prototype._formatResponse = function (responseType, success) {
                var xhr = this.xhr, status = xhr.status, response = xhr.response;
                // need to try, catch instead of boolean short circuit because chrome doesn't like checking 
                // responseText when the responseType is anything other than empty or 'text' 
                if (isNull(response)) {
                    try {
                        response = xhr.responseText;
                    }
                    catch (e) { }
                }
                if (status === 0) {
                    // file protocol issue **Needs to be tested more thoroughly** 
                    // ok if response empty, Not Found otherwise 
                    status = success ? 200 : 404;
                }
                xhr.onreadystatechange = null;
                if (isFunction(this.clearTimeout)) {
                    this.clearTimeout();
                }
                if (responseType === 'json' && isString(response)) {
                    try {
                        response = JSON.parse(response);
                    }
                    catch (e) { }
                }
                return {
                    response: response,
                    status: status,
                    getAllResponseHeaders: function () { return xhr.getAllResponseHeaders(); },
                    xhr: xhr
                };
            };
            /**
             * Sets the headers for an XMLHttpRequest
             */
            HttpRequest.prototype.__setHeaders = function () {
                var headers = this.__options.headers, keys = Object.keys(headers || {}), xhr = this.xhr, length = keys.length, key, i;
                for (i = 0; i < length; ++i) {
                    key = keys[i];
                    xhr.setRequestHeader(key, headers[key]);
                }
            };
            /**
             * Serializes multipart form data in an XMLHttpRequest as a string.
             */
            HttpRequest.prototype.__serializeFormData = function () {
                var data = this.__options.data, keys = Object.keys(data), key, val, formBuffer = [];
                while (keys.length > 0) {
                    key = keys.pop();
                    val = data[key];
                    if (isNull(val)) {
                        val = '';
                    }
                    else if (isObject(val)) {
                        // may throw a fatal error but this is an invalid case 
                        this._log.warn('Invalid form entry with key "' + key + '" and value "' + val);
                        val = JSON.stringify(val);
                    }
                    formBuffer.push(encodeURIComponent(key) + '=' + encodeURIComponent(val));
                }
                return formBuffer.join('&').replace(/%20/g, '+');
            };
            /**
             * Creates FormData to add to the XMLHttpRequest.
             */
            HttpRequest.prototype.__appendFormData = function () {
                var data = this.__options.data, formData = new FormData(), keys = Object.keys(data), key, val;
                while (keys.length > 0) {
                    key = keys.pop();
                    val = data[key];
                    if (isNull(val)) {
                        formData.append(key, '');
                    }
                    else if (isObject(val)) {
                        if (isFile(val)) {
                            formData.append(key, val, val.name || val.fileName || 'blob');
                        }
                        else {
                            // may throw a fatal error but this is an invalid case 
                            this._log.warn('Invalid form entry with key "' + key + '" and value "' + val);
                            formData.append(key, JSON.stringify(val));
                        }
                    }
                    else {
                        formData.append(key, val);
                    }
                }
                return formData;
            };
            /**
             * Handles submitting multipart form data using an iframe.
             */
            HttpRequest.prototype.__submitFramedFormData = function () {
                var _this = this;
                var options = this.__options, data = options.data, url = options.url, _document = this._document, $body = _document.body, Promise = acquire(__Promise), form = _document.createElement('form'), iframe = _document.createElement('iframe'), iframeName = uniqueId('iframe_target'), keys = Object.keys(data), key;
                iframe.name = form.target = iframeName;
                iframe.src = 'javascript:false;';
                form.enctype = form.encoding = 'multipart/form-data';
                form.action = url;
                form.method = 'POST';
                form.style.display = 'none';
                while (keys.length > 0) {
                    key = keys.pop();
                    form.insertBefore(this.__createInput(key, data[key]), null);
                }
                return new Promise(function (resolve, reject) {
                    _this.xhr.abort = function () {
                        iframe.onload = null;
                        $body.removeChild(form);
                        $body.removeChild(iframe);
                        reject();
                    };
                    iframe.onload = function () {
                        var content = iframe.contentDocument.body.innerHTML;
                        $body.removeChild(form);
                        $body.removeChild(iframe);
                        resolve({
                            response: content,
                            status: 200,
                            getAllResponseHeaders: function () { return ''; }
                        });
                        _this.xhr = iframe.onload = null;
                    };
                    $body.insertBefore(form, null);
                    $body.insertBefore(iframe, null);
                    form.submit();
                });
            };
            /**
             * Creates input for form data submissions.
             */
            HttpRequest.prototype.__createInput = function (key, val) {
                var _document = this._document, input = _document.createElement('input');
                input.type = 'hidden';
                input.name = key;
                if (isNull(val)) {
                    input.value = '';
                }
                else if (isObject(val)) {
                    // check if val is an pseudo File 
                    if (isFunction(val.slice) && !(isUndefined(val.name) || isUndefined(val.path))) {
                        var fileList = _document.querySelectorAll('input[type="file"][name="' + key + '"]'), length_4 = fileList.length;
                        // if no inputs found, stringify the data 
                        if (length_4 === 0) {
                            this._log.info('Could not find input[type="file"] with [name="' + key +
                                '"]. Stringifying data instead.');
                            input.value = JSON.stringify(val);
                        }
                        else if (length_4 === 1) {
                            input = fileList[0];
                            // swap nodes 
                            var clone = input.cloneNode(true);
                            input.parentNode.insertBefore(clone, input);
                        }
                        else {
                            // rare case but may have multiple forms with file inputs 
                            // that have the same name 
                            var fileInput = void 0, path = val.path;
                            while (length_4-- > 0) {
                                fileInput = fileList[length_4];
                                if (fileInput.value === path) {
                                    input = fileInput;
                                    // swap nodes 
                                    var inputClone = input.cloneNode(true);
                                    input.parentNode.insertBefore(inputClone, input);
                                    break;
                                }
                            }
                            // could not find the right file 
                            if (length_4 === -1) {
                                this._log.info('Could not find input[type="file"] with [name="' + key + '"] and [value="' +
                                    val.path + '"]. Stringifying data instead.');
                                input.value = JSON.stringify(val);
                            }
                        }
                    }
                    else {
                        // may throw a fatal error but this is an invalid case 
                        this._log.info('Invalid form entry with key "' + key + '" and value "' + val);
                        input.value = JSON.stringify(val);
                    }
                }
                else {
                    input.value = val;
                }
                return input;
            };
            HttpRequest._inject = {
                _browser: __Browser,
                _window: __Window,
                _document: __Document,
                _config: __HttpConfig,
                _log: __Log
            };
            return HttpRequest;
        }());
        async.HttpRequest = HttpRequest;
        /**
         * A class that forms an Error object with an IAjaxResponse.
         */
        var AjaxError = (function () {
            /**
             * The constructor for an AjaxError.
             * @param {plat.async.IAjaxResponse} response The IAjaxResponse object.
             */
            function AjaxError(response) {
                /**
                 * The name of the Error ('AjaxError')
                 */
                this.name = 'AjaxError';
                Error.apply(this);
                this.response = this.message = response.response;
                this.status = response.status;
                this.getAllResponseHeaders = response.getAllResponseHeaders;
                this.xhr = response.xhr;
            }
            /**
             * Outputs a formatted string describing the AjaxError.
             */
            AjaxError.prototype.toString = function () {
                var response = this.response, responseText = response;
                if (isObject(response) && !response.hasOwnProperty('toString')) {
                    responseText = JSON.stringify(response);
                }
                return 'Request failed with status: ' + this.status + ' and response: ' + responseText;
            };
            return AjaxError;
        }());
        async.AjaxError = AjaxError;
        // have to bypass TS flags in order to properly extend Error 
        AjaxError.prototype = Error.prototype;
        /**
         * Describes a type of Promise that fulfills with an IAjaxResponse
         * and can be optionally cancelled.
         */
        var AjaxPromise = (function (_super) {
            __extends(AjaxPromise, _super);
            function AjaxPromise(resolveFunction, promise) {
                _super.call(this, resolveFunction);
                /**
                 * The Window object.
                 */
                this._window = acquire(__Window);
                if (!isNull(promise)) {
                    this.__http = promise.__http;
                }
            }
            /**
             * A method to initialize this AjaxPromise, passing it the
             * associated IHttpRequest.
             * @param {plat.async.HttpRequest} http The http request for this promise.
             */
            AjaxPromise.prototype.initialize = function (http) {
                if (isObject(http) && isNull(this.__http)) {
                    this.__http = http;
                }
            };
            /**
             * A method to cancel the AJAX call associated with this AjaxPromise.
             */
            AjaxPromise.prototype.cancel = function () {
                var http = this.__http, xhr = http.xhr, jsonpCallback = http.jsonpCallback;
                if (isFunction(http.clearTimeout)) {
                    http.clearTimeout();
                }
                if (!isNull(xhr)) {
                    xhr.onreadystatechange = null;
                    xhr.abort();
                    http.xhr = null;
                }
                else if (!isNull(jsonpCallback)) {
                    this._window[jsonpCallback] = noop;
                }
                this.__subscribers = [];
            };
            AjaxPromise.prototype.then = function (onFulfilled, onRejected) {
                return _super.prototype.then.call(this, onFulfilled, onRejected);
            };
            AjaxPromise.prototype.catch = function (onRejected) {
                return _super.prototype.catch.call(this, onRejected);
            };
            return AjaxPromise;
        }(Promise));
        async.AjaxPromise = AjaxPromise;
        /**
         * The instantiated class of the injectable for making
         * AJAX requests.
         */
        var Http = (function () {
            function Http() {
                /**
                 * Provides value mappings for XMLHttpRequestResponseTypes
                 */
                this.responseType = {
                    DEFAULT: '',
                    ARRAYBUFFER: 'arraybuffer',
                    BLOB: 'blob',
                    DOCUMENT: 'document',
                    JSON: 'json',
                    TEXT: 'text'
                };
                /**
                 * Provides Content-Type mappings for Http POST requests.
                 */
                this.contentType = {
                    ENCODED_FORM: 'application/x-www-form-urlencoded;charset=utf-8',
                    JSON: 'application/json;charset=utf-8',
                    MULTIPART_FORM: 'multipart/form-data',
                    OCTET_STREAM: 'application/octet-stream;charset=utf-8',
                    XML: 'application/xml;charset=utf-8',
                    PLAIN_TEXT: 'text/plain',
                    HTML: 'text/html'
                };
            }
            /**
             * A wrapper method for the Http class that creates and executes a new Http with
             * the specified IHttpConfig. This function will check if
             * XMLHttpRequest level 2 is present, and will default to JSONP if it isn't and
             * the request is cross-domain.
             * @param {plat.async.IHttpConfig} options The IHttpConfig for either the XMLHttpRequest
             * or the JSONP callback.
             */
            Http.prototype.ajax = function (options) {
                var request = acquire(__HttpRequestInstance);
                request.initialize(options);
                return request.execute();
            };
            /**
             * A direct method to force a cross-domain JSONP request.
             * @param {plat.async.IJsonpConfig} options The IJsonpConfig
             */
            Http.prototype.jsonp = function (options) {
                var request = acquire(__HttpRequestInstance);
                request.initialize(options);
                return request.executeJsonp();
            };
            /**
             * Makes an ajax request, specifying responseType: 'json'.
             * @param {plat.async.IHttpConfig} options The IHttpConfig
             * for either the XMLHttpRequest or the JSONP callback.
             */
            Http.prototype.json = function (options) {
                var request = acquire(__HttpRequestInstance);
                request.initialize(_extend(false, false, {}, options, { responseType: 'json' }));
                return request.execute();
            };
            /**
             * Default Http config
             */
            Http.config = {
                url: null,
                method: 'GET',
                responseType: '',
                transforms: [],
                headers: {},
                withCredentials: false,
                timeout: null,
                jsonpIdentifier: 'callback',
                contentType: 'application/json;charset=utf-8'
            };
            return Http;
        }());
        async.Http = Http;
        register.injectable(__Http, Http);
        register.injectable(__HttpRequestInstance, HttpRequest, null, __INSTANCE);
        /**
         */
        function IHttpConfig() {
            return Http.config;
        }
        async.IHttpConfig = IHttpConfig;
        register.injectable(__HttpConfig, IHttpConfig);
    })(async = plat_1.async || (plat_1.async = {}));
    /**
     * Holds classes and interfaces related to storage in platypus.
     */
    var storage;
    (function (storage_1) {
        /**
         * The keyed collection of all created Caches in the
         * ICacheFactory.
         */
        var caches = {}, 
        /**
         * Internal storage for all the items stored in each Cache.
         */
        internalCaches = {};
        /**
         * A Cache class, for use with the ICacheFactory injectable.
         * Used for storing objects. Takes in a generic type corresponding to the type of objects it contains.
         */
        var Cache = (function () {
            /**
             * The constructor for a Cache.
             * @param {string} id The id to use to retrieve the cache from the ICacheFactory.
             * @param {plat.storage.ICacheOptions} options The ICacheOptions for customizing the cache.
             */
            function Cache(uid, options) {
                this.__uid = uid;
                this.__options = options;
                this.__size = 0;
                if (isNull(options)) {
                    this.__options = {
                        timeout: 0
                    };
                }
                internalCaches[uid] = {};
            }
            /**
             * Method for creating a new cache object. Takes a generic type to denote the
             * type of objects stored in the new cache.  If a cache with the same ID already exists
             * in the ICacheFactory, a new cache will not be created.
             * @param {string} uid The ID of the new Cache.
             * @param {plat.storage.ICacheOptions} options ICacheOptions
             * for customizing the Cache.
             */
            Cache.create = function (uid, options) {
                var cache = caches[uid];
                if (isNull(cache)) {
                    cache = caches[uid] = new Cache(uid, options);
                }
                return cache;
            };
            /**
             * Gets a cache out of the ICacheFactory if it exists.
             * @param {string} uid The identifier used to search for the cache.
             */
            Cache.fetch = function (uid) {
                return caches[uid];
            };
            /**
             * Clears the ICacheFactory and all of its caches.
             */
            Cache.clear = function () {
                var keys = Object.keys(caches), length = keys.length;
                for (var i = 0; i < length; ++i) {
                    caches[keys[i]].clear();
                }
                caches = {};
            };
            /**
             * Retrieves the ICacheInfo about this cache
             * (i.e. ID, size, options)
             */
            Cache.prototype.info = function () {
                return {
                    uid: this.__uid,
                    size: this.__size,
                    options: this.__options
                };
            };
            /**
             * Method for inserting an object into an Cache.
             * @param {string} key The key to use for storage/retrieval of the object.
             * @param {T} value The value to store with the associated key.
             */
            Cache.prototype.put = function (key, value) {
                var val = internalCaches[this.__uid][key];
                internalCaches[this.__uid][key] = value;
                if (isUndefined(val)) {
                    this.__size++;
                }
                var timeout = this.__options.timeout;
                if (isNumber(timeout) && timeout > 0) {
                    defer(this.remove, timeout, [key], this);
                }
                return value;
            };
            /**
             * Method for retrieving an object from an Cache.
             * @param key The key to search for in an Cache.
             */
            Cache.prototype.read = function (key) {
                return internalCaches[this.__uid][key];
            };
            /**
             * Method for removing an object from an Cache.
             * @param {string} key The key to remove from the Cache.
             */
            Cache.prototype.remove = function (key) {
                deleteProperty(internalCaches[this.__uid], key);
                this.__size--;
            };
            /**
             * Method for clearing an Cache, removing all of its keys.
             */
            Cache.prototype.clear = function () {
                internalCaches[this.__uid] = {};
                this.__size = 0;
            };
            /**
             * Method for removing an ICache from the ICacheFactory.
             */
            Cache.prototype.dispose = function () {
                this.clear();
                deleteProperty(caches, this.__uid);
            };
            return Cache;
        }());
        storage_1.Cache = Cache;
        /**
         */
        function ICacheFactory() {
            return Cache;
        }
        storage_1.ICacheFactory = ICacheFactory;
        register.injectable(__CacheFactory, ICacheFactory, null, __FACTORY);
        /**
         */
        storage_1.managerCache = Cache.create('__managerCache');
        /**
         */
        function IManagerCache() {
            return storage_1.managerCache;
        }
        storage_1.IManagerCache = IManagerCache;
        register.injectable(__ManagerCache, IManagerCache);
        /**
         * Used for caching compiled nodes. This class will
         * clone a template when you put it in the cache. It will
         * also clone the template when you retrieve it.
         */
        var TemplateCache = (function (_super) {
            __extends(TemplateCache, _super);
            /**
             * The constructor for a TemplateCache. Creates a new Cache
             * with the ID "__templateCache".
             */
            function TemplateCache() {
                _super.call(this, '__templateCache');
            }
            TemplateCache.prototype.put = function (key, value) {
                var Promise = this._Promise;
                _super.prototype.put.call(this, key, Promise.resolve(value));
                if (isDocumentFragment(value)) {
                    value = value.cloneNode(true);
                }
                else if (isNode(value)) {
                    var fragment = document.createDocumentFragment();
                    fragment.appendChild(value.cloneNode(true));
                    value = fragment;
                }
                else if (isString(value) || isNull(value)) {
                    value = serializeHtml(value);
                }
                return Promise.resolve(value);
            };
            /**
             * Method for retrieving a Node from this cache. The DocumentFragment that resolves from the returned
             * Promise will be cloned to avoid manipulating the cached template.
             * @param {string} key The key to search for in this cache.
             */
            TemplateCache.prototype.read = function (key) {
                var _this = this;
                var promise = _super.prototype.read.call(this, key);
                if (isNull(promise)) {
                    return this._Promise.reject(null);
                }
                return promise.then(function (node) {
                    return _this.put(key, node);
                }, function (error) {
                    _this._log.warn('Error retrieving template, ' + key + ', from promise.');
                    return null;
                });
            };
            TemplateCache._inject = {
                _Promise: __Promise,
                _log: __Log
            };
            return TemplateCache;
        }(Cache));
        storage_1.TemplateCache = TemplateCache;
        register.injectable(__TemplateCache, TemplateCache);
        /**
         * A base class for storing data with a designated storage type.
         */
        var BaseStorage = (function () {
            /**
             * The constructor for a BaseStorage.
             */
            function BaseStorage(storage) {
                var _this = this;
                this._storage = storage;
                forEach(function (value, key) {
                    _this[key] = value;
                }, storage);
            }
            Object.defineProperty(BaseStorage.prototype, "length", {
                /**
                 * Returns the number of items in storage.
                 */
                get: function () {
                    return this._storage.length;
                },
                enumerable: true,
                configurable: true
            });
            /**
             * Clears storage, deleting all of its keys.
             */
            BaseStorage.prototype.clear = function () {
                this._storage.clear();
            };
            /**
             * Gets an item out of storage with the assigned key.
             * @param {string} key The key of the item to retrieve from storage.
             */
            BaseStorage.prototype.getItem = function (key) {
                return this._storage.getItem(key);
            };
            /**
             * Allows for iterating over storage keys with an index. When
             * called with an index, it will return the key at that index in
             * storage.
             * @param {number} index The index used to retrieve the associated key.
             */
            BaseStorage.prototype.key = function (index) {
                return this._storage.key(index);
            };
            /**
             * Searches in storage for an item and removes it if it
             * exists.
             * @param {string} key The key of the item to remove from storage.
             */
            BaseStorage.prototype.removeItem = function (key) {
                this._storage.removeItem(key);
            };
            /**
             * Adds data to storage with the designated key.
             * @param {string} key The key of the item to store in storage.
             * @param {string} data The data to store in storage with the key.
             */
            BaseStorage.prototype.setItem = function (key, data) {
                this._storage.setItem(key, data);
                this[key] = this.getItem(key);
            };
            return BaseStorage;
        }());
        storage_1.BaseStorage = BaseStorage;
        /**
         * A class used to wrap HTML5 localStorage into an injectable.
         */
        var LocalStorage = (function (_super) {
            __extends(LocalStorage, _super);
            function LocalStorage() {
                _super.call(this, acquire(__Window).localStorage);
            }
            return LocalStorage;
        }(BaseStorage));
        storage_1.LocalStorage = LocalStorage;
        register.injectable(__LocalStorage, LocalStorage);
        /**
         * A class for wrapping SessionStorage as an injectable.
         */
        var SessionStorage = (function (_super) {
            __extends(SessionStorage, _super);
            function SessionStorage() {
                _super.call(this, acquire(__Window).sessionStorage);
            }
            return SessionStorage;
        }(BaseStorage));
        storage_1.SessionStorage = SessionStorage;
        register.injectable(__SessionStorage, SessionStorage);
    })(storage = plat_1.storage || (plat_1.storage = {}));
    /* tslint:disable:no-unused-variable */
    /**
     * An object used to create ITokenDetails for every operator.
     */
    var OPERATORS = {
        'u+': {
            precedence: 4, associativity: 'rtl',
            fn: function (context, aliases, a) {
                return +a(context, aliases);
            }
        },
        '+': {
            precedence: 6, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) + b(context, aliases);
            }
        },
        'u-': {
            precedence: 4, associativity: 'rtl',
            fn: function (context, aliases, a) {
                return -a(context, aliases);
            }
        },
        '-': {
            precedence: 6, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) - b(context, aliases);
            }
        },
        '*': {
            precedence: 5, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) * b(context, aliases);
            }
        },
        '/': {
            precedence: 5, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) / b(context, aliases);
            }
        },
        '%': {
            precedence: 5, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) % b(context, aliases);
            }
        },
        '?': {
            precedence: 15, associativity: 'rtl',
            fn: function () { return undefined; }
        },
        ':': {
            precedence: 15, associativity: 'rtl',
            fn: function () { return undefined; }
        },
        '>': {
            precedence: 8, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) > b(context, aliases);
            }
        },
        '<': {
            precedence: 8, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) < b(context, aliases);
            }
        },
        '!': {
            precedence: 4, associativity: 'rtl',
            fn: function (context, aliases, a) {
                return !a(context, aliases);
            }
        },
        '~': {
            precedence: 4, associativity: 'rtl',
            fn: function (context, aliases, a) {
                return ~a(context, aliases);
            }
        },
        '&': {
            precedence: 10, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) & b(context, aliases);
            }
        },
        '|': {
            precedence: 12, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) | b(context, aliases);
            }
        },
        '>>': {
            precedence: 7, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) >> b(context, aliases);
            }
        },
        '<<': {
            precedence: 7, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) << b(context, aliases);
            }
        },
        '>>>': {
            precedence: 7, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) >>> b(context, aliases);
            }
        },
        '&&': {
            precedence: 13, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) && b(context, aliases);
            }
        },
        '||': {
            precedence: 14, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) || b(context, aliases);
            }
        },
        '==': {
            precedence: 9, associativity: 'ltr',
            /* tslint:disable:triple-equals */
            fn: function (context, aliases, a, b) {
                return a(context, aliases) == b(context, aliases);
            }
        },
        '===': {
            precedence: 9, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) === b(context, aliases);
            }
        },
        '!=': {
            precedence: 9, associativity: 'ltr',
            /* tslint:disable:triple-equals */
            fn: function (context, aliases, a, b) {
                return a(context, aliases) != b(context, aliases);
            }
        },
        '!==': {
            precedence: 9, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) !== b(context, aliases);
            }
        },
        '>=': {
            precedence: 8, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) >= b(context, aliases);
            }
        },
        '<=': {
            precedence: 8, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) <= b(context, aliases);
            }
        },
        '=': {
            precedence: 17, associativity: 'rtl',
            fn: function (context, aliases, a, b) {
                var _log = plat.acquire(__Log);
                _log.error(new Error('Assignment operators are not supported'));
            }
        },
        '++': {
            precedence: 3, associativity: '',
            fn: function (context, aliases, a) {
                var _log = plat.acquire(__Log);
                _log.error(new Error('Assignment operators are not supported'));
            }
        },
        '--': {
            precedence: 3, associativity: '',
            fn: function (context, aliases, a) {
                var _log = plat.acquire(__Log);
                _log.error(new Error('Assignment operators are not supported'));
            }
        },
        '+=': {
            precedence: 17, associativity: 'rtl',
            fn: function (context, aliases, a, b) {
                var _log = plat.acquire(__Log);
                _log.error(new Error('Assignment operators are not supported'));
            }
        },
        '-=': {
            precedence: 17, associativity: 'rtl',
            fn: function (context, aliases, a, b) {
                var _log = plat.acquire(__Log);
                _log.error(new Error('Assignment operators are not supported'));
            }
        },
        '*=': {
            precedence: 17, associativity: 'rtl',
            fn: function (context, aliases, a, b) {
                var _log = plat.acquire(__Log);
                _log.error(new Error('Assignment operators are not supported'));
            }
        },
        '/=': {
            precedence: 17, associativity: 'rtl',
            fn: function (context, aliases, a, b) {
                var _log = plat.acquire(__Log);
                _log.error(new Error('Assignment operators are not supported'));
            }
        },
        '%=': {
            precedence: 17, associativity: 'rtl',
            fn: function (context, aliases, a, b) {
                var _log = plat.acquire(__Log);
                _log.error(new Error('Assignment operators are not supported'));
            }
        }
    };
    /**
     * An object used to create ITokenDetails for every accessor.
     */
    var ACCESSORS = {
        '()': { precedence: 2, associativity: null, fn: null },
        '[]': { precedence: 2, associativity: null, fn: null },
        '.': { precedence: 2, associativity: null, fn: null },
        '{}': { precedence: 1, associativity: null, fn: null }
    };
    /**
     * An object used to create ITokenDetails for every delimiter.
     */
    var DELIMITERS = {
        '{': { precedence: 1, associativity: null, fn: null },
        '}': { precedence: 1, associativity: null, fn: null },
        '[': { precedence: 2, associativity: null, fn: null },
        ']': { precedence: 2, associativity: null, fn: null },
        '(': { precedence: 2, associativity: null, fn: null },
        ')': { precedence: 2, associativity: null, fn: null },
        '.': { precedence: 2, associativity: null, fn: null },
        ',': { precedence: 18, associativity: null, fn: null },
        '\'': { precedence: 0, associativity: null, fn: null },
        '"': { precedence: 0, associativity: null, fn: null }
    };
    /**
     * An object used to get literal values from string values of false, true, and undefined
     */
    var KEYWORDS = {
        false: false,
        true: true,
        null: null,
        undefined: 'undefined'
    };
    /**
     * Checks if a string is in the DELIMITERS array.
     * @param {string} key The string to index into the DELIMITERS array.
     */
    function isDelimiter(key) {
        return !isNull(DELIMITERS[key]);
    }
    /**
     * Checks if a string is in the ACCESSORS array.
     * @param {string} key The string to index into the ACCESSORS array.
     */
    function isAccessor(key) {
        return !isNull(ACCESSORS[key]);
    }
    /**
     * Checks if a string is in the OPERATORS array.
     * @param {string} key The string to index into the OPERATORS array.
     */
    function isOperator(key) {
        return !isNull(OPERATORS[key]);
    }
    /**
     * Checks if a string is in the KEYWORDS array.
     * @param {string} key The string to index into the KEYWORDS array.
     */
    function isKeyword(key) {
        return !isUndefined(KEYWORDS[key]);
    }
    /* tslint:enable:no-unused-variable */
    /**
     * Holds all classes and interfaces related to observable components in platypus.
     */
    var observable;
    (function (observable) {
        /**
         * The array methods to be overwritten if it is to be observed.
         */
        var arrayMethods = ['push', 'pop', 'reverse', 'shift', 'sort', 'splice', 'unshift'];
        /**
         * A class for managing both context inheritance and observable properties on controls and
         * facilitating in data-binding.
         */
        var ContextManager = (function () {
            function ContextManager() {
                /**
                 * Reference to the Compat injectable.
                 */
                this._compat = acquire(__Compat);
                /**
                 * An object for quickly accessing callbacks associated with a given identifier.
                 */
                this.__identifiers = {};
                /**
                 * An object for quickly accessing child context associations (helps with
                 * notifying child properties).
                 */
                this.__identifierHash = {};
                /**
                 * An object for storing listeners for Array length changes.
                 */
                this.__lengthListeners = {};
                /**
                 * An object for quickly accessing previously accessed or observed objects and properties.
                 */
                this.__contextObjects = {};
                /**
                 * Whether or not the property currently being modified is due to an observed array function.
                 */
                this.__isArrayFunction = false;
            }
            /**
             * Gets the ContextManager associated to the given control. If no
             * ContextManager exists, one is created for that control.
             * @param {plat.Control} control The control on which to locate the ContextManager.
             */
            ContextManager.getManager = function (control) {
                var contextManager, managers = ContextManager.__managers, uid = control.uid, manager = managers[uid];
                if (!isNull(manager)) {
                    contextManager = manager;
                    return contextManager;
                }
                contextManager = managers[uid] = new ContextManager();
                contextManager.context = control;
                return contextManager;
            };
            ContextManager.dispose = function (control) {
                if (isNull(control)) {
                    return;
                }
                var uid = control.uid, controls = ContextManager.__controls, identifiers = controls[uid] || {}, managers = ContextManager.__managers, manager = managers[uid];
                if (!isNull(manager)) {
                    manager.dispose();
                    deleteProperty(managers, uid);
                }
                var keys = Object.keys(identifiers), listeners;
                while (keys.length > 0) {
                    listeners = identifiers[keys.shift()];
                    while (listeners.length > 0) {
                        listeners.shift()();
                    }
                }
                deleteProperty(controls, uid);
                if (!isNull(control.context)) {
                    ContextManager.unObserve(control.context);
                    ContextManager.defineProperty(control, __CONTEXT, control.context, true, true, true);
                }
            };
            /**
             * Removes all listeners for an Array associated with a given uid.
             * @param {string} absoluteIdentifier The identifier used to locate the array.
             * @param {string} uid The uid used to search for listeners.
             */
            ContextManager.removeArrayListeners = function (absoluteIdentifier, uid) {
                var listeners = ContextManager.arrayChangeListeners[absoluteIdentifier];
                if (!isNull(listeners)) {
                    deleteProperty(listeners, uid);
                }
            };
            /**
             * Safely retrieves the local context given a root context and an Array of
             * property strings.
             * @param {any} rootContext The root object in which to find a local context.
             * @param {Array<string>} split The string array containing properties used to index into
             * the rootContext.
             */
            ContextManager.getContext = function (rootContext, split) {
                if (isNull(rootContext)) {
                    return rootContext;
                }
                split = split.slice(0);
                while (split.length > 0) {
                    rootContext = rootContext[split.shift()];
                    if (isNull(rootContext)) {
                        return rootContext;
                    }
                }
                return rootContext;
            };
            /**
             * Defines an object property with the associated value. Useful for unobserving objects.
             * @param {any} obj The object on which to define the property.
             * @param {string} key The property key.
             * @param {any} value The value used to define the property.
             * @param {boolean} enumerable? Whether or not the property should be enumerable (able to be iterated
             * over in a loop)
             * @param {boolean} configurable? Whether or not the property is able to be reconfigured.
             * @param {boolean} writable? Whether or not assignment operators work on the property.
             */
            ContextManager.defineProperty = function (obj, key, value, enumerable, configurable, writable) {
                _defineProperty(obj, key, value, enumerable, configurable, writable);
            };
            /**
             * Defines an object property with the associated value. Useful for unobserving objects.
             * @param {any} obj The object on which to define the property.
             * @param {string} key The property key.
             * @param {any} value The value used to define the property.
             * @param {boolean} enumerable? Whether or not the property should be enumerable (able to be iterated
             * over in a loop)
             * @param {boolean} configurable? Whether or not the property is able to be reconfigured.
             */
            ContextManager.defineGetter = function (obj, key, value, enumerable, configurable) {
                _defineGetter(obj, key, value, enumerable, configurable);
            };
            /**
             * Pushes the function for removing an observed property upon adding the property.
             * @param {string} identifer The identifier for which the remove listener is being pushed.
             * @param {string} uid The unique ID of the control observing the identifier.
             * @param {plat.IRemoveListener} listener The function for removing the observed property.
             */
            ContextManager.pushRemoveListener = function (identifier, uid, listener) {
                var controls = ContextManager.__controls, control = controls[uid], listeners;
                if (isNull(control)) {
                    control = controls[uid] = {};
                }
                listeners = control[identifier];
                if (isNull(listeners)) {
                    listeners = control[identifier] = [];
                }
                listeners.push(listener);
            };
            /**
             * Splices a given function for removing an observed property.
             * @param {string} identifer The identifier for which the remove listener is being spliced.
             * @param {string} uid The unique ID of the control observing the identifier.
             * @param {plat.IRemoveListener} listener The function for removing the observed property.
             */
            ContextManager.spliceRemoveListener = function (identifier, uid, listener) {
                var controls = ContextManager.__controls, control = controls[uid], listeners;
                if (isNull(control)) {
                    return;
                }
                listeners = control[identifier];
                if (isNull(listeners)) {
                    return;
                }
                var index = listeners.indexOf(listener);
                if (index === -1) {
                    return;
                }
                listeners.splice(index, 1);
                if (listeners.length === 0) {
                    deleteProperty(control, identifier);
                }
            };
            /**
             * Removes a specified identifier from being observed for a given set of control IDs.
             * @param {Array<string>} uids The set of unique Ids for which to remove the specified identifier.
             * @param {string} identifier The identifier to stop observing.
             */
            ContextManager.removeIdentifier = function (uids, identifier) {
                var length = uids.length, controls = ContextManager.__controls, identifiers;
                for (var i = 0; i < length; ++i) {
                    identifiers = controls[uids[i]];
                    if (isNull(identifiers)) {
                        continue;
                    }
                    deleteProperty(identifiers, identifier);
                }
            };
            /**
             * Ensures that an identifier path will exist on a given control. Will create
             * objects/arrays if necessary.
             * @param {plat.ui.TemplateControl} control The TemplateControl
             * on which to create the context.
             * @param {string} identifier The period-delimited identifier string used to create
             * the context path.
             */
            ContextManager.createContext = function (control, identifier) {
                var context = control.context;
                if (!isObject(context)) {
                    if (isNull(context)) {
                        context = control.context = {};
                    }
                    else {
                        ContextManager._log.warn('A child control is trying to create a child context that has ' +
                            'a parent control with a primitive type context');
                        return;
                    }
                }
                var split = identifier.split('.'), property, temp;
                while (split.length > 0) {
                    property = split.shift();
                    temp = context[property];
                    if (isNull(temp)) {
                        if (isNumber(Number(split[0]))) {
                            temp = context[property] = [];
                        }
                        else {
                            temp = context[property] = {};
                        }
                    }
                    context = temp;
                }
                return context;
            };
            /**
             * Iterates through all the nested properties in an object and redefines the properties to not use getters/setters
             * @param {any} obj The object to stop observing.
             */
            ContextManager.unObserve = function (obj) {
                _extend(true, true, obj);
            };
            /**
             * Safely retrieves the local context for this manager given an Array of
             * property strings and observes it if not found.
             * @param {Array<string>} split The string array containing properties used to index into
             * the context.
             * @param {boolean} observe? Whether or not to observe the identifier indicated by the
             * split Array.
             */
            ContextManager.prototype.getContext = function (split, observe) {
                return this._getContext(split.join('.'), split, observe);
            };
            /**
             * Given a period-delimited identifier, observes an object and calls the given listener when the
             * object changes.
             * @param {string} absoluteIdentifier The period-delimited identifier noting the property to be observed.
             * @param {plat.observable.IListener} observableListener An object implmenting IObservableListener. The listener will be
             * notified of object changes.
             */
            ContextManager.prototype.observe = function (absoluteIdentifier, observableListener) {
                var _this = this;
                if (isEmpty(absoluteIdentifier)) {
                    return noop;
                }
                var split = absoluteIdentifier.split('.'), key = split.pop(), isLength = key === 'length', hasIdentifier = this._hasIdentifier(absoluteIdentifier), hasObservableListener = !isNull(observableListener), join, context;
                if (split.length > 0) {
                    join = split.join('.');
                    context = this._getContext(join, split, true);
                }
                else {
                    join = key;
                    context = this.context;
                }
                if (!isObject(context)) {
                    if (hasObservableListener) {
                        if (isLength) {
                            this.__lengthListeners[absoluteIdentifier] = observableListener;
                            ContextManager.pushRemoveListener(absoluteIdentifier, observableListener.uid, function () {
                                deleteProperty(_this.__lengthListeners, absoluteIdentifier);
                            });
                        }
                        return this._addObservableListener(absoluteIdentifier, observableListener, isLength);
                    }
                    return noop;
                }
                // set observedIdentifier to null 
                this.__observedIdentifier = null;
                this.__contextObjects[absoluteIdentifier] = context[key];
                // if observedIdentifier is not null, the primitive is already being watched 
                var observedIdentifier = this.__observedIdentifier, isObserved = !isNull(observedIdentifier), removeCallback = noop;
                if (isObserved) {
                    hasIdentifier = true;
                }
                if (hasObservableListener) {
                    var removeObservedCallback_1 = noop, removeAbsoluteCallback_1 = this._addObservableListener(absoluteIdentifier, observableListener, isLength);
                    if (isObserved && absoluteIdentifier !== observedIdentifier) {
                        removeObservedCallback_1 = this._addObservableListener(observedIdentifier, observableListener, isLength);
                    }
                    removeCallback = function () {
                        removeAbsoluteCallback_1();
                        removeObservedCallback_1();
                    };
                }
                var parentIsArray = isArray(context), removeObservableListener = removeCallback, removeListener = noop, removeArrayObserve = noop, numKey = Number(key);
                if (parentIsArray && numKey >= context.length) {
                    removeListener = this.observe(join + '.length', {
                        uid: observableListener.uid,
                        listener: function (newValue, oldValue) {
                            if (numKey >= newValue) {
                                return;
                            }
                            removeListener();
                            _this._define(absoluteIdentifier, context, key);
                        }
                    });
                    removeCallback = function () {
                        removeObservableListener();
                        removeListener();
                    };
                }
                else if (!hasIdentifier) {
                    // check if value is defined and context manager hasn't seen this identifier 
                    if (parentIsArray && isLength) {
                        var property = split.pop(), parentContext = this.getContext(split, false);
                        this.__observedIdentifier = null;
                        access(parentContext, property);
                        if (isString(this.__observedIdentifier)) {
                            join = this.__observedIdentifier;
                        }
                        if (hasObservableListener) {
                            var uid_1 = observableListener.uid;
                            removeListener = this.observeArrayMutation(uid_1, noop, join, context, null);
                            removeArrayObserve = this.observe(join, {
                                uid: uid_1,
                                listener: function (newValue, oldValue) {
                                    removeListener();
                                    removeListener = _this.observeArrayMutation(uid_1, noop, join, newValue, oldValue);
                                }
                            });
                        }
                        removeCallback = function () {
                            removeObservableListener();
                            removeArrayObserve();
                            removeListener();
                        };
                    }
                    else {
                        this._define(absoluteIdentifier, context, key);
                    }
                }
                return removeCallback;
            };
            /**
             * Observes an array and calls the listener when certain functions are called on
             * that array. The watched functions are push, pop, shift, splice, unshift, sort,
             * and reverse.
             * @param {string} uid The unique ID of the object observing the array.
             * @param {(changes: Array<plat.observable.IArrayChanges<any>>) => void} listener The callback for after
             * when an observed Array function has been called.
             * @param {string} absoluteIdentifier The identifier from the root context used to find the array.
             * @param {Array<any>} array The array to be observed.
             * @param {Array<any>} oldArray The old array to stop observing.
             */
            ContextManager.prototype.observeArrayMutation = function (uid, listener, absoluteIdentifier, array, oldArray) {
                if (isArray(oldArray)) {
                    this._restoreArray(oldArray);
                }
                if (isNull(array)) {
                    return noop;
                }
                var split = absoluteIdentifier.split('.'), property = split.pop(), context = this.getContext(split, false);
                this.__observedIdentifier = null;
                access(context, property);
                if (isString(this.__observedIdentifier)) {
                    absoluteIdentifier = this.__observedIdentifier;
                }
                var removeListeners = [];
                if (isFunction(listener)) {
                    removeListeners.push(this._pushArrayListener(uid, absoluteIdentifier, listener));
                }
                this._overwriteArray(absoluteIdentifier, array);
                return function () {
                    while (removeListeners.length > 0) {
                        removeListeners.pop()();
                    }
                };
            };
            /**
             * Disposes the memory for an ContextManager.
             */
            ContextManager.prototype.dispose = function () {
                this.context = null;
                this.__identifiers = {};
                this.__identifierHash = {};
                this.__contextObjects = {};
            };
            /**
             * Pushes Array mutation listeners and removers.
             * @param {string} uid The unique identifier to store the callback.
             * @param {string} absoluteIdentifier The identifier of the Array being observed.
             * @param {(changes: Array<plat.observable.IArrayChanges<any>>) => void} listener The Array mutation listener.
             */
            ContextManager.prototype._pushArrayListener = function (uid, absoluteIdentifier, listener) {
                var arrayListeners = ContextManager.arrayChangeListeners, arrayCallbacks = arrayListeners[absoluteIdentifier];
                if (isNull(arrayCallbacks)) {
                    arrayCallbacks = arrayListeners[absoluteIdentifier] = {};
                }
                var callbacks = arrayCallbacks[uid];
                if (isNull(callbacks)) {
                    callbacks = arrayCallbacks[uid] = [];
                }
                var listenerRemoved = false, removeListener = function () {
                    if (listenerRemoved) {
                        return;
                    }
                    listenerRemoved = true;
                    ContextManager.spliceRemoveListener(absoluteIdentifier, uid, removeListener);
                    var index = callbacks.indexOf(listener);
                    if (index === -1) {
                        return;
                    }
                    callbacks.splice(index, 1);
                    if (callbacks.length === 0) {
                        deleteProperty(arrayCallbacks, uid);
                        if (isEmpty(arrayCallbacks)) {
                            deleteProperty(arrayListeners, absoluteIdentifier);
                        }
                    }
                };
                callbacks.push(listener);
                ContextManager.pushRemoveListener(absoluteIdentifier, uid, removeListener);
                return removeListener;
            };
            /**
             * Restores an array to use Array.prototype instead of listener functions.
             * @param {Array<any>} array The array to restore.
             */
            ContextManager.prototype._restoreArray = function (array) {
                var _compat = this._compat;
                if (_compat.setProto) {
                    Object.setPrototypeOf(array, Object.create(Array.prototype));
                }
                else if (_compat.proto) {
                    array.__proto__ = Object.create(Array.prototype);
                }
                else {
                    var length_5 = arrayMethods.length, method = void 0;
                    for (var i = 0; i < length_5; ++i) {
                        method = arrayMethods[i];
                        array[method] = Array.prototype[method];
                    }
                }
            };
            /**
             * Overwrites an Array's prototype to observe mutation functions.
             * @param {string} absoluteIdentifier The identifier for the Array off context.
             * @param {Array<any>} array The array to overwrite.
             */
            ContextManager.prototype._overwriteArray = function (absoluteIdentifier, array) {
                var _compat = this._compat, length = arrayMethods.length, method, i;
                if (_compat.proto) {
                    var obj = Object.create(Array.prototype);
                    for (i = 0; i < length; ++i) {
                        method = arrayMethods[i];
                        obj[method] = this._overwriteArrayFunction(absoluteIdentifier, method);
                    }
                    if (_compat.setProto) {
                        Object.setPrototypeOf(array, obj);
                    }
                    else {
                        array.__proto__ = obj;
                    }
                    return;
                }
                for (i = 0; i < length; ++i) {
                    method = arrayMethods[i];
                    ContextManager.defineProperty(array, method, this._overwriteArrayFunction(absoluteIdentifier, method), false, true, true);
                }
            };
            /**
             * Gets the context object of an identifier.
             * @param {string} identifier The identifier for which we're getting the context.
             * @param {Array<string>} split The string array containing properties used to index into
             * the context.
             * @param {boolean} observe? Whether or not to observe the identifier indicated by the
             * split Array.
             */
            ContextManager.prototype._getContext = function (identifier, split, observe) {
                var context = this.__contextObjects[identifier];
                if (isNull(context)) {
                    if (observe === true) {
                        context = this.__contextObjects[identifier] = this._observeImmediateContext(split, identifier);
                    }
                    else {
                        context = this._getImmediateContext(split);
                    }
                }
                return context;
            };
            /**
             * Gets the immediate context of identifier by splitting on ".".
             * @param {Array<string>} split The string array containing properties used to index into
             * the context.
             */
            ContextManager.prototype._getImmediateContext = function (split) {
                var context = this.context;
                while (split.length > 0) {
                    context = context[split.shift()];
                    if (isNull(context)) {
                        break;
                    }
                }
                return context;
            };
            /**
             * Gets the immediate context of identifier by splitting on "."
             * and observes the objects along the way.
             * @param {Array<string>} split The identifier's split string array containing properties
             * used to index into the context.
             * @param {string} identifier The identifier being observed.
             */
            ContextManager.prototype._observeImmediateContext = function (split, identifier) {
                if (isNull(this.__identifiers[identifier])) {
                    this.observe(identifier, null);
                }
                return this._getImmediateContext(split);
            };
            /**
             * Obtains the old value and new value of a given context
             * property on a property changed event.
             * @param {Array<string>} split The split identifier of the property that changed.
             * @param {any} newRootContext The new context.
             * @param {any} oldRootContext The old context.
             */
            ContextManager.prototype._getValues = function (split, newRootContext, oldRootContext) {
                var property, doNew = isObject(newRootContext), doOld = isObject(oldRootContext);
                while (split.length > 1) {
                    property = split.shift();
                    if (doNew) {
                        newRootContext = newRootContext[property];
                        if (isNull(newRootContext)) {
                            doNew = false;
                        }
                    }
                    if (doOld) {
                        oldRootContext = oldRootContext[property];
                        if (isNull(oldRootContext)) {
                            doOld = false;
                        }
                    }
                    if (!(doNew || doOld)) {
                        break;
                    }
                }
                property = split[0];
                var newValue, oldValue;
                if (!isNull(newRootContext)) {
                    newValue = newRootContext[property];
                }
                if (!isNull(oldRootContext)) {
                    oldValue = oldRootContext[property];
                }
                return {
                    newValue: newValue,
                    oldValue: oldValue
                };
            };
            /**
             * Notifies all child properties being observed that a parent property
             * has changed.
             * @param {string} identifier The identifier for the property that changed.
             * @param {any} newValue The new value of the property.
             * @param {any} oldValue The old value of the property.
             * @param {Array<string>} mappings? An array of mapped child identifier keys to notify.
             */
            ContextManager.prototype._notifyChildProperties = function (identifier, newValue, oldValue, mappings) {
                var _this = this;
                mappings = mappings || Object.keys(this.__identifierHash[identifier] || {});
                var length = mappings.length, binding, property, parentProperty, split, values = {}, value, period = '.', lengthStr = 'length', key, keyIsLength, start = identifier.length + 1, newParent, oldParent, newChild, oldChild;
                for (var i = 0; i < length; ++i) {
                    binding = mappings[i];
                    property = binding.slice(start);
                    split = property.split(period);
                    key = split.pop();
                    keyIsLength = (key === lengthStr);
                    parentProperty = split.join(period);
                    if (isEmpty(parentProperty)) {
                        newParent = newValue;
                        oldParent = oldValue;
                        newChild = isNull(newParent) ? undefined : newParent[key];
                        oldChild = isNull(oldParent) ? undefined : oldParent[key];
                        if (keyIsLength && !isArray(oldParent) && isArray(newParent)) {
                            var lengthListener = this.__lengthListeners[binding];
                            if (!isNull(lengthListener)) {
                                var uid = lengthListener.uid;
                                var arraySplit = identifier.split(period), arrayKey = arraySplit.pop();
                                var join = arraySplit.join(period);
                                var arrayParent = this._getContext(join, arraySplit, false);
                                this.__observedIdentifier = null;
                                access(arrayParent, arrayKey);
                                if (isString(this.__observedIdentifier)) {
                                    join = this.__observedIdentifier;
                                }
                                var removeListener = this.observeArrayMutation(uid, noop, join, newParent, null);
                                this.observe(join, {
                                    uid: uid,
                                    listener: function (nValue, oValue) {
                                        removeListener();
                                        removeListener = _this.observeArrayMutation(uid, noop, join, nValue, oValue);
                                    }
                                });
                                deleteProperty(this.__lengthListeners, binding);
                            }
                        }
                    }
                    else {
                        value = values[parentProperty];
                        if (isNull(value)) {
                            value = values[parentProperty] = this._getValues(split, newValue, oldValue);
                        }
                        newParent = value.newValue;
                        oldParent = value.oldValue;
                        newChild = isNull(newParent) ? newParent : newParent[key];
                        oldChild = isNull(oldParent) ? oldParent : oldParent[key];
                    }
                    values[property] = {
                        newValue: newChild,
                        oldValue: oldChild
                    };
                    if (isObject(newParent) && (!isArray(newParent) || newParent.length > key)) {
                        this._define(binding, newParent, key);
                    }
                    this._execute(binding, newChild, oldChild);
                }
                values = null;
            };
            /**
             * Adds a listener to be fired for a particular identifier.
             * @param {string} absoluteIdentifier The identifier being observed.
             * @param {plat.observable.IListener} observableListener The function and associated unique ID to be fired
             * for this identifier.
             * @param {boolean} isLength? Indicates the property being observed is an Array's length.
             */
            ContextManager.prototype._addObservableListener = function (absoluteIdentifier, observableListener, isLength) {
                var _this = this;
                if (isLength === true) {
                    var split = absoluteIdentifier.split('.');
                    // pop length key 
                    split.pop();
                    var property = split.pop(), context = this.getContext(split, false);
                    if (isObject(context)) {
                        this.__observedIdentifier = null;
                        access(context, property);
                        if (isString(this.__observedIdentifier)) {
                            absoluteIdentifier = this.__observedIdentifier + (isLength === true ? '.length' : '');
                        }
                    }
                }
                this.__add(absoluteIdentifier, observableListener);
                var uid = observableListener.uid, remove = function () {
                    ContextManager.spliceRemoveListener(absoluteIdentifier, uid, remove);
                    _this._removeCallback(absoluteIdentifier, observableListener);
                };
                ContextManager.pushRemoveListener(absoluteIdentifier, uid, remove);
                return remove;
            };
            /**
             * Observes a property on a given context specified by an identifier.
             * @param {string} identifier The full identifier path for the property being observed.
             * @param {any} immediateContext The object whose property will be observed.
             * @param {string} key The property key for the value on the immediateContext that's
             * being observed.
             */
            ContextManager.prototype._define = function (identifier, immediateContext, key) {
                if (isObject(immediateContext[key])) {
                    this.__defineObject(identifier, immediateContext, key);
                }
                else {
                    this.__definePrimitive(identifier, immediateContext, key);
                }
            };
            /**
             * Intercepts an array function for observation.
             * @param {string} absoluteIdentifier The full identifier path for the observed array.
             * @param {string} method The array method being called.
             */
            ContextManager.prototype._overwriteArrayFunction = function (absoluteIdentifier, method) {
                var callbackObjects = ContextManager.arrayChangeListeners[absoluteIdentifier] || {}, _this = this;
                // we can't use a fat-arrow function here because we need the array context. 
                return function observedArrayFn() {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i - 0] = arguments[_i];
                    }
                    var oldLength = this.length, originalArray = this.slice(0), returnValue, isUnshift = method === 'unshift', isShift = method === 'shift', isSplice = method === 'splice', selfNotify = isShift || isUnshift || isSplice, isUpdate = method === 'sort' || method === 'reverse', oldArray, addedCount, index, newLength, removed;
                    if (selfNotify) {
                        _this.__isArrayFunction = true;
                        returnValue = Array.prototype[method].apply(this, args);
                        _this.__isArrayFunction = false;
                        newLength = this.length;
                        index = 0;
                        if (isShift) {
                            addedCount = 0;
                            removed = oldLength > 0 ? [returnValue] : [];
                        }
                        else if (isUnshift) {
                            addedCount = args.length;
                            removed = [];
                        }
                        else {
                            addedCount = args.length - 2;
                            index = args[0];
                            removed = returnValue;
                        }
                    }
                    else {
                        returnValue = Array.prototype[method].apply(this, args);
                        newLength = this.length;
                        if (isUpdate) {
                            oldArray = originalArray;
                        }
                        else if (method === 'push') {
                            addedCount = args.length;
                            index = oldLength;
                            removed = [];
                        }
                        else if (method === 'pop') {
                            addedCount = 0;
                            index = newLength;
                            removed = oldLength > 0 ? [returnValue] : [];
                        }
                    }
                    if (isShift || isSplice || method === 'pop') {
                        ContextManager.unObserve(returnValue);
                    }
                    var keys = Object.keys(callbackObjects), length = keys.length, callbacks, jLength, i, j;
                    for (i = 0; i < length; ++i) {
                        callbacks = callbackObjects[keys[i]];
                        jLength = callbacks.length;
                        for (j = 0; j < jLength; ++j) {
                            callbacks[j]([{
                                    object: this,
                                    type: method,
                                    index: index,
                                    removed: removed,
                                    addedCount: addedCount,
                                    oldArray: oldArray
                                }]);
                        }
                    }
                    if (selfNotify) {
                        _this._notifyChildProperties(absoluteIdentifier, this, originalArray);
                    }
                    else {
                        _this._execute(absoluteIdentifier + '.length', newLength, oldLength);
                    }
                    return returnValue;
                };
            };
            /**
             * Removes a single listener callback
             * @param {string} identifier The identifier attached to the callbacks.
             * @param {plat.observable.IListener} listener The observable listener to remove.
             */
            ContextManager.prototype._removeCallback = function (identifier, listener) {
                var callbacks = this.__identifiers[identifier];
                if (isNull(callbacks)) {
                    return;
                }
                // splice the observed listener 
                var index = callbacks.indexOf(listener);
                if (index === -1) {
                    return;
                }
                callbacks.splice(index, 1);
                if (callbacks.length === 0) {
                    deleteProperty(this.__contextObjects, identifier);
                }
            };
            /**
             * Checks if the specified identifier is already being
             * observed in this context.
             * @param {string} identifier The identifier being observed.
             */
            ContextManager.prototype._hasIdentifier = function (identifier) {
                return !isEmpty(this.__identifiers[identifier]);
            };
            /**
             * Executes the listeners for the specified identifier on
             * this context.
             * @param {string} identifier The identifier attached to the callbacks.
             * @param {any} value The new value on this context specified by
             * the identifier.
             * @param {any} oldValue The old value on this context specified by
             * the identifier.
             */
            ContextManager.prototype._execute = function (identifier, value, oldValue) {
                var observableListeners = this.__identifiers[identifier];
                if (isUndefined(value)) {
                    deleteProperty(this.__contextObjects, identifier);
                }
                else {
                    this.__contextObjects[identifier] = value;
                }
                if (value === oldValue || isNull(observableListeners)) {
                    return;
                }
                var listeners = observableListeners.slice(0), length = listeners.length;
                for (var i = 0; i < length; ++i) {
                    listeners[i].listener(value, oldValue);
                }
            };
            /**
             * Defines a getter and setter for an object using Object.defineProperty.
             * @param {string} identifier The identifier of the object being defined.
             * @param {any} immediateContext The parent object of the object being defined.
             * @param {string} key The property key of the object being defined.
             */
            ContextManager.prototype.__defineObject = function (identifier, immediateContext, key) {
                var _this = this;
                var value = immediateContext[key];
                Object.defineProperty(immediateContext, key, {
                    configurable: true,
                    enumerable: true,
                    get: function () {
                        _this.__observedIdentifier = identifier;
                        return value;
                    },
                    set: function (newValue) {
                        if (value === newValue) {
                            return;
                        }
                        var oldValue = value;
                        value = newValue;
                        if (_this.__isArrayFunction) {
                            return;
                        }
                        ContextManager.unObserve(oldValue);
                        var props = _this.__identifierHash[identifier], childPropertiesExist = false, mappings;
                        if (isObject(props)) {
                            mappings = Object.keys(props);
                            childPropertiesExist = mappings.length > 0;
                        }
                        _this._execute(identifier, value, oldValue);
                        if (childPropertiesExist) {
                            _this._notifyChildProperties(identifier, value, oldValue, mappings);
                            if (!isObject(value)) {
                                _this.__definePrimitive(identifier, immediateContext, key);
                            }
                        }
                        else if (isEmpty(_this.__identifiers[identifier])) {
                            ContextManager.defineProperty(immediateContext, key, value, true, true, true);
                        }
                        else if (!isObject(value)) {
                            _this.__definePrimitive(identifier, immediateContext, key);
                        }
                    }
                });
            };
            /**
             * Defines a getter and setter for a primitive using Object.defineProperty.
             * @param {string} identifier The identifier of the primitive being defined.
             * @param {any} immediateContext The parent object of the primitive being defined.
             * @param {string} key The property key of the primitive being defined.
             */
            ContextManager.prototype.__definePrimitive = function (identifier, immediateContext, key) {
                var _this = this;
                var value = immediateContext[key], isDefined = !isNull(value);
                if (isArray(immediateContext) && key === 'length') {
                    return;
                }
                Object.defineProperty(immediateContext, key, {
                    configurable: true,
                    enumerable: true,
                    get: function () {
                        _this.__observedIdentifier = identifier;
                        return value;
                    },
                    set: function (newValue) {
                        if (value === newValue) {
                            return;
                        }
                        var oldValue = value;
                        value = newValue;
                        if (_this.__isArrayFunction && isArray(immediateContext)) {
                            return;
                        }
                        var props = _this.__identifierHash[identifier], childPropertiesExist = false, mappings;
                        if (isObject(props)) {
                            mappings = Object.keys(props);
                            childPropertiesExist = mappings.length > 0;
                        }
                        _this._execute(identifier, newValue, oldValue);
                        if (!childPropertiesExist && isEmpty(_this.__identifiers[identifier])) {
                            ContextManager.defineProperty(immediateContext, key, value, true, true, true);
                        }
                        else if (isObject(value)) {
                            _this.__defineObject(identifier, immediateContext, key);
                            if (childPropertiesExist) {
                                _this._notifyChildProperties(identifier, newValue, oldValue, mappings);
                            }
                        }
                        else if (!isDefined) {
                            _this.__definePrimitive(identifier, immediateContext, key);
                            isDefined = true;
                        }
                    }
                });
            };
            /**
             * Adds and associates a listener with a given identifier.
             * @param {string} identifier The identifier to attach the listener.
             * @param {plat.observable.IListener} observableListener The listener being added.
             */
            ContextManager.prototype.__add = function (identifier, observableListener) {
                var callbacks = this.__identifiers[identifier], priority = observableListener.priority, found = false;
                if (isNull(callbacks)) {
                    callbacks = this.__identifiers[identifier] = [];
                }
                if (isNumber(priority)) {
                    var length_6 = callbacks.length;
                    for (var i = 0; i < length_6; ++i) {
                        if (priority > callbacks[i].priority) {
                            callbacks.splice(i, 0, observableListener);
                            found = true;
                            break;
                        }
                    }
                }
                else {
                    observableListener.priority = -1;
                }
                if (!found) {
                    callbacks.push(observableListener);
                }
                this.__addHashValues(identifier);
            };
            /**
             * Adds a mapping for an identifier which allows quick access to it
             * if a parent context is changed.
             * @param {string} identifier The identifier to map.
             */
            ContextManager.prototype.__addHashValues = function (identifier) {
                var identifierHash = this.__identifierHash;
                if (isObject(identifierHash[identifier])) {
                    return;
                }
                identifierHash[identifier] = {};
                var index, period = '.', ident = identifier, hashValue;
                while ((index = ident.lastIndexOf(period)) !== -1) {
                    ident = ident.slice(0, index);
                    hashValue = identifierHash[ident];
                    if (isNull(hashValue)) {
                        hashValue = identifierHash[ident] = {};
                        if (ident !== identifier) {
                            hashValue[identifier] = true;
                        }
                    }
                    else if (ident !== identifier && !hashValue[identifier]) {
                        hashValue[identifier] = true;
                    }
                }
            };
            /**
             * A set of functions to be fired when a particular observed array is mutated.
             */
            ContextManager.arrayChangeListeners = {};
            /**
             * An object for quickly accessing a previously created ContextManager.
             */
            ContextManager.__managers = {};
            /**
             * An object for storing functions to remove listeners for observed identifiers.
             */
            ContextManager.__controls = {};
            return ContextManager;
        }());
        observable.ContextManager = ContextManager;
        /**
         */
        function IContextManagerStatic(_log) {
            ContextManager._log = _log;
            return ContextManager;
        }
        observable.IContextManagerStatic = IContextManagerStatic;
        register.injectable(__ContextManagerStatic, IContextManagerStatic, [
            __Log
        ], __STATIC);
        register.injectable(__ContextManagerInstance, ContextManager, null, __INSTANCE);
    })(observable = plat_1.observable || (plat_1.observable = {}));
    /**
     * Holds classes and interfaces related to event management components in platypus.
     */
    var events;
    (function (events) {
        /**
         * An event class that propagates through a control tree.
         * Propagation of the event always starts at the sender, allowing a control to both
         * initialize and consume an event. If a consumer of an event throws an error while
         * handling the event it will be logged to the app using Log.debug. Errors will
         * not stop propagation of the event.
         */
        var DispatchEvent = (function () {
            function DispatchEvent() {
                /**
                 * Whether or not preventDefault() was called on the event. Senders of the
                 * event can check this property to know if they should carry out a default
                 * action as a result of the event.
                 */
                this.defaultPrevented = false;
                /**
                 * Whether or not the event propagation was stopped.
                 */
                this.stopped = false;
            }
            DispatchEvent.prototype.initialize = function (name, sender, direction) {
                this.name = name;
                this.direction = direction || this._EventManager.UP;
                this.sender = sender;
            };
            /**
             * Cancels the default action (if there is one) for an event. Does not affect propagation.
             */
            DispatchEvent.prototype.preventDefault = function () {
                if (!this.defaultPrevented) {
                    this._ContextManager.defineGetter(this, 'defaultPrevented', true);
                }
            };
            /**
             * Call this method to halt the propagation of an upward-moving event.
             * Downward events cannot be stopped with this method.
             */
            DispatchEvent.prototype.stopPropagation = function () {
                if (this.direction === this._EventManager.UP) {
                    this.stopped = true;
                    this._EventManager.propagatingEvents[this.name] = false;
                }
            };
            DispatchEvent._inject = {
                _EventManager: __EventManagerStatic,
                _ContextManager: __ContextManagerStatic
            };
            return DispatchEvent;
        }());
        events.DispatchEvent = DispatchEvent;
        register.injectable(__DispatchEventInstance, DispatchEvent, null, __INSTANCE);
        /**
         * Represents a Lifecycle Event. Lifecycle Events are always direct events.
         */
        var LifecycleEvent = (function (_super) {
            __extends(LifecycleEvent, _super);
            function LifecycleEvent() {
                _super.apply(this, arguments);
            }
            /**
             * Creates a new LifecycleEvent and fires it.
             * @param {string} name The name of the event.
             * @param {any} sender The sender of the event.
             */
            LifecycleEvent.dispatch = function (name, sender) {
                var event = acquire(__LifecycleEventInstance);
                event.initialize(name, sender);
                EventManager.sendEvent(event);
                return event;
            };
            /**
             * Initializes the event, populating its public properties.
             * @param {string} name The name of the event.
             * @param {any} sender The sender of the event.
             */
            LifecycleEvent.prototype.initialize = function (name, sender) {
                _super.prototype.initialize.call(this, name, sender, this._EventManager.DIRECT);
            };
            return LifecycleEvent;
        }(DispatchEvent));
        events.LifecycleEvent = LifecycleEvent;
        /**
         */
        function ILifecycleEventStatic() {
            return LifecycleEvent;
        }
        events.ILifecycleEventStatic = ILifecycleEventStatic;
        register.injectable(__LifecycleEventStatic, ILifecycleEventStatic, null, __STATIC);
        register.injectable(__LifecycleEventInstance, LifecycleEvent, null, __INSTANCE);
        /**
         * Manages dispatching events, handling all propagating events as well as any error handling.
         */
        var EventManager = (function () {
            function EventManager() {
            }
            /**
             * Initializes the EventManager, creating the initial ALM event listeners.
             */
            EventManager.initialize = function () {
                if (EventManager.__initialized) {
                    return;
                }
                EventManager.__initialized = true;
                var lifecycleListeners = EventManager.__lifecycleEventListeners, _compat = EventManager._compat, _document = EventManager._document, _window = EventManager._window, _dom = EventManager._dom, dispatch = LifecycleEvent.dispatch, listener;
                while (lifecycleListeners.length > 0) {
                    listener = lifecycleListeners.pop();
                    _document.removeEventListener(listener.name, listener.value, false);
                }
                if (_compat.cordova) {
                    var eventNames = [__resume, __online, __offline], winJs_1 = _compat.winJs, length_7 = eventNames.length, event_1, dispatcher = function (ev) { return function () {
                        dispatch(ev, EventManager);
                    }; }, fn = void 0;
                    for (var i = 0; i < length_7; ++i) {
                        event_1 = eventNames[i];
                        fn = dispatcher(event_1);
                        lifecycleListeners.push({
                            name: event_1,
                            value: fn
                        });
                        _dom.addEventListener(_document, event_1, fn, false);
                    }
                    fn = dispatcher(__suspend);
                    lifecycleListeners.push({
                        name: __pause,
                        value: fn
                    });
                    _dom.addEventListener(_document, __pause, fn, false);
                    fn = dispatcher(__ready);
                    lifecycleListeners.push({
                        name: __deviceReady,
                        value: fn
                    });
                    _dom.addEventListener(_document, __deviceReady, fn, false);
                    fn = function () {
                        if (!winJs_1) {
                            dispatch(__backButton, EventManager);
                        }
                        return true;
                    };
                    lifecycleListeners.push({
                        name: __backButton,
                        value: fn
                    });
                    _dom.addEventListener(_document, __backButton, fn, false);
                    if (winJs_1) {
                        fn = function () {
                            dispatch(__backButton, EventManager);
                            return true;
                        };
                        lifecycleListeners.push({
                            name: __backClick,
                            value: fn
                        });
                        _window.WinJS.Application.addEventListener(__backClick, fn, false);
                    }
                }
                else if (_compat.amd) {
                    return;
                }
                else {
                    _dom.addEventListener(_window, 'load', function () {
                        dispatch(__ready, EventManager);
                    });
                }
            };
            /**
             * Removes all event listeners for a given uid. Useful for garbage collection when
             * certain objects that listen to events go out of scope.
             * @param {string} uid The uid for which the event listeners will be removed.'
             */
            EventManager.dispose = function (uid) {
                deleteProperty(EventManager.__eventsListeners, uid);
            };
            /**
             * Registers a listener for a DispatchEvent. The listener will be called when a DispatchEvent is
             * propagating over the given uid. Any number of listeners can exist for a single event name.
             * @param {string} uid A unique id to associate with the object registering the listener.
             * @param {string} eventName The name of the event to listen to.
             * @param {(ev: DispatchEvent, ...args: any[]) => void} listener The method called when the event is fired.
             * @param {any} context? The context with which to call the listener method.
             */
            EventManager.on = function (uid, eventName, listener, context) {
                var eventsListener = EventManager.__eventsListeners[uid];
                if (isNull(eventsListener)) {
                    eventsListener = EventManager.__eventsListeners[uid] = {
                        listeners: {},
                        context: context
                    };
                }
                var eventListeners = eventsListener.listeners[eventName];
                if (!isArray(eventListeners)) {
                    eventListeners = eventsListener.listeners[eventName] = [];
                }
                eventListeners.push(listener);
                return function () {
                    var index = eventListeners.indexOf(listener);
                    if (index === -1) {
                        return;
                    }
                    eventListeners.splice(index, 1);
                };
            };
            EventManager.dispatch = function (name, sender, direction, args) {
                var _dispatchEvent = acquire(__DispatchEventInstance);
                _dispatchEvent.initialize(name, sender, direction);
                EventManager.sendEvent(_dispatchEvent, args);
                return _dispatchEvent;
            };
            /**
             * Returns whether or not the given string is a registered direction.
             * @param {string} direction The direction of the event
             */
            EventManager.hasDirection = function (direction) {
                return (direction === EventManager.UP ||
                    direction === EventManager.DOWN ||
                    direction === EventManager.DIRECT);
            };
            /**
             * Determines the appropriate direction and dispatches the event accordingly.
             * @param {plat.events.DispatchEvent} event The DispatchEvent to send
             * @param {Array<any>} args The arguments associated with the event
             */
            EventManager.sendEvent = function (event, args) {
                var name = event.name, direction = event.direction;
                args = args || [];
                EventManager.propagatingEvents[name] = true;
                args = args || [];
                switch (direction) {
                    case EventManager.UP:
                        EventManager._dispatchUp(event, args);
                        break;
                    case EventManager.DOWN:
                        EventManager._dispatchDown(event, args);
                        break;
                    case EventManager.DIRECT:
                        EventManager._dispatchDirect(event, args);
                        break;
                }
                deleteProperty(EventManager.propagatingEvents, name);
            };
            /**
             * Dispatches the event up the control chain.
             * @param {plat.events.DispatchEvent} event The event being dispatched.
             * @param {Array<any>} args The arguments associated with the event.
             */
            EventManager._dispatchUp = function (event, args) {
                var name = event.name, parent = event.sender;
                while (!isNull(parent) && EventManager.propagatingEvents[name]) {
                    if (isNull(parent.uid)) {
                        parent = parent.parent;
                        continue;
                    }
                    EventManager.__executeEvent(parent.uid, event, args);
                    parent = parent.parent;
                }
            };
            /**
             * Dispatches the event down the control chain.
             * @param {plat.events.DispatchEvent} event The event being dispatched.
             * @param {Array<any>} args The arguments associated with the event.
             */
            EventManager._dispatchDown = function (event, args) {
                var controls = [], control, name = event.name;
                controls.push(event.sender);
                while (controls.length && EventManager.propagatingEvents[name]) {
                    control = controls.pop();
                    if (isNull(control.uid)) {
                        continue;
                    }
                    EventManager.__executeEvent(control.uid, event, args);
                    if (isNull(control.controls)) {
                        continue;
                    }
                    controls = controls.concat(control.controls);
                }
            };
            /**
             * Dispatches the event directly to all listeners.
             * @param {plat.events.DispatchEvent} event The event being dispatched.
             * @param {Array<any>} args The arguments associated with the event.
             */
            EventManager._dispatchDirect = function (event, args) {
                var uids = Object.keys(EventManager.__eventsListeners), length = uids.length, name = event.name, eventsListener;
                for (var i = 0; i < length; ++i) {
                    if (!EventManager.propagatingEvents[name]) {
                        break;
                    }
                    eventsListener = EventManager.__eventsListeners[uids[i]];
                    if (isNull(eventsListener) || isNull(eventsListener.listeners[name])) {
                        continue;
                    }
                    EventManager.__callListeners(eventsListener.context, event, eventsListener.listeners[name], args);
                }
            };
            /**
             * Dispatches the event to the listeners for the given uid.
             * @param {string} uid The uid used to find the event listeners.
             * @param {plat.events.DispatchEvent} The event.
             * @param {Array<any>} args The arguments to send to the listeners.
             */
            EventManager.__executeEvent = function (uid, ev, args) {
                var eventsListener = EventManager.__eventsListeners[uid];
                if (isNull(eventsListener)) {
                    return;
                }
                var context = eventsListener.context, listeners = eventsListener.listeners[ev.name];
                if (isNull(listeners)) {
                    return;
                }
                EventManager.__callListeners(context, ev, listeners, args);
            };
            /**
             * Calls event listeners with the given context, event, and arguments.
             * @param {any} context The context with which to call the listeners.
             * @param {plat.events.DispatchEvent} The event.
             * @param {Array<(ev: DispatchEvent, ...args: any[]) => void>} The event listeners.
             * @param {Array<any>} args The arguments to send to the listeners.
             */
            EventManager.__callListeners = function (context, ev, listeners, args) {
                var name = ev.name, length = listeners.length, index = -1;
                args = [ev].concat(args);
                while (++index < length && EventManager.propagatingEvents[name]) {
                    try {
                        listeners[index].apply(context, args);
                    }
                    catch (e) {
                        EventManager._log.debug(e);
                    }
                }
            };
            /**
             * An upward-moving event will start at the sender and move
             * up the parent chain.
             */
            EventManager.UP = 'up';
            /**
             * A downward-moving event will start at the sender and move
             * to its children and beyond.
             */
            EventManager.DOWN = 'down';
            /**
             * Goes through all listeners for an event name, ignoring order.
             */
            EventManager.DIRECT = 'direct';
            /**
             * Keeps track of which events are currently propagating.
             */
            EventManager.propagatingEvents = {};
            /**
             * Holds all the event listeners keyed by uid.
             */
            EventManager.__eventsListeners = {};
            /**
             * Holds all the event listeners for the application lifefycle events.
             */
            EventManager.__lifecycleEventListeners = [];
            /**
             * whether or not the event manager has been initialized.
             */
            EventManager.__initialized = false;
            return EventManager;
        }());
        events.EventManager = EventManager;
        /**
         */
        function IEventManagerStatic(_log, _compat, _document, _window, _dom) {
            EventManager._log = _log;
            EventManager._compat = _compat;
            EventManager._document = _document;
            EventManager._window = _window;
            EventManager._dom = _dom;
            return EventManager;
        }
        events.IEventManagerStatic = IEventManagerStatic;
        register.injectable(__EventManagerStatic, IEventManagerStatic, [
            __Log,
            __Compat,
            __Document,
            __Window,
            __Dom
        ], __STATIC);
        /**
         * Represents an internal Error Event. This is used for any
         * internal errors (both fatal and warnings). All error events are
         * direct events.
         */
        var ErrorEvent = (function (_super) {
            __extends(ErrorEvent, _super);
            function ErrorEvent() {
                _super.apply(this, arguments);
            }
            /**
             * Creates a new ErrorEvent and fires it.
             * @param {string} name The name of the event.
             * @param {any} sender The sender of the event.
             * @param {E} error The error that occurred, resulting in the event.
             * @param {number} logLevel The severity level of the error
             */
            ErrorEvent.dispatch = function (name, sender, error, logLevel) {
                var event = acquire(ErrorEvent);
                event.initialize(name, sender, null, error);
                event.logLevel = logLevel;
                ErrorEvent._EventManager.sendEvent(event);
                return event;
            };
            ErrorEvent.prototype.initialize = function (name, sender, direction, error) {
                _super.prototype.initialize.call(this, name, sender, this._EventManager.DIRECT);
                this.error = error;
            };
            return ErrorEvent;
        }(DispatchEvent));
        events.ErrorEvent = ErrorEvent;
        /**
         */
        function IErrorEventStatic(_EventManager) {
            ErrorEvent._EventManager = _EventManager;
            return ErrorEvent;
        }
        events.IErrorEventStatic = IErrorEventStatic;
        register.injectable(__ErrorEventStatic, IErrorEventStatic, [__EventManagerStatic], __STATIC);
    })(events = plat_1.events || (plat_1.events = {}));
    /**
     * Used for facilitating data and DOM manipulation. Contains lifecycle events
     * as well as properties for communicating with other controls. This is the base
     * class for all types of controls.
     */
    var Control = (function () {
        /**
         * The constructor for a control. Any injectables specified during control registration will be
         * passed into the constructor as arguments as long as the control is instantiated with its associated
         * injector.
         */
        function Control() {
            /**
             * A unique id, created during instantiation and found on every Control.
             */
            this.uid = uniqueId(__Plat);
            /**
             * Specifies the priority of the control. The purpose of
             * this is so that controls like plat-bind can have a higher
             * priority than plat-tap. The plat-bind will be initialized
             * and loaded before plat-tap, meaning it has the first chance
             * to respond to events.
             */
            this.priority = 0;
            /**
             * Contains DOM helper methods for manipulating this control's element.
             */
            this.dom = Control._dom;
            /**
             * Contains helper methods for data manipulation.
             */
            this.utils = acquire(__Utils);
            /**
             * Reference to the Log injectable.
             */
            this._log = Control._log;
        }
        Control.getRootControl = function (control) {
            if (isNull(control)) {
                return control;
            }
            else if (!isNull(control.root)) {
                return control.root;
            }
            while (!(isNull(control.parent) || control.hasOwnContext)) {
                if (!isNull(control.root)) {
                    return control.root;
                }
                control = control.parent;
            }
            if (!control.hasOwnContext && isObject(control.context)) {
                Control._log.debug('Root control: ' + control.type + ' found that sets its context to an Object but does not set the hasOwnContext ' +
                    'flag to true. Please set the flag if the control intends to use its own context.');
            }
            return control;
        };
        /**
         * Given a control, calls the loaded method for the control if it exists.
         * @param {plat.Control} control The control to load.
         */
        Control.load = function (control) {
            var _Promise = Control._Promise;
            if (isNull(control)) {
                return _Promise.resolve();
            }
            var ctrl = control;
            if (isString(ctrl.absoluteContextPath)) {
                if (isFunction(ctrl.contextChanged)) {
                    var contextManager = Control._ContextManager.getManager(ctrl.root);
                    contextManager.observe(ctrl.absoluteContextPath, {
                        uid: control.uid,
                        priority: __CONTEXT_CHANGED_PRIORITY,
                        listener: function (newValue, oldValue) {
                            ui.TemplateControl.contextChanged(control, newValue, oldValue);
                        }
                    });
                    if (isFunction(ctrl.zCC__plat)) {
                        ctrl.zCC__plat();
                        deleteProperty(ctrl, 'zCC__plat');
                    }
                }
                var element = ctrl.element;
                if (isNode(element) && isFunction(element.removeAttribute)) {
                    element.removeAttribute(__Hide);
                }
            }
            if (isFunction(control.loaded)) {
                return _Promise.resolve(control.loaded());
            }
            return _Promise.resolve();
        };
        /**
         * Disposes all the necessary memory for a control. Uses specific dispose
         * methods related to a control's constructor if necessary.
         * @param {plat.Control} control The Control to dispose.
         */
        Control.dispose = function (control) {
            var ctrl = control;
            if (isNull(ctrl)) {
                return;
            }
            else if (!isUndefined(ctrl.templateControl)) {
                AttributeControl.dispose(ctrl);
                return;
            }
            else if (ctrl.hasOwnContext) {
                ui.ViewControl.dispose(ctrl);
                return;
            }
            else if (ctrl.controls) {
                ui.TemplateControl.dispose(ctrl);
                return;
            }
            if (isFunction(control.dispose)) {
                control.dispose();
            }
            Control.removeEventListeners(control);
            Control._ContextManager.dispose(control);
            control.element = null;
            Control.removeParent(control);
            if (control.__injectable__type === __STATIC) {
                var injector = controlInjectors[control.type];
                register.control(control.type, control.constructor, injector.dependencies, true);
            }
        };
        /**
         * Splices a control from its parent's controls list. Sets the control's parent
         * to null.
         * @param {plat.Control} control The control whose parent will be removed.
         */
        Control.removeParent = function (control) {
            if (isNull(control)) {
                return;
            }
            var parent = control.parent;
            if (isNull(parent)) {
                return;
            }
            var controls = parent.controls || [], index = controls.indexOf(control);
            if (index !== -1) {
                controls.splice(index, 1);
            }
            control.parent = null;
        };
        /**
         * Removes all event listeners for a control with the given uid.
         * @param {plat.Control} control The control having its event listeners removed.
         */
        Control.removeEventListeners = function (control) {
            if (isNull(control)) {
                return;
            }
            var removeListeners = Control.__eventListeners, uid = control.uid;
            var listeners = removeListeners[uid];
            if (isArray(listeners)) {
                var index = listeners.length;
                while (index-- > 0) {
                    listeners[index]();
                }
                deleteProperty(removeListeners, uid);
            }
        };
        /**
         * Returns a new instance of Control.
         */
        Control.getInstance = function () {
            return new Control();
        };
        /**
         * Adds a function to remove an event listener for the control specified
         * by its uid.
         * @param {string} uid The uid of the control associated with the remove function.
         * @param {plat.IRemoveListener} listener The remove function to add.
         */
        Control.__addRemoveListener = function (uid, listener) {
            var removeListeners = Control.__eventListeners;
            if (isArray(removeListeners[uid])) {
                removeListeners[uid].push(listener);
                return;
            }
            removeListeners[uid] = [listener];
        };
        /**
         * Removes a IRemoveListener from a control's listeners.
         * @param {string} uid The uid of the control associated with the remove function.
         * @param {plat.IRemoveListener} listener The remove function to add.
         */
        Control.__spliceRemoveListener = function (uid, listener) {
            var removeListeners = Control.__eventListeners, controlListeners = removeListeners[uid];
            if (isArray(controlListeners)) {
                var index = controlListeners.indexOf(listener);
                if (index === -1) {
                    return;
                }
                controlListeners.splice(index, 1);
            }
        };
        /**
         * Gets controls that have a specific key/value string pair.
         * @param {plat.Control} control The at which to start searching for key/value pairs.
         * @param {string} key The key to search for on all the controls in the tree.
         * @param {string} value The expected value used to find similar controls.
         */
        Control.__getControls = function (control, key, value) {
            var controls = [], root = Control.getRootControl(control), child;
            if (!isNull(root) && root[key] === value) {
                controls.push(root);
            }
            var children = root.controls;
            if (isNull(children)) {
                return controls;
            }
            var queue = [].concat(children);
            while (queue.length > 0) {
                child = queue.shift();
                if (child[key] === value) {
                    controls.push(child);
                }
                if (isNull(child.controls)) {
                    continue;
                }
                queue = queue.concat(child.controls);
            }
            return controls;
        };
        /**
         * The initialize event method for a control. In this method a control should initialize all the necessary
         * variables. This method is typically only necessary for view controls. If a control does not implement
         * IBaseViewControl then it is not safe to access, observe, or modify
         * the context property in this method. A view control should call services/set context in this method in
         * order to fire the loaded event. No control will be loaded until the view control has specified a context.
         */
        Control.prototype.initialize = function () { };
        /**
         * The loaded event method for a control. This event is fired after a control has been loaded,
         * meaning all of its children have also been loaded and initial DOM has been created and populated. It is now
         * safe for all controls to access, observe, and modify the context property.
         */
        Control.prototype.loaded = function () { };
        /**
         * Retrieves all the controls with the specified name.
         * @param {string} name The string name with which to populate the returned controls array.
         */
        Control.prototype.getControlsByName = function (name) {
            return Control.__getControls(this, 'name', name);
        };
        Control.prototype.getControlsByType = function (type) {
            if (isString(type)) {
                return Control.__getControls(this, 'type', type);
            }
            return Control.__getControls(this, 'constructor', type);
        };
        Control.prototype.addEventListener = function (element, type, listener, useCapture) {
            if (!isFunction(listener)) {
                this._log.warn('"Control.addEventListener" must take a function as the third argument.');
                return noop;
            }
            listener = listener.bind(this);
            var removeListener = this.dom.addEventListener(element, type, listener, useCapture), uid = this.uid;
            Control.__addRemoveListener(uid, removeListener);
            return function () {
                removeListener();
                Control.__spliceRemoveListener(uid, removeListener);
            };
        };
        Control.prototype.observe = function (listener, identifier) {
            var _this = this;
            var control = isObject(this.context) ? this : this.parent, root = Control.getRootControl(control);
            if (isNull(control)) {
                return noop;
            }
            else if (isNull(control.absoluteContextPath)) {
                this._log.warn('Should not call plat.Control.observe prior to the control being loaded');
                return noop;
            }
            var absoluteIdentifier;
            if (isEmpty(identifier)) {
                absoluteIdentifier = control.absoluteContextPath;
            }
            else if (isString(identifier)) {
                var identifierExpression = (Control._parser || acquire(__Parser)).parse(identifier), identifiers = identifierExpression.identifiers;
                if (identifiers.length > 1) {
                    this._log.warn('Only a single identifier can be observed when calling the function plat.Control.observe');
                }
                var expression = identifierExpression.identifiers[0];
                if (expression[0] === '@') {
                    var split = expression.split('.'), start = split.shift().slice(1), join = split.length > 0 ? ('.' + split.join('.')) : '';
                    if (start === __ROOT_CONTEXT_RESOURCE) {
                        absoluteIdentifier = __CONTEXT + join;
                    }
                    else if (start === __CONTEXT_RESOURCE) {
                        absoluteIdentifier = control.absoluteContextPath + join;
                    }
                    else {
                        absoluteIdentifier = control.absoluteContextPath + '.' + expression;
                    }
                }
                else {
                    absoluteIdentifier = control.absoluteContextPath + '.' + expression;
                }
            }
            else {
                absoluteIdentifier = control.absoluteContextPath + '.' + identifier;
            }
            var _ContextManager = Control._ContextManager || acquire(__ContextManagerStatic), contextManager = _ContextManager.getManager(root);
            return contextManager.observe(absoluteIdentifier, {
                listener: function (newValue, oldValue) {
                    listener.call(_this, newValue, oldValue, identifier);
                },
                uid: this.uid
            });
        };
        Control.prototype.observeArray = function (listener, identifier) {
            var control = isObject(this.context) ? this : this.parent, context = control.context;
            if (isNull(control) || !isObject(context)) {
                return noop;
            }
            var array, absoluteIdentifier;
            if (isEmpty(identifier)) {
                array = context;
                absoluteIdentifier = control.absoluteContextPath;
            }
            else if (isString(identifier)) {
                var identifierExpression = (Control._parser || acquire(__Parser)).parse(identifier);
                array = identifierExpression.evaluate(context);
                absoluteIdentifier = control.absoluteContextPath + '.' + identifierExpression.identifiers[0];
            }
            else {
                array = context[identifier];
                absoluteIdentifier = control.absoluteContextPath + '.' + identifier;
            }
            if (!isArray(array)) {
                return noop;
            }
            var listenerIsFunction = isFunction(listener);
            if (!listenerIsFunction) {
                return noop;
            }
            listener = listener.bind(this);
            var ContextManager = Control._ContextManager || acquire(__ContextManagerStatic), contextManager = ContextManager.getManager(Control.getRootControl(control)), uid = this.uid, callback = function (changes) {
                listener(changes, identifier);
            }, removeListener = contextManager.observeArrayMutation(uid, callback, absoluteIdentifier, array, null), removeCallback = contextManager.observe(absoluteIdentifier, {
                listener: function (newValue, oldValue) {
                    removeListener();
                    removeListener = contextManager
                        .observeArrayMutation(uid, callback, absoluteIdentifier, newValue, oldValue);
                },
                uid: uid
            });
            return function () {
                removeListener();
                removeCallback();
            };
        };
        Control.prototype.observeExpression = function (listener, expression) {
            var _this = this;
            if (isEmpty(expression)) {
                return noop;
            }
            if (isString(expression)) {
                expression = (Control._parser || acquire(__Parser)).parse(expression);
            }
            else if (!isFunction(expression.evaluate)) {
                return noop;
            }
            var control = !isNull(this.resources) ?
                this :
                this.parent;
            if (isNull(control) || !isString(control.absoluteContextPath)) {
                return noop;
            }
            var aliases = expression.aliases, alias, length = aliases.length, resources = {}, resourceObj, ContextManager = Control._ContextManager || acquire(__ContextManagerStatic), getManager = ContextManager.getManager, TemplateControl = ui.TemplateControl, findResource = TemplateControl.findResource, evaluateExpression = TemplateControl.evaluateExpression, type, i;
            for (i = 0; i < length; ++i) {
                alias = aliases[i];
                resourceObj = findResource(control, alias);
                if (!isNull(resourceObj)) {
                    type = resourceObj.resource.type;
                    if (type === __OBSERVABLE_RESOURCE || type === __LITERAL_RESOURCE) {
                        resources[alias] = getManager(resourceObj.control);
                    }
                }
            }
            var identifiers = expression.identifiers, contextManager = getManager(Control.getRootControl(control)), identifier, split = [], topIdentifier, absoluteContextPath = control.absoluteContextPath, absolutePath = absoluteContextPath + '.', managers = {};
            length = identifiers.length;
            for (i = 0; i < length; ++i) {
                identifier = identifiers[i];
                split = identifier.split('.');
                topIdentifier = split[0];
                if (identifier[0] === '@') {
                    alias = topIdentifier.slice(1);
                    if (alias === __CONTEXT_RESOURCE) {
                        managers[absoluteContextPath + identifier.replace(topIdentifier, '')] = contextManager;
                    }
                    else if (alias === __ROOT_CONTEXT_RESOURCE) {
                        managers[identifier.replace(topIdentifier, 'context')] = contextManager;
                    }
                    else {
                        identifier = identifier.replace(topIdentifier, 'resources.' + alias + '.value');
                        if (!isNull(resources[alias])) {
                            managers[identifier] = resources[alias];
                        }
                    }
                    continue;
                }
                managers[absolutePath + identifier] = contextManager;
            }
            identifiers = Object.keys(managers);
            length = identifiers.length;
            var oldValue = evaluateExpression(expression, control), listeners = [], uid = this.uid, observableListener = function () {
                var value = evaluateExpression(expression, control);
                listener.call(_this, value, oldValue, expression.expression);
                oldValue = value;
            };
            for (i = 0; i < length; ++i) {
                identifier = identifiers[i];
                listeners.push(managers[identifier].observe(identifier, {
                    uid: uid,
                    listener: observableListener
                }));
            }
            return function () {
                var length = listeners.length;
                for (var i_1 = 0; i_1 < length; ++i_1) {
                    listeners[i_1]();
                }
            };
        };
        Control.prototype.evaluateExpression = function (expression, aliases) {
            return ui.TemplateControl.evaluateExpression(expression, this.parent, aliases);
        };
        /**
         * Finds the first instance of the specified property
         * in the parent control chain. Returns undefined if not found.
         * @param {string} property The property identifer
         */
        Control.prototype.findProperty = function (property) {
            var control = this, expression = (Control._parser || acquire(__Parser)).parse(property), value;
            while (!isNull(control)) {
                value = expression.evaluate(control);
                if (!isNull(value)) {
                    return {
                        expresssion: expression,
                        control: control,
                        value: value
                    };
                }
                control = control.parent;
            }
        };
        Control.prototype.dispatchEvent = function (name, direction) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            var manager = Control._EventManager || acquire(__EventManagerStatic);
            if (!manager.hasDirection(direction)) {
                if (!isUndefined(direction)) {
                    args.unshift(direction);
                }
                direction = manager.UP;
            }
            var sender = this;
            if (!isNull(sender.templateControl)) {
                sender = sender.templateControl;
            }
            manager.dispatch(name, sender, direction, args);
        };
        /**
         * Registers a listener for a DispatchEvent. The listener will be called when a
         * DispatchEvent is propagating over the control. Any number of listeners can exist
         * for a single event name.
         * @param {string} name The name of the event, cooinciding with the DispatchEvent name.
         * @param {(ev: plat.events.DispatchEvent, ...args: Array<any>) => void} listener The method called when the
         * DispatchEvent is fired.
         */
        Control.prototype.on = function (name, listener) {
            var _EventManager = Control._EventManager || acquire(__EventManagerStatic);
            return _EventManager.on(this.uid, name, listener, this);
        };
        /**
         * The dispose event is called when a control is being removed from memory. A control should release
         * all of the memory it is using, including DOM event and property listeners.
         */
        Control.prototype.dispose = function () { };
        /**
         * An object containing all controls' registered event listeners.
         */
        Control.__eventListeners = {};
        return Control;
    }());
    plat_1.Control = Control;
    /**
     */
    function IControlFactory(_parser, _ContextManager, _EventManager, _Promise, _dom, _log) {
        Control._parser = _parser;
        Control._ContextManager = _ContextManager;
        Control._EventManager = _EventManager;
        Control._Promise = _Promise;
        Control._dom = _dom;
        Control._log = _log;
        return Control;
    }
    plat_1.IControlFactory = IControlFactory;
    register.injectable(__ControlFactory, IControlFactory, [
        __Parser,
        __ContextManagerStatic,
        __EventManagerStatic,
        __Promise,
        __Dom,
        __Log
    ], __FACTORY);
    /**
     * A type of control that can be used as an attribute but will
     * not be used to add, remove, or modify DOM.
     */
    var AttributeControl = (function (_super) {
        __extends(AttributeControl, _super);
        function AttributeControl() {
            _super.apply(this, arguments);
            /**
             * Specifies the TemplateControl associated with this
             * control's element. Can be null if no TemplateControl
             * exists.
             */
            this.templateControl = null;
        }
        /**
         * Method for disposing an attribute control. Removes any
         * necessary objects from the control.
         * @param {plat.AttributeControl} control The AttributeControl to dispose.
         */
        AttributeControl.dispose = function (control) {
            deleteProperty(control, 'templateControl');
            Control.dispose(control);
        };
        /**
         * Returns a new instance of AttributeControl.
         */
        AttributeControl.getInstance = function () {
            return new AttributeControl();
        };
        return AttributeControl;
    }(Control));
    plat_1.AttributeControl = AttributeControl;
    /**
     */
    function IAttributeControlFactory() {
        return AttributeControl;
    }
    plat_1.IAttributeControlFactory = IAttributeControlFactory;
    register.injectable(__AttributeControlFactory, IAttributeControlFactory, null, __FACTORY);
    /**
     * Holds all the classes and interfaces related to UI components for platypus.
     */
    var ui;
    (function (ui) {
        /**
         * The base control for any control that affects the UI. They provide properties for the control to use
         * to manage its body HTML.
         */
        var TemplateControl = (function (_super) {
            __extends(TemplateControl, _super);
            function TemplateControl() {
                _super.apply(this, arguments);
                /**
                 * By default TemplateControls have a priority of 100.
                 */
                this.priority = 100;
                /**
                 * The context of an TemplateControl, used for inheritance and data-binding.
                 */
                this.context = null;
                /**
                 * Specifies the absolute path from where the context was created to this Control's context.
                 * Used by the ContextManager for maintaining context parity
                 * (e.g. 'context.childContextProperty.grandChildContextProperty').
                 */
                this.absoluteContextPath = null;
                /**
                 * Flag indicating whether or not the TemplateControl defines the context property.
                 */
                this.hasOwnContext = false;
                /**
                 * Allows a TemplateControl to either swap its element with another element (e.g. plat-select),
                 * or replace its element altogether. If null or empty string, the element will be removed from the DOM, and the
                 * childNodes of the element will be in its place. In addition, when the element is placed startNode and endNode Comments
                 * are created, and the childNodes are added to the elementNodes property on the control. The replaceWith
                 * property can be any property that works with document.createElement(). If the control's element had
                 * attributes (as well as attribute Controls), those attributes will be carried to the swapped element. The default
                 * replaceWith is 'any,' meaning it will default to a 'div' in the case that the control type is used as the
                 * element's nodename (e.g. `<plat-foreach plat-context="..."></plat-foreach>`), but will maintain whatever element type
                 * is used otherwise (e.g. `<tr plat-control="plat-foreach" plat-context="..."></tr>`).
                 */
                this.replaceWith = 'any';
            }
            TemplateControl.evaluateExpression = function (expression, control, aliases) {
                if (isEmpty(expression)) {
                    return expression;
                }
                if (isString(expression)) {
                    expression = TemplateControl._parser.parse(expression);
                }
                else if (!isFunction(expression.evaluate)) {
                    return expression;
                }
                if (isNull(control)) {
                    return expression.evaluate(null, aliases);
                }
                if (expression.aliases.length > 0) {
                    aliases = TemplateControl.getResources(control, expression.aliases, aliases);
                    if (isEmpty(aliases)) {
                        return;
                    }
                }
                return expression.evaluate(control.context, aliases);
            };
            /**
             * Given a control and Array of aliases, finds the associated resources and builds a context object containing
             * the values. Returns the object.
             * @param {plat.ui.TemplateControl} control The control used as the starting point for finding resources.
             * @param {Array<string>} aliases An array of aliases to search for.
             * @param {IObject<any>} resources? An optional resources object to extend, if no resources object is passed in a
             * new one will be created.
             */
            TemplateControl.getResources = function (control, aliases, resources) {
                if (isNull(control)) {
                    return {};
                }
                var length = aliases.length, alias, resource, resourceObj, cache = TemplateControl.__resourceCache[control.uid];
                if (isNull(cache)) {
                    cache = TemplateControl.__resourceCache[control.uid] = {};
                }
                resources = resources || {};
                for (var i = 0; i < length; ++i) {
                    alias = aliases[i];
                    if (alias[0] === '@') {
                        alias = alias.slice(1);
                    }
                    if (alias === __CONTEXT_RESOURCE) {
                        resources[alias] = control.context;
                        continue;
                    }
                    else if (alias === __ROOT_CONTEXT_RESOURCE) {
                        resources[alias] = Control.getRootControl(control).context;
                        continue;
                    }
                    if (!isNull(resources[alias])) {
                        continue;
                    }
                    else if (!isNull(cache[alias])) {
                        var resourceControl = cache[alias].control, controlResources = resourceControl.resources;
                        if (isNull(controlResources)) {
                            resourceObj = TemplateControl.findResource(control, alias);
                        }
                        else {
                            resourceObj = {
                                control: resourceControl,
                                resource: controlResources[alias]
                            };
                        }
                    }
                    else {
                        resourceObj = TemplateControl.findResource(control, alias);
                    }
                    if (isNull(resourceObj)) {
                        if (control.type.indexOf(__COMPILED) !== -1) {
                            continue;
                        }
                        TemplateControl._log.warn('Resource alias: ' + alias + ' is not defined.');
                        continue;
                    }
                    cache[alias] = resourceObj;
                    resource = resourceObj.resource;
                    resources[alias] = isNull(resource) ? resource : resource.value;
                }
                return resources;
            };
            /**
             * Starts at a control and searches up its parent chain for a particular resource alias.
             * If the resource is found, it will be returned along with the control instance on which
             * the resource was found.
             * @param {plat.ui.TemplateControl} control The control on which to start searching for the resource alias.
             * @param {string} alias The alias to search for.
             */
            TemplateControl.findResource = function (control, alias) {
                var resource;
                if (isNull(control) || isNull(control.resources) || !isString(alias) || isEmpty(alias)) {
                    return;
                }
                if (alias[0] === '@') {
                    alias = alias.slice(1);
                }
                var isRootContext = alias === __ROOT_CONTEXT_RESOURCE;
                if (isRootContext || alias === __CONTEXT_RESOURCE || alias === __CONTROL_RESOURCE) {
                    if (isRootContext) {
                        control = Control.getRootControl(control);
                    }
                    resource = (control.resources || {})[alias];
                    if (isNull(resource)) {
                        return;
                    }
                    return {
                        resource: resource,
                        control: control
                    };
                }
                while (!isNull(control)) {
                    resource = (control.resources || {})[alias];
                    if (!isNull(resource)) {
                        return {
                            resource: resource,
                            control: control
                        };
                    }
                    control = control.parent;
                }
            };
            /**
             * Recursively disposes a control and its children.
             * @param {plat.ui.TemplateControl} control A control to dispose.
             */
            TemplateControl.dispose = function (control) {
                if (isNull(control)) {
                    return;
                }
                var uid = control.uid, childControls = control.controls, controls = (childControls && childControls.slice(0)), ContextManager = Control._ContextManager, define = ContextManager.defineProperty;
                if (!isNull(controls)) {
                    var length_8 = controls.length - 1;
                    for (var i = length_8; i >= 0; --i) {
                        Control.dispose(controls[i]);
                    }
                }
                if (isFunction(control.dispose)) {
                    control.dispose();
                }
                Control.removeEventListeners(control);
                TemplateControl.removeElement(control);
                TemplateControl._ResourcesFactory.dispose(control);
                TemplateControl._BindableTemplatesFactory.dispose(control);
                deleteProperty(TemplateControl.__resourceCache, control.uid);
                ContextManager.dispose(control);
                events.EventManager.dispose(control.uid);
                TemplateControl._managerCache.remove(uid);
                Control.removeParent(control);
                define(control, __RESOURCES, null, true, true, true);
                control.attributes = null;
                control.bindableTemplates = null;
                control.controls = [];
                control.root = null;
                control.innerTemplate = null;
                if (control.__injectable__type === __STATIC) {
                    var injector = controlInjectors[control.type];
                    register.control(control.type, control.constructor, injector.dependencies, true);
                }
            };
            /**
             * Loads the control tree depth first (visit children, then visit self).
             * @param {plat.ui.TemplateControl} control The control serving as the root control to load.
             */
            TemplateControl.loadControl = function (control) {
                var children = control.controls, length = children.length, child;
                for (var i = 0; i < length; ++i) {
                    child = children[i];
                    if (!isNull(child.controls)) {
                        TemplateControl.loadControl(child);
                    }
                    else {
                        child.loaded();
                    }
                }
                control.loaded();
            };
            /**
             * Notifies a control that its context has been changed by
             * calling the `control.contextChanged` method if it exists.
             * @param {plat.ui.TemplateControl} control The control whose context changed.
             * @param {any} newValue The new value of the control's context.
             * @param {any} oldValue The old value of the control's context.
             */
            TemplateControl.contextChanged = function (control, newValue, oldValue) {
                control.context = newValue;
                TemplateControl.setContextResources(control);
                if (isFunction(control.contextChanged)) {
                    control.contextChanged(newValue, oldValue);
                }
            };
            /**
             * Sets the `context` resource value on a TemplateControl. If the control specifies
             * hasOwnContext as true, the `rootContext` resource value will be set.
             * @param {plat.ui.TemplateControl} control The control whose context resources will be set.
             */
            TemplateControl.setContextResources = function (control) {
                var value = control.context;
                if (isNull(control.resources)) {
                    control.resources = TemplateControl._ResourcesFactory.getInstance();
                    control.resources.initialize(control);
                }
                if (control.hasOwnContext) {
                    if (isNull(control.resources.rootContext)) {
                        control.resources.add({
                            root: {
                                type: __OBSERVABLE_RESOURCE,
                                value: value
                            }
                        });
                    }
                    else {
                        control.resources.rootContext.value = value;
                    }
                }
                if (isNull(control.resources.context)) {
                    control.resources.add({
                        context: {
                            type: __OBSERVABLE_RESOURCE,
                            value: value
                        }
                    });
                    return;
                }
                control.resources.context.value = value;
            };
            /**
             * Completely removes a control's element from its parentNode.
             * @param {plat.ui.TemplateControl} control The control whose element should be removed.
             */
            TemplateControl.removeElement = function (control) {
                if (isNull(control)) {
                    return;
                }
                var element = control.element, parentNode;
                if (control.replaceWith === null ||
                    control.replaceWith === '' ||
                    isDocumentFragment(element)) {
                    removeAll(control.startNode, control.endNode);
                    control.elementNodes = control.startNode = control.endNode = null;
                    return;
                }
                else if (isNull(element)) {
                    return;
                }
                parentNode = element.parentNode;
                if (!isNull(parentNode)) {
                    parentNode.removeChild(element);
                }
                control.element = null;
            };
            /**
             * Sets the absoluteContextPath read-only property on a control.
             * @param {plat.ui.TemplateControl} control The control on which to set the absoluteContextPath.
             * @param {string} path The path to set on the control.
             */
            TemplateControl.setAbsoluteContextPath = function (control, path) {
                Control._ContextManager.defineGetter(control, 'absoluteContextPath', path, false, true);
            };
            /**
             * Determines the template for a control by searching for a templateUrl,
             * using the provided templateUrl, or serializing the control's templateString.
             * @param {plat.ui.TemplateControl} control The control whose template is being determined.
             * @param {string} templateUrl? The potential template URL to use to grab the template.
             */
            TemplateControl.determineTemplate = function (control, templateUrl) {
                var templateCache = TemplateControl._templateCache, dom = control.dom, Promise = TemplateControl._Promise;
                if (!isNull(templateUrl)) {
                }
                else if (!isNull(control.templateUrl)) {
                    templateUrl = control.templateUrl;
                }
                else if (!isNull(control.templateString)) {
                    var type_1 = control.type;
                    return templateCache.read(type_1).catch(function (template) {
                        if (isNull(template)) {
                            template = control.templateString;
                        }
                        return templateCache.put(type_1, template);
                    });
                }
                else {
                    return Promise.reject(null);
                }
                return dom.getTemplate(templateUrl);
            };
            /**
             * Detaches a TemplateControl. Disposes its children,
             * but does not dispose the TemplateControl.
             * @param {plat.ui.TemplateControl} control The control to be detached.
             */
            TemplateControl.detach = function (control) {
                if (isNull(control) || isNull(control.controls)) {
                    return;
                }
                var controls = control.controls.slice(0), length = controls.length;
                for (var i = 0; i < length; ++i) {
                    Control.dispose(controls[i]);
                }
                Control.removeEventListeners(control);
                TemplateControl.removeElement(control);
                TemplateControl._ResourcesFactory.dispose(control, true);
                deleteProperty(TemplateControl.__resourceCache, control.uid);
                Control._ContextManager.dispose(control);
                events.EventManager.dispose(control.uid);
                TemplateControl._managerCache.remove(control.uid);
                Control.removeParent(control);
                control.controls = [];
                control.attributes = null;
            };
            /**
             * Returns a new instance of TemplateControl.
             */
            TemplateControl.getInstance = function () {
                return new TemplateControl();
            };
            /**
             * This event is fired when an TemplateControl's context property
             * is changed by an ancestor control.
             * @param {any} newValue? The new value of the context.
             * @param {any} oldValue The old value of the context.
             */
            TemplateControl.prototype.contextChanged = function (newValue, oldValue) { };
            /**
             * A method called for TemplateControls to set their template.
             * During this method a control should ready its template for compilation. Whatever is in the control's
             * element (or elementNodes if replaceWith is implemented) after this method's execution will be compiled
             * and appear on the DOM.
             */
            TemplateControl.prototype.setTemplate = function () { };
            /**
             * Finds the associated resources and builds a context object containing
             * the values.
             * @param {Array<string>} aliases An array of aliases to search for.
             * @param {IObject<any>} resources? An optional resources object to extend,
             * if no resources object is passed in a new one will be created.
             */
            TemplateControl.prototype.getResources = function (aliases, resources) {
                return TemplateControl.getResources(this, aliases, resources);
            };
            /**
             * Starts at a control and searches up its parent chain for a particular resource alias.
             * If the resource is found, it will be returned along with the control instance on which
             * the resource was found.
             * @param {string} alias The alias to search for.
             */
            TemplateControl.prototype.findResource = function (alias) {
                return TemplateControl.findResource(this, alias);
            };
            TemplateControl.prototype.evaluateExpression = function (expression, context) {
                return TemplateControl.evaluateExpression(expression, this, context);
            };
            /**
             * An object for quickly retrieving previously accessed resources.
             */
            TemplateControl.__resourceCache = {};
            return TemplateControl;
        }(Control));
        ui.TemplateControl = TemplateControl;
        /**
         */
        function ITemplateControlFactory(_ResourcesFactory, _BindableTemplatesFactory, _managerCache, _templateCache, _parser, _http, _Promise, _log) {
            TemplateControl._ResourcesFactory = _ResourcesFactory;
            TemplateControl._BindableTemplatesFactory = _BindableTemplatesFactory;
            TemplateControl._managerCache = _managerCache;
            TemplateControl._templateCache = _templateCache;
            TemplateControl._parser = _parser;
            TemplateControl._http = _http;
            TemplateControl._Promise = _Promise;
            TemplateControl._log = _log;
            return TemplateControl;
        }
        ui.ITemplateControlFactory = ITemplateControlFactory;
        register.injectable(__TemplateControlFactory, ITemplateControlFactory, [
            __ResourcesFactory,
            __BindableTemplatesFactory,
            __ManagerCache,
            __TemplateCache,
            __Parser,
            __Http,
            __Promise,
            __Log
        ], __FACTORY);
        register.injectable(__TemplateControlInstance, TemplateControl, null, __INSTANCE);
        /**
         * An extended TemplateControl that allows for the binding of a value to
         * another listening control (e.g. plat-bind control).
         */
        var BindControl = (function (_super) {
            __extends(BindControl, _super);
            function BindControl() {
                _super.apply(this, arguments);
                /**
                 * Set to 120, higher than `plat-bind` to ensure that BinControls load
                 * prior to the `plat-bind`.
                 */
                this.priority = 120;
                /**
                 * The set of functions added externally that listens
                 * for property changes.
                 */
                this._listeners = [];
            }
            /**
             * Adds a listener to be called when the bindable property changes.
             * @param {plat.IPropertyChangedListener<any>} listener The function that acts as a listener.
             */
            BindControl.prototype.onInput = function (listener) {
                var listeners = this._listeners;
                listeners.push(listener);
                return function () {
                    var index = listeners.indexOf(listener);
                    if (index === -1) {
                        return;
                    }
                    listeners.splice(index, 1);
                };
            };
            /**
             * A function that allows this control to observe both the bound property itself as well as
             * potential child properties if being bound to an object.
             * @param {plat.observable.IImplementTwoWayBinding} binder The control that facilitates the
             * databinding.
             */
            BindControl.prototype.observeProperties = function (binder) { };
            /**
             * A function that signifies when this control's bindable property has changed.
             * @param {any} newValue The new value of the property after the change.
             * @param {any} oldValue? The old value of the property prior to the change.
             */
            BindControl.prototype.inputChanged = function (newValue, oldValue) {
                if (newValue === oldValue) {
                    return;
                }
                var listeners = this._listeners, length = listeners.length;
                for (var i = 0; i < length; ++i) {
                    listeners[i](newValue, oldValue);
                }
            };
            /**
             * Removes references to the listeners
             * defined externally.
             */
            BindControl.prototype.dispose = function () {
                this._listeners = [];
            };
            return BindControl;
        }(TemplateControl));
        ui.BindControl = BindControl;
        /**
         * A control used in a Viewport for page navigation. The
         * control has navigation events that are called when navigating to and from the control. A ViewControl
         * represents a routing component on a page (i.e. a piece of a page that is associated with a particular route).
         * It has the ability to initiate, approve, and reject navigation to/from itself. A ViewControl also has the
         * ability to inject a Router and configure sub-navigation.
         */
        var ViewControl = (function (_super) {
            __extends(ViewControl, _super);
            function ViewControl() {
                _super.apply(this, arguments);
                /**
                 * Specifies that this control will have its own context, and it should not inherit a context.
                 */
                this.hasOwnContext = true;
            }
            /**
             * Recursively disposes a ViewControl and its children.
             * @param {plat.ui.ViewControl} control A control to dispose.
             */
            ViewControl.dispose = function (control) {
                TemplateControl.dispose(control);
            };
            /**
             * Returns a new instance of a ViewControl.
             */
            ViewControl.getInstance = function () {
                return new ViewControl();
            };
            /**
             * Allows a ViewControl to asynchronously decide if the app is able to navigate away from the
             * current view. A possible use of this method might be to popup a confirmation modal. You can
             * return a boolean or IThenable<boolean> to accept/reject navigation.
             * A word of caution, this is a navigation-blocking function. It is best to avoid long-running functions.
             */
            ViewControl.prototype.canNavigateFrom = function () { };
            /**
             * Allows a ViewControl to asynchronously decide if it can be navigated to with the given parameters/query.
             * You can return a boolean or IThenable<boolean> to accept/reject navigation.
             * A word of caution, this is a navigation-blocking function. It is best to avoid long-running functions.
             */
            ViewControl.prototype.canNavigateTo = function (parameters, query) { };
            /**
             * This method is called when the ViewControl is going out of scope as a result of a navigation.
             */
            ViewControl.prototype.navigatingFrom = function () { };
            /**
             * This method is called when the ViewControl has come into scope as a result of navigation. It can
             * receive the route parameters and query in order to set its context.
             */
            ViewControl.prototype.navigatedTo = function (parameters, query) { };
            return ViewControl;
        }(TemplateControl));
        ui.ViewControl = ViewControl;
        /**
         * An extensible class dealing with the creation, deletion, and modification
         * of DOM.
         */
        var Dom = (function () {
            function Dom() {
                /**
                 * Reference to the DomEvents injectable.
                 */
                this._domEvents = acquire(__DomEvents);
            }
            Dom.prototype.addEventListener = function (element, type, listener, useCapture) {
                return this._domEvents.addEventListener(element, type, listener, useCapture);
            };
            Dom.prototype.appendChildren = function (nodeList, root) {
                return appendChildren(nodeList, root);
            };
            Dom.prototype.cloneChildren = function (nodeList, root) {
                return appendChildren(nodeList, root, true);
            };
            /**
             * Clears a DOM Node by removing all of its childNodes.
             * @param {Node} node The DOM Node to clear.
             */
            Dom.prototype.clearNode = function (node) {
                return clearNode(node);
            };
            Dom.prototype.clearNodeBlock = function (nodeList, parent) {
                return clearNodeBlock(nodeList, parent);
            };
            /**
             * Sets the innerHTML of a Node. Can take in a Node rather than an Element
             * because it does not use innerHTML on the passed-in Node (it appends its
             * childNodes).
             * @param {Node} node The Node to set innerHTML.
             * @param {string} html HTML string to be put inside the node.
             */
            Dom.prototype.setInnerHtml = function (node, html) {
                return setInnerHtml(node, html);
            };
            Dom.prototype.insertBefore = function (parent, nodes, endNode) {
                return insertBefore(parent, nodes, endNode);
            };
            /**
             * Takes the child nodes of the given node and places them above the node
             * in the DOM. Then removes the given node.
             * @param {Node} node The Node to replace.
             */
            Dom.prototype.replace = function (node) {
                return replace(node);
            };
            Dom.prototype.replaceWith = function (node, newNode) {
                return replaceWith(node, newNode);
            };
            /**
             * Takes in a string representing innerHTML and returns a DocumentFragment
             * containing the serialized DOM.
             * @param {string} html The DOM string.
             */
            Dom.prototype.serializeHtml = function (html) {
                return serializeHtml(html);
            };
            /**
             * Takes in a startNode and endNode, each having the same parentNode.
             * Removes every node in between the startNode.  If endNode is not specified,
             * DOM will be removed until the end of the parentNode's children.
             * @param {Node} startNode The starting node, which will not be removed.
             * @param {Node} endNode The ending node, which will not be removed.
             */
            Dom.prototype.removeBetween = function (startNode, endNode) {
                return removeBetween(startNode, endNode);
            };
            /**
             * Takes in a startNode and endNode, each having the same parentNode.
             * Removes every node in between the startNode and endNode as well as
             * the startNode and the endNode.  If endNode is not specified, DOM
             * will be removed until the end of the parentNode's children.
             * @param {Node} startNode The first node to remove.
             * @param {Node} endNode The last node to remove.
             */
            Dom.prototype.removeAll = function (startNode, endNode) {
                return removeAll(startNode, endNode);
            };
            /**
             * Adds a class or multiple classes to the specified element.
             * @param {Element} element The element to which the class name is being added.
             * @param {string} className The class name or space delimited class names to add to the element.
             */
            Dom.prototype.addClass = function (element, className) {
                return addClass(element, className);
            };
            /**
             * Removes a class or multiple classes from the specified element.
             * @param {Element} element The element from which the class name is being removed.
             * @param {string} className The class name or space delimited class names to remove from the element.
             */
            Dom.prototype.removeClass = function (element, className) {
                return removeClass(element, className);
            };
            /**
             * Toggles a class or multiple classes from the specified element.
             * @param {Element} element The element on which the class name is being toggled.
             * @param {string} className The class name or space delimited class names to toggle on the element.
             */
            Dom.prototype.toggleClass = function (element, className) {
                return toggleClass(element, className);
            };
            /**
             * Replaces a single class with another class.
             * @param {Element} element The element on which the class name is being toggled.
             * @param {string} oldClass The class name being replaced.
             * @param {string} newClass The class name doing the replacing.
             */
            Dom.prototype.replaceClass = function (element, oldClass, newClass) {
                return replaceClass(element, oldClass, newClass);
            };
            /**
             * Returns whether or not an element has a particular class or classes assigned to it.
             * @param {Element} element The element on which the class name is being checked.
             * @param {string} className The class name or space delimited class names to check on the element.
             */
            Dom.prototype.hasClass = function (element, className) {
                return hasClass(element, className);
            };
            /**
             * Retrieves and serializes HTML from an HTML template file using ajax. Will facilitate caching the template
             * as well.
             * @param {string} templateUrl The url where the HTML template is stored.
             */
            Dom.prototype.getTemplate = function (templateUrl) {
                return getTemplate(templateUrl);
            };
            /**
             * Inspects the Element and resolves when the Element is present in the DOM body.
             * @param {() => void} cb A callback that will fire when the element is present in the DOM body.
             * @param {Element} element The element whose presence is being inspected.
             */
            Dom.prototype.whenPresent = function (cb, element) {
                return whenPresent(cb, element);
            };
            /**
             * Inspects the Element and resolves when the Element is visible in the DOM.
             * @param {() => void} cb A callback that will fire when the element is visible in the DOM.
             * @param {Element} element The element whose visibility is being inspected.
             */
            Dom.prototype.whenVisible = function (cb, element) {
                return whenVisible(cb, element);
            };
            Dom._inject = {
                _domEvents: __DomEvents
            };
            return Dom;
        }());
        ui.Dom = Dom;
        register.injectable(__Dom, Dom);
        /**
         * The class which provides a way for TemplateControls to bind a template
         * to a context. Useful for narrowing context without needing another
         * TemplateControl. In addition, this object provides a performance increase because
         * it will only compile the template once. This object is also useful when a
         * TemplateControls expects multiple configuration templates in its innerHTML. It can
         * separate those templates and reuse them accordingly.
         */
        var BindableTemplates = (function () {
            function BindableTemplates() {
                /**
                 * Reference to the IResourcesFactory injectable.
                 */
                this._ResourcesFactory = acquire(__ResourcesFactory);
                /**
                 * Reference to the IControlFactory injectable.
                 */
                this._ControlFactory = acquire(__ControlFactory);
                /**
                 * Reference to the ITemplateControlFactory injectable.
                 */
                this._TemplateControlFactory = acquire(__TemplateControlFactory);
                /**
                 * Reference to the IContextManagerStatic injectable.
                 */
                this._ContextManager = acquire(__ContextManagerStatic);
                /**
                 * Reference to the IPromise injectable.
                 */
                this._Promise = acquire(__Promise);
                /**
                 * Reference to a cache injectable that stores ElementManagers.
                 */
                this._managerCache = acquire(__ManagerCache);
                /**
                 * Reference to the Document injectable.
                 */
                this._document = acquire(__Document);
                /**
                 * Reference to the IElementManagerFactory injectable.
                 */
                this._ElementManagerFactory = acquire(__ElementManagerFactory);
                /**
                 * Reference to the BindableTemplatesFactory injectable.
                 */
                this._BindableTemplatesFactory = acquire(__BindableTemplatesFactory);
                /**
                 * Reference to the Log injectable.
                 */
                this._log = acquire(__Log);
                /**
                 * Stores promises that resolve to all the compiled templates for this object, ready to be bound to a data context.
                 * All created templates are DocumentFragments, allowing an TemplateControl to
                 * easily insert the template into the DOM (without iterating over childNodes).
                 */
                this.templates = {};
                /**
                 * A keyed cache of ElementManagers that represent the roots of compiled templates
                 * created by this instance.
                 */
                this.cache = {};
                /**
                 * A collection of all the controls created while compiling an added template. Useful during disposal.
                 */
                this.__compiledControls = [];
            }
            /**
             * Creates a new instance of BindableTemplates and returns it. If a BindableTemplates is
             * passed in, it will use the properties on the original BindableTemplates.
             * @param {plat.ui.TemplateControl} control The TemplateControl
             * containing the new BindableTemplates object, used for data
             * context inheritance for templates.
             * @param {plat.ui.BindableTemplates} original? An optional BindableTemplates
             * object to copy.
             */
            BindableTemplates.create = function (control, original) {
                var bindableTemplates = new BindableTemplates();
                bindableTemplates.control = control;
                if (!isNull(original)) {
                    bindableTemplates.templates = original.templates;
                    bindableTemplates.cache = original.cache;
                }
                return bindableTemplates;
            };
            /**
             * Clears the memory being held by control's bindableTemplates.
             * @param {plat.ui.TemplateControl} control The control whose bindableTemplates will be disposed.
             */
            BindableTemplates.dispose = function (control) {
                if (isNull(control)) {
                    return;
                }
                var instance = control.bindableTemplates;
                if (isNull(instance) || !isFunction(instance.dispose)) {
                    return;
                }
                instance.dispose();
            };
            /**
             * Determines whether or not a control was created using bindableTemplates.
             * @param {plat.ui.TemplateControl} control The potential bound control.
             */
            BindableTemplates.isBoundControl = function (control) {
                if (isNull(control)) {
                    return false;
                }
                var parent = control.parent;
                if (isNull(parent)) {
                    return false;
                }
                return control.type.indexOf(parent.type + __BOUND_PREFIX) === 0;
            };
            BindableTemplates.prototype.once = function (template, relativeIdentifier, resources) {
                var _this = this;
                var fragment;
                if (isNull(template)) {
                    return this._Promise.resolve(this._document.createDocumentFragment());
                }
                else if (isString(template)) {
                    fragment = serializeHtml(template);
                }
                else if (isDocumentFragment(template)) {
                    fragment = template;
                }
                else {
                    fragment = this._document.createDocumentFragment();
                    if (isNode(template)) {
                        fragment.appendChild(template);
                    }
                    else if (isArrayLike(template)) {
                        appendChildren(template, fragment);
                    }
                    else {
                        return this._Promise.resolve(fragment);
                    }
                }
                if (!(isNull(relativeIdentifier) || isNumber(relativeIdentifier) || isString(relativeIdentifier))) {
                    this._log.warn(this.control.type + ' cannot bind template with relativeIdentifier: ' + relativeIdentifier +
                        '. Identifier must be either a string or number');
                    return;
                }
                var parent = this.control, controlManager = this._managerCache.read(parent.uid), manager = this._ElementManagerFactory.getInstance(), control = this._createBoundControl('', fragment, relativeIdentifier, resources), nodeMap = this._createNodeMap(control, fragment, relativeIdentifier);
                parent.controls.push(control);
                controlManager.children = [];
                manager.initialize(nodeMap, controlManager);
                manager.setUiControlTemplate();
                return manager.fulfillAndLoad().then(function () {
                    var _document = _this._document;
                    control.startNode = fragment.insertBefore(_document.createComment(control.type + __START_NODE), fragment.firstChild);
                    control.endNode = fragment.insertBefore(_document.createComment(control.type + __END_NODE), null);
                    return fragment;
                });
            };
            BindableTemplates.prototype.bind = function (key, relativeIdentifier, resources) {
                return this._bind(key, relativeIdentifier, resources);
            };
            BindableTemplates.prototype.add = function (key, template, overwrite) {
                if (isEmpty(key)) {
                    this._log.debug(this.control.type + ' must use a valid key to add a template to BindableTemplates.');
                    return;
                }
                var templatePromise = this.templates[key];
                if (!isNull(templatePromise) && !overwrite) {
                    return;
                }
                if (isNull(template)) {
                    return;
                }
                else if (isString(template)) {
                    this._compile(key, serializeHtml(template));
                    return;
                }
                else if (isDocumentFragment(template)) {
                    this._compile(key, template);
                    return;
                }
                var fragment = this._document.createDocumentFragment();
                if (isNode(template)) {
                    fragment.appendChild(template);
                }
                else if (isArrayLike(template)) {
                    appendChildren(template, fragment);
                }
                else {
                    return;
                }
                this._compile(key, fragment);
            };
            BindableTemplates.prototype.replace = function (index, key, relativeIdentifier, resources) {
                var control = this.control.controls[index];
                if (!BindableTemplates.isBoundControl(control)) {
                    this._log.warn('The child control of ' + this.control.type + ' at the specified index: ' + index +
                        ' is not a bound control and thus cannot be replaced by BindableTemplates.');
                    return this._Promise.resolve([]);
                }
                var endNode = control.endNode;
                if (!(isNode(endNode) && isNode(endNode.parentNode))) {
                    this._log.warn('The child control of ' + this.control.type + ' at the specified index: ' + index +
                        ' had either no placeholding comment nodes or its comment nodes had no parent and thus ' +
                        'cannot be replaced by BindableTemplates.');
                    return this._Promise.resolve([]);
                }
                return this._bind(key, relativeIdentifier, resources, index);
            };
            /**
             * Clears the memory being held by this instance.
             */
            BindableTemplates.prototype.dispose = function () {
                var dispose = this._TemplateControlFactory.dispose, compiledControls = this.__compiledControls, length = compiledControls.length;
                for (var i = 0; i < length; ++i) {
                    dispose(compiledControls[i]);
                }
                this.__compiledControls = [];
                this.control = null;
                this.cache = {};
                this.templates = {};
            };
            /**
             * Method for linking a template to a data context and returning a clone of the template,
             * with all new Controls created if the template contains controls. If no data context
             * is specified, it will be inherited.
             * @param {string} key The key used to retrieve the template.
             * @param {string} relativeIdentifier? The identifier string relative to this control's context
             * (e.g. 'foo.bar.baz' would signify the object this.context.foo.bar.baz). This is the
             * most efficient way of specifying context, else the framework has to search for the
             * object.
             * @param {plat.IObject<plat.IResource>} resources? An object used as the resources for any top-level
             * controls created in the template.
             * @param {number} index? An optional index only to be used if the newly bound template is intended to
             * replace an existing Control in the child controls Array and its element in the DOM.
             */
            BindableTemplates.prototype._bind = function (key, relativeIdentifier, resources, index) {
                var _this = this;
                var templatePromise = this.templates[key], noIndex = isNull(index);
                if (isNull(templatePromise)) {
                    this._log.error(new Error(this.control.type + ' cannot bind template, no template stored with key: ' + key));
                    return;
                }
                if (!(isNull(relativeIdentifier) || isNumber(relativeIdentifier) || isString(relativeIdentifier))) {
                    this._log.warn(this.control.type + ' cannot bind template with relativeIdentifier: ' + relativeIdentifier +
                        '. Identifier must be either a string or number');
                    return;
                }
                templatePromise = templatePromise.then(function (result) {
                    var template = result.cloneNode(true), control = _this._createBoundControl(key, template, relativeIdentifier, resources), nodeMap = _this._createNodeMap(control, template, relativeIdentifier);
                    if (noIndex) {
                        _this.control.controls.push(control);
                    }
                    return _this._bindTemplate(key, nodeMap);
                });
                if (!noIndex) {
                    return templatePromise.then(function (fragment) {
                        var childNodes = Array.prototype.slice.call(fragment.childNodes), oldControl = _this.control.controls[index], endNode = oldControl.endNode, parentNode = endNode.parentNode, nextSibling = endNode.nextSibling;
                        _this._TemplateControlFactory.dispose(oldControl);
                        parentNode.insertBefore(fragment, nextSibling);
                        return childNodes;
                    }).then(null, function (error) {
                        postpone(function () {
                            if (isString(error)) {
                                error = new Error(error);
                            }
                            _this._log.error(error);
                        });
                        return _this._document.createDocumentFragment();
                    });
                }
                return templatePromise.then(null, function (error) {
                    postpone(function () {
                        if (isString(error)) {
                            error = new Error(error);
                        }
                        _this._log.error(error);
                    });
                    return _this._document.createDocumentFragment();
                });
            };
            /**
             * Creates the template's bound control and INodeMap and initiates
             * the binding of the INodeMap for a cloned template.
             * @param {string} key The template key.
             * @param {plat.processing.INodeMap} nodeMap The node map to bind.
             */
            BindableTemplates.prototype._bindTemplate = function (key, nodeMap) {
                var _this = this;
                var control = nodeMap.uiControlNode.control, disposed = false, dispose = isFunction(control.dispose) ? control.dispose.bind(control) : noop;
                control.dispose = function () {
                    disposed = true;
                    dispose();
                    control.dispose = dispose;
                };
                return this._bindNodeMap(key, nodeMap).then(function () {
                    var _document = _this._document, template = nodeMap.element;
                    if (disposed) {
                        return _document.createDocumentFragment();
                    }
                    control.startNode = template.insertBefore(_document.createComment(control.type + __START_NODE), template.firstChild);
                    control.endNode = template.insertBefore(_document.createComment(control.type + __END_NODE), null);
                    return template;
                }, function (error) {
                    postpone(function () {
                        if (isString(error)) {
                            error = new Error(error);
                        }
                        _this._log.error(error);
                    });
                    return null;
                });
            };
            /**
             * Clones the compiled ElementManager using the newly created
             * INodeMap and binds and loads this control's
             * ElementManager.
             * @param {string} key The template key used to grab the ElementManager.
             * @param {plat.processing.INodeMap} nodeMap The node map to bind.
             */
            BindableTemplates.prototype._bindNodeMap = function (key, nodeMap) {
                var manager = this.cache[key], child = nodeMap.uiControlNode.control, template = nodeMap.element, _managerCache = this._managerCache;
                manager.clone(template, _managerCache.read(this.control.uid), nodeMap);
                return _managerCache.read(child.uid).bindAndLoad();
            };
            /**
             * Creates the template's compiled, bound control and INodeMap and initiates
             * the compilation of the template.
             * @param {string} key The template key.
             * @param {DocumentFragment} template The HTML template being bound.
             */
            BindableTemplates.prototype._compile = function (key, template) {
                var control = this._createBoundControl(key + __COMPILED, template), nodeMap = this._createNodeMap(control, template);
                this.__compiledControls.push(control);
                this._compileNodeMap(control, nodeMap, key);
            };
            /**
             * Instantiates a new ElementManager for the root of this
             * template and resolves any asynchronous url templates within the template being compiled.
             * @param {plat.ui.TemplateControl} control The newly created control used to bind the template.
             * @param {plat.processing.INodeMap} nodeMap The newly created node map to bind.
             * @param {string} key The template key.
             */
            BindableTemplates.prototype._compileNodeMap = function (control, nodeMap, key) {
                var _this = this;
                var manager = this._ElementManagerFactory.getInstance(), promises = [];
                manager.isClone = true;
                manager.initialize(nodeMap, null);
                manager.setUiControlTemplate();
                this.cache[key] = manager;
                promises.push(manager.fulfillTemplate());
                this.templates[key] = this._Promise.all(promises).then(function () {
                    var element = nodeMap.element, clone = element.cloneNode(true), _document = _this._document, startNode = control.startNode = _document.createComment(control.type + __START_NODE), endNode = control.endNode = _document.createComment(control.type + __END_NODE);
                    element.insertBefore(startNode, element.firstChild);
                    element.insertBefore(endNode, null);
                    return clone;
                });
            };
            /**
             * Creates an INodeMap for either a template being compiled or a
             * template being bound.
             * @param {plat.ui.TemplateControl} uiControl The newly created control used to bind the template.
             * @param {Node} template The template being compiled.
             * @param {string} childContext? A potential child context string identifier.
             */
            BindableTemplates.prototype._createNodeMap = function (uiControl, template, childContext) {
                return {
                    element: template,
                    attributes: {},
                    nodes: [],
                    childContext: childContext,
                    uiControlNode: {
                        control: uiControl,
                        nodeName: uiControl.type,
                        expressions: [],
                        injector: null
                    }
                };
            };
            /**
             * Creates a TemplateControl used for binding either a template being compiled
             * or a template being bound.
             * @param {string} key The template key.
             * @param {DocumentFragment} template The template being compiled or being bound.
             * @param {plat.IObject<plat.ui.IResource>} resources? A set of resources to add to the control used to
             * compile/bind this template.
             */
            BindableTemplates.prototype._createBoundControl = function (key, template, childContext, resources) {
                var _TemplateControlFactory = this._TemplateControlFactory, control = _TemplateControlFactory.getInstance(), _ResourcesFactory = this._ResourcesFactory, parent = this.control, compiledManager = this.cache[key], isCompiled = isObject(compiledManager), _resources = _ResourcesFactory.getInstance();
                if (isCompiled) {
                    var compiledControl = compiledManager.getUiControl();
                    _resources.initialize(control, compiledControl.resources);
                    _resources.add(resources);
                }
                else {
                    _resources.initialize(control, resources);
                }
                control.resources = _resources;
                _ResourcesFactory.addControlResources(control);
                control.bindableTemplates = this._BindableTemplatesFactory.create(control, parent.bindableTemplates);
                control.parent = parent;
                control.controls = [];
                control.element = template;
                control.type = parent.type + __BOUND_PREFIX + key;
                control.root = this._ControlFactory.getRootControl(control);
                if (isCompiled) {
                    var contextManager = this._ContextManager.getManager(control.root);
                    control.absoluteContextPath = parent.absoluteContextPath || __CONTEXT;
                    if (!isNull(childContext)) {
                        control.absoluteContextPath += '.' + childContext;
                    }
                    control.context = contextManager.getContext(control.absoluteContextPath.split('.'), false);
                }
                return control;
            };
            return BindableTemplates;
        }());
        ui.BindableTemplates = BindableTemplates;
        /**
         */
        function IBindableTemplatesFactory() {
            return BindableTemplates;
        }
        ui.IBindableTemplatesFactory = IBindableTemplatesFactory;
        register.injectable(__BindableTemplatesFactory, IBindableTemplatesFactory, null, __FACTORY);
        /**
         * The class that stores the information about an Element's attributes (NamedNodeMap).
         * Methods are implemented to allow you to observe for changes on an attribute.
         */
        var Attributes = (function () {
            function Attributes() {
                /**
                 * The set of functions added externally that listens
                 * for attribute changes.
                 */
                this.__listeners = {};
            }
            Attributes.getInstance = function () {
                return new Attributes();
            };
            /**
             * Initializes this instance with a Control and the camelCased
             * attribute properties and their values.
             * @param {plat.Control} control The function that acts as a listener.
             * @param {plat.IObject<string>} attributes The camelCased attribute properties and their values.
             */
            Attributes.prototype.initialize = function (control, attributes) {
                this.__control = control;
                var keys = Object.keys(attributes), attributeListeners = this.__listeners, key, length = keys.length;
                for (var i = 0; i < length; ++i) {
                    key = keys[i];
                    this[key] = attributes[key];
                    attributeListeners[key] = [];
                }
            };
            /**
             * Provides a way to observe an attribute for changes.
             * @param {plat.IPropertyChangedListener} listener The listener function to be called when the attribute changes.
             * @param {string} key The attribute to observe for changes (e.g. 'src').
             */
            Attributes.prototype.observe = function (listener, key) {
                var listeners = this.__listeners[camelCase(key)];
                if (isNull(listeners)) {
                    return noop;
                }
                listener = listener.bind(this.__control);
                listeners.push(listener);
                return function () {
                    var index = listeners.indexOf(listener);
                    if (index === -1) {
                        return;
                    }
                    listeners.splice(index, 1);
                };
            };
            /**
             * Used to show an attribute has been changed and forces listeners to be fired.
             * @param {string} key The attribute being observed for changes (e.g. 'src').
             * @param {any} newValue The new value of the attribute.
             * @param {any} oldValue The previous value of the attribute.
             */
            Attributes.prototype._attributeChanged = function (key, newValue, oldValue) {
                var listeners = this.__listeners[camelCase(key)], length = listeners.length;
                for (var i = 0; i < length; ++i) {
                    listeners[i](newValue, oldValue);
                }
            };
            return Attributes;
        }());
        ui.Attributes = Attributes;
        function IAttributesFactory() {
            return Attributes;
        }
        ui.IAttributesFactory = IAttributesFactory;
        register.injectable(__AttributesInstance, Attributes, null, __INSTANCE);
        register.injectable(__AttributesFactory, IAttributesFactory, null, __FACTORY);
        /**
         * Resources are used for providing aliases to use in markup expressions. They
         * are particularly useful when trying to access properties outside of the
         * current context, as well as reassigning context at any point in an app.
         */
        var Resources = (function () {
            function Resources() {
                /**
                 * An object representing all of the currently available resources.
                 */
                this.__resources = {};
                /**
                 * Whether this Resources instance has been bound yet.
                 */
                this.__bound = false;
            }
            /**
             * Populates an IResource value if necessary, and adds it to the given
             * control's resources.
             * @param {plat.ui.TemplateControl} control The control for which to create a resource.
             * @param {plat.ui.IResource} resource The object used to set the resource values.
             */
            Resources.create = function (control, resource) {
                if (isNull(resource)) {
                    return resource;
                }
                var value;
                switch (resource.type.toLowerCase()) {
                    case __INJECTABLE_RESOURCE:
                        var injector = injectableInjectors[resource.value];
                        if (!isNull(injector)) {
                            resource.value = injector.inject();
                        }
                        break;
                    case __OBSERVABLE_RESOURCE:
                        Resources._observeResource(control, resource);
                        break;
                    case __OBJECT_RESOURCE:
                        value = resource.value;
                        if (isString(value)) {
                            resource.value = control.evaluateExpression(value);
                        }
                        break;
                    case __LITERAL_RESOURCE:
                        break;
                    case __FUNCTION_RESOURCE:
                        value = resource.value;
                        if (isString(value)) {
                            value = control[value];
                            if (isFunction(value)) {
                                resource.value = value.bind(control);
                            }
                            else {
                                Resources._log.warn('Attempted to create a "function" ' +
                                    'type Resource, but the function ' + value + 'cannot be found on your control.');
                                resource.value = noop;
                            }
                        }
                        break;
                }
                return resource;
            };
            /**
             * Adds resource aliases for `@control` and `@context`. The resources are
             * aliases for the control instance and the control.context.
             * @param {plat.ui.TemplateControl} control The control on which to add the resources.
             */
            Resources.addControlResources = function (control) {
                control.resources.add({
                    context: {
                        value: control.context,
                        type: __OBSERVABLE_RESOURCE
                    },
                    control: {
                        value: control,
                        type: __OBJECT_RESOURCE
                    }
                });
                if (control.hasOwnContext) {
                    Resources.__addRoot(control);
                }
            };
            Resources.bindResources = function (resourcesInstance) {
                var resources = resourcesInstance.__resources;
                if (isNull(resources)) {
                    return;
                }
                var control = resourcesInstance.__controlInstance, aliases = Object.keys(resources), controlResources = Resources.__controlResources, length = aliases.length, alias;
                for (var i = 0; i < length; ++i) {
                    alias = aliases[i];
                    if (controlResources[alias] === true) {
                        continue;
                    }
                    resourcesInstance[alias] = resources[alias] = Resources.create(control, resourcesInstance[alias]);
                }
                resourcesInstance.__bound = true;
            };
            /**
             * Disposes a resource instance, removing its reference
             * from a control and breaking references to all resource
             * objects.
             * @param {plat.ui.TemplateControl} control The control whose resources will be disposed.
             * @param {boolean} persist? Whether or not to persist a resource object post
             * disposal or set it to null.
             */
            Resources.dispose = function (control, persist) {
                var resources = control.resources;
                if (isNull(resources)) {
                    return;
                }
                var keys = Object.keys(resources.__resources), key, length = keys.length, define = Resources._ContextManager.defineProperty, resource;
                for (var i = 0; i < length; ++i) {
                    key = keys[i];
                    resource = resources[key];
                    if (!isNull(resource) && (resource.type === __OBSERVABLE_RESOURCE || resource.type === __LITERAL_RESOURCE)) {
                        define(resources, key, persist ? _clone(resource, true) : null, true, true, true);
                    }
                }
                Resources._removeListeners(resources.__controlInstance);
            };
            /**
             * Parses a resources Element (`<plat-resources>`) and creates
             * an IObject<IResource> with its element children.
             * @param {Element} element The resources element to parse.
             */
            Resources.parseElement = function (element) {
                var children = Array.prototype.slice.call(element.children), child, _regex = Resources._regex, whiteSpaceRegex = _regex.whiteSpaceRegex, quotationRegex = _regex.quotationRegex, resources = {}, resource, types = Resources.__resourceTypes, attrs, attr, nodeName, text;
                while (children.length > 0) {
                    child = children.pop();
                    nodeName = child.nodeName.toLowerCase();
                    if (!types[nodeName]) {
                        continue;
                    }
                    attrs = child.attributes;
                    resource = {};
                    attr = attrs.getNamedItem(__ALIAS);
                    if (isNull(attr)) {
                        continue;
                    }
                    resource.alias = attr.value;
                    text = child.textContent.replace(whiteSpaceRegex, '$1');
                    if (isEmpty(text)) {
                        continue;
                    }
                    resource.value = (nodeName === __INJECTABLE_RESOURCE || nodeName === __LITERAL_RESOURCE) ?
                        text.replace(quotationRegex, '') : text;
                    resource.type = nodeName;
                    resources[resource.alias] = resource;
                }
                return resources;
            };
            /**
             * Returns a new instance with type Resources.
             */
            Resources.getInstance = function () {
                return new Resources();
            };
            /**
             * Observes the resource if the type is `observable`.
             * @param {plat.ui.TemplateControl} control The control in charge of the observable resource.
             * @param {plat.ui.IResource} resource The resource to observe.
             */
            Resources._observeResource = function (control, resource) {
                var value = resource.value, uid = control.uid, removeListeners = Resources.__observableResourceRemoveListeners[uid];
                if (isNull(removeListeners)) {
                    removeListeners = Resources.__observableResourceRemoveListeners[uid] = [];
                }
                if (isString(value)) {
                    if (!isNull(resource.initialValue)) {
                        value = resource.initialValue;
                    }
                    else {
                        resource.initialValue = value;
                    }
                    var listener = control.observeExpression(function (newValue) {
                        resource.value = newValue;
                    }, value);
                    resource.value = control.evaluateExpression(value);
                    removeListeners.push(listener);
                }
            };
            /**
             * Removes observable resource listeners for a specified control.
             * @param {plat.ui.TemplateControl} control The control whose listeners are being removed.
             */
            Resources._removeListeners = function (control) {
                if (isNull(control)) {
                    return;
                }
                var uid = control.uid, removeListeners = Resources.__observableResourceRemoveListeners[uid];
                if (isArray(removeListeners)) {
                    var length_9 = removeListeners.length;
                    for (var i = 0; i < length_9; ++i) {
                        removeListeners[i]();
                    }
                }
                deleteProperty(Resources.__observableResourceRemoveListeners, uid);
            };
            /**
             * Adds a `@root` alias and `@rootContext` to a control, specifying that it contains the root
             * and root context. Root controls are generally the root ViewControl.
             * @param {plat.ui.TemplateControl} control The root control.
             */
            Resources.__addRoot = function (control) {
                control.resources.add({
                    root: {
                        value: control,
                        type: __OBJECT_RESOURCE,
                        alias: __ROOT_RESOURCE
                    },
                    rootContext: {
                        value: control.context,
                        type: __OBSERVABLE_RESOURCE,
                        alias: __ROOT_CONTEXT_RESOURCE
                    }
                });
            };
            Resources.prototype.initialize = function (controlInstance, resources) {
                this.__controlInstance = controlInstance;
                if (isNull(resources)) {
                    return;
                }
                else if (isNode(resources)) {
                    resources = Resources.parseElement(resources);
                }
                else if (isObject(resources.resources)) {
                    resources = resources.resources;
                }
                this.__resources = resources;
                var keys = Object.keys(resources), key, length = keys.length;
                for (var i = 0; i < length; ++i) {
                    key = keys[i];
                    this[key] = resources[key];
                }
            };
            Resources.prototype.add = function (resources) {
                if (isNull(resources)) {
                    return;
                }
                else if (isNode(resources)) {
                    resources = Resources.parseElement(resources);
                }
                var keys = Object.keys(resources), length = keys.length, resource, control = this.__controlInstance, bound = this.__bound, key, create = Resources.create;
                for (var i = 0; i < length; ++i) {
                    key = keys[i];
                    resource = resources[key];
                    resource.alias = key;
                    this[key] = this.__resources[key] = bound ? create(control, resource) : resource;
                }
            };
            /**
             * The injectable resource type token.
             */
            Resources.INJECTABLE = __INJECTABLE_RESOURCE;
            /**
             * The object resource type token. Objects should be literal objects and won't be observed.
             */
            Resources.OBJECT = __OBJECT_RESOURCE;
            /**
             * The observable resource type token. Observable resources are expected to be
             * string identifiers and will be observed.
             */
            Resources.OBSERVABLE = __OBSERVABLE_RESOURCE;
            /**
             * The literal resource type token. Literals will be observed on the resource object,
             * so if you change `resources.<alias>.value` it will be reflected everywhere it is
             * observed.
             */
            Resources.LITERAL = __LITERAL_RESOURCE;
            /**
             * The function resource type token.
             */
            Resources.FUNCTION = __FUNCTION_RESOURCE;
            /**
             * An object consisting of keyed arrays containing functions for removing observation listeners.
             */
            Resources.__observableResourceRemoveListeners = {};
            return Resources;
        }());
        ui.Resources = Resources;
        /**
         */
        function IResourcesFactory(_ContextManager, _regex, _log) {
            Resources._ContextManager = _ContextManager;
            Resources._regex = _regex;
            Resources._log = _log;
            var controlResources = {}, resourceTypes = {};
            controlResources[__CONTROL_RESOURCE] = controlResources[__CONTEXT_RESOURCE] = controlResources[__ROOT_RESOURCE] = controlResources[__ROOT_CONTEXT_RESOURCE] = true;
            resourceTypes[__INJECTABLE_RESOURCE] = resourceTypes[__OBJECT_RESOURCE] = resourceTypes[__OBSERVABLE_RESOURCE] = resourceTypes[__FUNCTION_RESOURCE] = resourceTypes[__LITERAL_RESOURCE] = true;
            Resources.__controlResources = controlResources;
            Resources.__resourceTypes = resourceTypes;
            return Resources;
        }
        ui.IResourcesFactory = IResourcesFactory;
        register.injectable(__ResourcesFactory, IResourcesFactory, [
            __ContextManagerStatic,
            __Regex,
            __Log
        ], __FACTORY);
        register.injectable(__ResourcesInstance, Resources, null, __INSTANCE);
        /**
         * A class for managing DOM event registration and handling.
         */
        var DomEvents = (function () {
            /**
             * Retrieve the type of touch events for this browser and create the default gesture style.
             */
            function DomEvents() {
                /**
                 * An object containing the event types for all of the
                 * supported gestures.
                 */
                this._gestures = DomEvents.gestures;
                /**
                 * The version of android, or -1 if not on android.
                 */
                this._androidVersion = isUndefined(this._compat.ANDROID) ? -1 : this._compat.ANDROID;
                /**
                 * Whether or not we're on Android 4.4.x or below.
                 */
                this._android44orBelow = this._androidVersion > -1 && Math.floor(this._androidVersion / 10) <= 44;
                /**
                 * Whether or not the user is using mouse when touch events are present.
                 */
                this._inMouse = false;
                /**
                 * An object with keyed subscribers that keep track of all of the
                 * events registered on a particular element.
                 */
                this._subscribers = {};
                /**
                 * An object containing the number of currently active
                 * events of each base type.
                 */
                this._gestureCount = {
                    $tap: 0,
                    $dbltap: 0,
                    $hold: 0,
                    $release: 0,
                    $swipe: 0,
                    $track: 0,
                    $trackend: 0
                };
                /**
                 * Whether or not the user moved while in touch.
                 */
                this.__hasMoved = false;
                /**
                 * Whether or not their is a registered "release" event.
                 */
                this.__hasRelease = false;
                /**
                 * Whether or not we should be detecting move events.
                 */
                this.__detectingMove = false;
                /**
                 * The current tap count to help distinguish single from double taps.
                 */
                this.__tapCount = 0;
                /**
                 * The total number of touches on the screen.
                 */
                this.__touchCount = 0;
                /**
                 * A function to remove a deferred tap given the case that a tap delay was needed for
                 * something such as a double tap to zoom feature.
                 */
                this.__cancelDeferredTap = noop;
                /**
                 * A function for removing a deferred hold event.
                 */
                this.__cancelDeferredHold = noop;
                /**
                 * A regular expressino for determining a "cancel" event.
                 */
                this.__cancelRegex = /cancel/i;
                /**
                 * A regular expressino for determining a pointer end event.
                 */
                this.__pointerEndRegex = /up|cancel/i;
                /**
                 * Whether or not there are any swipe subscribers for the current target during touch move events.
                 */
                this.__haveSwipeSubscribers = false;
                /**
                 * A function to stop listening for blur events on the currently focused element.
                 */
                this.__blurRemover = noop;
                /**
                 * A set of flags signifying whether we should ignore native events or not.
                 */
                this.__ignoreEvent = { mousedown: false, mouseup: false };
                /**
                 * A function with a bound context that prevents default and stops propagation for delayed or phantom clicks.
                 */
                this.__boundPreventDefaultClick = this.__preventDefaultClick.bind(this);
                /**
                 * A hash map for mapping custom events to standard events.
                 */
                this.__reverseMap = {};
                /**
                 * An object containing the number of currently active mapped touch
                 * events of each type.
                 */
                this.__mappedCount = {
                    $touchstart: 0,
                    $touchmove: 0,
                    $touchend: 0,
                    $touchcancel: 0
                };
                /**
                 * A hash of the current pointer touch points on the page.
                 */
                this.__pointerHash = {};
                /**
                 * An array containing all current pointer touch points on the page.
                 */
                this.__pointerEvents = [];
                /**
                 * A set of touch start, move, and end listeners to be place on the document.
                 */
                this.__listeners = {};
                this.__getTypes();
                this.initialize();
            }
            DomEvents.prototype.addEventListener = function (element, type, listener, useCapture) {
                var _this = this;
                var _compat = this._compat, mappedGestures = _compat.mappedEvents, mappedType = mappedGestures[type], mappingExists = !isNull(mappedType), mappedCount = this.__mappedCount, gestures = this._gestures, listenerRemoved = false;
                if (mappingExists) {
                    this.__reverseMap[mappedType] = type;
                    this.__registerElement(element, type);
                    mappedCount[type]++;
                    if (_compat.hasTouchEvents && !this.__cancelRegex.test(mappedType)) {
                        mappedType = mappedType
                            .replace('touch', 'mouse')
                            .replace('start', 'down')
                            .replace('end', 'up');
                        this.__reverseMap[mappedType] = type;
                    }
                }
                element.addEventListener(type, listener, useCapture);
                if (!isUndefined(element['on' + type]) || isUndefined(gestures[type]) || mappingExists) {
                    return function () {
                        if (listenerRemoved) {
                            return;
                        }
                        else if (mappingExists) {
                            if (mappedCount[type] > 0) {
                                mappedCount[type]--;
                            }
                            _this.__unregisterElement(element, type);
                        }
                        listenerRemoved = true;
                        element.removeEventListener(type, listener, useCapture);
                    };
                }
                var swipeGesture = gestures.$swipe, trackGesture = gestures.$track, countType = type;
                if (type.indexOf(trackGesture) !== -1) {
                    var trackend = gestures.$trackend;
                    countType = type === trackend ? trackend : trackGesture;
                }
                else if (type.indexOf(swipeGesture) !== -1) {
                    countType = swipeGesture;
                }
                this._gestureCount[countType]++;
                this.__registerElement(element, type);
                return function () {
                    if (listenerRemoved) {
                        return;
                    }
                    listenerRemoved = true;
                    _this.__removeEventListener(element, type, listener, useCapture);
                };
            };
            /**
             * If DomEvents is inactive, will initialize behavior and
             * begin listening for events.
             */
            DomEvents.prototype.initialize = function () {
                var isActive = this._isActive;
                if (isActive === true) {
                    // has already been initialized and was never disposed 
                    return;
                }
                this.__registerTypes();
                if (isNull(isActive)) {
                    this.__appendGestureStyle();
                }
                this._isActive = true;
            };
            /**
             * Stops listening for touch events and resets the DomEvents
             * instance.
             */
            DomEvents.prototype.dispose = function () {
                this.__unregisterTypes();
                this.__blurRemover();
                this.__blurRemover = noop;
                this._gestureCount = {
                    $tap: 0,
                    $dbltap: 0,
                    $hold: 0,
                    $release: 0,
                    $swipe: 0,
                    $track: 0,
                    $trackend: 0
                };
                this.__mappedCount = {
                    $touchstart: 0,
                    $touchmove: 0,
                    $touchend: 0,
                    $touchcancel: 0
                };
                this._isActive = false;
                this._subscribers = {};
                this.__pointerEvents = [];
                this.__pointerHash = {};
                this.__reverseMap = {};
                this.__ignoreEvent = { mousedown: false, mouseup: false };
                this.__tapCount = this.__touchCount = 0;
                this.__detectingMove = this.__hasMoved = this.__hasRelease = this.__haveSwipeSubscribers = false;
                this.__lastMoveEvent = this.__lastTouchDown = this.__lastTouchUp = null;
                this.__swipeOrigin = this.__capturedTarget = this.__focusedElement = this.__delayedClickRemover = null;
                this.__cancelDeferredHold = this.__cancelDeferredTap = noop;
            };
            /**
             * A listener for touch/mouse start events.
             * @param {plat.ui.IPointerEvent} ev The touch start event object.
             */
            DomEvents.prototype._onTouchStart = function (ev) {
                var _this = this;
                var eventType = ev.type;
                if (this.__ignoreEvent[eventType]) {
                    this.__ignoreEvent[eventType] = false;
                    this.__delayedClickRemover[eventType]();
                    if (ev.target !== this.__focusedElement) {
                        if (ev.cancelable === true) {
                            ev.preventDefault();
                        }
                        return false;
                    }
                    return true;
                }
                else if (this.__touchCount++ > 0) {
                    return true;
                }
                if (eventType !== 'mousedown') {
                    this._inTouch = true;
                }
                else if (this._inTouch === true) {
                    // return immediately if mouse event and currently in a touch 
                    ev.preventDefault();
                    return false;
                }
                else if (this._compat.hasTouchEvents) {
                    this._inMouse = true;
                }
                ev = this.__standardizeEventObject(ev);
                if (isNull(ev)) {
                    return true;
                }
                // set last move back to null and hasMoved to false 
                this.__lastMoveEvent = null;
                this.__hasMoved = false;
                var clientX = ev.clientX, clientY = ev.clientY, timeStamp = ev.timeStamp, target = ev.target, gestures = this._gestures;
                this.__lastTouchDown = {
                    _buttons: ev._buttons,
                    clientX: clientX,
                    clientY: clientY,
                    timeStamp: timeStamp,
                    target: target,
                    identifier: ev.identifier
                };
                this.__swipeOrigin = {
                    clientX: clientX,
                    clientY: clientY,
                    xTimestamp: timeStamp,
                    yTimestamp: timeStamp,
                    xTarget: target,
                    yTarget: target
                };
                if (this._android44orBelow) {
                    this.__haveSwipeSubscribers = this.__findFirstSubscribers(target, [gestures.$swipe, gestures.$swipedown, gestures.$swipeleft, gestures.$swiperight, gestures.$swipeup]).length > 0;
                }
                var gestureCount = this._gestureCount, noHolds = gestureCount.$hold <= 0, noRelease = gestureCount.$release <= 0, mappedCount = this.__mappedCount;
                // if any moving events registered, register move 
                if (eventType === 'touchstart' || mappedCount.$touchmove > 0 || gestureCount.$track > 0 ||
                    gestureCount.$trackend > 0 || gestureCount.$swipe > 0) {
                    this.__registerType(this._moveEvents);
                    this.__detectingMove = true;
                }
                // check mapped events 
                var mappedType = this.__reverseMap[eventType];
                if (mappedCount[mappedType] > 0) {
                    var mappedDomEvent = this.__findFirstSubscriber(ev.target, mappedType);
                    if (!isNull(mappedDomEvent)) {
                        mappedDomEvent.trigger(ev);
                    }
                }
                // return if no hold or release events are registered 
                if (noHolds && noRelease) {
                    return true;
                }
                var holdInterval = DomEvents.config.intervals.holdInterval, domEvent, subscribeFn, domEventFound = false;
                if (noHolds) {
                    this.__hasRelease = false;
                    this.__cancelDeferredHold = defer(function () {
                        _this.__hasRelease = true;
                    }, holdInterval);
                    return true;
                }
                else if (noRelease) {
                    domEvent = this.__findFirstSubscriber(ev.target, this._gestures.$hold);
                    if ((domEventFound = !isNull(domEvent))) {
                        subscribeFn = function () {
                            domEvent.trigger(ev);
                            _this.__cancelDeferredHold = noop;
                        };
                    }
                }
                else {
                    this.__hasRelease = false;
                    // has both hold and release events registered 
                    domEvent = this.__findFirstSubscriber(ev.target, this._gestures.$hold);
                    if ((domEventFound = !isNull(domEvent))) {
                        subscribeFn = function () {
                            domEvent.trigger(ev);
                            _this.__hasRelease = true;
                            _this.__cancelDeferredHold = noop;
                        };
                    }
                }
                // set timeout to fire the subscribeFn 
                if (domEventFound) {
                    this.__cancelDeferredHold = defer(subscribeFn, holdInterval);
                }
            };
            /**
             * A listener for touch/mouse move events.
             * @param {plat.ui.IPointerEvent} ev The touch move event object.
             */
            DomEvents.prototype._onTouchMove = function (ev) {
                // clear hold event 
                this.__cancelDeferredHold();
                this.__cancelDeferredHold = noop;
                var eventType = ev.type;
                // return immediately if there are multiple touches present, or 
                // if it is a mouse event and currently in a touch 
                if (this._inTouch === true && eventType === 'mousemove') {
                    return true;
                }
                var evt = this.__standardizeEventObject(ev);
                if (isNull(evt)) {
                    return true;
                }
                // check mapped events 
                var mappedType = this.__reverseMap[eventType];
                if (this.__mappedCount[mappedType] > 0) {
                    var mappedDomEvent = this.__findFirstSubscriber(ev.target, mappedType);
                    if (!isNull(mappedDomEvent)) {
                        mappedDomEvent.trigger(evt);
                    }
                }
                var gestureCount = this._gestureCount, noTracking = gestureCount.$track <= 0, noSwiping = gestureCount.$swipe <= 0, config = DomEvents.config, swipeOrigin = this.__swipeOrigin, x = evt.clientX, y = evt.clientY, minMove = this.__hasMoved ||
                    (this.__getDistance(swipeOrigin.clientX, x, swipeOrigin.clientY, y) >= config.distances.minScrollDistance);
                // if minimum distance not met 
                if (!minMove) {
                    return true;
                }
                this.__hasMoved = true;
                // if no moving events return 
                if (noTracking && noSwiping) {
                    return true;
                }
                var lastMove = this.__lastMoveEvent || swipeOrigin, direction = evt.direction = this.__getDirection(x - lastMove.clientX, y - lastMove.clientY);
                this.__handleOriginChange(direction);
                var dx = Math.abs(x - swipeOrigin.clientX), dy = Math.abs(y - swipeOrigin.clientY);
                evt.velocity = this.__getVelocity(dx, dy, evt.timeStamp - swipeOrigin.xTimestamp, evt.timeStamp - swipeOrigin.yTimestamp);
                if (!noSwiping && this._android44orBelow && this.__haveSwipeSubscribers) {
                    ev.preventDefault();
                }
                // if tracking events exist 
                if (!noTracking) {
                    this.__handleTrack(evt, ev);
                }
                this.__lastMoveEvent = evt;
            };
            /**
             * A listener for touch/mouse end events.
             * @param {plat.ui.IPointerEvent} ev The touch end event object.
             */
            DomEvents.prototype._onTouchEnd = function (ev) {
                var _this = this;
                var eventType = ev.type;
                if (this.__ignoreEvent[eventType]) {
                    this.__ignoreEvent[eventType] = false;
                    this.__delayedClickRemover[eventType]();
                    if (ev.target !== this.__focusedElement) {
                        if (ev.cancelable === true) {
                            ev.preventDefault();
                        }
                        postpone(function () {
                            var target = (_this.__lastTouchUp || {}).target;
                            if (_this._document.body.contains(target)) {
                                _this.__handleInput(target);
                            }
                        });
                        return false;
                    }
                    return true;
                }
                var hasMoved = this.__hasMoved, notMouseUp = eventType !== 'mouseup';
                if (this.__touchCount <= 0) {
                    this.__touchCount = 0;
                }
                else {
                    this.__touchCount--;
                }
                if (notMouseUp) {
                    // all non mouse cases 
                    if (eventType === 'touchend') {
                        // all to handle a strange issue when touch clicking certain types 
                        // of DOM elements 
                        if (hasMoved) {
                            // we check ev.cancelable in the END case in case of scrolling conditions 
                            if (ev.cancelable === true) {
                                ev.preventDefault();
                            }
                        }
                        else if (this._inTouch === true) {
                            // immediately handle the input depending on type for more native-like experience 
                            if (ev.target !== this.__focusedElement) {
                                if (this.__handleInput(ev.target) && ev.cancelable === true) {
                                    ev.preventDefault();
                                }
                            }
                        }
                        else {
                            if (ev.cancelable === true) {
                                ev.preventDefault();
                            }
                            this.__preventClickFromTouch();
                            return true;
                        }
                        this.__preventClickFromTouch();
                    }
                }
                else if (!isUndefined(this._inTouch)) {
                    if (!this._inMouse) {
                        // this is case where touchend fired and now 
                        // mouse end is also being fired 
                        if (ev.cancelable === true) {
                            ev.preventDefault();
                        }
                        return false;
                    }
                    this._inMouse = false;
                }
                // check for cancel event 
                if (this.__cancelRegex.test(eventType)) {
                    this.__handleCanceled(ev);
                    return true;
                }
                // standardizeEventObject creates touches 
                ev = this.__standardizeEventObject(ev);
                if (isNull(ev)) {
                    return true;
                }
                else if (notMouseUp) {
                    this._inTouch = false;
                }
                // check mapped events 
                var mappedType = this.__reverseMap[eventType];
                if (this.__mappedCount[mappedType] > 0) {
                    var mappedDomEvent = this.__findFirstSubscriber(ev.target, mappedType);
                    if (!isNull(mappedDomEvent)) {
                        mappedDomEvent.trigger(ev);
                    }
                }
                // additional check for mousedown/touchstart - mouseup/touchend inconsistencies 
                if (this.__touchCount > 0) {
                    this.__touchCount = ev.touches.length;
                }
                this.__clearTempStates();
                // handle release event 
                if (this.__hasRelease) {
                    this.__handleRelease(ev);
                }
                // handle swipe events 
                this.__handleSwipe();
                var config = DomEvents.config, intervals = config.intervals, touchEnd = ev.timeStamp, touchDown = this.__lastTouchDown;
                // if the user moved their finger (for scroll) we handle $trackend and return, 
                // else if they had their finger down too long to be considered a tap, we want to return 
                if (hasMoved) {
                    this.__handleTrackEnd(ev);
                    this.__tapCount = 0;
                    // clear captured target 
                    this.__capturedTarget = null;
                    return true;
                }
                else if (isNull(touchDown) || ((touchEnd - touchDown.timeStamp) > intervals.tapInterval)) {
                    this.__tapCount = 0;
                    // clear captured target 
                    this.__capturedTarget = null;
                    return true;
                }
                var lastTouchUp = this.__lastTouchUp, x = ev.clientX, y = ev.clientY;
                // check if can be a double tap event by checking number of taps, distance between taps, 
                // and time between taps 
                if (this.__tapCount > 0 &&
                    this.__getDistance(x, lastTouchUp.clientX, y, lastTouchUp.clientY) <= config.distances.maxDblTapDistance &&
                    ((touchEnd - lastTouchUp.timeStamp) <= intervals.dblTapInterval)) {
                    // handle dbltap events 
                    this.__handleDbltap(ev);
                }
                else {
                    this.__tapCount = 0;
                }
                // handle tap events 
                this.__handleTap(ev);
                this.__lastTouchUp = ev;
                // clear captured target 
                this.__capturedTarget = null;
            };
            /**
             * Clears all temporary states like move and hold events.
             */
            DomEvents.prototype.__clearTempStates = function () {
                // clear hold event 
                this.__cancelDeferredHold();
                this.__cancelDeferredHold = noop;
                if (this.__detectingMove) {
                    this.__unregisterType(this._moveEvents);
                    this.__detectingMove = false;
                }
            };
            /**
             * A function for resetting all values potentially modified during the touch event sequence.
             */
            DomEvents.prototype.__resetTouchEnd = function () {
                this.__tapCount = this.__touchCount = 0;
                this._inTouch = this.__hasRelease = false;
                this.__pointerHash = {};
                this.__pointerEvents = [];
                // clear captured target 
                this.__capturedTarget = null;
            };
            // gesture handling methods 
            /**
             * A function for handling when gestures are canceled via the Browser.
             * @param {plat.ui.IPointerEvent} ev The touch cancel event object.
             */
            DomEvents.prototype.__handleCanceled = function (ev) {
                var touches = ev.touches || this.__pointerEvents, index = this.__getTouchIndex(touches);
                ev = index >= 0 ? touches[index] : this.__standardizeEventObject(ev);
                this._inTouch = false;
                this.__clearTempStates();
                // check mapped events 
                var mappedType = this.__reverseMap[ev.type];
                if (this.__mappedCount[mappedType] > 0) {
                    var mappedDomEvent = this.__findFirstSubscriber(ev.target, mappedType);
                    if (!isNull(mappedDomEvent)) {
                        mappedDomEvent.trigger(ev);
                    }
                }
                if (this.__hasMoved) {
                    // Android 4.4.x fires touchcancel when the finger moves off an element that 
                    // is listening for touch events, so we should handle swipes here in that case. 
                    if (this._android44orBelow) {
                        this.__handleSwipe();
                    }
                    this.__handleTrackEnd(ev);
                }
                this.__resetTouchEnd();
            };
            /**
             * A function for handling and firing tap events.
             * @param {plat.ui.IPointerEvent} ev The touch end event object.
             */
            DomEvents.prototype.__handleTap = function (ev) {
                var _this = this;
                this.__tapCount++;
                if (this._gestureCount.$tap <= 0) {
                    return;
                }
                var gestures = this._gestures, domEvent = this.__findFirstSubscriber(ev.target, gestures.$tap);
                if (isNull(domEvent)) {
                    return;
                }
                // fire tap event immediately if no dbltap zoom delay 
                // or a mouse is being used 
                if (DomEvents.config.intervals.dblTapZoomDelay <= 0 ||
                    ev.pointerType === 'mouse' || ev.type === 'mouseup') {
                    ev._buttons = this.__lastTouchDown._buttons;
                    domEvent.trigger(ev);
                    return;
                }
                // defer for tap delay in case of something like desired 
                // dbltap zoom 
                this.__cancelDeferredTap = defer(function () {
                    ev._buttons = _this.__lastTouchDown._buttons;
                    domEvent.trigger(ev);
                    _this.__tapCount = 0;
                    _this.__cancelDeferredTap = noop;
                }, DomEvents.config.intervals.dblTapZoomDelay);
            };
            /**
             * A function for handling and firing double tap events.
             * @param {plat.ui.IPointerEvent} ev The touch end event object.
             */
            DomEvents.prototype.__handleDbltap = function (ev) {
                this.__tapCount = 0;
                this.__cancelDeferredTap();
                this.__cancelDeferredTap = noop;
                if (this._gestureCount.$dbltap <= 0) {
                    return;
                }
                var domEvent = this.__findFirstSubscriber(ev.target, this._gestures.$dbltap);
                if (isNull(domEvent)) {
                    return;
                }
                ev._buttons = this.__lastTouchDown._buttons;
                domEvent.trigger(ev);
                // set touch count to -1 to prevent repeated fire on sequential taps 
                this.__tapCount = -1;
            };
            /**
             * A function for handling and firing release events.
             * @param {plat.ui.IPointerEvent} ev The touch end event object.
             */
            DomEvents.prototype.__handleRelease = function (ev) {
                var domEvent = this.__findFirstSubscriber(ev.target, this._gestures.$release);
                if (!isNull(domEvent)) {
                    domEvent.trigger(ev);
                }
                this.__hasRelease = false;
            };
            /**
             * A function for handling and firing swipe events.
             */
            DomEvents.prototype.__handleSwipe = function () {
                // if swiping events exist 
                if (this._gestureCount.$swipe <= 0) {
                    return;
                }
                var lastMove = this.__lastMoveEvent;
                if (isNull(lastMove)) {
                    return;
                }
                var origin = this.__swipeOrigin, dx = Math.abs(lastMove.clientX - origin.clientX), dy = Math.abs(lastMove.clientY - origin.clientY), swipeSubscribers = this.__getRegisteredSwipes(lastMove.direction, lastMove.velocity, dx, dy);
                while (swipeSubscribers.length > 0) {
                    swipeSubscribers.pop().trigger(lastMove);
                }
                this.__lastMoveEvent = null;
            };
            /**
             * A function for handling and firing track events.
             * @param {plat.ui.IPointerEvent} ev The touch move event object.
             * @param {plat.ui.IPointerEvent} originalEv The original touch move event object
             * used for preventing default in the case of an ANDROID device.
             */
            DomEvents.prototype.__handleTrack = function (ev, originalEv) {
                var gestures = this._gestures, trackGesture = gestures.$track, direction = ev.direction, eventTarget = this.__capturedTarget || ev.target;
                var domEvents = this.__findFirstSubscribers(eventTarget, [trackGesture, (trackGesture + direction.x), (trackGesture + direction.y)]);
                if (this._android44orBelow) {
                    var anyEvents = this.__findFirstSubscribers(eventTarget, [trackGesture, gestures.$trackdown, gestures.$trackup,
                        gestures.$trackleft, gestures.$trackright, gestures.$trackend]);
                    if (anyEvents.length > 0) {
                        originalEv.preventDefault();
                    }
                }
                if (domEvents.length > 0) {
                    if (this._androidVersion > -1) {
                        originalEv.preventDefault();
                    }
                    while (domEvents.length > 0) {
                        domEvents.pop().trigger(ev);
                    }
                }
            };
            /**
             * A function for handling and firing track end events.
             * @param {plat.ui.IPointerEvent} ev The touch end event object.
             */
            DomEvents.prototype.__handleTrackEnd = function (ev) {
                if (this._gestureCount.$trackend <= 0) {
                    return;
                }
                var eventTarget = this.__capturedTarget || ev.target, domEvent = this.__findFirstSubscriber(eventTarget, this._gestures.$trackend);
                if (isNull(domEvent)) {
                    return;
                }
                domEvent.trigger(ev);
            };
            // touch type and element registration 
            /**
             * A function for determining the proper touch events.
             */
            DomEvents.prototype.__getTypes = function () {
                var _compat = this._compat, touchEvents = _compat.mappedEvents, listeners = this.__listeners, startEvents, moveEvents, endEvents;
                if (_compat.hasPointerEvents) {
                    startEvents = this._startEvents = touchEvents.$touchstart;
                    moveEvents = this._moveEvents = touchEvents.$touchmove;
                    endEvents = this._endEvents = touchEvents.$touchend + ' ' + touchEvents.$touchcancel;
                }
                else if (_compat.hasTouchEvents) {
                    startEvents = this._startEvents = touchEvents.$touchstart + ' mousedown';
                    moveEvents = this._moveEvents = touchEvents.$touchmove + ' mousemove';
                    endEvents = this._endEvents = touchEvents.$touchend + ' mouseup ' + touchEvents.$touchcancel;
                }
                else {
                    var cancelEvent = touchEvents.$touchcancel;
                    startEvents = this._startEvents = touchEvents.$touchstart;
                    moveEvents = this._moveEvents = touchEvents.$touchmove;
                    endEvents = this._endEvents = touchEvents.$touchend + (!cancelEvent ? '' : (' ' + cancelEvent));
                }
                listeners[startEvents] = this._onTouchStart.bind(this);
                listeners[moveEvents] = this._onTouchMove.bind(this);
                listeners[endEvents] = this._onTouchEnd.bind(this);
            };
            /**
             * Registers for and starts listening to start and end touch events on the document.
             */
            DomEvents.prototype.__registerTypes = function () {
                this.__registerType(this._startEvents);
                this.__registerType(this._endEvents);
                // dragstart will cause touchend to not fire 
                this._document.addEventListener('dragstart', this.__preventDefault, false);
            };
            /**
             * Unregisters for and stops listening to all touch events on the document.
             */
            DomEvents.prototype.__unregisterTypes = function () {
                this.__unregisterType(this._startEvents);
                this.__unregisterType(this._endEvents);
                if (this.__detectingMove) {
                    this.__unregisterType(this._moveEvents);
                    this.__detectingMove = false;
                }
                this._document.removeEventListener('dragstart', this.__preventDefault, false);
            };
            /**
             * Registers for and begins listening to a particular touch event type.
             * @param {string} events The events to begin listening for.
             */
            DomEvents.prototype.__registerType = function (events) {
                var listener = this.__listeners[events], _document = this._document, eventSplit = events.split(' '), index = eventSplit.length;
                while (index-- > 0) {
                    _document.addEventListener(eventSplit[index], listener, false);
                }
            };
            /**
             * Unregisters for and stops listening to a particular touch event type.
             * @param {string} events The events to stop listening for.
             */
            DomEvents.prototype.__unregisterType = function (events) {
                var listener = this.__listeners[events], _document = this._document, eventSplit = events.split(' '), index = eventSplit.length;
                while (index-- > 0) {
                    _document.removeEventListener(eventSplit[index], listener, false);
                }
            };
            /**
             * Registers and associates an element with an event.
             * @param {plat.ui.ICustomElement} element The element being tied to a custom event.
             * @param {string} type The type of event.
             */
            DomEvents.prototype.__registerElement = function (element, type) {
                var id, _plat = element.__plat;
                if (isNull(_plat)) {
                    id = uniqueId('domEvent_');
                    element.__plat = _plat = {
                        domEvent: id
                    };
                }
                else if (isNull(_plat.domEvent)) {
                    id = uniqueId('domEvent_');
                    _plat.domEvent = id;
                }
                var _domEvent;
                if (isNull(id)) {
                    var subscriber = this._subscribers[_plat.domEvent];
                    if (isUndefined(subscriber[type])) {
                        _domEvent = new CustomDomEvent(element, type);
                        subscriber[type] = _domEvent;
                    }
                    else {
                        subscriber[type].count++;
                    }
                    subscriber.gestureCount++;
                    return;
                }
                var newSubscriber = { gestureCount: 1 };
                _domEvent = new CustomDomEvent(element, type);
                newSubscriber[type] = _domEvent;
                this._subscribers[id] = newSubscriber;
                if (!isUndefined(element.className)) {
                    addClass(element, DomEvents.config.styleConfig[0].className);
                }
                this.__removeSelections(element);
            };
            /**
             * Unregisters and disassociates an element with an event.
             * @param {plat.ui.ICustomElement} element The element being disassociated with the given custom event.
             * @param {string} type The type of event.
             */
            DomEvents.prototype.__unregisterElement = function (element, type) {
                var _plat = element.__plat;
                if (isNull(_plat) || isNull(_plat.domEvent)) {
                    return;
                }
                var domEventId = _plat.domEvent, eventSubscriber = this._subscribers[domEventId], domEvent = eventSubscriber[type];
                if (isNull(domEvent)) {
                    return;
                }
                domEvent.count--;
                if (domEvent.count === 0) {
                    deleteProperty(eventSubscriber, type);
                }
                eventSubscriber.gestureCount--;
                if (eventSubscriber.gestureCount === 0) {
                    deleteProperty(this._subscribers, domEventId);
                    this.__removeElement(element);
                }
            };
            /**
             * Sets the current touch point and helps standardize the given event object.
             * @param {plat.ui.IPointerEvent} ev The current point being touched.
             */
            DomEvents.prototype.__setTouchPoint = function (ev) {
                var eventType = ev.type, _compat = this._compat;
                if (_compat.hasPointerEvents || _compat.hasMsPointerEvents) {
                    this.__updatePointers(ev, this.__pointerEndRegex.test(eventType));
                    return;
                }
                ev.pointerType = eventType.indexOf('mouse') === -1 ? 'touch' : 'mouse';
            };
            /**
             * Sets the captured target.
             * @param {EventTarget} target The target to capture.
             */
            DomEvents.prototype.__setCapture = function (target) {
                if (isNull(this.__capturedTarget) && !isDocument(target)) {
                    this.__capturedTarget = target;
                }
            };
            /**
             * Sets the captured target.
             * @param {plat.ui.IPointerEvent} ev The current touch point.
             * @param {boolean} remove Whether to remove the touch point or add it.
             */
            DomEvents.prototype.__updatePointers = function (ev, remove) {
                var id = ev.pointerId, pointerHash = this.__pointerHash, pointer = pointerHash[id], index;
                if (remove) {
                    if (!isUndefined(pointer)) {
                        index = this.__pointerEvents.indexOf(pointer);
                        if (index > -1) {
                            this.__pointerEvents.splice(index, 1);
                        }
                        deleteProperty(this.__pointerHash, id);
                    }
                }
                else {
                    if (id === 1 && !isEmpty(pointerHash)) {
                        // this is a mouse movement while mid touch 
                        return;
                    }
                    ev.identifier = ev.pointerId;
                    if (isUndefined(pointer) || (index = this.__pointerEvents.indexOf(pointer)) < 0) {
                        this.__pointerEvents.push(ev);
                    }
                    else {
                        this.__pointerEvents.splice(index, 1, ev);
                    }
                    pointerHash[id] = ev;
                }
            };
            // event and subscription handling 
            /**
             * Searches from the EventTarget up the DOM tree looking for an element with the
             * registered event type.
             * @param {plat.ui.ICustomElement} eventTarget The current target of the touch event.
             * @param {string} type The type of event being searched for.
             */
            DomEvents.prototype.__findFirstSubscriber = function (eventTarget, type) {
                if (isNull(eventTarget)) {
                    return;
                }
                var _plat, subscriber, domEvent;
                do {
                    _plat = eventTarget.__plat;
                    if (isUndefined(_plat) || isUndefined(_plat.domEvent)) {
                        continue;
                    }
                    subscriber = this._subscribers[_plat.domEvent];
                    domEvent = subscriber[type];
                    if (isUndefined(domEvent)) {
                        continue;
                    }
                    return domEvent;
                } while (!isNull(eventTarget = eventTarget.parentNode));
            };
            /**
             * Searches from the EventTarget up the DOM tree looking for all elements with the
             * registered event types.
             * @param {plat.ui.ICustomElement} eventTarget The current target of the touch event.
             * @param {Array<string>} types An array of the types of events being searched for.
             */
            DomEvents.prototype.__findFirstSubscribers = function (eventTarget, types) {
                if (isNull(eventTarget)) {
                    return [];
                }
                var _plat, subscriber, subscriberKeys, subscriberKey, domEvents = [], index;
                do {
                    _plat = eventTarget.__plat;
                    if (isUndefined(_plat) || isUndefined(_plat.domEvent)) {
                        continue;
                    }
                    subscriber = this._subscribers[_plat.domEvent];
                    subscriberKeys = Object.keys(subscriber);
                    while (subscriberKeys.length > 0) {
                        subscriberKey = subscriberKeys.pop();
                        index = types.indexOf(subscriberKey);
                        if (index !== -1) {
                            domEvents.push(subscriber[subscriberKey]);
                            types.splice(index, 1);
                        }
                    }
                } while (types.length > 0 && !isNull(eventTarget = eventTarget.parentNode));
                return domEvents;
            };
            /**
             * Removes an event listener for a given event type.
             * @param {plat.ui.ICustomElement} element The element to remove the listener from.
             * @param {string} type The type of event being removed.
             * @param {plat.ui.IGestureListener} listener The listener being removed.
             * @param {boolean} useCapture? Whether the listener is fired on the capture or bubble phase.
             */
            DomEvents.prototype.__removeEventListener = function (element, type, listener, useCapture) {
                var gestures = this._gestures;
                element.removeEventListener(type, listener, useCapture);
                var swipeGesture = gestures.$swipe, trackGesture = gestures.$track, countType = type;
                if (type.indexOf(trackGesture) !== -1) {
                    var trackend = gestures.$trackend;
                    countType = type === trackend ? trackend : trackGesture;
                }
                else if (type.indexOf(swipeGesture) !== -1) {
                    countType = swipeGesture;
                }
                this._gestureCount[countType]--;
                this.__unregisterElement(element, type);
            };
            /**
             * Removes an element from the subscriber object.
             * @param {plat.ui.ICustomElement} element The element being removed.
             */
            DomEvents.prototype.__removeElement = function (element) {
                this.__returnSelections(element);
                if (!isUndefined(element.className)) {
                    removeClass(element, DomEvents.config.styleConfig[0].className);
                }
                var plat = element.__plat;
                deleteProperty(plat, 'domEvent');
                if (isEmpty(plat)) {
                    deleteProperty(element, '__plat');
                }
            };
            /**
             * Standardizes certain properties on the event object for custom events.
             * @param {plat.ui.IExtendedEvent} ev The event object to be standardized.
             */
            DomEvents.prototype.__standardizeEventObject = function (ev) {
                this.__setTouchPoint(ev);
                var isStart = this._startEvents.indexOf(ev.type) !== -1, touches = ev.touches || this.__pointerEvents, changedTouches = ev.changedTouches, changedTouchesExist = !isUndefined(changedTouches), preventDefault, timeStamp = ev.timeStamp;
                if (changedTouchesExist) {
                    if (isStart) {
                        preventDefault = ev.preventDefault.bind(ev);
                        ev = changedTouches[0];
                        ev.preventDefault = preventDefault;
                    }
                    else {
                        var changedTouchIndex = this.__getTouchIndex(changedTouches);
                        if (changedTouchIndex >= 0) {
                            preventDefault = ev.preventDefault.bind(ev);
                            ev = changedTouches[changedTouchIndex];
                            ev.preventDefault = preventDefault;
                        }
                        else if (this.__getTouchIndex(touches) >= 0) {
                            // we want to return null because our point of interest is in touches 
                            // but was not in changedTouches so it is still playing a part on the page 
                            return null;
                        }
                    }
                }
                if (isStart) {
                    this.__setCapture(ev.target);
                }
                this.__normalizeButtons(ev);
                ev.touches = touches;
                ev.offset = this.__getOffset(ev);
                if (isUndefined(ev.timeStamp) || timeStamp > ev.timeStamp) {
                    ev.timeStamp = timeStamp;
                }
                return ev;
            };
            /**
             * Normalizes the 'buttons' property on an IExetendedEvent.
             * @param {plat.ui.IExtendedEvent} ev The event.
             */
            DomEvents.prototype.__normalizeButtons = function (ev) {
                var buttons;
                if (isNumber(ev.buttons) && ev.buttons !== 0) {
                    buttons = ev.buttons;
                }
                else if (isNumber(ev.which) && ev.which > 0) {
                    buttons = ev.which;
                }
                else {
                    switch (ev.button) {
                        case -1:
                            buttons = 0;
                            break;
                        case 0:
                            buttons = 1;
                            break;
                        case 1:
                            buttons = 4;
                            break;
                        case 2:
                            buttons = 2;
                            break;
                        case 3:
                            buttons = 8;
                            break;
                        case 4:
                            buttons = 16;
                            break;
                        default:
                            buttons = 1;
                            break;
                    }
                }
                ev._buttons = buttons;
            };
            /**
             * Searches through the input array looking for the primary
             * touch down index.
             * @param {Array<plat.ui.IExtendedEvent>} ev The array of touch event objects
             * to search through.
             */
            DomEvents.prototype.__getTouchIndex = function (touches) {
                var identifier = (this.__lastTouchDown || {}).identifier, length = touches.length;
                for (var i = 0; i < length; ++i) {
                    if (touches[i].identifier === identifier) {
                        return i;
                    }
                }
                return -1;
            };
            /**
             * Grabs the x and y offsets of an event object's target.
             * @param {plat.ui.IExtendedEvent} ev The current event object.
             */
            DomEvents.prototype.__getOffset = function (ev) {
                var target = this.__capturedTarget || ev.target;
                if (isDocument(target)) {
                    return {
                        x: ev.clientX,
                        y: ev.clientY
                    };
                }
                else if (!isUndefined(ev.offsetX) && !isUndefined(ev.offsetY) && target === ev.target) {
                    return {
                        x: ev.offsetX,
                        y: ev.offsetY
                    };
                }
                var x, y;
                if (isFunction(target.getBoundingClientRect)) {
                    var rect = target.getBoundingClientRect();
                    x = rect.left;
                    y = rect.top;
                }
                else {
                    x = target.offsetLeft;
                    y = target.offsetTop;
                    while (!isNull(target = target.offsetParent)) {
                        x += target.offsetLeft;
                        y += target.offsetTop;
                    }
                }
                return {
                    x: (ev.clientX - x),
                    y: (ev.clientY - y)
                };
            };
            // utility methods 
            /**
             * Calculates the distance between two (x, y) coordinate points.
             * @param {number} x1 The x-coordinate of the first point.
             * @param {number} x2 The x-coordinate of the second point.
             * @param {number} y1 The y-coordinate of the first point.
             * @param {number} y2 The y-coordinate of the second point.
             */
            DomEvents.prototype.__getDistance = function (x1, x2, y1, y2) {
                var x = x2 - x1, y = y2 - y1;
                return Math.sqrt((x * x) + (y * y));
            };
            /**
             * Calculates the velocity between two (x, y) coordinate points over a given time.
             * @param {number} dx The change in x position.
             * @param {number} dy The change in y position.
             * @param {number} dtx The change in time in x direction.
             * @param {number} dty The change in time in y direction.
             */
            DomEvents.prototype.__getVelocity = function (dx, dy, dtx, dty) {
                var x = 0, y = 0;
                if (dtx > 0) {
                    x = (dx / dtx) || 0;
                }
                if (dty > 0) {
                    y = (dy / dty) || 0;
                }
                return {
                    x: x,
                    y: y
                };
            };
            /**
             * Calculates the direction of movement.
             * @param {number} dx The change in x position.
             * @param {number} dy The change in y position.
             */
            DomEvents.prototype.__getDirection = function (dx, dy) {
                var distanceX = Math.abs(dx), distanceY = Math.abs(dy), lastDirection = (this.__lastMoveEvent || {}).direction || {}, horizontal = dx === 0 ? (lastDirection.x || 'none') : (dx < 0 ? 'left' : 'right'), vertical = dy === 0 ? (lastDirection.y || 'none') : (dy < 0 ? 'up' : 'down');
                return {
                    x: horizontal,
                    y: vertical,
                    primary: (distanceX === distanceY ? (lastDirection.primary || 'none') : (distanceX > distanceY ? horizontal : vertical))
                };
            };
            /**
             * Checks to see if a swipe direction has changed to recalculate
             * an origin point.
             * @param {plat.ui.IDirection} direction The current vertical and horiztonal directions of movement.
             */
            DomEvents.prototype.__handleOriginChange = function (direction) {
                var lastMove = this.__lastMoveEvent;
                if (isNull(lastMove)) {
                    return;
                }
                var swipeDirection = lastMove.direction, xSame = swipeDirection.x === direction.x, ySame = swipeDirection.y === direction.y;
                if (xSame && ySame) {
                    return;
                }
                var origin = this.__swipeOrigin, gestures = this._gestures, swipes = [gestures.$swipe, gestures.$swipedown, gestures.$swipeleft, gestures.$swiperight, gestures.$swipeup];
                if (!xSame) {
                    origin.clientX = lastMove.clientX;
                    origin.xTimestamp = lastMove.timeStamp;
                    origin.xTarget = lastMove.target;
                    if (this._android44orBelow) {
                        this.__haveSwipeSubscribers = this.__findFirstSubscribers(origin.xTarget, swipes).length > 0;
                    }
                }
                if (!ySame) {
                    origin.clientY = lastMove.clientY;
                    origin.yTimestamp = lastMove.timeStamp;
                    origin.yTarget = lastMove.target;
                    if (this._android44orBelow) {
                        this.__haveSwipeSubscribers = this.__findFirstSubscribers(origin.yTarget, swipes).length > 0;
                    }
                }
            };
            /**
             * Checks to see if a swipe event has been registered.
             * @param {plat.ui.IDirection} direction The current horizontal and vertical directions of movement.
             * @param {plat.ui.IVelocity} velocity The current horizontal and vertical velocities.
             * @param {number} dx The distance in the x direction.
             * @param {number} dy The distance in the y direction.
             */
            DomEvents.prototype.__getRegisteredSwipes = function (direction, velocity, dx, dy) {
                var swipeTarget, swipeGesture = this._gestures.$swipe, minSwipeVelocity = DomEvents.config.velocities.minSwipeVelocity, events = [swipeGesture], origin = (this.__swipeOrigin || {});
                if (dx > dy) {
                    swipeTarget = origin.xTarget;
                    if (velocity.x >= minSwipeVelocity) {
                        events.push(swipeGesture + direction.x);
                    }
                }
                else if (dy > dx) {
                    swipeTarget = origin.yTarget;
                    if (velocity.y >= minSwipeVelocity) {
                        events.push(swipeGesture + direction.y);
                    }
                }
                return this.__findFirstSubscribers(swipeTarget, events);
            };
            /**
             * Checks to see if a swipe event has been registered.
             * @param {string} direction The current direction of movement.
             */
            DomEvents.prototype.__isHorizontal = function (direction) {
                return direction === 'left' || direction === 'right';
            };
            /**
             * Appends CSS to the head for gestures if needed.
             */
            DomEvents.prototype.__appendGestureStyle = function () {
                var _document = this._document, styleClasses, classLength;
                if (this._compat.platCss) {
                    return;
                }
                else if (!isNull(_document.styleSheets) && _document.styleSheets.length > 0) {
                    var styleSheet = _document.styleSheets[0];
                    styleClasses = DomEvents.config.styleConfig;
                    classLength = styleClasses.length;
                    while (classLength-- > 0) {
                        styleSheet.insertRule(this.__createStyle(styleClasses[classLength]), 0);
                    }
                    return;
                }
                var head = _document.head, style = _document.createElement('style'), textContent = '';
                style.type = 'text/css';
                styleClasses = DomEvents.config.styleConfig;
                classLength = styleClasses.length;
                while (classLength-- > 0) {
                    textContent = this.__createStyle(styleClasses[classLength]) + textContent;
                }
                style.textContent = textContent;
                head.appendChild(style);
            };
            /**
             * Creates a style text to append to the document head.
             * @param {plat.ui.IDefaultStyle} styleClass The object containing the custom styles for
             * gestures.
             */
            DomEvents.prototype.__createStyle = function (styleClass) {
                var styles = styleClass.styles || [], styleLength = styles.length, style = '.' + styleClass.className + ' { ', textContent = '';
                styleLength = styles.length;
                for (var j = 0; j < styleLength; ++j) {
                    textContent += styles[j] + ';';
                }
                style += textContent + ' } ';
                return style;
            };
            /**
             * Blurs the currently focused element.
             */
            DomEvents.prototype.__blurFocusedElement = function () {
                var focusedElement = this.__focusedElement || {};
                if (isFunction(focusedElement.blur)) {
                    focusedElement.blur();
                }
            };
            /**
             * Listens for blur and then sets the focused element back to null for the next case.
             * @param {HTMLInputElement} target The target to listen for the blur event on.
             */
            DomEvents.prototype.__waitForBlur = function (target) {
                var _this = this;
                this.__blurRemover = this.addEventListener(target, 'blur', function () {
                    _this.__blurRemover();
                    _this.__blurRemover = noop;
                    if (target === _this.__focusedElement) {
                        _this.__focusedElement = null;
                    }
                }, false);
            };
            /**
             * Handles a click target case.
             * @param {HTMLInputElement} target The target to handle click functionaliy for.
             */
            DomEvents.prototype.__clickTarget = function (target) {
                var _this = this;
                var clicked = false, handler = function () {
                    clicked = true;
                    target.removeEventListener('click', handler, false);
                };
                target.addEventListener('click', handler, false);
                postpone(function () {
                    if (clicked) {
                        return;
                    }
                    target.removeEventListener('click', handler, false);
                    if (_this._document.body.contains(target) && isFunction(target.click)) {
                        target.click();
                    }
                });
            };
            /**
             * Handles HTMLInputElements in WebKit based touch applications.
             * @param {HTMLInputElement} target The target to handle functionality for.
             */
            DomEvents.prototype.__handleInput = function (target) {
                this.__blurRemover();
                var nodeName = target.nodeName;
                if (!isString(nodeName)) {
                    this.__focusedElement = null;
                    this.__blurFocusedElement();
                    return;
                }
                var preventDefault = true;
                switch (nodeName.toLowerCase()) {
                    case 'input':
                        switch (target.type) {
                            case 'range':
                                this.__blurFocusedElement();
                                break;
                            case 'text':
                            case 'password':
                            case 'email':
                            case 'number':
                            case 'tel':
                            case 'search':
                            case 'url':
                                target.focus();
                                this.__waitForBlur(target);
                                break;
                            default:
                                this.__blurFocusedElement();
                                this.__clickTarget(target);
                                break;
                        }
                        break;
                    case 'a':
                    case 'button':
                    case 'label':
                        this.__blurFocusedElement();
                        this.__clickTarget(target);
                        break;
                    case 'textarea':
                        target.focus();
                        this.__waitForBlur(target);
                        break;
                    case 'select':
                        preventDefault = false;
                        break;
                    default:
                        this.__blurFocusedElement();
                        this.__clickTarget(target);
                        break;
                }
                this.__focusedElement = target;
                return preventDefault;
            };
            /**
             * Handles the phantom click in WebKit based touch applications.
             */
            DomEvents.prototype.__preventClickFromTouch = function () {
                var _document = this._document, ignoreEvents = this.__ignoreEvent, boundPreventDefault = this.__boundPreventDefaultClick, interval = DomEvents.config.intervals.delayedClickInterval;
                if (interval <= 0) {
                    return;
                }
                this.__delayedClickRemover = {
                    mousedown: defer(function () {
                        ignoreEvents.mousedown = false;
                    }, interval),
                    mouseup: defer(function () {
                        ignoreEvents.mouseup = false;
                    }, interval),
                    click: defer(function () {
                        _document.removeEventListener('click', boundPreventDefault, true);
                    }, interval)
                };
                ignoreEvents.mousedown = ignoreEvents.mouseup = true;
                postpone(function () {
                    _document.addEventListener('click', boundPreventDefault, true);
                });
            };
            /**
             * Prevents default and stops propagation for delayed or phantom clicks.
             * @param {Event} ev The event object.
             */
            DomEvents.prototype.__preventDefaultClick = function (ev) {
                ev.preventDefault();
                ev.stopImmediatePropagation();
                this._document.removeEventListener('click', this.__boundPreventDefaultClick, true);
                this.__delayedClickRemover.click();
                return false;
            };
            /**
             * Removes selection capability from the element.
             * @param {Node} element The element to remove selections on.
             */
            DomEvents.prototype.__removeSelections = function (element) {
                if (!isNode(element)) {
                    return;
                }
                if (!isUndefined(element.onselectstart)) {
                    element.addEventListener('selectstart', this.__preventDefault, false);
                }
                if (!isUndefined(element.ondragstart)) {
                    element.addEventListener('dragstart', this.__preventDefault, false);
                }
            };
            /**
             * Returns selection capability from the element.
             * @param {Node} element The element to return selections on.
             */
            DomEvents.prototype.__returnSelections = function (element) {
                if (!isNode(element)) {
                    return;
                }
                if (!isUndefined(element.onselectstart)) {
                    element.removeEventListener('selectstart', this.__preventDefault, false);
                }
                if (!isUndefined(element.ondragstart)) {
                    element.removeEventListener('dragstart', this.__preventDefault, false);
                }
            };
            /**
             * Prevents default and stops propagation in all elements other than
             * inputs and textareas.
             * @param {Event} ev The event object.
             */
            DomEvents.prototype.__preventDefault = function (ev) {
                var nodeName = ev.target.nodeName;
                if (isString(nodeName)) {
                    nodeName = nodeName.toLowerCase();
                }
                if (nodeName === 'input' || nodeName === 'textarea') {
                    return true;
                }
                ev.preventDefault();
                return false;
            };
            DomEvents._inject = {
                _document: __Document,
                _compat: __Compat
            };
            /**
             * A configuration object for all DOM events.
             */
            DomEvents.config = {
                /**
                 */
                intervals: {
                    /**
                     */
                    tapInterval: 300,
                    /**
                     */
                    dblTapInterval: 300,
                    /**
                     */
                    holdInterval: 400,
                    /**
                     */
                    dblTapZoomDelay: 0,
                    /**
                     */
                    delayedClickInterval: 400
                },
                /**
                 */
                distances: {
                    /**
                     */
                    minScrollDistance: 3,
                    /**
                     */
                    maxDblTapDistance: 10
                },
                /**
                 */
                velocities: {
                    /**
                     */
                    minSwipeVelocity: 0.645
                },
                /**
                 */
                styleConfig: [{
                        /**
                         */
                        className: 'plat-gesture',
                        /**
                         */
                        styles: [
                            '-moz-user-select: none',
                            '-khtml-user-select: none',
                            '-webkit-touch-callout: none',
                            '-webkit-user-select: none',
                            '-webkit-user-drag: none',
                            '-webkit-tap-highlight-color: transparent',
                            '-webkit-overflow-scrolling: touch',
                            '-ms-user-select: none',
                            '-ms-touch-action: manipulation',
                            'touch-action: manipulation'
                        ]
                    }, {
                        /**
                         */
                        className: 'plat-no-touch-action',
                        /**
                         */
                        styles: [
                            '-ms-touch-action: none',
                            'touch-action: none'
                        ]
                    }]
            };
            /**
             * An object containing the event types for all of the
             * supported gestures.
             */
            DomEvents.gestures = {
                $tap: __tap,
                $dbltap: __dbltap,
                $hold: __hold,
                $release: __release,
                $swipe: __swipe,
                $swipeleft: __swipeleft,
                $swiperight: __swiperight,
                $swipeup: __swipeup,
                $swipedown: __swipedown,
                $track: __track,
                $trackleft: __trackleft,
                $trackright: __trackright,
                $trackup: __trackup,
                $trackdown: __trackdown,
                $trackend: __trackend
            };
            return DomEvents;
        }());
        ui.DomEvents = DomEvents;
        register.injectable(__DomEvents, DomEvents);
        /**
         */
        function IDomEventsConfig() {
            return DomEvents.config;
        }
        ui.IDomEventsConfig = IDomEventsConfig;
        register.injectable(__IDomEventsConfig, IDomEventsConfig);
        /**
         * A class for managing a single custom event.
         */
        var DomEvent = (function () {
            function DomEvent() {
                /**
                 * Reference to the Document injectable.
                 */
                this._document = acquire(__Document);
            }
            DomEvent.prototype.initialize = function (element, event, eventType) {
                this.element = element;
                this.event = event;
                this.eventType = isString(eventType) ? eventType : 'CustomEvent';
            };
            /**
             * Triggers its event on its element.
             * @param {Object} eventExtension? An event extension to extend the dispatched CustomEvent.
             * @param {any} detailArg? The detail arg to include in the event object
             * @param {Node} dispatchElement? The element to dispatch the Event from. If not specified,
             * this instance's element will be used.
             */
            DomEvent.prototype.trigger = function (eventExtension, detailArg, dispatchElement) {
                var customEv = this._document.createEvent(this.eventType);
                if (isObject(eventExtension)) {
                    _extend(false, false, customEv, eventExtension);
                }
                customEv.initCustomEvent(this.event, true, true, isNull(detailArg) ? 0 : detailArg);
                return (dispatchElement || this.element).dispatchEvent(customEv);
            };
            return DomEvent;
        }());
        ui.DomEvent = DomEvent;
        register.injectable(__DomEventInstance, DomEvent, null, __INSTANCE);
        /**
         * A specialized class for managing a single custom touch event in DomEvents.
         */
        var CustomDomEvent = (function (_super) {
            __extends(CustomDomEvent, _super);
            function CustomDomEvent(element, event) {
                _super.call(this);
                /**
                 * The number of listeners added for this event on this element.
                 */
                this.count = 0;
                this.element = element;
                this.event = event;
                this.count++;
            }
            /**
             * Triggers its event on its element.
             * @param {plat.ui.IPointerEvent} ev The current touch event object used to extend the
             * newly created custom event.
             */
            CustomDomEvent.prototype.trigger = function (ev) {
                var customEv = this._document.createEvent('CustomEvent'), element = this.element, target = ev.target;
                this.__extendEventObject(customEv, ev);
                customEv.initCustomEvent(this.event, true, true, 0);
                var success = isDocument(element) || element.contains(target) ? target.dispatchEvent(customEv) : element.dispatchEvent(customEv);
                if (!success) {
                    ev.preventDefault();
                }
                return success;
            };
            /**
             * Extends the custom event to mimic a standardized touch event.
             * @param {plat.ui.IGestureEvent} customEv The newly created custom event object.
             * @param {plat.ui.IPointerEvent} ev The current touch event object.
             */
            CustomDomEvent.prototype.__extendEventObject = function (customEv, ev) {
                // not using extend function because this gets called so often for certain events. 
                var pointerType = ev.pointerType;
                customEv.clientX = ev.clientX;
                customEv.clientY = ev.clientY;
                customEv.offsetX = ev.offset.x;
                customEv.offsetY = ev.offset.y;
                customEv.direction = ev.direction || {
                    x: 'none',
                    y: 'none',
                    primary: 'none'
                };
                customEv.touches = ev.touches;
                customEv.velocity = ev.velocity || { x: 0, y: 0 };
                customEv.identifier = ev.identifier || 0;
                customEv.pointerType = isNumber(pointerType) ? this.__convertPointerType(pointerType, ev.type) : pointerType;
                customEv.screenX = ev.screenX;
                customEv.screenY = ev.screenY;
                customEv.pageX = ev.pageX;
                customEv.pageY = ev.pageY;
                customEv.buttons = ev._buttons;
            };
            /**
             * Converts pointer type to a standardized string.
             * @param {any} pointerType The pointer type as either a number or a string.
             * @param {string} eventType The touch event type.
             */
            CustomDomEvent.prototype.__convertPointerType = function (pointerType, eventType) {
                switch (pointerType) {
                    case MSPointerEvent.MSPOINTER_TYPE_MOUSE:
                        return 'mouse';
                    case MSPointerEvent.MSPOINTER_TYPE_PEN:
                        return 'pen';
                    case MSPointerEvent.MSPOINTER_TYPE_TOUCH:
                        return 'touch';
                }
                return (eventType.indexOf('mouse') === -1) ? 'touch' : 'mouse';
            };
            return CustomDomEvent;
        }(DomEvent));
        /**
         * Holds all the classes and interfaces related to UI animation components for platypus.
         */
        var animations;
        (function (animations) {
            /**
             * A class used for animating elements.
             */
            var Animator = (function () {
                function Animator() {
                    /**
                     * Objects representing collections of all currently animated elements.
                     */
                    this._animatedElements = {};
                }
                Animator.prototype.create = function (elements, key, options) {
                    return this._create(elements, key, options, {
                        key: null
                    });
                };
                Animator.prototype.animate = function (elements, key, options) {
                    return this._animate(elements, key, options, {
                        key: null
                    });
                };
                Animator.prototype.enter = function (elements, key, parent, refChild, options) {
                    return this._animate(elements, key, options, {
                        key: 'enter',
                        parent: parent,
                        refChild: refChild
                    });
                };
                Animator.prototype.leave = function (elements, key, options) {
                    return this._animate(elements, key, options, {
                        key: 'leave'
                    });
                };
                Animator.prototype.move = function (elements, key, parent, refChild, options) {
                    return this._animate(elements, key, options, {
                        key: 'move',
                        parent: parent,
                        refChild: refChild
                    });
                };
                Animator.prototype.show = function (elements, key, options) {
                    return this._animate(elements, key, options, {
                        key: 'show'
                    });
                };
                Animator.prototype.hide = function (elements, key, options) {
                    return this._animate(elements, key, options, {
                        key: 'hide'
                    });
                };
                /**
                 * Returns a promise that fulfills when every animation promise in the input array is fulfilled.
                 */
                Animator.prototype.all = function (promises) {
                    var _this = this;
                    var length = promises.length, args = [], animationPromise = new AnimationPromise(function (resolve) {
                        _this._Promise.all(promises).then(function () {
                            resolve();
                        });
                    });
                    for (var i = 0; i < length; ++i) {
                        args = args.concat(promises[i].getInstances());
                    }
                    animationPromise.initialize(args);
                    return animationPromise.then(noop);
                };
                /**
                 * Immediately resolves an empty AnimationPromise.
                 */
                Animator.prototype.resolve = function () {
                    var animationPromise = new AnimationPromise(function (resolve) {
                        resolve(function () {
                            return animationPromise;
                        });
                    });
                    return animationPromise;
                };
                /**
                 * Animates the passed in elements with the given key and handles special animation functionality.
                 * @param {any} elements The Nodes to be animated. All nodes in the Array must have
                 * the same parent, otherwise the animation will not function correctly.
                 * @param {string} key The identifier specifying the type of animation.
                 * @param {any} options? Specified options for the animation.
                 * @param {plat.ui.animations.IAnimationFunction} functionality An object containing detailed information about
                 * special animation functionality.
                 */
                Animator.prototype._animate = function (elements, key, options, functionality) {
                    var animation = this._create(elements, key, options, functionality), current = animation.current;
                    animation.previous.then(function () {
                        requestAnimationFrameGlobal(function () {
                            current.start();
                        });
                    });
                    return current;
                };
                /**
                 * Animates the passed in elements with the given key and handles special animation functionality. Returns both
                 * the previous and current animations for the given element(s).
                 * @param {any} elements The Nodes to be animated. All nodes in the Array must have
                 * the same parent, otherwise the animation will not function correctly.
                 * @param {string} key The identifier specifying the type of animation.
                 * @param {any} options? Specified options for the animation.
                 * @param {plat.ui.animations.IAnimationFunction} functionality An object containing detailed information about
                 * special animation functionality.
                 */
                Animator.prototype._create = function (elements, key, options, functionality) {
                    var _this = this;
                    var animationInjector = animationInjectors[key], animationInstances = [], elementNodes = [], immediateResolve;
                    if (!this._compat.animationSupported || isUndefined(animationInjector)) {
                        animationInjector = jsAnimationInjectors[key];
                        if (isUndefined(animationInjector)) {
                            elements = this.__constructAnimatableElements(elements, { inject: noop }, elementNodes, animationInstances);
                            this._handlePreInitFunctionality(elements, elementNodes, functionality);
                            this._handlePostInitFunctionality(elements, elementNodes, functionality);
                            this._handleEndFunctionality(elements, elementNodes, functionality);
                            immediateResolve = this.resolve();
                            return { previous: immediateResolve, current: immediateResolve };
                        }
                    }
                    elements = this.__constructAnimatableElements(elements, animationInjector, elementNodes, animationInstances);
                    var length = elementNodes.length;
                    if (length === 0) {
                        this._handlePreInitFunctionality(elements, elementNodes, functionality);
                        this._handlePostInitFunctionality(elements, elementNodes, functionality);
                        this._handleEndFunctionality(elements, elementNodes, functionality);
                        immediateResolve = this.resolve();
                        return { previous: immediateResolve, current: immediateResolve };
                    }
                    this._handlePreInitFunctionality(elements, elementNodes, functionality);
                    var id = uniqueId('animation_'), previousAnimations = this.__setAnimationId(id, elementNodes), previousPromise, animationPromise = new AnimationPromise(function (resolve) {
                        var _Promise = _this._Promise;
                        previousPromise = _Promise.all(previousAnimations).then(function () {
                            var animationPromises = [];
                            for (var i = 0; i < length; ++i) {
                                animationPromises.push(animationInstances[i].instantiate(elementNodes[i], options));
                            }
                            _this._handlePostInitFunctionality(elements, elementNodes, functionality);
                            var animationsFinished = _Promise.all(animationPromises), animatingParentId = _this.__isParentAnimating(elementNodes), animatedElement = _this.__generateAnimatedElement(id, elementNodes, animationPromise);
                            if (!isNull(animatingParentId)) {
                                _this._handleEndFunctionality(elements, elementNodes, functionality);
                                animatedElement.animationEnd(true);
                                var parent_1 = _this._animatedElements[animatingParentId], resolvedPromise_1 = isPromise(parent_1.promise) ?
                                    function () {
                                        return parent_1.promise;
                                    } : function () {
                                    return animationPromise;
                                };
                                animationsFinished.then(function () {
                                    resolve(resolvedPromise_1);
                                });
                            }
                            _this.__stopChildAnimations(elementNodes);
                            animatedElement.promise = animationPromise;
                            animationsFinished.then(function () {
                                _this._handleEndFunctionality(elements, elementNodes, functionality);
                                animatedElement.animationEnd();
                                resolve(function () {
                                    return animationPromise;
                                });
                            });
                        });
                    });
                    animationPromise.initialize(animationInstances);
                    return { previous: previousPromise, current: animationPromise };
                };
                /**
                 * Handles different specialized functionalities immediately before the init portion of the animation cycle.
                 * @param {Array<Node>} nodes All the nodes being animated.
                 * @param {Array<Element>} elementNodes The animatable nodes being animated (only of type Node.ELEMENT_NODE).
                 * @param {plat.ui.animations.IAnimationFunction} functionality The specialized animation function attributes.
                 */
                Animator.prototype._handlePreInitFunctionality = function (nodes, elementNodes, functionality) {
                    switch (functionality.key) {
                        case 'move':
                            for (var i = 0; i < length; ++i) {
                                removeNode(nodes[i]);
                            }
                            break;
                        default:
                            break;
                    }
                };
                /**
                 * Handles different specialized functionalities immediately after the init portion of the animation cycle.
                 * @param {Array<Node>} nodes All the nodes being animated.
                 * @param {Array<Element>} elementNodes The animatable nodes being animated (only of type Node.ELEMENT_NODE).
                 * @param {plat.ui.animations.IAnimationFunction} functionality The specialized animation function attributes.
                 */
                Animator.prototype._handlePostInitFunctionality = function (nodes, elementNodes, functionality) {
                    var length, i;
                    switch (functionality.key) {
                        case 'enter':
                        case 'move':
                            var refChild = functionality.refChild, parent_2;
                            if (isNode(refChild)) {
                                parent_2 = refChild.parentNode;
                            }
                            else {
                                parent_2 = functionality.parent;
                                refChild = null;
                            }
                            if (!isNode(parent_2)) {
                                break;
                            }
                            length = nodes.length;
                            for (i = 0; i < length; ++i) {
                                parent_2.insertBefore(nodes[i], refChild);
                            }
                            break;
                        case 'show':
                            length = elementNodes.length;
                            for (i = 0; i < length; ++i) {
                                elementNodes[i].removeAttribute(__Hide);
                            }
                            break;
                        default:
                            break;
                    }
                };
                /**
                 * Handles different specialized functionalities at the end portion of the animation cycle.
                 * @param {Array<Node>} nodes All the nodes being animated.
                 * @param {Array<Element>} elementNodes The animatable nodes being animated (only of type Node.ELEMENT_NODE).
                 * @param {plat.ui.animations.IAnimationFunction} functionality The specialized animation function attributes.
                 */
                Animator.prototype._handleEndFunctionality = function (nodes, elementNodes, functionality) {
                    var length, i;
                    switch (functionality.key) {
                        case 'leave':
                            length = nodes.length;
                            for (i = 0; i < length; ++i) {
                                removeNode(nodes[i]);
                            }
                            break;
                        case 'hide':
                            length = elementNodes.length;
                            for (i = 0; i < length; ++i) {
                                elementNodes[i].setAttribute(__Hide, '');
                            }
                            break;
                        default:
                            break;
                    }
                };
                /**
                 * Sets a new, unique animation ID and denotes the elements as currently being animated.
                 * @param {string} id The animation ID.
                 * @param {Array<Element>} elements The Array of Elements being animated.
                 */
                Animator.prototype.__setAnimationId = function (id, elements) {
                    var animatedElements = this._animatedElements, animatedElement, _plat, promises = [], length = elements.length, element;
                    for (var i = 0; i < length; ++i) {
                        element = elements[i];
                        _plat = element.__plat;
                        if (isUndefined(_plat)) {
                            element.__plat = { animation: id };
                            addClass(element, __Animating);
                        }
                        else if (isUndefined(_plat.animation)) {
                            _plat.animation = id;
                            addClass(element, __Animating);
                        }
                        else {
                            animatedElement = animatedElements[_plat.animation];
                            if (!isUndefined(animatedElement)) {
                                promises.push(animatedElement.promise);
                                animatedElement.animationEnd(true);
                            }
                            _plat.animation = id;
                        }
                    }
                    return promises;
                };
                /**
                 * Generates a new animated element for the Animator to easily reference and be able
                 * to end later on.
                 * @param {string} id The animation ID.
                 * @param {Array<Element>} elements The Array of Elements being animated.
                 * @param {plat.ui.animations.AnimationPromise} animationPromise The animation's associated promise.
                 */
                Animator.prototype.__generateAnimatedElement = function (id, elements, animationPromise) {
                    var animatedElements = this._animatedElements, removeListener = function (cancel) {
                        var _plat, element, length = elements.length, animationId;
                        if (cancel === true) {
                            animationPromise.cancel();
                            deleteProperty(animatedElements, id);
                            return;
                        }
                        for (var i = 0; i < length; ++i) {
                            element = elements[i];
                            _plat = element.__plat || {};
                            animationId = _plat.animation;
                            if (isUndefined(animationId) || animationId !== id) {
                                continue;
                            }
                            removeClass(element, __Animating);
                            deleteProperty(_plat, 'animation');
                            if (isEmpty(_plat)) {
                                deleteProperty(element, '__plat');
                            }
                        }
                        deleteProperty(animatedElements, id);
                    };
                    return animatedElements[id] = {
                        animationEnd: removeListener
                    };
                };
                /**
                 * Checks whether or not any parent elements are animating.
                 * @param {Array<Element>} elements The Elements whose parents we need to check.
                 */
                Animator.prototype.__isParentAnimating = function (elements) {
                    var animationId, element = elements[0];
                    while (!(isDocument(element = element.parentNode) || isNull(element) || element.nodeType !== Node.ELEMENT_NODE)) {
                        if (hasClass(element, __Animating)) {
                            var _plat = element.__plat;
                            animationId = (_plat || {}).animation;
                            if (isString(animationId)) {
                                if (!isNull(this._animatedElements[animationId])) {
                                    return animationId;
                                }
                                deleteProperty(_plat, 'animation');
                                if (isEmpty(_plat)) {
                                    deleteProperty(element, '__plat');
                                }
                                removeClass(element, __Animating);
                            }
                        }
                    }
                };
                /**
                 * Forces child nodes of an animating element to stop animating.
                 * @param {Element} element The element being animated.
                 */
                Animator.prototype.__stopChildAnimations = function (elements) {
                    var animatingElements = this._animatedElements, slice = Array.prototype.slice, customAnimationElements, animatedElement, _plat, id;
                    for (var i = 0; i < elements.length; ++i) {
                        customAnimationElements = slice.call(elements[i].querySelectorAll('.' + __Animating));
                        while (customAnimationElements.length > 0) {
                            _plat = customAnimationElements.pop().__plat || {};
                            id = _plat.animation;
                            if (isNull(id)) {
                                continue;
                            }
                            animatedElement = animatingElements[id] || {};
                            if (isFunction(animatedElement.animationEnd)) {
                                animatedElement.animationEnd(true);
                            }
                        }
                    }
                };
                /**
                 * Sifts through an Array of Nodes and finds all animatable Elements and creates
                 * BaseAnimations for them.
                 * @param {any} elements The Array of Nodes, DocumentFragment, or element to sift through.
                 * @param {plat.dependency.Injector<plat.ui.animations.BaseAnimation>} animationInjector The injector to instantiate
                 * BaseAnimations.
                 * @param {Array<Element>} elementNodes The Array of only animatable elements.
                 * @param {Array<plat.ui.animations.BaseAnimation>>} animationInstances An empty Array of animation instances to add to.
                 */
                Animator.prototype.__constructAnimatableElements = function (elements, animationInjector, elementNodes, animationInstances) {
                    if (!isArray(elements)) {
                        if (isDocumentFragment(elements)) {
                            elements = Array.prototype.slice.call(elements.childNodes);
                        }
                        else if (isArrayLike(elements)) {
                            elements = Array.prototype.slice.call(elements);
                        }
                        else if (!(isNode(elements) && elements.nodeType === Node.ELEMENT_NODE)) {
                            return [];
                        }
                        else {
                            elements = [elements];
                        }
                    }
                    var length = elements.length, element;
                    for (var i = 0; i < length; ++i) {
                        element = elements[i];
                        if (isNode(element) && element.nodeType === Node.ELEMENT_NODE) {
                            elementNodes.push(element);
                            animationInstances.push(animationInjector.inject());
                        }
                    }
                    return elements;
                };
                Animator._inject = {
                    _compat: __Compat,
                    _Promise: __Promise,
                    _document: __Document
                };
                return Animator;
            }());
            animations.Animator = Animator;
            register.injectable(__Animator, Animator);
            /**
             * Describes a type of Promise that can be optionally cancelled.
             * Further, in the case where it may have a parent that is animating (which will cause it to immediately cancel and fulfill
             * itself, it resolves with a IGetAnimatingThenable for acccessing
             * the IAnimationThenable of the animating parent element.
             */
            var AnimationPromise = (function (_super) {
                __extends(AnimationPromise, _super);
                function AnimationPromise(resolveFunction, promise) {
                    _super.call(this, resolveFunction);
                    /**
                     * Reference to the IPromise injectable.
                     */
                    this._Promise = acquire(__Promise);
                    /**
                     * The state of the animation. 0 prior to start, 1 if started, and
                     * 2 if canceled.
                     */
                    this.__animationState = 0;
                    /**
                     * An Array of animation instances linked to this promise.
                     */
                    this.__animationInstances = [];
                    if (!isNull(promise)) {
                        this.__animationInstances = promise.__animationInstances;
                        this.__animationState = promise.__animationState;
                    }
                }
                AnimationPromise.prototype.initialize = function (instances) {
                    if (isEmpty(this.__animationInstances)) {
                        if (isArray(instances)) {
                            this.__animationInstances = instances;
                        }
                        else if (isObject(instances)) {
                            this.__animationInstances = [instances];
                        }
                    }
                };
                /**
                 * Gets the associated animation instances or animated promises.
                 */
                AnimationPromise.prototype.getInstances = function () {
                    return this.__animationInstances;
                };
                /**
                 * Fires the start method on the animation instances to kickoff the animations.
                 */
                AnimationPromise.prototype.start = function () {
                    if (this.__animationState > 0) {
                        return;
                    }
                    var animationInstances = this.__animationInstances, animationInstance, length = animationInstances.length;
                    for (var i = 0; i < length; ++i) {
                        animationInstance = animationInstances[i];
                        if (isFunction(animationInstance.start)) {
                            animationInstance.start();
                        }
                    }
                    this.__animationState = 1;
                };
                /**
                 * Fires the pause method on the animation instance.
                 */
                AnimationPromise.prototype.pause = function () {
                    if (this.__animationState !== 1) {
                        return this._Promise.resolve();
                    }
                    var animationInstances = this.__animationInstances, pausePromises = [], animationInstance, length = animationInstances.length;
                    for (var i = 0; i < length; ++i) {
                        animationInstance = animationInstances[i];
                        if (isFunction(animationInstance.pause)) {
                            pausePromises.push(animationInstance.pause());
                        }
                    }
                    return this._Promise.all(pausePromises).then(noop);
                };
                /**
                 * Fires the resume method on the animation instance.
                 */
                AnimationPromise.prototype.resume = function () {
                    if (this.__animationState !== 1) {
                        return this._Promise.resolve();
                    }
                    var animationInstances = this.__animationInstances, resumePromises = [], animationInstance, length = animationInstances.length;
                    for (var i = 0; i < length; ++i) {
                        animationInstance = animationInstances[i];
                        if (isFunction(animationInstance.resume)) {
                            resumePromises.push(animationInstance.resume());
                        }
                    }
                    return this._Promise.all(resumePromises).then(noop);
                };
                /**
                 * A method to cancel the associated animation.
                 */
                AnimationPromise.prototype.cancel = function () {
                    if (this.__animationState === 2) {
                        return this;
                    }
                    var animationInstances = this.__animationInstances, animationInstance, length = animationInstances.length;
                    for (var i = 0; i < length; ++i) {
                        animationInstance = animationInstances[i];
                        if (isFunction(animationInstance.cancel)) {
                            animationInstance.cancel();
                        }
                        if (isFunction(animationInstance.end)) {
                            animationInstance.end();
                        }
                    }
                    this.__animationState = 2;
                    return this;
                };
                /**
                 * A method to determine whether or not this promise has been canceled.
                 */
                AnimationPromise.prototype.isCanceled = function () {
                    return this.__animationState === 2;
                };
                AnimationPromise.prototype.then = function (onFulfilled) {
                    return _super.prototype.then.call(this, onFulfilled);
                };
                AnimationPromise.prototype.catch = function (onRejected) {
                    return _super.prototype.catch.call(this, onRejected);
                };
                return AnimationPromise;
            }(async.Promise));
            animations.AnimationPromise = AnimationPromise;
            /**
             * A class representing a single animation for a single element.
             */
            var BaseAnimation = (function () {
                function BaseAnimation() {
                    /**
                     * An Array of remove functions to dispose of event listeners.
                     */
                    this.__eventListeners = [];
                }
                /**
                 * A function for initializing the animation or any of its properties before start.
                 */
                BaseAnimation.prototype.initialize = function () { };
                /**
                 * A function denoting the start of the animation.
                 */
                BaseAnimation.prototype.start = function () { };
                /**
                 * A function to be called when the animation is over.
                 */
                BaseAnimation.prototype.end = function () {
                    var eventListeners = this.__eventListeners;
                    while (eventListeners.length > 0) {
                        eventListeners.pop()();
                    }
                    if (isFunction(this._resolve)) {
                        this._resolve();
                        this._resolve = null;
                    }
                };
                /**
                 * A function to be called to pause the animation.
                 */
                BaseAnimation.prototype.pause = function () {
                    return this._Promise.resolve();
                };
                /**
                 * A function to be called to resume a paused animation.
                 */
                BaseAnimation.prototype.resume = function () {
                    return this._Promise.resolve();
                };
                /**
                 * A function to be called to let it be known the animation is being cancelled. Although not
                 * necessary, we call end() in this function as well for safe measure.
                 */
                BaseAnimation.prototype.cancel = function () {
                    this.end();
                };
                /**
                 * Adds an event listener of the specified type to this animation's element. Removal of the
                 * event is handled automatically upon animation end.
                 * @param {string} type The type of event to listen to.
                 * @param {EventListener} listener The listener to fire when the event occurs.
                 * @param {boolean} useCapture? Whether to fire the event on the capture or the bubble phase
                 * of event propagation.
                 */
                BaseAnimation.prototype.addEventListener = function (type, listener, useCapture) {
                    if (!isFunction(listener)) {
                        this._log.warn('An animation\'s "addEventListener" must take a function as the second argument.');
                        return noop;
                    }
                    listener = listener.bind(this);
                    var removeListener = this.dom.addEventListener(this.element, type, function (ev) {
                        ev.stopPropagation();
                        listener(ev);
                    }, useCapture), eventListeners = this.__eventListeners;
                    eventListeners.push(removeListener);
                    return function () {
                        removeListener();
                        var index = eventListeners.indexOf(removeListener);
                        if (index !== -1) {
                            eventListeners.splice(index, 1);
                        }
                    };
                };
                /**
                 * Initializes the element and key properties of this animation and grabs a
                 * reference to its resolve function.
                 * @param {Element} element The element on which the animation will occur.
                 * @param {any} options Specified options for the animation.
                 */
                BaseAnimation.prototype.instantiate = function (element, options) {
                    var _this = this;
                    this.element = element;
                    this.options = options;
                    var promise = new AnimationPromise(function (resolve) {
                        _this._resolve = resolve;
                        _this.initialize();
                    });
                    promise.initialize(this);
                    return promise;
                };
                BaseAnimation._inject = {
                    _window: __Window,
                    _compat: __Compat,
                    _log: __Log,
                    _Promise: __Promise,
                    dom: __Dom,
                    utils: __Utils
                };
                return BaseAnimation;
            }());
            animations.BaseAnimation = BaseAnimation;
            /**
             * A class representing a single CSS animation for a single element.
             */
            var CssAnimation = (function (_super) {
                __extends(CssAnimation, _super);
                function CssAnimation() {
                    _super.apply(this, arguments);
                    /**
                     * A set of browser compatible CSS animation events capable of being listened to.
                     */
                    this._animationEvents = this._compat.animationEvents;
                }
                /**
                 * A function to listen to the start of an animation event.
                 * @param {() => void} listener The function to call when the animation begins.
                 */
                CssAnimation.prototype.animationStart = function (listener) {
                    return this.addEventListener(this._animationEvents.$animationStart, listener, false);
                };
                /**
                 * A function to listen to the end of an animation event.
                 * @param {(ev?: AnimationEvent) => void} listener The function to call when the animation ends.
                 */
                CssAnimation.prototype.animationEnd = function (listener) {
                    return this.addEventListener(this._animationEvents.$animationEnd, listener, false);
                };
                /**
                 * A function to listen to the completion of an animation iteration.
                 * @param {(ev?: AnimationEvent) => void} listener The function to call when the animation iteration completes.
                 */
                CssAnimation.prototype.animationIteration = function (listener) {
                    return this.addEventListener(this._animationEvents.$animationIteration, listener, false);
                };
                /**
                 * A function to listen to the start of a transition event.
                 * @param {(ev?: TransitionEvent) => void} listener The function to call when the transition begins.
                 */
                CssAnimation.prototype.transitionStart = function (listener) {
                    return this.addEventListener(this._animationEvents.$transitionStart, listener, false);
                };
                /**
                 * A function to listen to the end of a transition event.
                 * @param {(ev?: TransitionEvent) => void} listener The function to call when the transition ends.
                 */
                CssAnimation.prototype.transitionEnd = function (listener) {
                    return this.addEventListener(this._animationEvents.$transitionEnd, listener, false);
                };
                return CssAnimation;
            }(BaseAnimation));
            animations.CssAnimation = CssAnimation;
            /**
             * A simple CSS Animation class that places the 'plat-animation' class on an
             * element, checks for animation properties, and waits for the animation to end.
             */
            var SimpleCssAnimation = (function (_super) {
                __extends(SimpleCssAnimation, _super);
                function SimpleCssAnimation() {
                    _super.apply(this, arguments);
                    /**
                     * The class name added to the animated element.
                     */
                    this.className = __SimpleAnimation;
                    /**
                     * A function for stopping a potential callback in the animation chain.
                     */
                    this._cancelAnimation = noop;
                }
                /**
                 * Adds the class to initialize the animation.
                 */
                SimpleCssAnimation.prototype.initialize = function () {
                    addClass(this.element, this.className + __INIT_SUFFIX);
                };
                /**
                 * A function denoting the start of the animation.
                 */
                SimpleCssAnimation.prototype.start = function () {
                    var _this = this;
                    this._cancelAnimation = requestAnimationFrameGlobal(function () {
                        var element = _this.element, className = _this.className;
                        if (element.offsetParent === null) {
                            _this._dispose();
                            _this.end();
                            return;
                        }
                        addClass(element, className);
                        var animationId = _this._animationEvents.$animation, options = _this.options || {}, computedStyle = _this._window.getComputedStyle(element, options.pseudo), animationName = computedStyle[(animationId + 'Name')];
                        if (animationName === '' || animationName === 'none' ||
                            computedStyle[(animationId + 'PlayState')] === 'paused') {
                            _this._dispose();
                            _this.end();
                            return;
                        }
                        if (!options.preserveInit) {
                            removeClass(element, className + __INIT_SUFFIX);
                        }
                        _this._cancelAnimation = _this.animationEnd(function () {
                            _this._cancelAnimation = requestAnimationFrameGlobal(function () {
                                _this._dispose();
                                _this.end();
                            });
                        });
                    });
                };
                /**
                 * A function to be called to pause the animation.
                 */
                SimpleCssAnimation.prototype.pause = function () {
                    var _this = this;
                    if (this._cancelAnimation === noop) {
                        return this._Promise.resolve();
                    }
                    var animationEvents = this._compat.animationEvents;
                    return new this._Promise(function (resolve) {
                        requestAnimationFrameGlobal(function () {
                            if (_this._cancelAnimation !== noop) {
                                _this.element.style[(animationEvents.$animation + 'PlayState')] = 'paused';
                            }
                            resolve();
                        });
                    });
                };
                /**
                 * A function to be called to resume a paused animation.
                 */
                SimpleCssAnimation.prototype.resume = function () {
                    var _this = this;
                    if (this._cancelAnimation === noop) {
                        return this._Promise.resolve();
                    }
                    var animationEvents = this._compat.animationEvents;
                    return new this._Promise(function (resolve) {
                        requestAnimationFrameGlobal(function () {
                            if (_this._cancelAnimation !== noop) {
                                _this.element.style[(animationEvents.$animation + 'PlayState')] = 'running';
                            }
                            resolve();
                        });
                    });
                };
                /**
                 * A function to be called to let it be known the animation is being cancelled.
                 * Removes the animation class and the animation "-init" class.
                 */
                SimpleCssAnimation.prototype.cancel = function () {
                    this._cancelAnimation();
                    this._dispose();
                    this.end();
                };
                /**
                 * Removes the animation class and the animation "-init" class.
                 */
                SimpleCssAnimation.prototype._dispose = function () {
                    var className = this.className;
                    removeClass(this.element, className + ' ' + className + __INIT_SUFFIX);
                    this._cancelAnimation = noop;
                };
                return SimpleCssAnimation;
            }(CssAnimation));
            animations.SimpleCssAnimation = SimpleCssAnimation;
            register.animation(__SimpleAnimation, SimpleCssAnimation);
            /**
             * An animation control that fades in an element as defined by the included CSS.
             */
            var FadeIn = (function (_super) {
                __extends(FadeIn, _super);
                function FadeIn() {
                    _super.apply(this, arguments);
                    /**
                     * The class name added to the element fading in.
                     */
                    this.className = __FadeIn;
                }
                return FadeIn;
            }(SimpleCssAnimation));
            animations.FadeIn = FadeIn;
            register.animation(__FadeIn, FadeIn);
            /**
             * An animation control that fades out an element as defined by the included CSS.
             */
            var FadeOut = (function (_super) {
                __extends(FadeOut, _super);
                function FadeOut() {
                    _super.apply(this, arguments);
                    /**
                     * The class name added to the element fading out.
                     */
                    this.className = __FadeOut;
                }
                return FadeOut;
            }(SimpleCssAnimation));
            animations.FadeOut = FadeOut;
            register.animation(__FadeOut, FadeOut);
            /**
             * An animation control that causes an element to enter as defined by the included CSS.
             */
            var Enter = (function (_super) {
                __extends(Enter, _super);
                function Enter() {
                    _super.apply(this, arguments);
                    /**
                     * The class name added to the entering element.
                     */
                    this.className = __Enter;
                }
                return Enter;
            }(SimpleCssAnimation));
            animations.Enter = Enter;
            register.animation(__Enter, Enter);
            /**
             * An animation control that causes an element to leave as defined by the included CSS.
             */
            var Leave = (function (_super) {
                __extends(Leave, _super);
                function Leave() {
                    _super.apply(this, arguments);
                    /**
                     * The class name added to the leaving element.
                     */
                    this.className = __Leave;
                }
                return Leave;
            }(SimpleCssAnimation));
            animations.Leave = Leave;
            register.animation(__Leave, Leave);
            /**
             * An animation control that causes an element to move as defined by the included CSS.
             */
            var Move = (function (_super) {
                __extends(Move, _super);
                function Move() {
                    _super.apply(this, arguments);
                    /**
                     * The class name added to the leaving element.
                     */
                    this.className = __Move;
                }
                return Move;
            }(SimpleCssAnimation));
            animations.Move = Move;
            register.animation(__Move, Move);
            /**
             * A simple CSS Animation class that places the 'plat-transition' class on an
             * element, checks for transition properties, and waits for the transition to end.
             */
            var SimpleCssTransition = (function (_super) {
                __extends(SimpleCssTransition, _super);
                function SimpleCssTransition() {
                    _super.apply(this, arguments);
                    /**
                     * The class name added to the animated element.
                     */
                    this.className = __SimpleTransition;
                    /**
                     * A function for stopping a potential callback in the animation chain.
                     */
                    this._animationCanceled = noop;
                    /**
                     * A regular expression to normalize modified property keys.
                     */
                    this._normalizeRegex = /-/g;
                    /**
                     * A regular expression grab everything that is not a number.
                     */
                    this._nonNumRegex = /[^\-0-9\.]/g;
                    /**
                     * An Object whose keys are the normalized keys of modified properties.
                     */
                    this._normalizedKeys = {};
                    /**
                     * The "transitionend" event handler call count.
                     */
                    this._transitionCount = 0;
                    /**
                     * The user defined "transitionend" event handler call count.
                     */
                    this._count = 0;
                    /**
                     * Denotes whether or not the transition was ever started.
                     */
                    this._started = false;
                    /**
                     * Denotes whether or not the transition changes are being performed
                     * with CSS or with JS through this.options.
                     */
                    this._usingCss = false;
                }
                /**
                 * Adds the class to enable the transition.
                 */
                SimpleCssTransition.prototype.initialize = function () {
                    addClass(this.element, this.className + __INIT_SUFFIX);
                };
                /**
                 * A function denoting the start of the animation.
                 */
                SimpleCssTransition.prototype.start = function () {
                    var _this = this;
                    this._animationCanceled = requestAnimationFrameGlobal(function () {
                        var element = _this.element, className = _this.className;
                        if (element.offsetParent === null) {
                            _this._animate();
                            _this._dispose();
                            _this.end();
                        }
                        addClass(element, className);
                        _this._started = true;
                        var utils = _this.utils, transitionId = _this._animationEvents.$transition, options = _this.options || {}, computedStyle = _this._window.getComputedStyle(element, options.pseudo), properties = _this._properties = computedStyle[(transitionId + 'Property')].split(','), durations = computedStyle[(transitionId + 'Duration')].split(','), length = properties.length, propLength = length, noTransition = false, prop;
                        while (length-- > 0) {
                            prop = properties[length];
                            if (prop === '' || prop === 'none') {
                                properties.splice(length, 1);
                            }
                            else if (propLength > 1 && prop === 'all') {
                                // most likely developer error (extra comma at end of shorthand multi transition declaration) 
                                // so we will splice 
                                _this._log.debug("Improper transition declaration on class \"" + element.className + "\"");
                                properties.splice(length, 1);
                            }
                        }
                        if (properties.length === 0) {
                            noTransition = true;
                        }
                        else {
                            length = durations.length;
                            while (length-- > 0) {
                                prop = durations[length];
                                if (!(prop === '' || prop === '0s')) {
                                    break;
                                }
                            }
                            if (length < 0) {
                                noTransition = true;
                            }
                        }
                        if (noTransition) {
                            _this._animate();
                            _this._dispose();
                            _this.end();
                            return;
                        }
                        if (utils.isNumber(options.count) && options.count > 0) {
                            _this._count = options.count;
                        }
                        if (options.preserveInit === false) {
                            removeClass(element, className + __INIT_SUFFIX);
                        }
                        _this._animationCanceled = _this.transitionEnd(_this._done);
                        if (_this._animate()) {
                            return;
                        }
                        else if (utils.isEmpty(options.properties)) {
                            _this.__cssTransition(computedStyle, durations);
                            return;
                        }
                        _this._dispose();
                        _this.end();
                    });
                };
                /**
                 * A function to be called to let it be known the animation is being cancelled.
                 */
                SimpleCssTransition.prototype.cancel = function () {
                    this._animationCanceled();
                    if (!this._started) {
                        this._animate();
                    }
                    this._dispose();
                    this.end();
                };
                /**
                 * Removes the animation class and the animation "-init" class.
                 */
                SimpleCssTransition.prototype._dispose = function () {
                    var className = this.className;
                    removeClass(this.element, className + ' ' + className + __INIT_SUFFIX);
                    this._animationCanceled = noop;
                };
                /**
                 * A handler for the "transitionend" event. Will clean up the class and resolve the
                 * promise when necessary based on the options that were input.
                 * @param {TransitionEvent} ev? The transition event object.
                 * @param {boolean} immediate? Whether clean up should be immediate or conditional.
                 */
                SimpleCssTransition.prototype._done = function (ev) {
                    var propertyName = ev.propertyName;
                    if (isString(propertyName)) {
                        var count = ++this._transitionCount;
                        propertyName = propertyName.replace(this._normalizeRegex, '').toLowerCase();
                        if ((count < this._count) ||
                            (!this._usingCss && this._normalizedKeys[propertyName] === true &&
                                count < this._properties.length)) {
                            return;
                        }
                    }
                    this._dispose();
                    this.end();
                };
                /**
                 * Animate the element based on the options passed in.
                 */
                SimpleCssTransition.prototype._animate = function () {
                    var style = this.element.style || {}, properties = (this.options || {}).properties || {}, keys = Object.keys(properties), length = keys.length, key, normalizedKeys = this._normalizedKeys, normalizeRegex = this._normalizeRegex, currentProperty, newProperty, unchanged = 0;
                    while (keys.length > 0) {
                        key = keys.shift();
                        currentProperty = style[key];
                        newProperty = properties[key];
                        if (!isString(newProperty)) {
                            unchanged++;
                            continue;
                        }
                        style[key] = newProperty;
                        if (currentProperty === style[key]) {
                            unchanged++;
                        }
                        else {
                            normalizedKeys[key.replace(normalizeRegex, '').toLowerCase()] = true;
                        }
                    }
                    return unchanged < length;
                };
                /**
                 * Handles element transitions that are defined with CSS.
                 * @param {CSSStyleDeclaration} computedStyle The computed style of the
                 * element.
                 * @param {Array<string>} durations The array of declared transition duration values.
                 */
                SimpleCssTransition.prototype.__cssTransition = function (computedStyle, durations) {
                    var _this = this;
                    var transitionId = this._animationEvents.$transition, delays = computedStyle[(transitionId + 'Delay')].split(','), properties = this._properties, property, duration, delay, length = properties.length, computedProperty, normalizedKeys = this._normalizedKeys, normalizeRegex = this._normalizeRegex, i = 0, count = 0, changed = false, defer = this.utils.defer.bind(this, function (prop, computedProp) {
                        if (_this._animationCanceled === noop) {
                            // disposal has already occurred 
                            return;
                        }
                        else if (prop === 'all' || computedStyle[prop] !== computedProp) {
                            // we can't know if the transition started due to 'all' being set and have to rely on this.options.count 
                            // or 
                            // we know the transition started due to the properties being different 
                            changed = true;
                        }
                        if (++count < length || changed) {
                            return;
                        }
                        _this._dispose();
                        _this.end();
                    });
                    this._usingCss = true;
                    this._count = this._count || length;
                    for (; i < length; ++i) {
                        property = properties[i] = properties[i].trim();
                        duration = durations.length > i ? durations[i].trim() : durations[durations.length - 1].trim();
                        delay = delays.length > i ? delays[i].trim() : delays[delays.length - 1].trim();
                        normalizedKeys[property.replace(normalizeRegex, '').toLowerCase()] = true;
                        computedProperty = computedStyle[property];
                        defer(this._toMs(duration) + this._toMs(delay), [property, computedProperty]);
                    }
                };
                /**
                 * A function that converts a string value expressed as either seconds or milliseconds
                 * to a numerical millisecond value.
                 * @param {string} duration The transition duration specified by the computed style.
                 */
                SimpleCssTransition.prototype._toMs = function (duration) {
                    var regex = this._nonNumRegex, units = duration.match(regex)[0], time = Number(duration.replace(regex, ''));
                    if (!this.utils.isNumber(time)) {
                        return 0;
                    }
                    else if (units === 's') {
                        return time * 1000;
                    }
                    else if (units === 'ms') {
                        return time;
                    }
                    return 0;
                };
                return SimpleCssTransition;
            }(CssAnimation));
            animations.SimpleCssTransition = SimpleCssTransition;
            register.animation(__SimpleTransition, SimpleCssTransition);
        })(animations = ui.animations || (ui.animations = {}));
        /**
         * Holds classes and interfaces related to UI control components in platypus.
         */
        var controls;
        (function (controls_1) {
            /**
             * A control that facilitates routing between ViewControls. A Viewport is
             * the link between a ViewControl, a Navigator, and a Router.
             * It registers with a router and receives route change events. It then instantiates the proper viewcontrol and appends it
             * to the DOM.
             */
            var Viewport = (function (_super) {
                __extends(Viewport, _super);
                function Viewport() {
                    _super.apply(this, arguments);
                }
                /**
                 * Allows the viewport to initialize its navigator with the current
                 * router.
                 */
                Viewport.prototype.initialize = function () {
                    var router = this._router = this._Router.currentRouter(), parentViewport = this._getParentViewport(), parentRouter;
                    if (!(isNull(parentViewport) || isNull(parentViewport._router))) {
                        parentRouter = this._parentRouter = parentViewport._router;
                        parentRouter.addChild(router);
                    }
                    this._navigator.initialize(router);
                };
                /**
                 * The viewport registers itself with its router, notifying the
                 * router that it is ready to receive navigation events.
                 */
                Viewport.prototype.loaded = function () {
                    var _this = this;
                    if (isObject(this.options)) {
                        var animate = this.options.value.animate === true;
                        if (animate) {
                            this.dom.addClass(this.element, __Viewport + '-animate');
                        }
                        this._animate = animate;
                    }
                    this._Promise.resolve(this._router.finishNavigating).then(function () {
                        _this._router.register(_this);
                    });
                };
                /**
                 * The viewport's router has matched a route and is asking the viewport if it is safe to
                 * navigate. Here the viewport can instantiate the new view and ask it if it is safe to
                 * navigate to the view.
                 * @param {plat.routing.IRouteInfo} routeInfo Contains the information necessary to instantiate
                 * the view and feed it the route parameters/query.
                 */
                Viewport.prototype.canNavigateTo = function (routeInfo) {
                    var _this = this;
                    var getRouter = this._Router.currentRouter, currentRouter = getRouter(), response = true, injector = this._Injector.getDependency(routeInfo.delegate.view), view = injector.inject(), parameters = routeInfo.parameters, nextRouter = getRouter();
                    if (!isObject(view)) {
                        return this._Promise.resolve(null);
                    }
                    if (currentRouter !== nextRouter) {
                        nextRouter.initialize(this._router);
                        var navigator_1 = acquire(__NavigatorInstance);
                        view.navigator = navigator_1;
                        navigator_1.initialize(nextRouter);
                    }
                    else {
                        view.navigator = this._navigator;
                    }
                    if (isFunction(view.canNavigateTo)) {
                        response = view.canNavigateTo(parameters, routeInfo.query);
                    }
                    return this._Promise.resolve(response).then(function (canNavigateTo) {
                        _this._nextInjector = injector;
                        _this._nextView = view;
                        return canNavigateTo;
                    });
                };
                /**
                 * The viewport's router has matched a route and is asking the viewport if it is safe to
                 * navigate from the current state. Here the viewport can query the current ViewControl and
                 * ask it if it is safe to navigate from its current state.
                 */
                Viewport.prototype.canNavigateFrom = function () {
                    var view = this.controls[0], response = true;
                    if (isObject(view) && isFunction(view.canNavigateFrom)) {
                        response = view.canNavigateFrom();
                    }
                    return this._Promise.resolve(response);
                };
                /**
                 * The viewport's router has matched a route and determined that it is safe to navigate to the
                 * next view. The viewport will now go through the steps to compile and link the next view then append
                 * it to the DOM.
                 * @param {plat.routing.IRouteInfo} routeInfo Contains the information necessary to instantiate
                 * the view and feed it the route parameters/query.
                 */
                Viewport.prototype.navigateTo = function (routeInfo) {
                    var injector = this._nextInjector || this._Injector.getDependency(routeInfo.delegate.view), nodeMap = this._createNodeMap(injector), element = this.element, node = nodeMap.element, parameters = routeInfo.parameters, query = routeInfo.query, control = nodeMap.uiControlNode.control;
                    this._nextInjector = this._nextView = undefined;
                    if (this._animate) {
                        var animator = this._animator, dom_1 = this.dom;
                        if (this._navigator.isBackNavigation()) {
                            dom_1.addClass(node, __NavigatingBack);
                            animator.enter(node, __Enter, element).then(function () {
                                dom_1.removeClass(node, __NavigatingBack);
                            });
                        }
                        else {
                            animator.enter(node, __Enter, element);
                        }
                    }
                    else {
                        element.insertBefore(node, null);
                    }
                    var viewportManager = this._managerCache.read(this.uid), manager = this._ElementManagerFactory.getInstance();
                    viewportManager.children = [];
                    manager.initialize(nodeMap, viewportManager);
                    if (isFunction(control.navigatedTo)) {
                        control.navigatedTo(routeInfo.parameters, query);
                    }
                    manager.setUiControlTemplate();
                    if (control.hasOwnContext) {
                        return manager.observeRootContext(control, manager.fulfillAndLoad);
                    }
                    return manager.fulfillAndLoad();
                };
                /**
                 * The viewport's router has matched a route and determined that it is safe to navigate to the
                 * next view. It is now safe for the viewport to dispose of the current state.
                 */
                Viewport.prototype.navigateFrom = function () {
                    var _this = this;
                    var view = this.controls[0], promise, viewExists = isObject(view);
                    if (viewExists && isFunction(view.navigatingFrom)) {
                        promise = this._Promise.resolve(view.navigatingFrom());
                    }
                    else {
                        promise = this._Promise.resolve();
                    }
                    return promise.catch(function (error) {
                        if (isObject(error)) {
                            if (isString(error.message)) {
                                _this._log.debug(_this.type + ' error: ' + error.message);
                                return;
                            }
                            _this._log.debug(_this.type + ' error: ' + JSON.stringify(error));
                            return;
                        }
                        _this._log.debug(error);
                    }).then(function () {
                        if (!(_this._animate && viewExists)) {
                            Control.dispose(view);
                            return;
                        }
                        var oldElement = view.element;
                        if (_this._navigator.isBackNavigation()) {
                            _this.dom.addClass(oldElement, __NavigatingBack);
                        }
                        _this._animator.leave(oldElement, __Leave).then(function () {
                            Control.dispose(view);
                        });
                    });
                };
                /**
                 * The viewport is going out of scope, so it needs to unregister from its router in order to stop receiving routing
                 * events.
                 */
                Viewport.prototype.dispose = function () {
                    this._router.unregister(this);
                    this._navigator.dispose();
                };
                /**
                 * Creates an INodeMap for a ViewControl in order to compile it.
                 * @param {plat.dependency.Injector<plat.ui.ViewControl>} The injector used to instantiate the ViewControl.
                 */
                Viewport.prototype._createNodeMap = function (injector) {
                    var control = this._nextView || injector.inject(), doc = this._document, type = injector.name, replaceWith = control.replaceWith, node = (isEmpty(replaceWith) || replaceWith === 'any') ?
                        doc.createElement('div') : doc.createElement(replaceWith);
                    node.setAttribute(__Control, type);
                    node.className = __ViewControl;
                    return {
                        element: node,
                        attributes: {},
                        nodes: [],
                        uiControlNode: {
                            control: control,
                            nodeName: type,
                            expressions: [],
                            injector: injector
                        }
                    };
                };
                /**
                 * Finds the first Viewport in the parent chain. This is useful in order to properly initialize the viewport's
                 * router as a child of the parent viewport's router.
                 */
                Viewport.prototype._getParentViewport = function () {
                    var viewport = this.parent, type = this.type;
                    while (!isNull(viewport) && viewport.type !== type) {
                        viewport = viewport.parent;
                    }
                    return viewport;
                };
                Viewport._inject = {
                    _Router: __RouterStatic,
                    _Promise: __Promise,
                    _Injector: __InjectorStatic,
                    _ElementManagerFactory: __ElementManagerFactory,
                    _document: __Document,
                    _managerCache: __ManagerCache,
                    _animator: __Animator,
                    _navigator: __NavigatorInstance
                };
                return Viewport;
            }(TemplateControl));
            controls_1.Viewport = Viewport;
            register.control(__Viewport, Viewport);
            /**
             * A TemplateControl for easily reusing a
             * defined HTML template.
             */
            var Template = (function (_super) {
                __extends(Template, _super);
                /**
                 * The constructor for a Template. Creates the control cache.
                 */
                function Template() {
                    _super.call(this);
                    /**
                     * Removes the `<plat-template>` node from the DOM
                     */
                    this.replaceWith = null;
                    /**
                     * Whether or not this is the first instance of the control,
                     * specifying that it defines the template to copy.
                     */
                    this.__isFirst = false;
                    var _CacheFactory = acquire(__CacheFactory);
                    this.__templateControlCache = _CacheFactory.create(__TemplateControlCache);
                }
                /**
                 * Initializes the creation of the template.
                 */
                Template.prototype.initialize = function () {
                    var optionsObj = this.options || {}, options = optionsObj.value || {}, id = this._id = options.id;
                    if (isNull(id)) {
                        this._log.warn(this.type + ' instantiated without an id option');
                        return;
                    }
                    this._url = options.templateUrl;
                    var templatePromise = this.__templateControlCache.read(id);
                    if (!isNull(templatePromise)) {
                        this.__templatePromise = templatePromise;
                        return;
                    }
                    this.__isFirst = true;
                    this._initializeTemplate();
                };
                /**
                 * Decides if this is a template definition or
                 * a template instance.
                 */
                Template.prototype.loaded = function () {
                    if (!this.__isFirst) {
                        this._waitForTemplateControl(this.__templatePromise);
                    }
                };
                /**
                 * Removes the template from the template cache.
                 */
                Template.prototype.dispose = function () {
                    if (this.__isFirst) {
                        var cache = this.__templateControlCache;
                        cache.remove(this._id);
                        if (cache.info().size === 0) {
                            cache.dispose();
                        }
                    }
                };
                /**
                 * Determines whether a URL or innerHTML is being used,
                 * creates the bindable template, and stores the template
                 * in a template cache for later use.
                 */
                Template.prototype._initializeTemplate = function () {
                    var _this = this;
                    var id = this._id;
                    if (isNull(id)) {
                        return;
                    }
                    var parentNode = this.endNode.parentNode, url = this._url, template;
                    if (!isNull(url)) {
                        template = this._templateCache.read(url);
                        clearNodeBlock(this.elementNodes, parentNode);
                    }
                    else {
                        template = this._document.createDocumentFragment();
                        appendChildren(this.elementNodes, template);
                    }
                    var controlPromise;
                    if (isPromise(template)) {
                        controlPromise = template.catch(function (error) {
                            if (isNull(error)) {
                                return TemplateControl.determineTemplate(_this, url);
                            }
                        }).then(function (template) {
                            _this.bindableTemplates.add(id, template.cloneNode(true));
                            return _this;
                        });
                    }
                    else {
                        this.bindableTemplates.add(id, template.cloneNode(true));
                        controlPromise = this._Promise.resolve(this);
                    }
                    this.__templateControlCache.put(id, controlPromise);
                };
                /**
                 * Waits for the template promise to resolve, then initializes
                 * the binding of the bindable template and places it into the
                 * DOM.
                 * @param {plat.async.IThenable<plat.ui.controls.Template>} templatePromise The promise
                 * associated with the first instance of the control with this ID.
                 */
                Template.prototype._waitForTemplateControl = function (templatePromise) {
                    var _this = this;
                    if (!isPromise(templatePromise)) {
                        return;
                    }
                    templatePromise.then(function (templateControl) {
                        if (!(isNull(_this._url) || (_this._url === templateControl._url))) {
                            _this._log.warn('The specified url: ' + _this._url +
                                ' does not match the original ' + _this.type + ' with id: ' +
                                '"' + _this._id + '". The original url will be loaded.');
                        }
                        _this.__mapBindableTemplates(templateControl);
                        return _this.bindableTemplates.bind(_this._id);
                    }).then(function (clone) {
                        var endNode = _this.endNode;
                        insertBefore(endNode.parentNode, clone, endNode);
                    }).catch(function (error) {
                        postpone(function () {
                            _this._log.warn('Problem resolving ' + _this.type + ' url: ' +
                                error.response);
                        });
                    });
                };
                /**
                 * Maps the bindable templates cache and html templates of the first
                 * control with the proper ID to this control's bindable templates.
                 * @param {plat.ui.controls.Template} control The first of the controls
                 * with this corresponding ID that defined the HTML template to reuse.
                 */
                Template.prototype.__mapBindableTemplates = function (control) {
                    var bindableTemplates = this.bindableTemplates;
                    bindableTemplates.cache = control.bindableTemplates.cache;
                    bindableTemplates.templates = control.bindableTemplates.templates;
                };
                Template._inject = {
                    _Promise: __Promise,
                    _templateCache: __TemplateCache,
                    _document: __Document
                };
                return Template;
            }(TemplateControl));
            controls_1.Template = Template;
            register.control(__Template, Template);
            /**
             * A TemplateControl for inner HTML that contains controls
             * and/or markup and not having it bind or evaluate.
             */
            var Ignore = (function (_super) {
                __extends(Ignore, _super);
                function Ignore() {
                    _super.apply(this, arguments);
                }
                /**
                 * Removes the innerHTML from the DOM and saves it.
                 */
                Ignore.prototype.setTemplate = function () {
                    this.innerTemplate = appendChildren(this.element.childNodes);
                };
                /**
                 * Places the saved innerHTML back into the DOM.
                 */
                Ignore.prototype.loaded = function () {
                    this.element.appendChild(this.innerTemplate.cloneNode(true));
                };
                return Ignore;
            }(TemplateControl));
            controls_1.Ignore = Ignore;
            register.control(__Ignore, Ignore);
            /**
             * A TemplateControl for repeating a block of
             * DOM nodes bound to an array.
             */
            var ForEach = (function (_super) {
                __extends(ForEach, _super);
                /**
                 * The constructor for a ForEach. Creates the itemsLoaded promise.
                 */
                function ForEach() {
                    var _this = this;
                    _super.call(this);
                    /**
                     * The load priority of the control (needs to load before a Bind control).
                     */
                    this.priority = 120;
                    /**
                     * Used to hold the alias tokens for the built-in foreach aliases. You
                     * can overwrite these with the options for
                     * the ForEach control.
                     */
                    this._aliases = {
                        index: __forEachAliasOptions.index,
                        even: __forEachAliasOptions.even,
                        odd: __forEachAliasOptions.odd,
                        first: __forEachAliasOptions.first,
                        last: __forEachAliasOptions.last
                    };
                    /**
                     * The node length of each item's childNodes (innerHTML).
                     * For the ForEach it should be a
                     * single constant number.
                     */
                    this._blockLength = 0;
                    /**
                     * A queue representing all current add operations.
                     */
                    this._addQueue = [];
                    /**
                     * The number of items currently in the list or in the process of being added
                     * or removed from the list.
                     */
                    this._itemLength = 0;
                    /**
                     * Whether or not the Array listener has been set.
                     */
                    this.__listenerSet = false;
                    this.itemsLoaded = new this._Promise(function (resolve, reject) {
                        _this.__resolveFn = resolve;
                        _this.__rejectFn = reject;
                    }).catch(noop);
                }
                /**
                 * Creates a bindable template with the control element's childNodes (innerHTML).
                 */
                ForEach.prototype.setTemplate = function () {
                    this.bindableTemplates.add('item', this.element.childNodes);
                };
                /**
                 * Re-syncs the ForEach child controls and DOM with the new
                 * array.
                 * @param {Array<any>} newValue The new Array
                 * @param {Array<any>} oldValue The old Array
                 */
                ForEach.prototype.contextChanged = function (newValue, oldValue) {
                    if (isArray(newValue)) {
                        this._setListener();
                    }
                    else {
                        newValue = [];
                    }
                    this._executeEvent([{
                            object: newValue,
                            type: 'splice'
                        }]);
                };
                /**
                 * Observes the Array context for changes and adds initial items to the DOM.
                 */
                ForEach.prototype.loaded = function () {
                    var options = this.options, animating = this._animate = !isUndefined(options) && options.value.animate === true, context = this.context;
                    this._container = this.element;
                    if (animating) {
                        this._animationQueue = [];
                    }
                    this._setAliases();
                    if (!isArray(context)) {
                        return;
                    }
                    var addQueue = this._addQueue, itemCount = context.length;
                    var addPromise = this._addItems(0, itemCount, 0).then(function () {
                        var index = addQueue.indexOf(addPromise);
                        if (index !== -1) {
                            addQueue.splice(index, 1);
                        }
                    });
                    addQueue.push(addPromise);
                    this._setListener();
                };
                /**
                 * Removes any potentially held memory.
                 */
                ForEach.prototype.dispose = function () {
                    if (this.utils.isFunction(this.__rejectFn)) {
                        this.__rejectFn();
                        this.__resolveFn = this.__rejectFn = null;
                    }
                    this._animationQueue = this._addQueue = null;
                };
                /**
                 * Sets the alias tokens to use for all the items in the ForEach context Array.
                 */
                ForEach.prototype._setAliases = function () {
                    var options = this.options;
                    if (isUndefined(options)) {
                        return;
                    }
                    var aliases = options.value.aliases;
                    if (!isObject(aliases)) {
                        return;
                    }
                    var _aliases = this._aliases, keys = Object.keys(_aliases), length = keys.length, value;
                    for (var i = 0; i < length; ++i) {
                        value = aliases[keys[i]];
                        if (isString(value)) {
                            _aliases[keys[i]] = value;
                        }
                    }
                };
                /**
                 * Adds new items to the control's element when items are added to
                 * the array.
                 * @param {number} index The point in the array to start adding items.
                 * @param {number} numberOfItems The number of items to add.
                 * @param {number} animateItems The number of items to animate.
                 */
                ForEach.prototype._addItems = function (index, numberOfItems, animateItems) {
                    var _this = this;
                    var max = +(index + numberOfItems), promises = [], initialIndex = index;
                    this._itemLength += numberOfItems;
                    while (index < max) {
                        promises.push(this._bindItem(index++));
                    }
                    if (promises.length > 0) {
                        this.itemsLoaded = this._Promise.all(promises).then(function (templates) {
                            _this._setBlockLength(templates);
                            if (animateItems > 0) {
                                var length_10 = templates.length, container = _this._container;
                                for (var i = 0; i < length_10; ++i) {
                                    if (i < animateItems) {
                                        _this._appendAnimatedItem(templates[i]);
                                    }
                                    else {
                                        container.insertBefore(templates[i], null);
                                    }
                                }
                            }
                            else {
                                _this._appendItems(templates);
                            }
                            _this._updateResource(initialIndex - 1);
                            if (isFunction(_this.__resolveFn)) {
                                _this.__resolveFn();
                                _this.__resolveFn = _this.__rejectFn = null;
                            }
                        }).catch(function (error) {
                            postpone(function () {
                                if (isString(error)) {
                                    error = new Error(error);
                                }
                                _this._log.error(error);
                            });
                        });
                    }
                    return this.itemsLoaded;
                };
                /**
                 * Adds an Array of items to the element without animating.
                 * @param {Array<Node>} items The Array of items to add.
                 */
                ForEach.prototype._appendItems = function (items) {
                    appendChildren(items, this._container);
                };
                /**
                 * Adds an item to the control's element animating its elements.
                 * @param {DocumentFragment} item The HTML fragment representing a single item.
                 */
                ForEach.prototype._appendAnimatedItem = function (item) {
                    if (!isNode(item)) {
                        return;
                    }
                    var animationQueue = this._animationQueue, animation = {
                        animation: this._animator.enter(item, __Enter, this._container).then(function () {
                            var index = animationQueue.indexOf(animation);
                            if (index === -1) {
                                return;
                            }
                            animationQueue.splice(index, 1);
                        }),
                        op: null
                    };
                    animationQueue.push(animation);
                };
                /**
                 * Removes items from the control's element.
                 * @param {number} index The index to start disposing from.
                 * @param {number} numberOfItems The number of items to remove.
                 */
                ForEach.prototype._removeItems = function (index, numberOfItems) {
                    var dispose = TemplateControl.dispose, controls = this.controls, last = index + numberOfItems;
                    while (last-- > index) {
                        dispose(controls[last]);
                    }
                    this._updateResource(controls.length - 1);
                };
                /**
                 * Binds the item to a template at that index.
                 */
                ForEach.prototype._bindItem = function (index) {
                    return this.bindableTemplates.bind('item', index, this._getAliases(index));
                };
                /**
                 * Sets the corresponding block length for animation.
                 */
                ForEach.prototype._setBlockLength = function (templates) {
                    if (this._blockLength > 0 || templates.length === 0) {
                        return;
                    }
                    this._blockLength = templates[0].childNodes.length;
                };
                /**
                 * Updates a child resource object when
                 * the array changes.
                 * @param {number} index The control whose resources we will update.
                 */
                ForEach.prototype._updateResource = function (index) {
                    var controls = this.controls;
                    if (index < 0 || index >= controls.length) {
                        return;
                    }
                    controls[index].resources.add(this._getAliases(index));
                };
                /**
                 * Sets a listener for the changes to the array.
                 */
                ForEach.prototype._setListener = function () {
                    if (!this.__listenerSet) {
                        this.observeArray(this._executeEvent);
                        this.__listenerSet = true;
                    }
                };
                /**
                 * Receives an event when a method has been called on an array and maps the array
                 * method to its associated method handler.
                 * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
                 */
                ForEach.prototype._executeEvent = function (changes) {
                    var method = '_' + changes[0].type;
                    if (isFunction(this[method])) {
                        this[method](changes);
                    }
                };
                /**
                 * Returns a resource alias object for an item in the array. The
                 * resource object contains index:number, even:boolean, odd:boolean,
                 * first:boolean, and last:boolean.
                 * @param {number} index The index used to create the resource aliases.
                 */
                ForEach.prototype._getAliases = function (index) {
                    var isEven = (index & 1) === 0, aliases = {}, _aliases = this._aliases, type = __LITERAL_RESOURCE;
                    aliases[_aliases.index] = {
                        value: index,
                        type: type
                    };
                    aliases[_aliases.even] = {
                        value: isEven,
                        type: type
                    };
                    aliases[_aliases.odd] = {
                        value: !isEven,
                        type: type
                    };
                    aliases[_aliases.first] = {
                        value: index === 0,
                        type: type
                    };
                    aliases[_aliases.last] = {
                        value: index === (this.context.length - 1),
                        type: type
                    };
                    return aliases;
                };
                /**
                 * Handles items being pushed into the array.
                 * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
                 */
                ForEach.prototype._push = function (changes) {
                    var change = changes[0], addQueue = this._addQueue, itemCount = change.addedCount;
                    var addPromise = this._addItems(change.index, itemCount, this._animate ? itemCount : 0).then(function () {
                        var index = addQueue.indexOf(addPromise);
                        if (index !== -1) {
                            addQueue.splice(index, 1);
                        }
                    });
                    addQueue.push(addPromise);
                };
                /**
                 * Handles items being popped off the array.
                 * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
                 */
                ForEach.prototype._pop = function (changes) {
                    var _this = this;
                    var change = changes[0], start = change.object.length;
                    if (change.removed.length === 0) {
                        return;
                    }
                    var removeIndex = change.object.length;
                    if (this._itemLength > 0) {
                        this._itemLength--;
                    }
                    this._Promise.all(this._addQueue).then(function () {
                        if (_this._animate) {
                            _this._animateItems(start, 1, __Leave, 'leave', false).then(function () {
                                _this._removeItems(removeIndex, 1);
                            });
                            return;
                        }
                        _this._removeItems(removeIndex, 1);
                    });
                };
                /**
                 * Handles items being unshifted into the array.
                 * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
                 */
                ForEach.prototype._unshift = function (changes) {
                    var change = changes[0], addedCount = change.addedCount, addQueue = this._addQueue;
                    if (this._animate) {
                        var animationQueue = this._animationQueue, animationLength = animationQueue.length;
                        this._animateItems(0, addedCount, __Enter, null, animationLength > 0 && animationQueue[animationLength - 1].op === 'clone');
                    }
                    var addPromise = this._addItems(change.object.length - addedCount, addedCount, 0).then(function () {
                        var index = addQueue.indexOf(addPromise);
                        if (index !== -1) {
                            addQueue.splice(index, 1);
                        }
                    });
                    addQueue.push(addPromise);
                };
                /**
                 * Handles items being shifted off the array.
                 * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
                 */
                ForEach.prototype._shift = function (changes) {
                    var _this = this;
                    var addQueue = this._addQueue, change = changes[0];
                    if (change.removed.length === 0) {
                        return;
                    }
                    else if (this._animate) {
                        if (addQueue.length === 0) {
                            addQueue = addQueue.concat([this._animateItems(0, 1, __Leave, 'clone', true)]);
                        }
                    }
                    var removeIndex = change.object.length;
                    if (this._itemLength > 0) {
                        this._itemLength--;
                    }
                    this._Promise.all(addQueue).then(function () {
                        _this._removeItems(removeIndex, 1);
                    });
                };
                /**
                 * Handles adding/removing items when an array is spliced.
                 * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
                 */
                ForEach.prototype._splice = function (changes) {
                    var _this = this;
                    var change = changes[0], addCount = change.addedCount, addQueue = this._addQueue, currentLength = this._itemLength, addPromise, animating = this._animate;
                    if (isNull(addCount)) {
                        if (animating) {
                            this._cancelCurrentAnimations();
                        }
                        var newLength = change.object.length, itemCount_1 = currentLength - newLength;
                        if (newLength > currentLength) {
                            // itemCount will be negative 
                            addPromise = this._addItems(currentLength, -itemCount_1, 0).then(function () {
                                var index = addQueue.indexOf(addPromise);
                                if (index !== -1) {
                                    addQueue.splice(index, 1);
                                }
                            });
                            addQueue.push(addPromise);
                        }
                        else if (currentLength > newLength) {
                            if (currentLength >= itemCount_1) {
                                this._itemLength -= itemCount_1;
                            }
                            else {
                                this._itemLength = 0;
                            }
                            this._Promise.all(addQueue).then(function () {
                                _this._removeItems(currentLength - itemCount_1, itemCount_1);
                            });
                        }
                        return;
                    }
                    var removeCount = change.removed.length, animationQueue = this._animationQueue;
                    if (addCount > removeCount) {
                        var itemAddCount = addCount - removeCount, animationCount = void 0;
                        if (animating) {
                            animationCount = addCount;
                            var animationLength = animationQueue.length, startIndex = change.index;
                            if (currentLength < addCount - startIndex) {
                                animationCount = currentLength - startIndex;
                            }
                            this._animateItems(startIndex, animationCount, __Enter, null, animationLength > 0 && animationQueue[animationLength - 1].op === 'clone');
                            animationCount = addCount - animationCount;
                        }
                        else {
                            animationCount = 0;
                        }
                        addPromise = this._addItems(change.object.length - itemAddCount, itemAddCount, animationCount).then(function () {
                            var index = addQueue.indexOf(addPromise);
                            if (index !== -1) {
                                addQueue.splice(index, 1);
                            }
                        });
                        addQueue.push(addPromise);
                    }
                    else if (removeCount > addCount) {
                        var adding_1 = addCount > 0;
                        if (animating && !adding_1 && addQueue.length === 0) {
                            addQueue = addQueue.concat([this._animateItems(change.index, removeCount, __Leave, 'clone', true)]);
                        }
                        var deleteCount_1 = removeCount - addCount;
                        if (currentLength >= deleteCount_1) {
                            this._itemLength -= deleteCount_1;
                        }
                        else {
                            this._itemLength = 0;
                        }
                        this._Promise.all(addQueue).then(function () {
                            if (animating && adding_1) {
                                var animLength = animationQueue.length;
                                _this._animateItems(change.index, addCount, __Enter, null, animLength > 0 && animationQueue[animLength - 1].op === 'clone');
                            }
                            _this._removeItems(currentLength - deleteCount_1, deleteCount_1);
                        });
                    }
                };
                /**
                 * Grabs the total blocklength of the specified items.
                 * @param {number} startIndex The starting index of items.
                 * @param {number} numberOfItems The number of consecutive items.
                 */
                ForEach.prototype._calculateBlockLength = function (startIndex, numberOfItems) {
                    return this._blockLength;
                };
                /**
                 * Animates the indicated items.
                 * @param {number} startIndex The starting index of items to animate.
                 * @param {number} numberOfItems The number of consecutive items to animate.
                 * @param {string} key The animation key/type.
                 * @param {string} animationOp Denotes animation operation.
                 * @param {boolean} cancel Whether or not to cancel the current animation before beginning this one.
                 */
                ForEach.prototype._animateItems = function (startIndex, numberOfItems, key, animationOp, cancel) {
                    var blockLength = this._calculateBlockLength();
                    if (blockLength === 0) {
                        return this._Promise.resolve();
                    }
                    var start = startIndex * blockLength;
                    switch (animationOp) {
                        case 'clone':
                            return this._handleClonedContainerAnimation(start, numberOfItems * blockLength + start, key, cancel === true);
                        case 'leave':
                            return this._handleLeave(start, numberOfItems * blockLength + start, key);
                        default:
                            return this._handleSimpleAnimation(start, numberOfItems * blockLength + start, key, cancel === true);
                    }
                };
                /**
                 * Handles a simple animation of a block of elements.
                 * @param {number} startNode The starting childNode of the ForEach to animate.
                 * @param {number} endNode The ending childNode of the ForEach to animate.
                 * @param {string} key The animation key/type.
                 * @param {boolean} cancel Whether or not to cancel the current animation before beginning this one.
                 */
                ForEach.prototype._handleSimpleAnimation = function (startNode, endNode, key, cancel) {
                    var container = this._container, nodes = Array.prototype.slice.call(container.childNodes, startNode, endNode);
                    if (nodes.length === 0) {
                        return this._Promise.resolve();
                    }
                    var animationQueue = this._animationQueue, animationCreation = this._animator.create(nodes, key), animationPromise = animationCreation.current.then(function () {
                        var index = animationQueue.indexOf(animation);
                        if (index === -1) {
                            return;
                        }
                        animationQueue.splice(index, 1);
                    }), callback = function () {
                        animationCreation.previous.then(function () {
                            animationPromise.start();
                        });
                        return animationPromise;
                    };
                    var animation = {
                        animation: animationPromise,
                        op: null
                    };
                    if (cancel && animationQueue.length > 0) {
                        var cancelPromise = this._cancelCurrentAnimations().then(callback);
                        animationQueue.push(animation);
                        return cancelPromise;
                    }
                    animationQueue.push(animation);
                    return callback();
                };
                /**
                 * Handles a simple animation of a block of elements.
                 * @param {number} startNode The starting childNode of the ForEach to animate.
                 * @param {number} endNode The ending childNode of the ForEach to animate.
                 * @param {string} key The animation key/type.
                 */
                ForEach.prototype._handleLeave = function (startNode, endNode, key) {
                    var container = this._container, nodes = Array.prototype.slice.call(container.childNodes, startNode, endNode);
                    if (nodes.length === 0) {
                        return this._Promise.resolve();
                    }
                    var animationQueue = this._animationQueue, animationPromise = this._animator.leave(nodes, key).then(function () {
                        var index = animationQueue.indexOf(animation);
                        if (index === -1) {
                            return;
                        }
                        animationQueue.splice(index, 1);
                    });
                    var animation = {
                        animation: animationPromise,
                        op: 'leave'
                    };
                    animationQueue.push(animation);
                    return animationPromise;
                };
                /**
                 * Handles a simple animation of a block of elements.
                 * @param {number} startNode The starting childNode of the ForEach to animate.
                 * @param {number} endNode The ending childNode of the ForEach to animate.
                 * @param {string} key The animation key/type.
                 * @param {boolean} cancel Whether or not to cancel the current animation before beginning this one.
                 */
                ForEach.prototype._handleClonedContainerAnimation = function (startNode, endNode, key, cancel) {
                    var container = this._container, clonedContainer = container.cloneNode(true), nodes = Array.prototype.slice.call(clonedContainer.childNodes, startNode, endNode);
                    if (nodes.length === 0) {
                        return this._Promise.resolve();
                    }
                    var parentNode, animationQueue = this._animationQueue, animationCreation = this._animator.create(nodes, key), animationPromise = animationCreation.current.then(function () {
                        var index = animationQueue.indexOf(animation);
                        if (index > -1) {
                            animationQueue.splice(index, 1);
                        }
                        if (isNull(parentNode)) {
                            return;
                        }
                        parentNode.replaceChild(container, clonedContainer);
                    }), callback = function () {
                        parentNode = container.parentNode;
                        if (isNull(parentNode) || animationPromise.isCanceled()) {
                            return animationPromise;
                        }
                        parentNode.replaceChild(clonedContainer, container);
                        animationCreation.previous.then(function () {
                            animationPromise.start();
                        });
                        return animationPromise;
                    };
                    var animation = {
                        animation: animationPromise,
                        op: 'clone'
                    };
                    if (cancel && animationQueue.length > 0) {
                        var cancelPromise = this._cancelCurrentAnimations().then(callback);
                        animationQueue.push(animation);
                        return cancelPromise;
                    }
                    animationQueue.push(animation);
                    return callback();
                };
                /**
                 * Cancels all current animations.
                 */
                ForEach.prototype._cancelCurrentAnimations = function () {
                    var animationQueue = this._animationQueue, animations = [], length = animationQueue.length;
                    for (var i = 0; i < length; ++i) {
                        animations.push(animationQueue[i].animation.cancel());
                    }
                    return this._Promise.all(animations);
                };
                ForEach._inject = {
                    _animator: __Animator,
                    _Promise: __Promise
                };
                return ForEach;
            }(TemplateControl));
            controls_1.ForEach = ForEach;
            register.control(__ForEach, ForEach);
            /**
             * A special type of TemplateControl for managing meta tags, useful for SEO. This
             * control will not exist unless you register it as a control with the name 'head'. It is static, so you can inject
             * it into other components and get access to its properties.
             */
            var Head = (function (_super) {
                __extends(Head, _super);
                function Head() {
                    _super.apply(this, arguments);
                    /**
                     * Rather than be replaced by a 'div', this control wants to be a 'head' element.
                     */
                    this.replaceWith = __Head;
                    /**
                     * A reference to all the structured data elements added to the DOM for this page.
                     */
                    this._structuredDataElements = [];
                }
                /**
                 * Registers for the navigating event to know when to remove all the elements so they
                 * don't bleed onto the next page.
                 */
                Head.prototype.initialize = function () {
                    var _this = this;
                    this.on(__navigating, function () {
                        _this._removeAllElements();
                    });
                };
                /**
                 * Makes sure all the elements exist.
                 */
                Head.prototype.setTemplate = function () {
                    var meta = __Meta, title = __Title, link = __MetaLink, author = __Author, type = __MetaType, creator = __Creator, image = __MetaImage, video = __MetaVideo, description = __Description, url = __Url, og = __OpenGraph, article = __Article, twitter = __Twitter;
                    this._titleElement = this._createElement(title);
                    this._ogTitleElement = this._createElement(meta, og + title);
                    this._twitterTitleElement = this._createElement(meta, twitter + title);
                    this._descriptionElement = this._createElement(meta, description);
                    this._ogDescriptionElement = this._createElement(meta, og + description);
                    this._twitterDescriptionElement = this._createElement(meta, twitter + description);
                    this._ogUrlElement = this._createElement(meta, og + url);
                    this._twitterUrlElement = this._createElement(meta, twitter + url);
                    this._authorElement = this._createElement(meta, author);
                    this._googleAuthorElement = this._createElement(link, author);
                    this._fbAuthorElement = this._createElement(meta, article + author);
                    this._twitterCreatorElement = this._createElement(meta, twitter + creator);
                    this._ogTypeElement = this._createElement(meta, og + type);
                };
                /**
                 * Gets the title or sets the title elements.
                 * @param {string} title? If supplied, the title elements will be set to this value.
                 */
                Head.prototype.title = function (title) {
                    if (!isString(title)) {
                        return this._getContent(this._titleElement);
                    }
                    this._titleElement.innerText = title;
                    this._setContent([
                        this._ogTitleElement,
                        this._twitterTitleElement
                    ], title);
                    return title;
                };
                /**
                 * Gets the description or sets the description elements.
                 * @param {string} description? If supplied, the description elements will be set to this value.
                 */
                Head.prototype.description = function (description) {
                    if (!isString(description)) {
                        return this._getContent(this._descriptionElement);
                    }
                    this._setContent([
                        this._descriptionElement,
                        this._ogDescriptionElement,
                        this._twitterDescriptionElement
                    ], description);
                    return description;
                };
                /**
                 * Gets the url or sets the url elements.
                 * @param {string} url? If supplied, the url elements will be set to this value.
                 */
                Head.prototype.url = function (url) {
                    if (!isString(url)) {
                        return this._getContent(this._ogUrlElement);
                    }
                    this._setContent([
                        this._ogUrlElement,
                        this._twitterUrlElement
                    ], url);
                    return url;
                };
                /**
                 * Gets the author or sets the author elements.
                 * @param {string} author? If supplied, the author elements will be set to this value. The value should be the
                 * display name of the content author.
                 */
                Head.prototype.author = function (author) {
                    if (!isString(author)) {
                        return this._getContent(this._authorElement);
                    }
                    this._setContent([
                        this._authorElement,
                    ], author);
                    return author;
                };
                /**
                 * Gets the author or sets the author elements.
                 * @param {string} author? If supplied, the author elements will be set to this value. The value should be the
                 * Google+ profile url for the author.
                 */
                Head.prototype.googleAuthor = function (author) {
                    if (!isString(author)) {
                        return this._getContent(this._googleAuthorElement);
                    }
                    this._setContent([
                        this._googleAuthorElement,
                    ], author);
                    return author;
                };
                /**
                 * Gets the author or sets the author elements. This method is for use with the Facebook profile authors.
                 * @param {string} author? If supplied, the author elements will be set to this value. The value should be
                 * the `https://www.facebook.com/username` account, and make sure the user supports followers.
                 */
                Head.prototype.fbAuthor = function (author) {
                    if (!isString(author)) {
                        return this._getContent(this._fbAuthorElement);
                    }
                    this._setContent([
                        this._fbAuthorElement
                    ], author);
                    return author;
                };
                /**
                 * Gets the creator or sets the creator elements
                 * @param {string} creator? If supplied, the creator elements will be set to this value. The
                 * value should be the twitter `@username` of the creator
                 */
                Head.prototype.twitterCreator = function (creator) {
                    if (!isString(creator)) {
                        return this._getContent(this._twitterCreatorElement);
                    }
                    this._setContent([
                        this._twitterCreatorElement
                    ], creator);
                    return creator;
                };
                /**
                 * Gets the type or sets the type elements.
                 * @param {string} type? If supplied, the image elements will be set to this value.
                 */
                Head.prototype.fbType = function (type) {
                    if (!isString(type)) {
                        return this._getContent(this._ogTypeElement);
                    }
                    this._setContent([
                        this._ogTypeElement
                    ], type);
                    return type;
                };
                /**
                 * Sets the image elements.
                 * @param {Array<string>} images For each image, a tag will be created
                 */
                Head.prototype.images = function (images) {
                    var _this = this;
                    if (!isArray(images)) {
                        return;
                    }
                    var meta = __Meta, og = __OpenGraph, twitter = __Twitter, ogElement, twitterElement;
                    forEach(function (image) {
                        ogElement = _this._createElement(meta, og + __MetaImage, true);
                        twitterElement = _this._createElement(meta, twitter + __MetaImage, true);
                        image = _this._browser.urlUtils(image).href;
                        _this._setContent([
                            ogElement,
                            twitterElement
                        ], image);
                    }, images);
                };
                /**
                 * Sets the video elements.
                 * @param {Array<string>} videos For each video, a tag will be created
                 */
                Head.prototype.videos = function (videos) {
                    var _this = this;
                    if (!isArray(videos)) {
                        return;
                    }
                    var meta = __Meta, og = __OpenGraph, metaVideo = __MetaVideo, _browser = this._browser, ogElement;
                    forEach(function (video) {
                        ogElement = _this._createElement(meta, og + metaVideo, true);
                        video = _browser.urlUtils(video).href;
                        _this._setContent([
                            ogElement
                        ], video);
                    }, videos);
                };
                /**
                 * Adds a structured data ld+json element to the DOM.
                 * @param {any} The object, it will be stringified and put in the ld+json tag.
                 */
                Head.prototype.structuredData = function (obj) {
                    if (isEmpty(obj)) {
                        return;
                    }
                    var el = this._document.createElement('script'), sibling = this._titleElement.nextSibling;
                    el.setAttribute('type', 'application/ld+json');
                    el.textContent = JSON.stringify(obj);
                    this._structuredDataElements.push(el);
                    this.dom.insertBefore(this.element, el, sibling);
                };
                /**
                 * Takes in one or more BlogPosting <http://schema.org/BlogPosting> objects and sets them as ld+json tags in the head.
                 * @param {plat.ui.controls.IBlogPosting} The posting object, it will be stringified and put in the ld+json tag.
                 */
                Head.prototype.blogPostings = function () {
                    var postings = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        postings[_i - 0] = arguments[_i];
                    }
                    for (var i = 0, length_11 = postings.length; i < length_11; ++i) {
                        this.structuredData(postings[i]);
                    }
                };
                /**
                 * Sets the url elements initially.
                 */
                Head.prototype.loaded = function () {
                    this.url(this._browser.url());
                };
                /**
                 * Sets the url elements.
                 */
                Head.prototype.navigated = function (url) {
                    this.url(url);
                };
                /**
                 * Gets the innerText/content/href of an element.
                 * @param {HTMLElement} element The element from which to get the content.
                 */
                Head.prototype._getContent = function (element) {
                    var nodeName = element.nodeName.toLowerCase();
                    if (nodeName === __Title) {
                        return element.innerText;
                    }
                    else if (nodeName === __Meta) {
                        return element.getAttribute(__Content);
                    }
                    else if (nodeName === __MetaLink) {
                        return element.getAttribute(__MetaHref);
                    }
                };
                /**
                 * Sets the innerText/content/href of a list elements. If an element is not in the DOM, it
                 * is added to the dom right after the <title /> element.
                 * @param {Array<HTMLElement>} elements The elements for which to set values.
                 */
                Head.prototype._setContent = function (elements, value) {
                    var el = this.element, nodes = Array.prototype.slice.call(el.children), length = elements.length, content = __Content, href = __MetaHref, sibling = this._titleElement.nextSibling, dom = this.dom, nodeName, element;
                    for (var i = 0; i < length; ++i) {
                        element = elements[i];
                        nodeName = element.nodeName.toLowerCase();
                        if (nodeName === __Meta) {
                            element.setAttribute(content, value);
                        }
                        else {
                            element.setAttribute(href, value);
                        }
                        if (nodes.indexOf(element) === -1) {
                            dom.insertBefore(el, element, sibling);
                        }
                    }
                };
                /**
                 * Creates an element with the specified tag and name. The name corresponds to
                 * the type of the meta/link tag (i.e. title/description/author etc), and is also the
                 * value that will be set for the proper attribute. The attribute is determined based on
                 * the tag/name combination.
                 * @param {string} tag The tag name for the element.
                 * @param {string} name? The name corresponding to the type of meta/link tag.
                 * @param {boolean} multiple? Whether or not there can be multiple of this tag/name in the dom
                 */
                Head.prototype._createElement = function (tag, name, multiple) {
                    var el, hasName = isString(name), attr = (hasName && (name.indexOf(__OpenGraph) === 0 || name.indexOf(__Article) === 0)) ? __MetaProperty : __MetaName, element = this.element;
                    if (tag === __MetaLink) {
                        attr = __Rel;
                    }
                    if (!multiple && hasName) {
                        el = element.querySelector(tag + '[' + attr + '="' + name + '"]');
                    }
                    else if (!multiple) {
                        el = element.querySelector(tag);
                    }
                    if (!isNode(el)) {
                        el = this._document.createElement(tag);
                    }
                    if (hasName) {
                        el.setAttribute(attr, name);
                    }
                    return el;
                };
                /**
                 * Removes all the unnecessary elements from the <head /> to avoid having
                 * incorrect tags on the page.
                 */
                Head.prototype._removeAllElements = function () {
                    var slice = Array.prototype.slice, og = this._document.head.querySelectorAll('meta[' + __MetaProperty + '^="' + __OpenGraph + '"]'), twitter = this._document.head.querySelectorAll('meta[' + __MetaName + '^="' + __Twitter + '"]');
                    this._removeElements.apply(this, [
                        this._descriptionElement,
                        this._authorElement,
                        this._googleAuthorElement
                    ].concat(slice.call(og), slice.call(twitter), slice.call(this._structuredDataElements)));
                    this._structuredDataElements = [];
                };
                /**
                 * Removes elements from the <head />
                 */
                Head.prototype._removeElements = function () {
                    var elements = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        elements[_i - 0] = arguments[_i];
                    }
                    var el = this.element, nodes = Array.prototype.slice.call(el.children), length = elements.length, element;
                    for (var i = 0; i < length; ++i) {
                        element = elements[i];
                        if (nodes.indexOf(element) !== -1) {
                            el.removeChild(element);
                        }
                    }
                };
                Head._inject = {
                    _document: __Document,
                    _browser: __Browser
                };
                return Head;
            }(ui.TemplateControl));
            controls_1.Head = Head;
            /**
             * A TemplateControl for adding HTML to the
             * DOM through bound context strings.
             */
            var InnerHtml = (function (_super) {
                __extends(InnerHtml, _super);
                function InnerHtml() {
                    _super.apply(this, arguments);
                }
                /**
                 * Clears the inner template if one exists.
                 */
                InnerHtml.prototype.setTemplate = function () {
                    this.dom.clearNode(this.element);
                };
                /**
                 * Checks options and initializes bindings.
                 */
                InnerHtml.prototype.loaded = function () {
                    var options = this.options;
                    if (!isObject(options)) {
                        return;
                    }
                    this._onOptionsChanged(options.value);
                    options.observe(this._onOptionsChanged);
                };
                /**
                 * The function called when any of the options for this control changes.
                 * @param {IInnerHtmlOptions} newValue The new value of the options property.
                 * @param {IInnerHtmlOptions} oldValue? The old value of the options property.
                 */
                InnerHtml.prototype._onOptionsChanged = function (newValue, oldValue) {
                    var _this = this;
                    if (newValue === oldValue) {
                        return;
                    }
                    else if (!isObject(newValue)) {
                        this._log.debug('plat-options for ' + this.type + ' must be an object.');
                        return;
                    }
                    var html = newValue.html;
                    if (html === this._html) {
                        return;
                    }
                    this._html = html;
                    var htmlIsString = isString(html);
                    if (isNull(html) || (htmlIsString && html.trim() === '')) {
                        if (this.controls.length > 0) {
                            this._TemplateControlFactory.dispose(this.controls[0]);
                        }
                        else {
                            this.dom.clearNode(this.element);
                        }
                        return;
                    }
                    else if (!htmlIsString) {
                        this._log.debug('Trying to bind a non-string value to ' + this.type + '.');
                        return;
                    }
                    else if (newValue.compile === true) {
                        var hasControl_1 = this.controls.length > 0;
                        this.bindableTemplates.once(html).then(function (template) {
                            if (hasControl_1) {
                                _this._TemplateControlFactory.dispose(_this.controls[0]);
                            }
                            else {
                                _this.dom.clearNode(_this.element);
                            }
                            _this.element.insertBefore(template, null);
                        });
                        return;
                    }
                    setInnerHtml(this.element, html);
                };
                InnerHtml._inject = {
                    _TemplateControlFactory: __TemplateControlFactory
                };
                return InnerHtml;
            }(TemplateControl));
            controls_1.InnerHtml = InnerHtml;
            register.control(__Html, InnerHtml);
            /**
             * A BindControl for binding an HTML select element
             * to an Array context.
             */
            var Select = (function (_super) {
                __extends(Select, _super);
                /**
                 * The constructor for a Select. Creates the itemsLoaded promise.
                 */
                function Select() {
                    var _this = this;
                    _super.call(this);
                    /**
                     * Replaces the `<plat-select>` node with
                     * a <select> node.
                     */
                    this.replaceWith = 'select';
                    /**
                     * The load priority of the control (needs to load before a Bind control).
                     */
                    this.priority = 120;
                    /**
                     * An object that keeps track of unique
                     * optgroups.
                     */
                    this.groups = {};
                    this.itemsLoaded = new this._Promise(function (resolve, reject) {
                        _this.__resolveFn = resolve;
                        _this.__rejectFn = reject;
                    }).catch(noop);
                }
                /**
                 * Creates the bindable option template and grouping
                 * template if necessary.
                 */
                Select.prototype.setTemplate = function () {
                    this.bindableTemplates.add('option', this.element.childNodes);
                    var options = this.options || {}, platOptions = options.value || {}, defaultOptionValues = platOptions.default;
                    if (isObject(defaultOptionValues)) {
                        var defaultOption = this._document.createElement('option'), defaultValue = defaultOptionValues.value, defaultTextContent = defaultOptionValues.textContent;
                        defaultOption.value = isUndefined(defaultValue) ? defaultTextContent : defaultValue;
                        defaultOption.textContent = isUndefined(defaultTextContent) ? defaultValue : defaultTextContent;
                        this.element.insertBefore(defaultOption, null);
                    }
                    if (!isNull(platOptions.group)) {
                        var group = this._group = platOptions.group, optionGroup = this._document.createElement('optgroup');
                        optionGroup.label = __startSymbol + group + __endSymbol;
                        this.bindableTemplates.add('group', optionGroup);
                        this._isGrouped = true;
                    }
                    else {
                        this._isGrouped = false;
                    }
                };
                /**
                 * Re-observes the new array context and modifies
                 * the options accordingly.
                 * @param {Array<any>} newValue The new array context.
                 * @param {Array<any>} oldValue The old array context.
                 */
                Select.prototype.contextChanged = function (newValue, oldValue) {
                    var _this = this;
                    if (isEmpty(newValue)) {
                        if (!isEmpty(oldValue)) {
                            this.itemsLoaded.then(function () {
                                _this._removeItems(_this.controls.length);
                            });
                        }
                        return;
                    }
                    else if (!isArray(newValue)) {
                        return;
                    }
                    var newLength = isArray(newValue) ? newValue.length : 0, oldLength = isArray(oldValue) ? oldValue.length : 0;
                    this._setListener();
                    if (newLength > oldLength) {
                        this._addItems(newLength - oldLength, oldLength);
                    }
                    else if (newLength < oldLength) {
                        this._removeItems(oldLength - newLength);
                    }
                };
                /**
                 * Observes the new array context and adds
                 * the options accordingly.
                 */
                Select.prototype.loaded = function () {
                    if (isUndefined(this._isGrouped)) {
                        var options = this.options || {}, platOptions = options.value || {};
                        this._isGrouped = !isNull((this._group = platOptions.group));
                    }
                    this._defaultOption = this.element.firstElementChild;
                    var context = this.context;
                    if (!isArray(context)) {
                        return;
                    }
                    this._addItems(context.length, 0);
                    this._setListener();
                };
                /**
                 * Removes any potentially held memory.
                 */
                Select.prototype.dispose = function () {
                    _super.prototype.dispose.call(this);
                    if (this.utils.isFunction(this.__rejectFn)) {
                        this.__rejectFn();
                        this.__resolveFn = this.__rejectFn = null;
                    }
                    this._defaultOption = null;
                };
                /**
                 * A function that allows this control to observe both the bound property itself as well as
                 * potential child properties if being bound to an object.
                 * @param {plat.observable.IImplementTwoWayBinding} binder The control that facilitates the
                 * databinding.
                 */
                Select.prototype.observeProperties = function (binder) {
                    var _this = this;
                    var element = this.element;
                    this._binder = binder;
                    if (element.multiple) {
                        if (isNull(binder.evaluate())) {
                            this.inputChanged([]);
                        }
                        binder.observeProperty(this._setSelectedIndices);
                        binder.observeArrayChange(function () {
                            _this._setSelectedIndices(binder.evaluate(), null, null);
                        });
                    }
                    else {
                        binder.observeProperty(this._setSelectedIndex);
                    }
                    this.addEventListener(element, 'change', this._observeChange, false);
                };
                /**
                 * Updates the selected index if bound to a property.
                 * @param {string} newValue The new value of the bound property.
                 * @param {string} oldValue The old value of the bound property.
                 * @param {string} identifier The child identifier of the bound property.
                 * @param {boolean} firstTime? Whether or not this is the first time being called as a setter.
                 */
                Select.prototype._setSelectedIndex = function (newValue, oldValue, identifier, firstTime) {
                    var _this = this;
                    var element = this.element, value = element.value;
                    if (isNull(newValue)) {
                        if (firstTime === true || !this._document.body.contains(element)) {
                            this.itemsLoaded.then(function () {
                                if (isNull(_this._binder.evaluate())) {
                                    _this.inputChanged(element.value);
                                }
                            });
                            return;
                        }
                        element.selectedIndex = -1;
                        return;
                    }
                    else if (!isString(newValue)) {
                        if (isNumber(newValue)) {
                            this._propertyType = 'number';
                            newValue = newValue.toString();
                        }
                        else if (isBoolean(newValue)) {
                            this._propertyType = 'boolean';
                            newValue = newValue.toString();
                        }
                        else {
                            if (isFunction(newValue.toString)) {
                                newValue = newValue.toString();
                            }
                            else {
                                newValue = Object.prototype.toString.call(newValue);
                            }
                            this._log.info('Trying to bind the invalid value "' + newValue + '" to a ' + this.type + '.');
                        }
                    }
                    if (value === newValue) {
                        return;
                    }
                    this.itemsLoaded.then(function () {
                        if (!_this._document.body.contains(element)) {
                            element.value = newValue;
                            if (element.value !== newValue) {
                                element.value = value;
                                _this.inputChanged(_this._castValue(element.value));
                            }
                            return;
                        }
                        element.value = newValue;
                        // check to make sure the user changed to a valid value 
                        // second boolean argument is an ie fix for inconsistency 
                        if (element.value !== newValue || element.selectedIndex === -1) {
                            element.selectedIndex = -1;
                        }
                    });
                };
                /**
                 * Updates the selected index if bound to a property.
                 * @param {Array<any>} newValue The new value Array of the bound property.
                 * @param {Array<any>} oldValue The old value Array of the bound property.
                 * @param {string} identifier The child identifier of the bound property.
                 * @param {boolean} firstTime? Whether or not this is the first time being called as a setter.
                 */
                Select.prototype._setSelectedIndices = function (newValue, oldValue, identifier, firstTime) {
                    var _this = this;
                    this.itemsLoaded.then(function () {
                        var element = _this.element, options = element.options, length = isNull(options) ? 0 : options.length, option, nullValue = isNull(newValue);
                        if (nullValue || !isArray(newValue)) {
                            if (firstTime === true && isNull(_this._binder.evaluate())) {
                                _this.inputChanged(_this._getSelectedValues());
                            }
                            // unselects the options unless a match is found 
                            while (length-- > 0) {
                                option = options[length];
                                if (!nullValue && option.value === '' + newValue) {
                                    option.selected = true;
                                    return;
                                }
                                option.selected = false;
                            }
                            return;
                        }
                        var value, numberValue, index, highestIndex = Infinity;
                        while (length-- > 0) {
                            option = options[length];
                            value = option.value;
                            if (newValue.indexOf(value) !== -1) {
                                option.selected = true;
                                continue;
                            }
                            numberValue = Number(value);
                            if (isNumber(numberValue) && (index = newValue.indexOf(numberValue)) !== -1) {
                                if (index < highestIndex) {
                                    _this._propertyType = 'number';
                                    highestIndex = index;
                                }
                                option.selected = true;
                                continue;
                            }
                            else if ((value === 'true' && (index = newValue.indexOf(true)) !== -1) ||
                                value === 'false' && (index = newValue.indexOf(false)) !== -1) {
                                if (index < highestIndex) {
                                    _this._propertyType = 'boolean';
                                    highestIndex = index;
                                }
                                option.selected = true;
                                continue;
                            }
                            option.selected = false;
                        }
                    });
                };
                /**
                 * Fires the inputChanged event when the select's value changes.
                 */
                Select.prototype._observeChange = function () {
                    var element = this.element;
                    this.inputChanged(element.multiple ? this._getSelectedValues() : this._castValue(element.value));
                };
                /**
                 * Getter for select-multiple.
                 */
                Select.prototype._getSelectedValues = function () {
                    var options = this.element.options, length = options.length, option, selectedValues = [];
                    for (var i = 0; i < length; ++i) {
                        option = options[i];
                        if (option.selected) {
                            selectedValues.push(this._castValue(option.value));
                        }
                    }
                    return selectedValues;
                };
                /**
                 * Casts a value to the determined initial property type.
                 */
                Select.prototype._castValue = function (value) {
                    var type = this._propertyType;
                    if (isNull(type)) {
                        return value;
                    }
                    var castValue;
                    switch (type) {
                        case 'number':
                            castValue = isEmpty(value) ? undefined : Number(value);
                            break;
                        case 'boolean':
                            switch (value) {
                                case 'true':
                                    castValue = true;
                                    break;
                                case 'false':
                                case '0':
                                case 'null':
                                case 'undefined':
                                    castValue = false;
                                    break;
                                default:
                                    castValue = !!value;
                                    break;
                            }
                            break;
                        default:
                            castValue = value;
                            break;
                    }
                    return castValue;
                };
                /**
                 * Sets a listener for the changes to the array.
                 */
                Select.prototype._setListener = function () {
                    if (!this.__listenerSet) {
                        this.observeArray(this._executeEvent);
                        this.__listenerSet = true;
                    }
                };
                /**
                 * Receives an event when a method has been called on an array and maps the array
                 * method to its associated method handler.
                 * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
                 */
                Select.prototype._executeEvent = function (changes) {
                    var method = '_' + changes[0].type;
                    if (isFunction(this[method])) {
                        this[method](changes);
                    }
                };
                /**
                 * Adds the options to the select element.
                 * @param {number} numberOfItems The number of items to add.
                 * @param {number} index The starting index of the next
                 * set of items to add.
                 */
                Select.prototype._addItems = function (numberOfItems, index) {
                    var _this = this;
                    var bindableTemplates = this.bindableTemplates, promises = [], insertOption = this._insertOption;
                    while (numberOfItems-- > 0) {
                        promises.push(bindableTemplates.bind('option', index).then(insertOption.bind(this, index++)));
                    }
                    if (promises.length > 0) {
                        this.itemsLoaded = this._Promise.all(promises).then(function () {
                            if (isFunction(_this.__resolveFn)) {
                                _this.__resolveFn();
                                _this.__resolveFn = _this.__rejectFn = null;
                            }
                            return;
                        }).catch(function (error) {
                            postpone(function () {
                                if (isString(error)) {
                                    error = new Error(error);
                                }
                                _this._log.error(error);
                            });
                        });
                    }
                    return this.itemsLoaded;
                };
                /**
                 * The callback used to add an option after
                 * its template has been bound.
                 * @param {number} index The current index of the item being added.
                 * @param {DocumentFragment} option The bound DocumentFragment to be
                 * inserted into the DOM.
                 */
                Select.prototype._insertOption = function (index, option) {
                    var element = this.element;
                    if (this._isGrouped) {
                        var groups_1 = this.groups, newGroup_1 = (this.context[index] || {})[this._group], optgroup_1 = groups_1[newGroup_1];
                        if (isNull(optgroup_1)) {
                            return (groups_1[newGroup_1] = this.bindableTemplates.bind('group', index)
                                .then(function (groupFragment) {
                                optgroup_1 = groups_1[newGroup_1] = groupFragment.childNodes[1];
                                optgroup_1.insertBefore(option, null);
                                element.insertBefore(groupFragment, null);
                                return optgroup_1;
                            }));
                        }
                        else if (isPromise(optgroup_1)) {
                            return optgroup_1.then(function (group) {
                                group.insertBefore(option, null);
                            });
                        }
                        optgroup_1.insertBefore(option, null);
                        return this._Promise.resolve();
                    }
                    element.insertBefore(option, null);
                    return this._Promise.resolve();
                };
                /**
                 * Removes a specified number of elements.
                 * @param {number} numberOfItems The number of items
                 * to remove.
                 */
                Select.prototype._removeItems = function (numberOfItems) {
                    var dispose = TemplateControl.dispose, controls = this.controls;
                    while (numberOfItems-- > 0) {
                        dispose(controls.pop());
                    }
                };
                /**
                 * The function called when an item has been removed
                 * from the Array context.
                 */
                Select.prototype._removeItem = function () {
                    if (this._isGrouped) {
                        this._resetSelect();
                        return;
                    }
                    this._removeItems(1);
                };
                /**
                 * Resets the select element by removing all its
                 * items and adding them back.
                 */
                Select.prototype._resetSelect = function () {
                    this._removeItems(this.controls.length);
                    this.groups = {};
                    if (!isNull(this._defaultOption)) {
                        this.element.insertBefore(this._defaultOption.cloneNode(true), null);
                    }
                    this._addItems(this.context.length, 0);
                };
                /**
                 * The function called when an element is pushed to
                 * the array context.
                 * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
                 */
                Select.prototype._push = function (changes) {
                    var change = changes[0];
                    this._addItems(change.addedCount, change.index);
                };
                /**
                 * The function called when an item is popped
                 * from the array context.
                 * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
                 */
                Select.prototype._pop = function (changes) {
                    var _this = this;
                    if (changes[0].removed.length === 0) {
                        return;
                    }
                    this.itemsLoaded.then(function () {
                        _this._removeItem();
                    });
                };
                /**
                 * The function called when an item is unshifted
                 * onto the array context.
                 * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
                 */
                Select.prototype._unshift = function (changes) {
                    if (this._isGrouped) {
                        this._resetSelect();
                        return;
                    }
                    var change = changes[0], addedCount = change.addedCount;
                    this._addItems(addedCount, change.object.length - addedCount - 1);
                };
                /**
                 * The function called when an item is shifted
                 * from the array context.
                 * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
                 */
                Select.prototype._shift = function (changes) {
                    var _this = this;
                    if (changes[0].removed.length === 0) {
                        return;
                    }
                    this.itemsLoaded.then(function () {
                        _this._removeItem();
                    });
                };
                /**
                 * The function called when items are spliced
                 * from the array context.
                 * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
                 */
                Select.prototype._splice = function (changes) {
                    var _this = this;
                    if (this._isGrouped) {
                        this._resetSelect();
                        return;
                    }
                    var change = changes[0], addCount = change.addedCount, removeCount = change.removed.length;
                    if (addCount > removeCount) {
                        this._addItems(addCount - removeCount, change.object.length - addCount - 1);
                    }
                    else if (removeCount > addCount) {
                        this.itemsLoaded.then(function () {
                            _this._removeItems(removeCount - addCount);
                        });
                    }
                };
                /**
                 * The function called when the array context
                 * is sorted.
                 * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
                 */
                Select.prototype._sort = function (changes) {
                    if (this._isGrouped) {
                        this._resetSelect();
                    }
                };
                /**
                 * The function called when the array context
                 * is reversed.
                 * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
                 */
                Select.prototype._reverse = function (changes) {
                    if (this._isGrouped) {
                        this._resetSelect();
                    }
                };
                Select._inject = {
                    _Promise: __Promise,
                    _document: __Document
                };
                return Select;
            }(BindControl));
            controls_1.Select = Select;
            register.control(__Select, Select);
            /**
             * A TemplateControl conditionally adding or removing
             * a block of nodes to or from the DOM.
             */
            var If = (function (_super) {
                __extends(If, _super);
                /**
                 * The constructor for a If. Creates the comment node and document fragment storage
                 * used by this control.
                 */
                function If() {
                    _super.call(this);
                    /**
                     * The current evaluated condition (whether or not the
                     * control is visible) of the control.
                     */
                    this.__condition = true;
                    /**
                     * A boolean value stating whether or not the condition has already
                     * been evaluated.
                     */
                    this.__firstTime = true;
                    var _document = this._document;
                    this.commentNode = _document.createComment(__If + __BOUND_PREFIX + 'placeholder');
                    this.fragmentStore = _document.createDocumentFragment();
                }
                /**
                 * Checks the options and initializes the
                 * evaluation.
                 */
                If.prototype.contextChanged = function () {
                    var options = this.options.value;
                    if (isEmpty(options)) {
                        return;
                    }
                    return this._setter(options);
                };
                /**
                 * Creates a bindable template with the control element's childNodes (innerHTML).
                 */
                If.prototype.setTemplate = function () {
                    this.bindableTemplates.add('template', Array.prototype.slice.call(this.element.childNodes));
                };
                /**
                 * Sets the visibility to true if no options are
                 * defined, kicks off the evaluation, and observes
                 * the options for changes.
                 */
                If.prototype.loaded = function () {
                    if (isNull(this.options)) {
                        this._log.warn('No condition specified in ' + __Options + ' for ' + this.type + '.');
                        this.options = {
                            value: {
                                condition: true
                            },
                            observe: noop
                        };
                    }
                    var promise = this.contextChanged();
                    this.__removeListener = this.options.observe(this._setter);
                    return promise;
                };
                /**
                 * Stops listening to the options for changes.
                 */
                If.prototype.dispose = function () {
                    if (isFunction(this.__removeListener)) {
                        this.__removeListener();
                        this.__removeListener = null;
                    }
                    this.commentNode = null;
                    this.fragmentStore = null;
                };
                /**
                 * Checks the condition and decides
                 * whether or not to add or remove
                 * the node from the DOM.
                 */
                If.prototype._setter = function (options) {
                    var _this = this;
                    var value = !!options.condition, promise;
                    if (value === this.__condition && !this.__firstTime) {
                        return this._Promise.resolve(null);
                    }
                    if (value) {
                        if (!isNull(this.__leaveAnimation)) {
                            promise = this.__leaveAnimation.cancel().then(function () {
                                _this.__leaveAnimation = null;
                                return _this._addItem();
                            });
                        }
                        else {
                            promise = this._addItem();
                        }
                    }
                    else {
                        if (!isNull(this.__enterAnimation)) {
                            promise = this.__enterAnimation.cancel().then(function () {
                                _this.__enterAnimation = null;
                                return _this._removeItem();
                            });
                        }
                        else {
                            this._removeItem();
                            promise = this._Promise.resolve(null);
                        }
                    }
                    this.__condition = value;
                    return promise;
                };
                /**
                 * Adds the conditional nodes to the DOM.
                 */
                If.prototype._addItem = function () {
                    var _this = this;
                    if (!isNode(this.commentNode.parentNode) && !this.__firstTime) {
                        return this._Promise.resolve(null);
                    }
                    if (this.__firstTime) {
                        this.__firstTime = false;
                        this.__initialBind = this.bindableTemplates.bind('template').then(function (template) {
                            var element = _this.element;
                            _this.__initialBind = null;
                            if (element.parentNode === _this.fragmentStore) {
                                element.insertBefore(template, null);
                                return _this._animateEntrance();
                            }
                            _this.__enterAnimation = _this._animator.animate(element, __Enter);
                            element.insertBefore(template, null);
                            return _this.__enterAnimation;
                        }).then(function () {
                            _this.__enterAnimation = null;
                        });
                        return this.__initialBind;
                    }
                    if (isPromise(this.__initialBind)) {
                        return this.__initialBind.then(function () {
                            return _this._animateEntrance();
                        });
                    }
                    return this._animateEntrance();
                };
                /**
                 * Animates the template as it enters the DOM.
                 */
                If.prototype._animateEntrance = function () {
                    var _this = this;
                    var commentNode = this.commentNode, parentNode = commentNode.parentNode;
                    if (!isNode(parentNode)) {
                        return this._animator.resolve().then(noop);
                    }
                    return this.__enterAnimation = this._animator.enter(this.element, __Enter, parentNode, commentNode).then(function () {
                        _this.__enterAnimation = null;
                    });
                };
                /**
                 * Removes the conditional nodes from the DOM.
                 */
                If.prototype._removeItem = function () {
                    var _this = this;
                    if (isPromise(this.__initialBind)) {
                        return this.__initialBind.then(function () {
                            return _this._animateLeave();
                        });
                    }
                    return this._animateLeave();
                };
                /**
                 * Animates the template as it leaves the DOM.
                 */
                If.prototype._animateLeave = function () {
                    var _this = this;
                    var element = this.element, parent = element.parentElement, nextSibling = element.nextSibling;
                    if (!isNode(parent)) {
                        return this._animator.resolve().then(noop);
                    }
                    return this.__leaveAnimation = this._animator.leave(element, __Leave).then(function () {
                        _this.__leaveAnimation = null;
                        parent.insertBefore(_this.commentNode, nextSibling);
                        _this.fragmentStore.insertBefore(element, null);
                    });
                };
                If._inject = {
                    _animator: __Animator,
                    _Promise: __Promise,
                    _document: __Document
                };
                return If;
            }(TemplateControl));
            controls_1.If = If;
            register.control(__If, If);
            /**
             * A TemplateControl for adding additonal
             * functionality to a native HTML anchor tag.
             */
            var Link = (function (_super) {
                __extends(Link, _super);
                function Link() {
                    _super.apply(this, arguments);
                    /**
                     * Replaces the Link's element with a native anchor tag.
                     */
                    this.replaceWith = 'a';
                    /**
                     * The router associated with this link.
                     */
                    this._router = this._Router.currentRouter();
                }
                /**
                 * Initializes click event.
                 */
                Link.prototype.initialize = function () {
                    this._removeClickListener = this.dom.addEventListener(this.element, 'click', this._handleClick, false);
                };
                /**
                 * Calls to normalize the href for internal links and initializes the tap event.
                 */
                Link.prototype.loaded = function () {
                    var options = this.options, setHref = this.setHref.bind(this);
                    if (!isObject(options)) {
                        this._log.warn('No options specified for ' + this.type +
                            '. Please send in options of type plat.ui.controls.ILinkOptions.');
                        options = this.options = {};
                        options.value = { view: '' };
                        this.setHref();
                        return;
                    }
                    else if (!isObject(options.value)) {
                        options.value = { view: '' };
                    }
                    this.addEventListener(this.element, __tap, this._handleTap, false);
                    setHref();
                    options.observe(setHref);
                };
                /**
                 * Sets the element href to the one formed using the associated options.
                 */
                Link.prototype.setHref = function () {
                    var href = this.getHref();
                    if (!isEmpty(href)) {
                        var element = this.element;
                        element.href = href;
                    }
                };
                /**
                 * Determines the href based on the input options.
                 */
                Link.prototype.getHref = function () {
                    if (isNull(this._router)) {
                        return;
                    }
                    var value = this.options.value, href = value.view;
                    if (value.isUrl !== true) {
                        var parameters = value.parameters, query = value.query;
                        if (isEmpty(href)) {
                            return href;
                        }
                        href = this._router.generate(href, parameters, query);
                    }
                    return this._browser.formatUrl(href);
                };
                /**
                 * Determines Whether or not the default click behavior should be prevented.
                 */
                Link.prototype._handleClick = function (ev) {
                    var buttons;
                    if (isNumber(ev.buttons) && ev.buttons !== 0) {
                        buttons = ev.buttons;
                    }
                    else if (isNumber(ev.which) && ev.which > 0) {
                        buttons = ev.which;
                    }
                    else {
                        switch (ev.button) {
                            case -1:
                                buttons = 0;
                                break;
                            case 0:
                                buttons = 1;
                                break;
                            case 1:
                                buttons = 4;
                                break;
                            case 2:
                                buttons = 2;
                                break;
                            case 3:
                                buttons = 8;
                                break;
                            case 4:
                                buttons = 16;
                                break;
                            default:
                                buttons = 1;
                                break;
                        }
                    }
                    if (buttons === 1) {
                        ev.preventDefault();
                    }
                };
                /**
                 * Determines the proper link upon $tap.
                 */
                Link.prototype._handleTap = function (ev) {
                    var _this = this;
                    if (ev.buttons !== 1) {
                        return;
                    }
                    var href = this.getHref();
                    if (isUndefined(href)) {
                        return;
                    }
                    ev.preventDefault();
                    requestAnimationFrameGlobal(function () {
                        _this._browser.url(href);
                    });
                };
                /**
                 * Calls to remove the click eater after a delay.
                 */
                Link.prototype.dispose = function () {
                    defer(this._removeClickListener, 3000);
                };
                Link._inject = {
                    _Router: __RouterStatic,
                    _Injector: __InjectorStatic,
                    _browser: __Browser
                };
                return Link;
            }(TemplateControl));
            controls_1.Link = Link;
            register.control(__Link, Link);
        })(controls = ui.controls || (ui.controls = {}));
    })(ui = plat_1.ui || (plat_1.ui = {}));
    /**
     * Holds classes and interfaces related to Document processing in platypus.
     */
    var processing;
    (function (processing) {
        /**
         * Responsible for iterating through the DOM and collecting controls.
         */
        var Compiler = (function () {
            function Compiler() {
            }
            Compiler.prototype.compile = function (node, control) {
                var childNodes = node.childNodes, length, newLength, childNode, hasControl = !isNull(control), manager = (hasControl ? this._managerCache.read(control.uid) : null), create = this._ElementManagerFactory.create;
                if (!isUndefined(childNodes)) {
                    childNodes = Array.prototype.slice.call(childNodes);
                }
                else if (isFunction(node.push)) {
                    childNodes = node;
                }
                else {
                    childNodes = Array.prototype.slice.call(node);
                }
                if (isNull(manager)) {
                    length = childNodes.length;
                    for (var i = 0; i < length; ++i) {
                        childNode = childNodes[i];
                        if (childNode.nodeType === Node.ELEMENT_NODE) {
                            if (!isNull(create(childNode))) {
                                this.compile(childNode);
                            }
                        }
                        newLength = childNodes.length;
                        i += newLength - length;
                        length = newLength;
                    }
                }
                else {
                    this._compileNodes(childNodes, manager);
                }
            };
            /**
             * Iterates through the array of nodes creating ElementManagers on Element
             * nodes, TextManagers on text nodes, and
             * CommentManagers on comment nodes.
             * @param {Array<Node>} nodes The array of nodes to be compiled.
             * @param {plat.processing.ElementManager} manager The parent ElementManagers
             * for the given array of nodes.
             */
            /**
             * @param nodes The NodeList to be compiled.
             * @param manager The parent Element Manager for the given array of nodes.
             */
            Compiler.prototype._compileNodes = function (nodes, manager) {
                var length = nodes.length, node, newManager, newLength, create = this._ElementManagerFactory.create, commentCreate = this._CommentManagerFactory.create, textCreate = this._TextManagerFactory.create;
                for (var i = 0; i < length; ++i) {
                    node = nodes[i];
                    switch (node.nodeType) {
                        case Node.ELEMENT_NODE:
                            newManager = create(node, manager);
                            if (!isNull(newManager)) {
                                this._compileNodes(Array.prototype.slice.call(node.childNodes), newManager);
                            }
                            break;
                        case Node.TEXT_NODE:
                            textCreate(node, manager);
                            break;
                        case Node.COMMENT_NODE:
                            commentCreate(node, manager);
                            break;
                    }
                    newLength = nodes.length;
                    i += newLength - length;
                    length = newLength;
                }
            };
            Compiler._inject = {
                _ElementManagerFactory: __ElementManagerFactory,
                _TextManagerFactory: __TextManagerFactory,
                _CommentManagerFactory: __CommentManagerFactory,
                _managerCache: __ManagerCache
            };
            return Compiler;
        }());
        processing.Compiler = Compiler;
        register.injectable(__Compiler, Compiler);
        /**
         * Responsible for data binding a data context to a Node.
         */
        var NodeManager = (function () {
            function NodeManager() {
                /**
                 * Whether or not this NodeManager is a clone.
                 */
                this.isClone = false;
            }
            /**
             * Determines if a string has the markup notation.
             * @param {string} text The text string in which to search for markup.
             */
            NodeManager.hasMarkup = function (text) {
                return NodeManager._markupRegex.test(text);
            };
            /**
             * Given a string, finds markup in the string and creates an array of
             * IParsedExpression.
             * @param {string} text The text string in which to search for markup.
             */
            NodeManager.findMarkup = function (text) {
                var start, end, parsedExpressions = [], wrapExpression = NodeManager._wrapExpression, substring, expression, _parser = NodeManager._parser;
                text = text.replace(NodeManager._newLineRegex, '');
                while ((start = text.indexOf(__startSymbol)) !== -1 && (end = text.indexOf(__endSymbol)) !== -1) {
                    if (start !== 0) {
                        parsedExpressions.push(wrapExpression(text.slice(0, start)));
                    }
                    // incremement with while loop instead of just += 2 for nested object literal case. 
                    while (text[++end] === '}') { }
                    substring = text.slice(start + 2, end - 2);
                    // check for one-time databinding 
                    if (substring[0] === '=') {
                        expression = _parser.parse(substring.slice(1).trim());
                        expression.oneTime = true;
                        parsedExpressions.push(expression);
                    }
                    else {
                        parsedExpressions.push(_parser.parse(substring.trim()));
                    }
                    text = text.slice(end);
                }
                if (start > -1 && end >= 0) {
                    parsedExpressions.push(wrapExpression(text.slice(end)));
                }
                else if (text !== '') {
                    parsedExpressions.push(wrapExpression(text));
                }
                return parsedExpressions;
            };
            /**
             * Takes in a control with a data context and an array of IParsedExpression
             * and outputs a string of the evaluated expressions.
             * @param {Array<plat.expressions.IParsedExpression>} expressions The composition array to evaluate.
             * @param {plat.ui.TemplateControl} control? The TemplateControl used to parse
             * the expressions.
             */
            NodeManager.build = function (expressions, control) {
                var text = '', length = expressions.length, resources = {}, expression, value, evaluateExpression = NodeManager._TemplateControlFactory.evaluateExpression;
                for (var i = 0; i < length; ++i) {
                    expression = expressions[i];
                    value = evaluateExpression(expression, control, resources);
                    if (isObject(value)) {
                        try {
                            text += JSON.stringify(value, null, 4);
                        }
                        catch (e) {
                            if (!isNull(e.description)) {
                                e.description = 'Cannot stringify object: ' + e.description;
                            }
                            e.message = 'Cannot stringify object: ' + e.message;
                            NodeManager._log.warn(e);
                        }
                    }
                    else if (!isNull(value)) {
                        text += value;
                    }
                }
                return text;
            };
            /**
             * Registers a listener to be notified of a change in any associated identifier.
             * @param {Array<plat.expressions.IParsedExpression>} expressions An Array of
             * IParsedExpressions to observe.
             * @param {plat.ui.TemplateControl} control The TemplateControl associated
             * to the identifiers.
             * @param {(...args: Array<any>) => void} listener The listener to call when any identifier property changes.
             */
            NodeManager.observeExpressions = function (expressions, control, listener) {
                var uniqueIdentifiers = NodeManager.__findUniqueIdentifiers(expressions), identifiers = uniqueIdentifiers.identifiers, oneTimeIdentifiers = uniqueIdentifiers.oneTimeIdentifiers, oneTimeIdentifier, observableCallback = {
                    listener: listener,
                    uid: control.uid
                }, observationDetails, manager, absoluteIdentifier;
                while (identifiers.length > 0) {
                    observationDetails = NodeManager.__getObservationDetails(identifiers.pop(), control);
                    manager = observationDetails.manager;
                    if (!isNull(manager)) {
                        manager.observe(observationDetails.absoluteIdentifier, observableCallback);
                    }
                }
                while (oneTimeIdentifiers.length > 0) {
                    oneTimeIdentifier = oneTimeIdentifiers.pop();
                    observationDetails = NodeManager.__getObservationDetails(oneTimeIdentifier, control);
                    manager = observationDetails.manager;
                    if (!(isNull(manager) || observationDetails.isDefined)) {
                        absoluteIdentifier = observationDetails.absoluteIdentifier;
                        var stopObserving = manager.observe(absoluteIdentifier, observableCallback), stopListening = manager.observe(absoluteIdentifier, {
                            uid: control.uid,
                            listener: function () {
                                stopObserving();
                                stopListening();
                            }
                        });
                    }
                }
            };
            /**
             * Wraps constant text as a static IParsedExpression.
             * @param text The text to wrap into a static expression.
             */
            NodeManager._wrapExpression = function (text) {
                return {
                    evaluate: function () { return text; },
                    identifiers: [],
                    aliases: [],
                    expression: text
                };
            };
            /**
             * Given an IParsedExpression array, creates an array of unique identifers
             * to use with binding. This allows us to avoid creating multiple listeners for the identifier and node.
             * @param {Array<plat.expressions.IParsedExpression>} expressions An array of parsed expressions to search for identifiers.
             */
            NodeManager.__findUniqueIdentifiers = function (expressions) {
                var length = expressions.length, expression;
                if (length === 1) {
                    expression = expressions[0];
                    if (expression.oneTime === true) {
                        return {
                            identifiers: [],
                            oneTimeIdentifiers: expression.identifiers.slice(0)
                        };
                    }
                    return {
                        identifiers: expression.identifiers.slice(0),
                        oneTimeIdentifiers: []
                    };
                }
                var uniqueIdentifierObject = {}, oneTimeIdentifierObject = {}, uniqueIdentifiers = [], oneTimeIdentifiers = [], identifiers, identifier, j, jLength, oneTime;
                for (var i = 0; i < length; ++i) {
                    expression = expressions[i];
                    oneTime = expression.oneTime;
                    identifiers = expression.identifiers;
                    jLength = identifiers.length;
                    for (j = 0; j < jLength; ++j) {
                        identifier = identifiers[j];
                        if (oneTime) {
                            if (uniqueIdentifierObject[identifier] === true) {
                                continue;
                            }
                            if (!oneTimeIdentifierObject[identifier]) {
                                oneTimeIdentifierObject[identifier] = true;
                                oneTimeIdentifiers.push(identifier);
                            }
                        }
                        else {
                            if (!uniqueIdentifierObject[identifier]) {
                                uniqueIdentifierObject[identifier] = true;
                                uniqueIdentifiers.push(identifier);
                            }
                            if (oneTimeIdentifierObject[identifier] === true) {
                                oneTimeIdentifierObject[identifier] = false;
                                oneTimeIdentifiers.splice(oneTimeIdentifiers.indexOf(identifier), 1);
                            }
                        }
                    }
                }
                return {
                    identifiers: uniqueIdentifiers,
                    oneTimeIdentifiers: oneTimeIdentifiers
                };
            };
            /**
             * Takes in an identifier and returns an object containing both its converted absolute path and the
             * ContextManager needed to observe it.
             * @param {string} identifier The identifier looking to be observed.
             * @param {plat.ui.TemplateControl} control The TemplateControl associated
             * to the identifiers.
             */
            NodeManager.__getObservationDetails = function (identifier, control) {
                var _ContextManager = NodeManager._ContextManager, manager, split = identifier.split('.'), absoluteIdentifier = '', isDefined = false;
                if (identifier[0] === '@') {
                    // we found an alias 
                    var resourceObj = void 0, resources = {}, topIdentifier = split.shift(), alias = topIdentifier.slice(1);
                    if (split.length > 0) {
                        absoluteIdentifier = '.' + split.join('.');
                    }
                    resourceObj = resources[alias];
                    if (isNull(resourceObj)) {
                        resourceObj = resources[alias] = control.findResource(alias);
                    }
                    if (!isNull(resourceObj) && !isNull(resourceObj.resource)) {
                        var type = resourceObj.resource.type;
                        if (alias === __CONTEXT_RESOURCE) {
                            manager = _ContextManager.getManager(Control.getRootControl(control));
                            absoluteIdentifier = control.absoluteContextPath + absoluteIdentifier;
                        }
                        else if (alias === __ROOT_CONTEXT_RESOURCE) {
                            manager = _ContextManager.getManager(resources[alias].control);
                            absoluteIdentifier = 'context' + absoluteIdentifier;
                        }
                        else if (type === __OBSERVABLE_RESOURCE || type === __LITERAL_RESOURCE) {
                            manager = _ContextManager.getManager(resources[alias].control);
                            absoluteIdentifier = 'resources.' + alias + '.value' + absoluteIdentifier;
                        }
                    }
                }
                else {
                    // look on the control.context 
                    isDefined = !isUndefined(_ContextManager.getContext(control.context, split));
                    if (isDefined || isUndefined(_ContextManager.getContext(control, split))) {
                        manager = _ContextManager.getManager(Control.getRootControl(control));
                        absoluteIdentifier = control.absoluteContextPath + '.' + identifier;
                    }
                    else {
                        manager = null;
                    }
                }
                return {
                    absoluteIdentifier: absoluteIdentifier,
                    manager: manager,
                    isDefined: isDefined
                };
            };
            /**
             * Initializes the manager's properties.
             * @param {plat.processing.INodeMap} nodeMap The mapping associated with this manager. We have to use an
             * Used to treat all NodeManagers the same.
             * @param {plat.processing.ElementManager} parent The parent ElementManager.
             */
            NodeManager.prototype.initialize = function (nodeMap, parent) {
                this.nodeMap = nodeMap;
                this.parent = parent;
                if (!isNull(parent)) {
                    this.isClone = parent.isClone;
                    parent.children.push(this);
                }
            };
            /**
             * Retrieves the parent control associated with the parent manager.
             */
            NodeManager.prototype.getParentControl = function () {
                var parent = this.parent, control;
                while (isNull(control)) {
                    if (isNull(parent)) {
                        break;
                    }
                    control = parent.getUiControl();
                    parent = parent.parent;
                }
                return control;
            };
            /**
             * Clones this NodeManager with the new node.
             * @param {Node} newNode The new node associated with the new manager.
             * @param {plat.processing.ElementManager} parentManager The parent
             * ElementManager for the clone.
             */
            NodeManager.prototype.clone = function (newNode, parentManager) {
                return 1;
            };
            /**
             * The function used for data-binding a data context to the DOM.
             */
            NodeManager.prototype.bind = function () { };
            return NodeManager;
        }());
        processing.NodeManager = NodeManager;
        /**
         */
        function INodeManagerStatic(_regex, _ContextManager, _parser, _TemplateControlFactory, _log) {
            // NOTE: This is not advised by TypeScript, but we want to do this. 
            NodeManager._markupRegex = _regex.markupRegex;
            NodeManager._newLineRegex = _regex.newLineRegex;
            NodeManager._ContextManager = _ContextManager;
            NodeManager._parser = _parser;
            NodeManager._TemplateControlFactory = _TemplateControlFactory;
            NodeManager._log = _log;
            return NodeManager;
        }
        processing.INodeManagerStatic = INodeManagerStatic;
        register.injectable(__NodeManagerStatic, INodeManagerStatic, [
            __Regex,
            __ContextManagerStatic,
            __Parser,
            __TemplateControlFactory,
            __Log
        ], __STATIC);
        /**
         * A class used to manage element nodes. Provides a way for compiling and binding the
         * element/template. Also provides methods for cloning an
         * ElementManager.
         */
        var ElementManager = (function (_super) {
            __extends(ElementManager, _super);
            function ElementManager() {
                _super.apply(this, arguments);
                /**
                 * The child managers for this manager.
                 */
                this.children = [];
                /**
                 * Specifies the type for this NodeManager.
                 * It's value is "element".
                 */
                this.type = 'element';
                /**
                 * Specifies whether or not this manager has a TemplateControl which has a
                 * replaceWith property set to null or empty string.
                 */
                this.replace = false;
                /**
                 * Indicates whether the TemplateControl for this manager has its own context
                 * or inherits it from a parent.
                 */
                this.hasOwnContext = false;
            }
            /**
             * Determines if the associated Element has controls that need to be instantiated or Attr nodes
             * containing text markup. If controls exist or markup is found a new
             * ElementManager will be created,
             * else an empty NodeManager will be added to the Array of
             * NodeManagers.
             * @param {Element} element The Element to use to identifier markup and controls.
             * @param {plat.processing.ElementManager} parent? The parent ElementManager
             * used for context inheritance.
             */
            ElementManager.create = function (element, parent) {
                var name = element.nodeName.toLowerCase(), nodeName = name, injector = controlInjectors[name] || viewControlInjectors[name], noControlAttribute = true, hasUiControl = false, uiControlNode;
                if (isNull(injector)) {
                    if (element.hasAttribute(__Control)) {
                        name = element.getAttribute(__Control).toLowerCase();
                        injector = controlInjectors[name] || viewControlInjectors[name];
                        noControlAttribute = false;
                    }
                    else if (element.hasAttribute(__AttributePrefix + __Control)) {
                        name = element.getAttribute(__AttributePrefix + __Control).toLowerCase();
                        injector = controlInjectors[name] || viewControlInjectors[name];
                        noControlAttribute = false;
                    }
                }
                if (!isNull(injector)) {
                    var uiControl = injector.inject(), resourceElement = ElementManager.locateResources(element);
                    uiControlNode = {
                        control: uiControl,
                        resourceElement: resourceElement,
                        nodeName: name,
                        expressions: [],
                        injector: injector
                    };
                    hasUiControl = true;
                    if (noControlAttribute) {
                        element.setAttribute(__Control, name);
                    }
                    var replacementType = uiControl.replaceWith, replaceWithDiv = replacementType === 'any' && noControlAttribute;
                    if (!isEmpty(replacementType) && (replacementType !== 'any' || replaceWithDiv) &&
                        replacementType.toLowerCase() !== nodeName) {
                        if (replaceWithDiv) {
                            replacementType = 'div';
                        }
                        var replacement = ElementManager._document.createElement(replacementType);
                        if (replacement.nodeType === Node.ELEMENT_NODE) {
                            element = replaceWith(element, replacement);
                        }
                    }
                }
                var elementMap = ElementManager._collectAttributes(element.attributes), manager = ElementManager.getInstance();
                elementMap.element = element;
                if (!hasUiControl && isString(elementMap.childContext)) {
                    injector = injectableInjectors[__TemplateControlInstance];
                    hasUiControl = true;
                    elementMap.uiControlNode = {
                        control: injector.inject(),
                        resourceElement: null,
                        nodeName: __TemplateContext,
                        expressions: [],
                        injector: injector
                    };
                }
                else {
                    elementMap.uiControlNode = uiControlNode;
                }
                manager.initialize(elementMap, parent);
                if (!(elementMap.hasControl || hasUiControl)) {
                    manager.bind = function () { return []; };
                }
                else {
                    manager.setUiControlTemplate();
                    return hasUiControl ? null : manager;
                }
                return manager;
            };
            /**
             * Looks through the Node's child nodes to try and find any
             * defined Resources in a <plat-resources> tags.
             * @param {Node} node The node whose child nodes may contain Resources.
             */
            ElementManager.locateResources = function (node) {
                var childNodes = Array.prototype.slice.call(node.childNodes), childNode, nodeName;
                while (childNodes.length > 0) {
                    childNode = childNodes.shift();
                    nodeName = childNode.nodeName.toLowerCase();
                    if (nodeName === __Resources || nodeName === 'x-' + __Resources) {
                        return node.removeChild(childNode);
                    }
                }
                return null;
            };
            /**
             * Clones an ElementManager with a new element.
             * @param {plat.processing.ElementManager} sourceManager The original ElementManager.
             * @param {plat.processing.ElementManager} parent The parent ElementManager
             * for the new clone.
             * @param {Element} element The new element to associate with the clone.
             * @param {plat.ui.TemplateControl} newControl? An optional control to associate with the clone.
             * @param {plat.processing.INodeMap} nodeMap? The {@link plat.processing.INodeMap} used to clone this
             * ElementManager.
             */
            ElementManager.clone = function (sourceManager, parent, element, newControl, nodeMap) {
                if (isNull(nodeMap)) {
                    nodeMap = ElementManager._cloneNodeMap(sourceManager.nodeMap, element, parent.getUiControl() ||
                        parent.getParentControl(), newControl);
                }
                var manager = ElementManager.getInstance(), hasNewControl = !isNull(newControl);
                manager.nodeMap = nodeMap;
                manager.parent = parent;
                if (!isNull(parent)) {
                    parent.children.push(manager);
                }
                manager.replace = sourceManager.replace;
                manager.replaceNodeLength = sourceManager.replaceNodeLength;
                manager.hasOwnContext = sourceManager.hasOwnContext;
                manager.isClone = true;
                if (!(nodeMap.hasControl || hasNewControl)) {
                    manager.bind = function () { return []; };
                }
                if (hasNewControl) {
                    ElementManager._managerCache.put(newControl.uid, manager);
                }
                return manager;
            };
            /**
             * Clones an TemplateControl with a new INodeMap.
             * @param {plat.processing.INodeMap} sourceMap The source INodeMap used to clone the
             * TemplateControl.
             * @param {plat.ui.TemplateControl} parent The parent control of the clone.
             */
            ElementManager.cloneUiControl = function (sourceMap, parent) {
                var uiControlNode = sourceMap.uiControlNode;
                if (isNull(uiControlNode) || isNull(uiControlNode.injector)) {
                    return;
                }
                var uiControl = uiControlNode.control, newUiControl = uiControlNode.injector.inject(), resources = ElementManager._ResourcesFactory.getInstance(), attributes = ElementManager._AttributesFactory.getInstance();
                newUiControl.parent = parent;
                parent.controls.push(newUiControl);
                newUiControl.controls = [];
                attributes.initialize(newUiControl, sourceMap.attributes);
                newUiControl.attributes = attributes;
                resources.initialize(newUiControl, uiControl.resources);
                newUiControl.resources = resources;
                ElementManager._ResourcesFactory.addControlResources(newUiControl);
                if (!isNull(uiControl.innerTemplate)) {
                    newUiControl.innerTemplate = uiControl.innerTemplate.cloneNode(true);
                }
                newUiControl.type = uiControl.type;
                newUiControl.bindableTemplates = ElementManager._BindableTemplatesFactory.create(newUiControl, uiControl.bindableTemplates);
                newUiControl.replaceWith = uiControl.replaceWith;
                return newUiControl;
            };
            /**
             * Creates new INodes corresponding to the element
             * associated with the INodeMap or the passed-in element.
             * @param {plat.processing.INodeMap} nodeMap The INodeMap that contains
             * the attribute nodes.
             * @param {plat.ui.TemplateControl} parent The parent TemplateControl for
             * the newly created controls.
             * @param {plat.ui.TemplateControl} templateControl? The TemplateControl
             * linked to these created controls if one exists.
             * @param {Element} newElement? An optional element to use for attributes (used in cloning).
             * @param {boolean} isClone? Whether or not these controls are clones.
             */
            ElementManager.createAttributeControls = function (nodeMap, parent, templateControl, newElement, isClone) {
                var nodes = nodeMap.nodes, element = isClone === true ? newElement : nodeMap.element, attributes;
                if (isNode(element)) {
                    if (element.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                        return isClone === true ? ElementManager._copyAttributeNodes(nodes) : [];
                    }
                    attributes = element.attributes;
                }
                var attrs = nodeMap.attributes, newAttributes, node, injector, control, newNodes = [], length = nodes.length, nodeName, i;
                for (i = 0; i < length; ++i) {
                    node = nodes[i];
                    nodeName = node.nodeName;
                    injector = node.injector;
                    control = null;
                    if (!isNull(injector)) {
                        control = injector.inject();
                        node.control = control;
                        control.parent = parent;
                        control.element = element;
                        newAttributes = ElementManager._AttributesFactory.getInstance();
                        newAttributes.initialize(control, attrs);
                        control.attributes = newAttributes;
                        control.type = nodeName;
                        if (!isString(control.uid)) {
                            control.uid = uniqueId(__Plat);
                        }
                        control.templateControl = templateControl;
                    }
                    if (isClone === true) {
                        newNodes.push({
                            control: control,
                            expressions: node.expressions,
                            node: !attributes ? null : (attributes.getNamedItem(nodeName) ||
                                attributes.getNamedItem(__AttributePrefix + nodeName)),
                            nodeName: nodeName,
                            injector: injector
                        });
                        if (!isNull(control)) {
                            if (!isNull(parent)) {
                                parent.controls.push(control);
                            }
                            if (isFunction(control.initialize)) {
                                control.initialize();
                            }
                        }
                    }
                }
                if (!isClone) {
                    nodes.sort(function (a, b) {
                        var aControl = a.control, bControl = b.control;
                        if (isNull(aControl)) {
                            return 1;
                        }
                        else if (isNull(bControl)) {
                            return -1;
                        }
                        var aPriority = isNumber(aControl.priority) ? aControl.priority : 0, bPriority = isNumber(bControl.priority) ? bControl.priority : 0;
                        return bPriority - aPriority;
                    });
                    for (i = 0; i < length; ++i) {
                        node = nodes[i];
                        control = node.control;
                        if (!isNull(control)) {
                            if (!isNull(parent)) {
                                parent.controls.push(control);
                            }
                            if (isFunction(control.initialize)) {
                                control.initialize();
                            }
                        }
                    }
                }
                return newNodes;
            };
            /**
             * Returns a new instance of an ElementManager.
             */
            ElementManager.getInstance = function () {
                var manager = new ElementManager();
                manager._Promise = acquire(__Promise);
                manager._ContextManager = NodeManager._ContextManager;
                manager._compiler = acquire(__Compiler);
                manager._CommentManagerFactory = acquire(__CommentManagerFactory);
                manager._ControlFactory = acquire(__ControlFactory);
                manager._TemplateControlFactory = NodeManager._TemplateControlFactory;
                manager._BindableTemplatesFactory = ElementManager._BindableTemplatesFactory;
                manager._log = ElementManager._log;
                return manager;
            };
            /**
             * Iterates over the attributes (NamedNodeMap), creating an INodeMap.
             * This map will contain injectors for all the Controls as well as parsed expressions
             * and identifiers found for each Attribute (useful for data binding).
             * @param {NamedNodeMap} attributes The attributes used to create the INodeMap.
             */
            ElementManager._collectAttributes = function (attributes) {
                var nodes = [], attribute, name, value, childContext, childIdentifier, hasMarkup, hasMarkupFn = NodeManager.hasMarkup, findMarkup = NodeManager.findMarkup, _parser = NodeManager._parser, expressions, hasControl = false, injector, length = attributes.length, controlAttributes = {};
                for (var i = 0; i < length; ++i) {
                    attribute = attributes[i];
                    value = attribute.value;
                    name = attribute.name.replace(/^data-/i, '').toLowerCase();
                    injector = controlInjectors[name] || viewControlInjectors[name];
                    if (name === __Context) {
                        if (value !== '') {
                            childContext = _parser.parse(value);
                            if (childContext.identifiers.length !== 1) {
                                ElementManager._log.warn('Incorrect ' + __Context + ': ' +
                                    value + ', must contain a single identifier.');
                            }
                            childIdentifier = childContext.identifiers[0];
                        }
                    }
                    else if (name !== __Control) {
                        hasMarkup = hasMarkupFn(value);
                        expressions = hasMarkup ? findMarkup(value) : [];
                        if (!hasControl && (hasMarkup || !isNull(injector))) {
                            hasControl = true;
                        }
                        nodes.push({
                            control: null,
                            node: attribute,
                            nodeName: name,
                            expressions: expressions,
                            injector: injector
                        });
                    }
                    controlAttributes[camelCase(name)] = value;
                }
                return {
                    element: null,
                    attributes: controlAttributes,
                    nodes: nodes,
                    childContext: childIdentifier,
                    hasControl: hasControl
                };
            };
            /**
             * Used to copy the attribute nodes during the cloning process.
             * @param {Array<plat.processing.INode>} nodes The compiled INodes
             * to be cloned.
             */
            ElementManager._copyAttributeNodes = function (nodes) {
                var newNodes = [], length = nodes.length, node;
                for (var i = 0; i < length; ++i) {
                    node = nodes[i];
                    newNodes.push({
                        expressions: node.expressions,
                        nodeName: node.nodeName
                    });
                }
                return newNodes;
            };
            /**
             * Clones an INode with a new node.
             * @param {plat.processing.INode} sourceNode The original INode.
             * @param {Node} node The new node used for cloning.
             * @param {plat.ui.TemplateControl} newControl? An optional new control to associate with the cloned node.
             */
            ElementManager._cloneNode = function (sourceNode, node, newControl) {
                return {
                    control: newControl,
                    injector: sourceNode.injector,
                    expressions: sourceNode.expressions,
                    node: node,
                    nodeName: sourceNode.nodeName
                };
            };
            /**
             * Clones an INodeMap with a new element.
             * @param {plat.processing.INodeMap} sourceMap The original INodeMap.
             * @param {Element} element The new Element used for cloning.
             * @param {plat.ui.TemplateControl} parent The TemplateControl associated
             * with the parent ElementManager.
             * @param {plat.ui.TemplateControl} newControl? An optional new TemplateControl
             * to associate with the element.
             */
            ElementManager._cloneNodeMap = function (sourceMap, element, parent, newControl) {
                var hasControl = sourceMap.hasControl, nodeMap = {
                    attributes: sourceMap.attributes,
                    childContext: sourceMap.childContext,
                    nodes: [],
                    element: element,
                    uiControlNode: !isNull(sourceMap.uiControlNode) ?
                        ElementManager._cloneNode(sourceMap.uiControlNode, element, newControl) : null,
                    hasControl: hasControl
                };
                if (hasControl) {
                    nodeMap.nodes = ElementManager.createAttributeControls(sourceMap, parent, newControl, element, true);
                }
                return nodeMap;
            };
            /**
             * Clones the ElementManager with a new node.
             * @param {Node} newNode The new element used to clone the ElementManager.
             * @param {plat.processing.ElementManager} parentManager The parent manager for the clone.
             * @param {plat.processing.INodeMap} nodeMap? An optional INodeMap to clone a ui control if needed.
             */
            ElementManager.prototype.clone = function (newNode, parentManager, nodeMap) {
                var childNodes, clonedManager, replace = this.replace, children = this.children, newControl = !isNull(nodeMap) ? nodeMap.uiControlNode.control : null, newControlExists = !isNull(newControl), startNodeManager, endNodeManager;
                if (!newControlExists) {
                    // create new control 
                    newControl = ElementManager.cloneUiControl(this.nodeMap, (parentManager.getUiControl() || parentManager.getParentControl()));
                    newControlExists = !isNull(newControl);
                }
                if (replace) {
                    // definitely have newControl 
                    var nodes = newNode.parentNode.childNodes, arrayProto = Array.prototype, startIndex = arrayProto.indexOf.call(nodes, newNode);
                    childNodes = arrayProto.slice.call(nodes, startIndex + 1, startIndex + this.replaceNodeLength);
                    clonedManager = ElementManager.clone(this, parentManager, null, newControl, nodeMap);
                    newControl.elementNodes = childNodes;
                    newControl.startNode = newNode;
                    newControl.endNode = childNodes.pop();
                    startNodeManager = children.shift();
                    endNodeManager = children.shift();
                    startNodeManager.clone(newControl.startNode, clonedManager);
                    endNodeManager.clone(newControl.endNode, clonedManager);
                    if (isFunction(newControl.initialize)) {
                        newControl.initialize();
                    }
                }
                else {
                    childNodes = Array.prototype.slice.call(newNode.childNodes);
                    clonedManager = ElementManager.clone(this, parentManager, newNode, newControl, nodeMap);
                    nodeMap = clonedManager.nodeMap;
                    if (newControlExists) {
                        newControl.element = newNode;
                        if (isFunction(newControl.initialize)) {
                            newControl.initialize();
                        }
                    }
                }
                var length = children.length, childNodeOffset = 0;
                for (var i = 0; i < length; ++i) {
                    // clone children 
                    childNodeOffset += children[i].clone(childNodes[childNodeOffset], clonedManager);
                }
                if (replace) {
                    children.unshift(endNodeManager);
                    children.unshift(startNodeManager);
                    return childNodeOffset + 2;
                }
                return 1;
            };
            /**
             * Initializes both the manager itself and all the controls associated to the manager's
             * INodeMap.
             * @param {plat.processing.INodeMap} nodeMap A map of the nodes (element and attributes)
             * associated with this ElementManager.
             * @param {plat.processing.ElementManager} parent The parent
             * ElementManager.
             * @param {boolean} dontInitialize? Specifies whether or not the initialize method should
             * be called for a TemplateControl if one is attached
             * to this ElementManager.
             */
            ElementManager.prototype.initialize = function (nodeMap, parent, dontInitialize) {
                _super.prototype.initialize.call(this, nodeMap, parent);
                var controlNode = nodeMap.uiControlNode, hasUiControl = !isNull(controlNode), control;
                if (hasUiControl) {
                    this._populateUiControl();
                    control = controlNode.control;
                    this.hasOwnContext = control.hasOwnContext;
                }
                if (nodeMap.hasControl) {
                    ElementManager.createAttributeControls(nodeMap, this.getParentControl(), control);
                }
                if (!dontInitialize && hasUiControl && isFunction(control.initialize)) {
                    control.initialize();
                }
            };
            /**
             * Links the data context to the DOM (data-binding).
             */
            ElementManager.prototype.bind = function () {
                var _this = this;
                var nodeMap = this.nodeMap, parent = this.getParentControl(), controlNode = nodeMap.uiControlNode, controls = [];
                if (!isNull(controlNode)) {
                    var uiControl_1 = controlNode.control, childContext = nodeMap.childContext, getManager = this._ContextManager.getManager, contextManager_1, absoluteContextPath_1 = isNull(parent) ? __CONTEXT : parent.absoluteContextPath, _TemplateControlFactory = this._TemplateControlFactory, inheritsContext = !uiControl_1.hasOwnContext;
                    controls.push(uiControl_1);
                    if (inheritsContext && !isNull(childContext)) {
                        if (childContext[0] === '@') {
                            var split = childContext.split('.'), topIdentifier = split.shift(), alias = topIdentifier.slice(1), resourceObj = _TemplateControlFactory.findResource(uiControl_1, alias);
                            if (isObject(resourceObj)) {
                                var resource = resourceObj.resource;
                                childContext = (split.length > 0 ? ('.' + split.join('.')) : '');
                                if (alias === __CONTEXT_RESOURCE) {
                                    absoluteContextPath_1 += childContext;
                                }
                                else if (alias === __ROOT_CONTEXT_RESOURCE) {
                                    absoluteContextPath_1 = __CONTEXT + childContext;
                                }
                                else if (resource.type === __OBSERVABLE_RESOURCE || resource.type === __LITERAL_RESOURCE) {
                                    absoluteContextPath_1 = 'resources.' + alias + '.value' + childContext;
                                    uiControl_1.root = resourceObj.control;
                                }
                                else {
                                    this._log.warn('Only resources of type "observable" can be set as context.');
                                }
                            }
                            else {
                                this._log.warn('Could not set the context of ' + uiControl_1.type +
                                    ' with the resource specified as "' + childContext + '".');
                            }
                        }
                        else {
                            absoluteContextPath_1 += '.' + childContext;
                        }
                    }
                    if (!isObject(uiControl_1.root)) {
                        uiControl_1.root = this._ControlFactory.getRootControl(uiControl_1) || uiControl_1;
                    }
                    contextManager_1 = getManager(uiControl_1.root);
                    var awaitContext = false;
                    if (inheritsContext) {
                        uiControl_1.context = contextManager_1.getContext(absoluteContextPath_1.split('.'), false);
                        awaitContext = isUndefined(uiControl_1.context) && !this._BindableTemplatesFactory.isBoundControl(uiControl_1);
                    }
                    else {
                        absoluteContextPath_1 = __CONTEXT;
                    }
                    if (awaitContext) {
                        this.contextPromise = new this._Promise(function (resolve, reject) {
                            var removeListener = contextManager_1.observe(absoluteContextPath_1, {
                                uid: uiControl_1.uid,
                                listener: function (newValue, oldValue) {
                                    if (isUndefined(newValue)) {
                                        return;
                                    }
                                    removeListener();
                                    uiControl_1.context = newValue;
                                    _this._beforeLoad(uiControl_1, absoluteContextPath_1);
                                    resolve();
                                }
                            });
                        });
                    }
                    else {
                        this._beforeLoad(uiControl_1, absoluteContextPath_1);
                    }
                }
                this._observeControlIdentifiers(nodeMap.nodes, parent, controls, nodeMap.element);
                return controls;
            };
            /**
             * Sets the template for an manager by obtaining any needed HTML templates and
             * calling its associated TemplateControl's
             * setTemplate method.
             * @param {string} templateUrl? The URL for the associated TemplateControl's
             * HTML template.
             */
            ElementManager.prototype.setUiControlTemplate = function (templateUrl) {
                var _this = this;
                var controlNode = this.nodeMap.uiControlNode;
                if (!isNull(controlNode)) {
                    var control_1 = controlNode.control;
                    this.templatePromise = this._TemplateControlFactory.determineTemplate(control_1, templateUrl).then(function (template) {
                        _this.templatePromise = null;
                        _this._initializeControl(control_1, template.cloneNode(true));
                    }, function (error) {
                        _this.templatePromise = null;
                        if (isNull(error)) {
                            var template = error;
                            if (_this._BindableTemplatesFactory.isBoundControl(control_1)) {
                                template = appendChildren(control_1.element.childNodes);
                            }
                            _this._initializeControl(control_1, template);
                        }
                        else {
                            postpone(function () {
                                if (isString(error)) {
                                    error = new Error(error);
                                }
                                _this._log.error(error);
                            });
                        }
                    });
                    return;
                }
                if (!isNull(this.parent)) {
                    return;
                }
                this.bindAndLoad();
            };
            /**
             * Retrieves the TemplateControl instance
             * associated with this ElementManager.
             */
            ElementManager.prototype.getUiControl = function () {
                var uiControlNode = this.nodeMap.uiControlNode;
                if (isNull(uiControlNode)) {
                    return;
                }
                return uiControlNode.control;
            };
            /**
             * Fullfills any template promises and finishes the compile phase for the HTML template associated
             * with this ElementManager.
             */
            ElementManager.prototype.fulfillTemplate = function () {
                var _this = this;
                if (!isNull(this.templatePromise)) {
                    return this.templatePromise.then(function () {
                        return _this._fulfillChildTemplates();
                    });
                }
                return this._fulfillChildTemplates();
            };
            /**
             * Fulfills the template promise prior to binding and loading the control.
             */
            ElementManager.prototype.fulfillAndLoad = function () {
                var _this = this;
                return this.fulfillTemplate().then(function () {
                    return _this.bindAndLoad();
                }).catch(function (error) {
                    postpone(function () {
                        if (isString(error)) {
                            error = new Error(error);
                        }
                        _this._log.error(error);
                    });
                });
            };
            /**
             * Binds context to the DOM and loads controls.
             */
            ElementManager.prototype.bindAndLoad = function () {
                var _this = this;
                var controls = this.bind(), promise;
                if (isPromise(this.contextPromise)) {
                    promise = this.contextPromise.then(function () {
                        return _this._bindChildren();
                    });
                }
                else {
                    promise = this._bindChildren();
                }
                return promise.then(function () {
                    return _this._loadControls(controls, _this.getUiControl());
                }).catch(function (error) {
                    postpone(function () {
                        if (isString(error)) {
                            error = new Error(error);
                        }
                        _this._log.error(error);
                    });
                });
            };
            /**
             * Observes the root context for controls that specify their own context, and initiates
             * a load upon a successful set of the context.
             * @param {plat.ui.TemplateControl} root The TemplateControl specifying its own context.
             * @param {() => async.IThenable<void>} loadMethod The function to initiate the loading of the root control and its
             * children.
             */
            ElementManager.prototype.observeRootContext = function (root, loadMethod) {
                var _this = this;
                loadMethod = loadMethod.bind(this);
                if (!isNull(root.context)) {
                    return loadMethod();
                }
                return new this._Promise(function (resolve) {
                    var removeListener = _this._ContextManager.getManager(root).observe(__CONTEXT, {
                        listener: function () {
                            removeListener();
                            loadMethod().then(resolve);
                        },
                        uid: root.uid
                    });
                }).catch(function (error) {
                    postpone(function () {
                        if (isString(error)) {
                            error = new Error(error);
                        }
                        _this._log.error(error);
                    });
                });
            };
            /**
             * Finalizes all the properties on an TemplateControl
             * before loading.
             * @param {plat.ui.TemplateControl} uiControl The control to finalize.
             * @param {string} absoluteContextPath The absoluteContextPath of the uiControl.
             */
            ElementManager.prototype._beforeLoad = function (uiControl, absoluteContextPath) {
                var contextManager = this._ContextManager.getManager(uiControl.root), _TemplateControlFactory = this._TemplateControlFactory;
                uiControl.zCC__plat = contextManager.observe(absoluteContextPath, {
                    uid: uiControl.uid,
                    priority: __CONTEXT_CHANGED_PRIORITY,
                    listener: function (newValue, oldValue) {
                        uiControl.context = newValue;
                    }
                });
                _TemplateControlFactory.setAbsoluteContextPath(uiControl, absoluteContextPath);
                _TemplateControlFactory.setContextResources(uiControl);
                ElementManager._ResourcesFactory.bindResources(uiControl.resources);
            };
            /**
             * Binds context to the DOM and calls bindAndLoad on all children.
             */
            ElementManager.prototype._bindChildren = function () {
                var children = this.children, length = children.length, child, promises = [];
                for (var i = 0; i < length; ++i) {
                    child = children[i];
                    if (child.hasOwnContext) {
                        if (this.isClone) {
                            promises.push(child.observeRootContext(child.getUiControl(), child.bindAndLoad));
                        }
                        else {
                            promises.push(child.observeRootContext(child.getUiControl(), child.fulfillAndLoad));
                        }
                    }
                    else if (!isUndefined(child.children)) {
                        promises.push(child.bindAndLoad());
                    }
                    else {
                        child.bind();
                    }
                }
                return this._Promise.all(promises);
            };
            /**
             * Loads the potential attribute based controls associated with this
             * ElementManager and
             * attaches the corresponding TemplateControl if available.
             * @param {Array<plat.AttributeControl>} controls The array of attribute based controls to load.
             * @param {plat.ui.TemplateControl} templateControl The TemplateControl
             * associated with this manager.
             */
            ElementManager.prototype._loadControls = function (controls, templateControl) {
                var length = controls.length, control, load = this._ControlFactory.load, templateControlLoaded = isNull(templateControl), promise, templateControlPriority, i;
                if (templateControlLoaded) {
                    // don't need to set templateControlPriority because it will never be checked. 
                    i = 0;
                }
                else {
                    var priority = templateControl.priority;
                    templateControlPriority = isNumber(priority) ? priority : 100;
                    i = 1;
                }
                for (; i < length; ++i) {
                    control = controls[i];
                    control.templateControl = templateControl;
                    if (!templateControlLoaded && templateControlPriority > control.priority) {
                        templateControlLoaded = true;
                        promise = load(templateControl);
                    }
                    load(control);
                }
                if (!templateControlLoaded) {
                    promise = load(templateControl);
                }
                return promise;
            };
            /**
             * Populates the TemplateControl properties associated with this manager
             * if one exists.
             */
            ElementManager.prototype._populateUiControl = function () {
                var nodeMap = this.nodeMap, parent = this.getParentControl(), controlNode = nodeMap.uiControlNode, uiControl = controlNode.control, uid = uiControl.uid, resources = uiControl.resources, element = nodeMap.element, childNodes = Array.prototype.slice.call(element.childNodes), newAttributes = ElementManager._AttributesFactory.getInstance(), replace = this.replace = (uiControl.replaceWith === null || uiControl.replaceWith === '');
                if (!isString(uid)) {
                    uid = uiControl.uid = uniqueId(__Plat);
                }
                ElementManager._managerCache.put(uid, this);
                if (!isNull(parent) && uiControl.parent !== parent) {
                    parent.controls.push(uiControl);
                    uiControl.parent = parent;
                }
                if (isFunction(element.setAttribute)) {
                    element.setAttribute(__Hide, '');
                }
                uiControl.element = element;
                uiControl.controls = [];
                newAttributes.initialize(uiControl, nodeMap.attributes);
                uiControl.attributes = newAttributes;
                if (isObject(resources) && isFunction(resources.add)) {
                    resources.add(controlNode.resourceElement);
                }
                else {
                    resources = ElementManager._ResourcesFactory.getInstance();
                    resources.initialize(uiControl, controlNode.resourceElement);
                    uiControl.resources = resources;
                }
                ElementManager._ResourcesFactory.addControlResources(uiControl);
                uiControl.type = controlNode.nodeName;
                uiControl.bindableTemplates = uiControl.bindableTemplates || this._BindableTemplatesFactory.create(uiControl);
                if (childNodes.length > 0 && (!isEmpty(uiControl.templateString) || !isEmpty(uiControl.templateUrl))) {
                    uiControl.innerTemplate = appendChildren(childNodes);
                }
                if (replace) {
                    this._replaceElement(uiControl, nodeMap);
                }
            };
            /**
             * Removes the TemplateControl's element. Called if its replaceWith property is
             * null or empty string.
             * @param {plat.ui.TemplateControl} control The TemplateControl whose element
             * will be removed.
             * @param {plat.processing.INodeMap} nodeMap The INodeMap associated with this manager.
             */
            ElementManager.prototype._replaceElement = function (control, nodeMap) {
                var element = nodeMap.element, parentNode = element.parentNode, _document = ElementManager._document, controlType = control.type, controlUid = control.uid, startNode = control.startNode = _document.createComment(controlType + ' ' + controlUid + __START_NODE), endNode = control.endNode = _document.createComment(controlType + ' ' + controlUid + __END_NODE), create = this._CommentManagerFactory.create;
                create(startNode, this);
                create(endNode, this);
                parentNode.insertBefore(startNode, element);
                parentNode.insertBefore(endNode, element.nextSibling);
                control.elementNodes = replace(element);
                control.element = nodeMap.element = null;
            };
            /**
             * Initializes a control's template and compiles the control.
             * @param {plat.ui.TemplateControl} uiControl The TemplateControl
             * associated with this manager.
             * @param {DocumentFragment} template The associated TemplateControl's
             * template.
             */
            ElementManager.prototype._initializeControl = function (uiControl, template) {
                var element = this.nodeMap.element, 
                // have to check if null since isNull checks for undefined case 
                replaceElement = this.replace, endNode;
                if (!isNull(template)) {
                    var resourceElement = ElementManager.locateResources(template);
                    if (!isNull(resourceElement)) {
                        uiControl.resources.add(ElementManager._ResourcesFactory.parseElement(resourceElement));
                    }
                    if (replaceElement) {
                        endNode = uiControl.endNode;
                        uiControl.elementNodes = Array.prototype.slice.call(template.childNodes);
                        insertBefore(endNode.parentNode, template, endNode);
                    }
                    else {
                        insertBefore(element, template, element.lastChild);
                    }
                }
                if (isFunction(uiControl.setTemplate)) {
                    uiControl.setTemplate();
                }
                if (replaceElement) {
                    this._compiler.compile(uiControl.elementNodes, uiControl);
                    var startNode = uiControl.startNode, parentNode = startNode.parentNode, childNodes = Array.prototype.slice.call(parentNode.childNodes);
                    endNode = uiControl.endNode;
                    uiControl.elementNodes = childNodes.slice(childNodes.indexOf(startNode) + 1, childNodes.indexOf(endNode));
                    this.replaceNodeLength = uiControl.elementNodes.length + 2;
                }
                else {
                    this._compiler.compile(element, uiControl);
                }
                if (isNull(uiControl.parent)) {
                    this.fulfillAndLoad();
                }
            };
            /**
             * Observes the identifiers associated with this manager's INodes.
             * @param {Array<plat.processing.INode>} nodes The array of INodes to iterate through.
             * @param {plat.ui.TemplateControl} parent The parent TemplateControl for context.
             * @param {Array<plat.Control>} controls The array of controls whose attributes will need to be updated
             * upon the context changing.
             */
            ElementManager.prototype._observeControlIdentifiers = function (nodes, parent, controls, element) {
                var length = nodes.length, hasParent = !isNull(parent), node, control, i = 0, replace = this.replace, managers = [], manager;
                for (; i < length; ++i) {
                    node = nodes[i];
                    control = node.control;
                    if (hasParent && node.expressions.length > 0) {
                        manager = AttributeManager.getInstance();
                        managers.push(manager);
                        manager.initialize(element, node, parent, controls, replace);
                        NodeManager.observeExpressions(node.expressions, parent, manager.attributeChanged.bind(manager));
                    }
                    if (!isNull(control)) {
                        controls.push(control);
                    }
                }
                length = managers.length;
                for (i = 0; i < length; ++i) {
                    managers[i].attributeChanged();
                }
            };
            /**
             * Runs through all the children of this manager and calls fulfillTemplate.
             */
            ElementManager.prototype._fulfillChildTemplates = function () {
                var _this = this;
                var children = this.children, child, length = children.length, promises = [];
                for (var i = 0; i < length; ++i) {
                    child = children[i];
                    if (!isUndefined(child.children)) {
                        promises.push(child.fulfillTemplate());
                    }
                }
                return this._Promise.all(promises).catch(function (error) {
                    postpone(function () {
                        if (isString(error)) {
                            error = new Error(error);
                        }
                        _this._log.error(error);
                    });
                });
            };
            ElementManager._inject = {
                _Promise: __Promise,
                _ContextManager: __ContextManagerStatic,
                _compiler: __Compiler,
                _CommentManagerFactory: __CommentManagerFactory,
                _ControlFactory: __ControlFactory,
                _TemplateControlFactory: __TemplateControlFactory,
                _BindableTemplatesFactory: __BindableTemplatesFactory,
                _log: __Log
            };
            return ElementManager;
        }(NodeManager));
        processing.ElementManager = ElementManager;
        /**
         */
        function IElementManagerFactory(_document, _managerCache, _ResourcesFactory, _AttributesFactory, _BindableTemplatesFactory, _log) {
            ElementManager._document = _document;
            ElementManager._managerCache = _managerCache;
            ElementManager._ResourcesFactory = _ResourcesFactory;
            ElementManager._AttributesFactory = _AttributesFactory;
            ElementManager._BindableTemplatesFactory = _BindableTemplatesFactory;
            ElementManager._log = _log;
            return ElementManager;
        }
        processing.IElementManagerFactory = IElementManagerFactory;
        register.injectable(__ElementManagerFactory, IElementManagerFactory, [
            __Document,
            __ManagerCache,
            __ResourcesFactory,
            __AttributesFactory,
            __BindableTemplatesFactory,
            __Log
        ], __FACTORY);
        register.injectable(__ElementManagerInstance, ElementManager, null, __INSTANCE);
        /**
         * The class responsible for initializing and data-binding values to text nodes.
         */
        var TextManager = (function (_super) {
            __extends(TextManager, _super);
            function TextManager() {
                _super.apply(this, arguments);
                /**
                 * Specifies the type for this NodeManager.
                 * It's value is "text".
                 */
                this.type = 'text';
            }
            /**
             * Determines if a text node has markup, and creates a TextManager if it does.
             * An TextManager responsible for markup in the passed in node or an empty
             * TextManager if not markup is found will be added to the managers array.
             * @param {Node} node The Node used to find markup.
             * @param {plat.processing.ElementManager} parent The parent ElementManager
             * for the node.
             */
            TextManager.create = function (node, parent) {
                var value = node.nodeValue, manager = new TextManager();
                if (NodeManager.hasMarkup(value)) {
                    var expressions_1 = NodeManager.findMarkup(value), map_1 = {
                        nodes: [{
                                node: node,
                                expressions: expressions_1
                            }]
                    };
                    manager.initialize(map_1, parent);
                    return manager;
                }
                manager.initialize(null, parent);
                manager.bind = noop;
                return manager;
            };
            /**
             * Clones an INodeMap with a new text node.
             * @param {plat.processing.INodeMap} sourceMap The original INodeMap.
             * @param {Node} newNode The new text node used for cloning.
             */
            TextManager._cloneNodeMap = function (sourceMap, newNode) {
                var node = sourceMap.nodes[0], nodeMap = {
                    nodes: [{
                            expressions: node.expressions,
                            nodeName: node.nodeName,
                            node: newNode
                        }]
                };
                return nodeMap;
            };
            /**
             * Clones a TextManager with a new text node.
             * @param {plat.processing.NodeManager} sourceManager The original NodeManager.
             * @param {Node} node The new text node to associate with the clone.
             * @param {plat.processing.ElementManager} parent The parent ElementManager
             * for the new clone.
             */
            TextManager._clone = function (sourceManager, node, parent) {
                var map = sourceManager.nodeMap, manager = new TextManager();
                if (!isNull(map)) {
                    manager.initialize(TextManager._cloneNodeMap(map, node), parent);
                }
                else {
                    manager.initialize(null, parent);
                    manager.bind = noop;
                }
                return manager;
            };
            /**
             * Clones this TextManager with a new node.
             * @param {Node} newNode The new node attached to the cloned TextManager.
             * @param {plat.processing.ElementManager} parentManager The parent ElementManager
             * for the clone.
             */
            TextManager.prototype.clone = function (newNode, parentManager) {
                TextManager._clone(this, newNode, parentManager);
                return 1;
            };
            /**
             * The function used for data-binding a data context to the DOM.
             */
            TextManager.prototype.bind = function () {
                var parent = this.getParentControl(), node = this.nodeMap.nodes[0], textNode = node.node, expressions = node.expressions;
                NodeManager.observeExpressions(node.expressions, parent, this._setText.bind(this, textNode, parent, expressions));
                this._setText(textNode, parent, expressions);
            };
            /**
             * Builds the node expression and sets the value.
             * @param {Node} Node The associated node whose value will be set.
             * @param {plat.ui.TemplateControl} control The control whose context will be used to bind
             * the data.
             * @param {Array<plat.expressions.IParsedExpression>} expressions An array of parsed expressions used to build
             * the node value.
             */
            TextManager.prototype._setText = function (node, control, expressions) {
                node.nodeValue = NodeManager.build(expressions, (control || {}));
            };
            return TextManager;
        }(NodeManager));
        processing.TextManager = TextManager;
        /**
         */
        function ITextManagerFactory() {
            return TextManager;
        }
        processing.ITextManagerFactory = ITextManagerFactory;
        register.injectable(__TextManagerFactory, ITextManagerFactory, null, __FACTORY);
        register.injectable(__TextManagerInstance, TextManager, null, __INSTANCE);
        /**
         * A class used to manage Comment nodes. Provides a way to
         * clone a Comment node.
         */
        var CommentManager = (function (_super) {
            __extends(CommentManager, _super);
            function CommentManager() {
                _super.apply(this, arguments);
                /**
                 * Specifies the type for this NodeManager.
                 * It's value is "comment".
                 */
                this.type = 'comment';
            }
            /**
             * Creates a new CommentManager for the given Comment node.
             * @param {Node} node The Comment to associate with the new manager.
             * @param {plat.processing.ElementManager} parent The parent
             * ElementManager.
             */
            CommentManager.create = function (node, parent) {
                var manager = new CommentManager();
                manager.initialize({
                    nodes: [{
                            node: node
                        }]
                }, parent);
                return manager;
            };
            /**
             * A method for cloning this manager with a new Comment.
             * @param {Node} newNode The new Comment node to associate with the cloned
             * manager.
             * @param {plat.processing.ElementManager} parentManager The parent ElementManager
             * for the clone.
             */
            CommentManager.prototype.clone = function (newNode, parentManager) {
                CommentManager.create(newNode, parentManager);
                return 1;
            };
            return CommentManager;
        }(NodeManager));
        processing.CommentManager = CommentManager;
        /**
         */
        function ICommentManagerFactory() {
            return CommentManager;
        }
        processing.ICommentManagerFactory = ICommentManagerFactory;
        register.injectable(__CommentManagerFactory, ICommentManagerFactory, null, __FACTORY);
        register.injectable(__CommentManagerInstance, CommentManager, null, __INSTANCE);
        /**
         * Used to facilitate observing expressions on attributes. Has the ability to alert Attributes
         * with changes. Handles dynamic and static attributes (dynamic meaning "class"-like attributes).
         */
        var AttributeManager = (function () {
            function AttributeManager() {
                /**
                 * A regular expression for finding markup in a string.
                 */
                this._markupRegex = new RegExp("^" + __startSymbol + "[\\S\\s]*?" + __endSymbol + "\\S*\\s*|\\s*\\S*" + __startSymbol + "[\\S\\s]*?" + __endSymbol + "\\S*", 'g');
                /**
                 * Keeps track of the previous bound values of a "dynamic" attribute.
                 */
                this._lastValues = {};
            }
            /**
             * Returns a new instance of an AttributeManager.
             */
            AttributeManager.getInstance = function () {
                var manager = new AttributeManager();
                manager._NodeManager = acquire(__NodeManagerStatic);
                return manager;
            };
            /**
             * Initializes the manager and determines what method should be used to handle attribute changes.
             * @param {HTMLElement} element The element that contains this attribute.
             * @param {plat.processing.INode} node The INode associated with this attribute.
             * @param {plat.ui.TemplateControl} parent The parent control for all the controls associated with
             * the element.
             * @param {Array<plat.Control>} controls The controls associated with the element.
             * @param {boolean} replace? Whether or not the element is replaced.
             */
            AttributeManager.prototype.initialize = function (element, node, parent, controls, replace) {
                this.element = element;
                this.node = node;
                this.parent = parent;
                this._controls = controls;
                this.replace = replace;
                if (node.nodeName !== 'class') {
                    this.attributeChanged = this._staticAttributeChanged;
                }
                else {
                    this.attributeChanged = this._dynamicAttributeChanged;
                }
            };
            /**
             * Handles changes to dynamic attributes. Takes into account that the attribute may have been changed programmatically, and
             * we need to only mutate the piece of the attribute corresponding to expressions with markup.
             */
            AttributeManager.prototype._dynamicAttributeChanged = function () {
                var node = this.node, attr = node.node, nodeValue = attr.value, classes = this._NodeManager.build(node.expressions, this.parent).trim().split(/\s/), last = this._lastValues, element = this.element, c, length = classes.length, i;
                if (this._NodeManager.hasMarkup(nodeValue)) {
                    attr.value = nodeValue.replace(this._markupRegex, '').trim();
                }
                for (i = 0; i < length; ++i) {
                    last[classes[i]] = true;
                }
                classes = Object.keys(last);
                length = classes.length;
                for (i = 0; i < length; ++i) {
                    c = classes[i];
                    if (last[c]) {
                        addClass(element, c);
                        last[c] = false;
                    }
                    else {
                        deleteProperty(last, c);
                        removeClass(element, c);
                    }
                }
                this._notifyAttributes(node.nodeName, attr.value);
            };
            /**
             * Handles changes to static attributes. Builds a string from the node expressions, then sets the attribute value
             * and notifies the associated Attributes.
             */
            AttributeManager.prototype._staticAttributeChanged = function () {
                var controls = this._controls, node = this.node, key = camelCase(node.nodeName), value = this._NodeManager.build(node.expressions, this.parent);
                this._notifyAttributes(key, value);
                if (!this.replace) {
                    node.node.value = value;
                }
            };
            /**
             * Notifies the necessary Attributes of changes to an attribute.
             */
            AttributeManager.prototype._notifyAttributes = function (key, value) {
                var controls = this._controls, length = controls.length, attributes, oldValue;
                for (var i = 0; i < length; ++i) {
                    attributes = controls[i].attributes;
                    oldValue = attributes[key];
                    attributes[key] = value;
                    attributes._attributeChanged(key, value, oldValue);
                }
            };
            return AttributeManager;
        }());
        processing.AttributeManager = AttributeManager;
    })(processing = plat_1.processing || (plat_1.processing = {}));
    /**
     * Holds all classes and interfaces related to routing components in platypus.
     */
    var routing;
    (function (routing) {
        /**
         * Ties the browser and routers together, facilitating app navigation at every router level.
         * Listens for url changes and responds accordingly. Also contains functionality for generating
         * and changing the url.
         */
        var Navigator = (function () {
            function Navigator() {
                /**
                 * A unique id, created during instantiation and found on every Navigator.
                 */
                this.uid = uniqueId(__Plat);
                /**
                 * States whether or not the Navigator is the root Navigator.
                 */
                this.isRoot = false;
                /**
                 * A method to call to stop listening for url changes, only works on the root navigator.
                 */
                this._removeUrlListener = noop;
                /**
                 * A method to call to stop listening for url changes, only works on the root navigator.
                 */
                this._ignoreOnce = false;
                /**
                 * Whether or not the current navigation is a backward navigation
                 */
                this._backNavigate = false;
            }
            /**
             * Initializes this Navigator with a router.
             * @param {plat.routing.Router} router The router that the navigator should use to match/generate routes.
             */
            Navigator.prototype.initialize = function (router) {
                this._router = router;
                if (isObject(router) && router.isRoot && !isObject(Navigator._root)) {
                    this.isRoot = true;
                    Navigator._root = this;
                    this._observeUrl();
                }
            };
            /**
             * Tells the navigator to navigate to the url registered for a particular view.
             * @param {any} view The view to which the Navigator should navigate.
             * @param {plat.routing.INavigateOptions} options used to generate the url and perform navigation.
             */
            Navigator.prototype.navigate = function (view, options) {
                var _this = this;
                options = isObject(options) ? options : {};
                var url;
                return this.finishNavigating().then(function () {
                    if (options.isUrl) {
                        url = view;
                    }
                    else {
                        url = _this._generate(view, options.parameters, options.query);
                    }
                    if (!isString(url)) {
                        var error = new Error('Cannot serialize url from input parameters, check your view reference.');
                        _this._log.error(error);
                    }
                    return _this._navigate(url, options.replace);
                });
            };
            /**
             * Returns a promise that resolves when all navigation has finished.
             */
            Navigator.prototype.finishNavigating = function () {
                var router = Navigator._root._router;
                if (router.navigating) {
                    return router.finishNavigating.catch(noop);
                }
                return this._Promise.resolve();
            };
            /**
             * Tells the router to go back with the given options.
             */
            Navigator.prototype.goBack = function (options) {
                var _this = this;
                options = isObject(options) ? options : {};
                var length = Number(options.length);
                if (!isNumber(length)) {
                    length = 1;
                }
                if (!this.isRoot) {
                    return Navigator._root.goBack(options);
                }
                return this.finishNavigating().then(function () {
                    _this._backNavigate = true;
                    return _this._goBack(length);
                });
            };
            /**
             * Indicates whether or not the current navigation is a backward navigation.
             */
            Navigator.prototype.isBackNavigation = function () {
                if (!this.isRoot) {
                    return Navigator._root.isBackNavigation();
                }
                return this._backNavigate;
            };
            /**
             * Lets the router dispose of all of the necessary properties.
             */
            Navigator.prototype.dispose = function () {
                this._removeUrlListener();
                deleteProperty(this, 'router');
            };
            /**
             * Internal method for navigating to the specified url.
             */
            Navigator.prototype._navigate = function (url, replace) {
                var _this = this;
                if (!this.isRoot) {
                    return Navigator._root._navigate(url, replace);
                }
                return new this._Promise(function (resolve, reject) {
                    _this._resolveNavigate = resolve;
                    _this._rejectNavigate = reject;
                    var current = _this._browser.url(), next = _this._browser.url(url, replace);
                    if (current === next) {
                        _this._resolveNavigate();
                    }
                });
            };
            /**
             * Internal method for going back a certain length in history
             */
            Navigator.prototype._goBack = function (length) {
                var _this = this;
                return new this._Promise(function (resolve, reject) {
                    _this._resolveNavigate = resolve;
                    _this._rejectNavigate = reject;
                    _this._browser.back(length);
                });
            };
            /**
             * The root navigator will always observe for url changes and handle them accordingly. This means instructing the
             * router to navigate, and determining what to do in the event that navigation is prevented.
             */
            Navigator.prototype._observeUrl = function () {
                var _this = this;
                if (!isObject(this._router)) {
                    return;
                }
                var EventManager = this._EventManager, previousUrl, headControl = acquire(__Head), headExists = isObject(headControl) && isFunction(headControl.navigated), onFailedNavigaton = function (e) {
                    _this._previousUrl = previousUrl;
                    var _history = _this._history, state = _history.state;
                    _this._ignoreOnce = true;
                    if (isNull(state.previousLocation) || state.previousLocation === previousUrl) {
                        _history.go(-1);
                    }
                    else {
                        _history.go(1);
                    }
                    _this._backNavigate = false;
                    if (isFunction(_this._rejectNavigate)) {
                        _this._rejectNavigate(e);
                    }
                    if (!isEmpty(e)) {
                        _this._log.warn(e);
                    }
                };
                this._previousUrl = this._browser.url();
                // Protect against accidentally calling this method twice. 
                EventManager.dispose(this.uid);
                EventManager.on(this.uid, __backButton, function () {
                    var ev = EventManager.dispatch(__backButtonPressed, _this, EventManager.DIRECT);
                    if (ev.defaultPrevented) {
                        return;
                    }
                    _this.goBack();
                });
                EventManager.on(this.uid, __urlChanged, function (ev, utils) {
                    if (_this._ignoreOnce) {
                        _this._ignoreOnce = false;
                        if (isFunction(_this._resolveNavigate)) {
                            _this._backNavigate = false;
                            _this._resolveNavigate();
                        }
                        return;
                    }
                    previousUrl = _this._previousUrl;
                    ev = EventManager.dispatch(__beforeNavigate, _this, EventManager.DIRECT, [utils]);
                    if (ev.defaultPrevented) {
                        onFailedNavigaton(new Error('Navigation prevented during ' + __beforeNavigate + ' event'));
                        return;
                    }
                    _this.finishNavigating()
                        .then(function () {
                        EventManager.dispatch(__navigating, _this, EventManager.DIRECT, [utils]);
                        return _this._router.navigate(utils.pathname, utils.query);
                    }).then(function () {
                        _this._previousUrl = utils.pathname;
                        if (isFunction(_this._resolveNavigate)) {
                            _this._backNavigate = false;
                            _this._resolveNavigate();
                        }
                        if (headExists) {
                            headControl.navigated(utils.href);
                        }
                        EventManager.dispatch(__navigated, _this, EventManager.DIRECT, [utils]);
                    }, onFailedNavigaton);
                });
            };
            /**
             * Generates a url with the given view, parameters, and query.
             */
            Navigator.prototype._generate = function (view, parameters, query) {
                if (isNull(this._router)) {
                    return;
                }
                if (isEmpty(view)) {
                    return view;
                }
                return this._router.generate(view, parameters, query);
            };
            Navigator._inject = {
                _Promise: __Promise,
                _Injector: __InjectorStatic,
                _browserConfig: __BrowserConfig,
                _browser: __Browser,
                _EventManager: __EventManagerStatic,
                _window: __Window,
                _log: __Log,
                _history: __History
            };
            return Navigator;
        }());
        routing.Navigator = Navigator;
        register.injectable(__NavigatorInstance, Navigator, null, __INSTANCE);
        /**
         */
        function History(_window) {
            return _window.history;
        }
        routing.History = History;
        register.injectable(__History, History, [__Window]);
        var specialCharacters = [
            '/', '.', '*', '+', '?', '|',
            '(', ')', '[', ']', '{', '}', '\\'
        ], escapeRegex = new RegExp('(\\' + specialCharacters.join('|\\') + ')', 'g');
        var baseSegment, dynamicSegments = {}, splatSegments = {}, staticSegments = {};
        /**
         * Stores information about a segment, publishes a regex for matching the segment as well as
         * methods for generating the segment and iterating over the characters in the segment.
         */
        var BaseSegment = (function () {
            function BaseSegment() {
                /**
                 * Denotes the type of segment for this instance.
                 */
                this.type = __BASE_SEGMENT_TYPE;
                /**
                 * The name of the segment.
                 */
                this.name = '';
                /**
                 * A regular expression string which can be used to match the segment.
                 */
                this.regex = '';
            }
            /**
             * Parses a route into segments, populating an array of names (for dynamic and splat segments) as well as
             * an ISegmentTypeCount object.
             * @param {string} route The route to parse.
             * @param {Array<string>} names An array to populate with dynamic/splat segment names
             * @param {plat.routing.ISegmentTypeCount} types An object to use for counting segment types in the route.
             */
            BaseSegment.parse = function (route, names, types) {
                if (!isString(route) || !isArray(names) || !isObject(types)) {
                    return [];
                }
                else if (route[0] === '/') {
                    route = route.slice(1);
                }
                var segments = route.split('/'), length = segments.length, findSegment = BaseSegment.__findSegment, results = [], segment, name, match, _regex = BaseSegment._regex;
                for (var i = 0; i < length; ++i) {
                    segment = segments[i];
                    if (segment === '') {
                        if (!isObject(baseSegment)) {
                            baseSegment = acquire(__BaseSegmentInstance);
                        }
                        results.push(baseSegment);
                    }
                    else if (match = segment.match(_regex.dynamicSegmentsRegex)) {
                        name = match[1];
                        results.push(findSegment(name, __DynamicSegmentInstance, dynamicSegments));
                        names.push(name);
                        types.dynamics++;
                    }
                    else if (match = segment.match(_regex.splatSegmentRegex)) {
                        name = match[1];
                        results.push(findSegment(name, __SplatSegmentInstance, splatSegments));
                        names.push(name);
                        types.splats++;
                    }
                    else {
                        results.push(findSegment(segment, __StaticSegmentInstance, staticSegments));
                        types.statics++;
                    }
                }
                return results;
            };
            /**
             * Parses a route into segments, populating an array of names (for dynamic and splat segments) as well as
             * an ISegmentTypeCount object.
             * @param {string} name The name of the segment to look for.
             * @param {string} token The token used to acquire a new segment if necessary.
             * @param {plat.IObject<plat.routing.BaseSegment>} cache The cache in which to look for/store the segment.
             */
            BaseSegment.__findSegment = function (name, token, cache) {
                var segment = cache[name];
                if (!isObject(segment)) {
                    segment = cache[name] = acquire(token);
                    segment.initialize(name);
                }
                return segment;
            };
            /**
             * Initializes the segment.
             * @param {string} name? The name for the new segment.
             */
            BaseSegment.prototype.initialize = function (name) {
                this.name = name;
            };
            /**
             * Iterates over the characters in the segment, calling an iterator method and accumulating the result of each call in
             * a defined object.
             * @param {(previousValue: T, spec: plat.routing.ICharacterSpecification) => T} iterator The iterator to call with each character.
             * @param {T} initialValue? An optional initial value with which to start the accumulation.
             */
            BaseSegment.prototype.reduceCharacters = function (iterator, initialValue) {
                if (isObject(this._specification)) {
                    initialValue = iterator(initialValue, this._specification);
                }
                return initialValue;
            };
            /**
             * Generates a new segment, using the input parameters if necessary.
             * @param {plat.IObject<string>} parameters? The input parameters for the segment.
             */
            BaseSegment.prototype.generate = function (parameters) {
                return this.name;
            };
            return BaseSegment;
        }());
        routing.BaseSegment = BaseSegment;
        /**
         */
        function IBaseSegmentFactory(_regex) {
            BaseSegment._regex = _regex;
            return BaseSegment;
        }
        routing.IBaseSegmentFactory = IBaseSegmentFactory;
        register.injectable(__BaseSegmentFactory, IBaseSegmentFactory, [__Regex], __FACTORY);
        register.injectable(__BaseSegmentInstance, BaseSegment, null, __INSTANCE);
        /**
         * Stores information about a static segment, publishes a regex for matching the segment as well as
         * methods for generating the segment and iterating over the characters in the segment.
         */
        var StaticSegment = (function (_super) {
            __extends(StaticSegment, _super);
            function StaticSegment() {
                _super.apply(this, arguments);
                /**
                 * Denotes that this is a static segment.
                 */
                this.type = __STATIC_SEGMENT_TYPE;
            }
            /**
             * Initializes the segment.
             * @param {string} name? The name for the new segment.
             */
            StaticSegment.prototype.initialize = function (name) {
                _super.prototype.initialize.call(this, name);
                this.regex = this.name.replace(escapeRegex, '\\$1');
            };
            /**
             * Iterates over the characters in the segment, calling an iterator method and accumulating the result of each call in
             * a defined object.
             * @param {(previousValue: T, spec: plat.routing.ICharacterSpecification) => T} iterator The iterator to call with each character.
             * @param {T} initialValue? An optional initial value with which to start the accumulation.
             */
            StaticSegment.prototype.reduceCharacters = function (iterator, initialValue) {
                var name = this.name, length = name.length, value = initialValue;
                for (var i = 0; i < length; ++i) {
                    value = iterator(value, { validCharacters: name[i] });
                }
                return value;
            };
            return StaticSegment;
        }(BaseSegment));
        routing.StaticSegment = StaticSegment;
        register.injectable(__StaticSegmentInstance, StaticSegment, null, __INSTANCE);
        /**
         * Stores information about a variable segment (either dynamic or splat), publishes a regex for matching the segment as well as
         * methods for generating the segment and iterating over the characters in the segment.
         */
        var VariableSegment = (function (_super) {
            __extends(VariableSegment, _super);
            function VariableSegment() {
                _super.apply(this, arguments);
                /**
                 * Denotes that this is a variable segment.
                 */
                this.type = __VARIABLE_SEGMENT_TYPE;
            }
            /**
             * Generates a new segment, using the input parameters.
             * @param {plat.IObject<string>} parameters? The input parameters for the segment.
             */
            VariableSegment.prototype.generate = function (parameters) {
                if (isObject(parameters)) {
                    return parameters[this.name];
                }
            };
            return VariableSegment;
        }(BaseSegment));
        routing.VariableSegment = VariableSegment;
        register.injectable(__VariableSegmentInstance, VariableSegment, null, __INSTANCE);
        /**
         * Stores information about a splat segment, publishes a regex for matching the segment as well as
         * methods for generating the segment and iterating over the characters in the segment.
         */
        var SplatSegment = (function (_super) {
            __extends(SplatSegment, _super);
            function SplatSegment() {
                _super.apply(this, arguments);
                /**
                 * Denotes that this is a splat segment.
                 */
                this.type = __SPLAT_SEGMENT_TYPE;
                /**
                 * A regular expression string which can be used to match the segment.
                 */
                this.regex = '(.+)';
                /**
                 * A regular expression string which can be used to match the segment.
                 */
                this._specification = {
                    invalidCharacters: '',
                    repeat: true
                };
            }
            return SplatSegment;
        }(VariableSegment));
        routing.SplatSegment = SplatSegment;
        register.injectable(__SplatSegmentInstance, SplatSegment, null, __INSTANCE);
        /**
         * Stores information about a dynamic segment, publishes a regex for matching the segment as well as
         * methods for generating the segment and iterating over the characters in the segment.
         */
        var DynamicSegment = (function (_super) {
            __extends(DynamicSegment, _super);
            function DynamicSegment() {
                _super.apply(this, arguments);
                /**
                 * Denotes that this is a dynamic segment.
                 */
                this.type = __DYNAMIC_SEGMENT_TYPE;
                /**
                 * A regular expression string which can be used to match the segment.
                 */
                this.regex = '([^/]+)';
                /**
                 * A regular expression string which can be used to match the segment.
                 */
                this._specification = {
                    invalidCharacters: '/',
                    repeat: true
                };
            }
            return DynamicSegment;
        }(VariableSegment));
        routing.DynamicSegment = DynamicSegment;
        register.injectable(__DynamicSegmentInstance, DynamicSegment, null, __INSTANCE);
        /**
         * Route segment matching is done using a state machine. Each state contains
         * a specification indicating valid and invalid characters. Each State has a
         * list of potential next states. When matching a route segment you start with
         * a root state and then iteratively match next states until you complete the
         * segment or invalidate the segment.
         */
        var State = (function () {
            /**
             * The constructor for a State.
             */
            function State() {
                this.initialize();
            }
            /**
             * Compiles a segment into a state tree.
             * @param {plat.routing.BaseSegment} segment The segment to compile.
             * @param {plat.routing.State} state The initial state with which to start compilation.
             */
            State.compile = function (segment, state) {
                return segment.reduceCharacters(function (s, char) {
                    return s.add(char);
                }, state);
            };
            /**
             * Links a path to a compiled state, and returns the result.
             * @param {plat.routing.State} state The state with which to link the result.
             * @param {string} path The path to link to the given state.
             */
            State.link = function (state, path) {
                var delegates = state.delegates, regex = state.regex, length = delegates.length, matches = path.match(regex), matchIndex = 1, result = [], names, parameters, j, jLength, delegate;
                for (var i = 0; i < length; ++i) {
                    delegate = delegates[i];
                    names = delegate.names;
                    parameters = {};
                    for (j = 0, jLength = names.length; j < jLength; ++j) {
                        parameters[names[j]] = matches[matchIndex++];
                    }
                    result.push({
                        delegate: delegate.delegate,
                        parameters: parameters,
                        isDynamic: jLength > 0
                    });
                }
                return result;
            };
            /**
             * Finds all the next states for a given character.
             * @param {string} char The character used to match next states.
             * @param {Array<plat.routing.State>} states The states with which to match the character.
             */
            State.recognize = function (char, states) {
                var nextStates = [], length = states.length, state;
                for (var i = 0; i < length; ++i) {
                    state = states[i];
                    nextStates = nextStates.concat(state.match(char));
                }
                return nextStates;
            };
            /**
             * Sorts states by statics/dynamics/splats.
             * @param {Array<plat.routing.State>} states The states to sort.
             */
            State.sort = function (states) {
                if (!isArray(states)) {
                    return states;
                }
                var aTypes, aSplats, aStatics, aDynamics, bTypes, bSplats, bStatics, bDynamics;
                return states.sort(function (a, b) {
                    aTypes = a.types;
                    bTypes = b.types;
                    aSplats = aTypes.splats;
                    bSplats = bTypes.splats;
                    if (aSplats !== bSplats) {
                        return aSplats - bSplats;
                    }
                    aStatics = aTypes.statics;
                    aDynamics = aTypes.dynamics;
                    bStatics = bTypes.statics;
                    bDynamics = bTypes.dynamics;
                    if (aSplats > 0) {
                        if (aStatics !== bStatics) {
                            return bStatics - aStatics;
                        }
                        if (aDynamics !== bDynamics) {
                            return bDynamics - aDynamics;
                        }
                    }
                    if (aDynamics !== bDynamics) {
                        return aDynamics - bDynamics;
                    }
                    if (aStatics !== bStatics) {
                        return bStatics = aStatics;
                    }
                    return 0;
                });
            };
            /**
             * Initializes the state with the given specification.
             * @param {plat.routing.ICharacterSpecification} specification? The character specification for the state.
             */
            State.prototype.initialize = function (specification) {
                this.specification = specification;
                this.nextStates = [];
            };
            /**
             * Adds a new specification to the next states. If the specification
             * already exists as a next state a new one won't be used.
             * @param {plat.routing.ICharacterSpecification} specification? The character specification used to create
             * the next state if necessary.
             */
            State.prototype.add = function (specification) {
                var state = this._find(specification);
                if (isObject(state)) {
                    return state;
                }
                state = acquire(State);
                state.initialize(specification);
                this.nextStates.push(state);
                if (specification.repeat) {
                    state.nextStates.push(state);
                }
                return state;
            };
            /**
             * Finds next states that match the input character. If the character exists
             * in the state's specification for valid characters, or if it does not
             * exist in the specification for invalid characters, then the state is considered
             * a match.
             * @param {string} char The character with which to match next states.
             */
            State.prototype.match = function (char) {
                var matches = [], spec, chars;
                this._someChildren(function (child) {
                    spec = child.specification;
                    // Check for valid characters first 
                    chars = spec.validCharacters;
                    if (isString(chars) && chars.indexOf(char) > -1) {
                        matches.push(child);
                        return;
                    }
                    // Check for no invalid characters 
                    chars = spec.invalidCharacters;
                    if (isString(chars) && chars.indexOf(char) === -1) {
                        matches.push(child);
                    }
                });
                return matches;
            };
            /**
             * Finds the next state that shares the same specification
             * as the input spec.
             * @param {plat.routing.ICharacterSpecification} spec The character specification used to find
             * the next state.
             */
            State.prototype._find = function (spec) {
                var validChars = spec.validCharacters, invalidChars = spec.invalidCharacters, s, found;
                this._someChildren(function (child) {
                    s = child.specification;
                    if (s.validCharacters === validChars &&
                        s.invalidCharacters === invalidChars) {
                        found = child;
                        return true;
                    }
                });
                return found;
            };
            State.prototype._someChildren = function (iterator) {
                var nextStates = this.nextStates, length = nextStates.length;
                for (var i = 0; i < length; ++i) {
                    if (iterator(nextStates[i]) === true) {
                        return true;
                    }
                }
                return false;
            };
            return State;
        }());
        routing.State = State;
        /**
         */
        function IStateStatic() {
            return State;
        }
        routing.IStateStatic = IStateStatic;
        register.injectable(__StateStatic, IStateStatic, null, __STATIC);
        register.injectable(__StateInstance, State, null, __INSTANCE);
        /**
         * Assists in compiling and linking route strings. You can register route strings using
         * a defined scheme, and it will compile the routes. When you want to match a route, it will
         * find the associated compiled route and link it to the data given with the passed-in route.
         */
        var RouteRecognizer = (function () {
            function RouteRecognizer() {
                /**
                 * All the named routes for this recognizer.
                 */
                this._namedRoutes = {};
            }
            /**
             * A method for registering routes to be identified later. Internally the
             * routes will be compiled into a series of states
             * which will be used to recognize the route later.
             * @param {Array<plat.routing.IRouteDelegate>} routes The routes to register.
             * @param {plat.routing.IRegisterOptions} options? An object containing options for the
             * registered route.
             */
            RouteRecognizer.prototype.register = function (routes, options) {
                if (!isArray(routes)) {
                    return;
                }
                var finalState = this._rootState, length = routes.length, regex = ['^'], types = {
                    statics: 0,
                    dynamics: 0,
                    splats: 0
                }, delegates = [], allSegments = [], segments;
                for (var i = 0; i < length; ++i) {
                    segments = this._parse(routes[i], delegates, types);
                    allSegments = allSegments.concat(segments);
                    finalState = this._compile(segments, finalState, regex);
                }
                finalState = this._finalize(finalState, regex);
                finalState.delegates = delegates;
                finalState.regex = new RegExp(regex.join('') + '$');
                finalState.types = types;
                if (isObject(options) && isString(options.name)) {
                    this._namedRoutes[this._toLowerCase(options.name)] = {
                        segments: allSegments,
                        delegates: delegates
                    };
                }
            };
            /**
             * Searches for a match to the provided path. If a match is found, the path is deconstructed
             * to populate a parameters object (if the registered route was a dynamic/splat route).
             * @param {string} path The path to recognize.
             */
            RouteRecognizer.prototype.recognize = function (path) {
                var isTrailingSlashDropped = false, solutions = [];
                path = this._addLeadingSlash(path);
                isTrailingSlashDropped = this._hasTrailingSlash(path);
                if (isTrailingSlashDropped) {
                    path = path.substr(0, path.length - 1);
                }
                solutions = this._filter(this._findStates(path));
                return this._link(solutions[0], path, isTrailingSlashDropped);
            };
            /**
             * Finds a INamedRoute and generates a string
             * if it exists. Uses the parameters object to generate dynamic routes.
             * @param {string} name The named route with which to generate the route string.
             * @param {plat.IObject<string>} parameters The route parameters, in the case that the
             * named route is dynamic.
             */
            RouteRecognizer.prototype.generate = function (name, parameters) {
                name = this._toLowerCase(name);
                var route = this._namedRoutes[name], output = '', segments, length;
                if (!isObject(route)) {
                    return;
                }
                segments = route.segments;
                length = segments.length;
                for (var i = 0; i < length; i++) {
                    var segment = segments[i];
                    if (segment.type === __BASE_SEGMENT_TYPE) {
                        continue;
                    }
                    output += '/';
                    output += segment.generate(parameters);
                }
                output = this._addLeadingSlash(output);
                return output;
            };
            /**
             * Finds the delegates for an INamedRoute
             * @param {string} name The named route from which to get the delegates.
             */
            RouteRecognizer.prototype.delegatesFor = function (name) {
                name = this._toLowerCase(name);
                var namedRoute = this._namedRoutes[name], delegates;
                if (!isObject(namedRoute)) {
                    return [];
                }
                delegates = namedRoute.delegates;
                if (!isArray(delegates)) {
                    return [];
                }
                return delegates.slice(0);
            };
            /**
             * Determines whether or not an INamedRoute is registered.
             * @param {string} name The named route to search for.
             */
            RouteRecognizer.prototype.exists = function (name) {
                return isObject(this._namedRoutes[this._toLowerCase(name)]);
            };
            /**
             * Safely converts a string to lower case.
             * @param {string} str The string to convert to lower case.
             */
            RouteRecognizer.prototype._toLowerCase = function (str) {
                if (!isString(str)) {
                    return str;
                }
                return str.toLowerCase();
            };
            /**
             * Finalizes a compiled route, adding a final state if necessary. If the state is equal to the
             * root state for the recognizer, a new state will be created. This is because the root state does not
             * represent any route.
             * @param {plat.routing.State} state The state to finalize.
             * @param {string} regex The regular expression string built for the compiled routes. Used to recognize
             * routes and associate them with the compiled routes.
             */
            RouteRecognizer.prototype._finalize = function (state, regex) {
                if (state === this._rootState) {
                    state = state.add({
                        validCharacters: '/'
                    });
                    regex.push('/');
                }
                return state;
            };
            /**
             * Parses a route into different segments;
             * @param {plat.routing.IRouteDelegate} route The route options to be parsed.
             * @param {Array<plat.routing.IDelegateParameterNames>} delegates The delegates and associated names for mapping parameters.
             * @param {plat.routing.ISegmentTypeCount} types A count of all the segment types in the route.
             */
            RouteRecognizer.prototype._parse = function (route, delegates, types) {
                var names = [];
                delegates.push({
                    delegate: route.delegate,
                    names: names
                });
                return this._BaseSegmentFactory.parse(route.pattern, names, types);
            };
            /**
             * Compiles a list of segments into a series of states.
             * @param {Array<plat.routing.BaseSegment>} segments The segments to compile.
             * @param {plat.routing.State} state The initial state used to compile.
             * @param {Array<string>} regex A regular expression string to build in order to match the segments.
             */
            RouteRecognizer.prototype._compile = function (segments, state, regex) {
                var length = segments.length, compile = this._State.compile, segment;
                for (var i = 0; i < length; ++i) {
                    segment = segments[i];
                    if (segment.type === __BASE_SEGMENT_TYPE) {
                        continue;
                    }
                    state = state.add({ validCharacters: '/' });
                    state = compile(segment, state);
                    regex.push('/' + segment.regex);
                }
                return state;
            };
            /**
             * Adds a leading slash to the passed-in string if necessary.
             * @param {string} path The path to which to add the slash.
             */
            RouteRecognizer.prototype._addLeadingSlash = function (path) {
                path = decodeURI(path);
                if (path[0] !== '/') {
                    path = '/' + path;
                }
                return path;
            };
            /**
             * Checks for a trailing slash on a given string.
             * @param {string} path The path on which to look for a trailing slash.
             */
            RouteRecognizer.prototype._hasTrailingSlash = function (path) {
                var length = path.length;
                return length > 1 && path[length - 1] === '/';
            };
            /**
             * Finds the compiled states for a given path.
             * @param {string} path The path with which to look for compiled states.
             */
            RouteRecognizer.prototype._findStates = function (path) {
                var states = [
                    this._rootState
                ], recognize = this._State.recognize, length = path.length;
                for (var i = 0; i < length; ++i) {
                    states = recognize(path[i], states);
                    if (states.length === 0) {
                        break;
                    }
                }
                return states;
            };
            /**
             * Filters out states with no delegates, and sorts the states.
             * @param {Array<plat.routing.State>} states The states to filter.
             */
            RouteRecognizer.prototype._filter = function (states) {
                var length = states.length, solutions = [], state;
                for (var i = 0; i < length; ++i) {
                    state = states[i];
                    if (isArray(state.delegates)) {
                        solutions.push(state);
                    }
                }
                return this._State.sort(solutions);
            };
            /**
             * Links a state to a path, producing an IRecognizeResult.
             * @param {plat.routing.State} states The state to link.
             * @param {string} path The path to link.
             * @param {boolean} isTrailingSlashDropped Whether or not the trailing slash is dropped from the path.
             */
            RouteRecognizer.prototype._link = function (state, path, isTrailingSlashDropped) {
                if (isObject(state) && isArray(state.delegates)) {
                    if (isTrailingSlashDropped && this._isDynamic(state)) {
                        path = path + '/';
                    }
                    return this._State.link(state, path);
                }
            };
            /**
             * Determines whether or not the state is dynamic.
             * @param {plat.routing.State} states The state used to determine if it is dynamic or not.
             */
            RouteRecognizer.prototype._isDynamic = function (state) {
                return state.regex.source.slice(-5) === '(.+)$';
            };
            RouteRecognizer._inject = {
                _BaseSegmentFactory: __BaseSegmentFactory,
                _State: __StateStatic,
                _rootState: __StateInstance
            };
            return RouteRecognizer;
        }());
        routing.RouteRecognizer = RouteRecognizer;
        register.injectable(__RouteRecognizerInstance, RouteRecognizer, null, __INSTANCE);
        ;
        var __CHILD_ROUTE = '/*childRoute', __CHILD_ROUTE_LENGTH = __CHILD_ROUTE.length;
        /**
         * Matches URLs to registered views. Allows for rejecting navigation, as well as
         * processing route and query parameters. When a route is matches, the current view
         * has the opportunity to reject/delay navigation. The next view can also reject navigation,
         * or redirect.
         * This is done asynchronously, giving the application the ability to make web service calls
         * to determing
         */
        var Router = (function () {
            /**
             * Instantiates a new router and sets it as the current router.
             */
            function Router() {
                /**
                 * Whether or not the router is currently navigating.
                 */
                this.navigating = false;
                /**
                 * All the registered children for this router. Useful for generating and matching routes.
                 */
                this.children = [];
                /**
                 * Whether or not this router is the root router (has no parent).
                 */
                this.isRoot = false;
                /**
                 * An object containing transform methods for route parameters.
                 */
                this._paramTransforms = {};
                /**
                 * An object containing transform methods for query parameters.
                 */
                this._queryTransforms = {};
                /**
                 * An object containing interceptor methods for particular routes.
                 */
                this._interceptors = {};
                /**
                 * All the registered Viewports for the router.
                 */
                this._ports = [];
                /**
                 * A shortcut to the Promise.resolve function.
                 */
                this._resolve = this._Promise.resolve.bind(this._Promise);
                /**
                 * A shortcut to the Promise.reject function.
                 */
                this._reject = this._Promise.reject.bind(this._Promise);
                this.uid = uniqueId(__Plat);
                this.isRoot = isNull(Router.currentRouter());
                Router.currentRouter(this);
                this.initialize();
            }
            /**
             * Exposes the current router property. Also provides the
             * ability to set the current router.
             * @param {plat.routing.Router} router Will set the current router.
             */
            Router.currentRouter = function (router) {
                if (!isNull(router)) {
                    Router.__currentRouter = router;
                }
                return Router.__currentRouter;
            };
            /**
             * Initializes a router, giving it a parent router to link to if necessary.
             * @param {plat.routing.Router} parent? The parent router to link.
             */
            Router.prototype.initialize = function (parent) {
                this.parent = parent;
            };
            /**
             * Registers a child router with the current router.
             * @param {plat.routing.Router} child A child router.
             */
            Router.prototype.addChild = function (child) {
                if (isNull(child) || this.children.indexOf(child) > -1) {
                    return child;
                }
                child.initialize(this);
                this.children.push(child);
                return child;
            };
            /**
             * Removes a child from the router's children, if it exists.
             * @param {plat.routing.Router} child The child router to remove.
             */
            Router.prototype.removeChild = function (child) {
                var children = this.children, index = children.indexOf(child);
                if (index < 0) {
                    return;
                }
                children.splice(index, 1);
                var current = Router.currentRouter();
                if (current === child) {
                    Router.currentRouter(this);
                }
            };
            /**
             * Registers a Viewport (or similar object) with the
             * router, and triggers a navigation if possible.
             * @param {plat.routing.ISupportRouteNavigation} port An object that supports all the navigation events.
             */
            Router.prototype.register = function (port) {
                var _this = this;
                var ports = this._ports;
                if (isNull(port) || ports.indexOf(port) > -1) {
                    return this._resolve();
                }
                ports.push(port);
                if (!isObject(this.currentRouteInfo)) {
                    return this._resolve();
                }
                this.navigating = true;
                return this._resolve(this.finishNavigating)
                    .catch(noop)
                    .then(function () {
                    var routeInfo = _clone(_this.currentRouteInfo, true);
                    return _this.finishNavigating = _this._canNavigateTo(routeInfo)
                        .then(function (canNavigateTo) {
                        if (!canNavigateTo) {
                            return;
                        }
                        _this.currentRouteInfo = undefined;
                        return _this._performNavigation(routeInfo);
                    }).then(function () {
                        _this.navigating = false;
                        _this.currentRouteInfo = routeInfo;
                    }, function () {
                        _this.navigating = false;
                    });
                });
            };
            /**
             * Unregisters a Viewport (or similar object) with the
             * router in order to stop receiving navigation events.
             * @param {plat.routing.ISupportRouteNavigation} port An object that supports all the navigation events.
             */
            Router.prototype.unregister = function (port) {
                var ports = this._ports, index = ports.indexOf(port);
                if (index < 0) {
                    return;
                }
                ports.splice(index, 1);
                if (ports.length === 0 && !isNull(this.parent)) {
                    this.parent.removeChild(this);
                }
            };
            Router.prototype.configure = function (routes) {
                var _this = this;
                if (isArray(routes)) {
                    forEach(function (route) {
                        _this._configureRoute(route);
                    }, routes);
                }
                else {
                    this._configureRoute(routes);
                }
                return this._forceNavigate();
            };
            /**
             * Allows for dynamic routing. Call this method in order to register a handler for dynamically determining what view to
             * use when a registered route is not found.
             * @param {(info: IUnknownRouteInfo) => any} handler A method called to determine what view is associated with a route.
             */
            Router.prototype.unknown = function (handler) {
                this._unknownHandler = handler;
                return this;
            };
            Router.prototype.param = function (handler, parameter, view) {
                return this._addHandler(handler, parameter, view, this._paramTransforms);
            };
            Router.prototype.queryParam = function (handler, parameter, view) {
                return this._addHandler(handler, parameter, view, this._queryTransforms);
            };
            Router.prototype.intercept = function (interceptor, view) {
                if (isUndefined(view)) {
                    view = '*';
                }
                var alias = view;
                if (view !== '*') {
                    view = this._Injector.convertDependency(view);
                }
                if (view === __NOOP_INJECTOR) {
                    view = alias;
                }
                var interceptors = this._interceptors[view];
                if (!isArray(interceptors)) {
                    interceptors = this._interceptors[view] = [];
                }
                interceptors.push(interceptor);
                return this;
            };
            /**
             * Tells the router to match a new route. The router will attempt to find the route and if it succeeds it will
             * attempt to navigate to it. If it fails, it will return a Promise that rejects.
             * @param {string} url The new route to match.
             * @param {plat.IObject<any>} query The query parameters for the route.
             * @param {boolean} force Whether or not to force navigation, even if the same url has already been matched.
             */
            Router.prototype.navigate = function (url, query, force, poll) {
                var _this = this;
                if (poll === false) {
                    poll = !isObject(this.currentRouteInfo);
                }
                if (!isObject(query)) {
                    query = {};
                }
                var resolve = this._resolve, queryString = serializeQuery(query);
                if (url === '/') {
                    url = '';
                }
                force = force === true;
                if (!isString(url) || this.navigating || (!force && url === this._previousUrl && queryString === this._previousQuery)) {
                    if (this.navigating) {
                        return this.finishNavigating.then(function () {
                            return _this.navigate(url, query, force);
                        });
                    }
                    return resolve();
                }
                var recognizer = this._recognizer, result = recognizer.recognize(url), routeInfo, emptyResult = isEmpty(result), pattern, segment;
                if (!emptyResult) {
                    routeInfo = result[0];
                    routeInfo.query = query;
                }
                var sameRoute = this._isSameRoute(routeInfo);
                if (emptyResult || sameRoute) {
                    var childUrl_1 = url;
                    if (sameRoute) {
                        segment = recognizer.generate(routeInfo.delegate.alias || routeInfo.delegate.view, routeInfo.parameters);
                        childUrl_1 = childUrl_1.replace(segment, '');
                    }
                    if (childUrl_1 === '/' || childUrl_1 === '') {
                        childUrl_1 = '';
                        some(function (child) {
                            result = child._recognizer.recognize(childUrl_1);
                            return !isEmpty(result);
                        }, this.children);
                    }
                    else {
                        result = this._childRecognizer.recognize(childUrl_1);
                    }
                    if (isEmpty(result)) {
                        if (!emptyResult) {
                            result = recognizer.recognize(url);
                            routeInfo = result[0];
                            routeInfo.query = query;
                            pattern = routeInfo.delegate.pattern;
                        }
                        else {
                            // route has not been matched 
                            this._previousUrl = childUrl_1;
                            this._previousQuery = queryString;
                            this.currentRouteInfo = routeInfo;
                            if (isFunction(this._unknownHandler)) {
                                var unknownRouteConfig_1 = {
                                    segment: url,
                                    view: undefined
                                };
                                return resolve(this._unknownHandler(unknownRouteConfig_1)).then(function () {
                                    var view = unknownRouteConfig_1.view;
                                    if (isUndefined(view)) {
                                        return;
                                    }
                                    return _this.configure({
                                        pattern: url,
                                        view: view
                                    });
                                });
                            }
                            return resolve();
                        }
                    }
                    else {
                        routeInfo = result[0];
                        routeInfo.query = query;
                        pattern = routeInfo.delegate.pattern;
                        pattern = pattern.slice(0, pattern.length - __CHILD_ROUTE_LENGTH);
                        if (!emptyResult || this._isSameRoute(routeInfo)) {
                            // the pattern for this router is the same as the last pattern so 
                            // only navigate child routers. 
                            this.navigating = true;
                            return this.finishNavigating = this._navigateChildren(routeInfo)
                                .then(function () {
                                _this._previousUrl = url;
                                _this._previousQuery = queryString;
                                _this.navigating = false;
                            }, function (e) {
                                _this.navigating = false;
                                throw e;
                            });
                        }
                    }
                }
                else {
                    pattern = routeInfo.delegate.pattern;
                }
                segment = recognizer.generate(routeInfo.delegate.alias || routeInfo.delegate.view, routeInfo.parameters);
                var previousSegment = this._previousSegment;
                this._previousSegment = segment;
                this.navigating = true;
                var routeInfoCopy = this._nextRouteInfo = _clone(routeInfo, true);
                return this.finishNavigating = this._canNavigate(routeInfo, poll)
                    .then(function (canNavigate) {
                    if (!canNavigate) {
                        _this.navigating = false;
                        throw new Error('Not cleared to navigate');
                    }
                    _this._previousUrl = url;
                    _this._previousQuery = queryString;
                    return _this._performNavigation(routeInfo);
                }).then(function () {
                    _this._previousPattern = pattern;
                    _this._previousSegment = segment;
                    _this.currentRouteInfo = routeInfoCopy;
                    _this.navigating = false;
                }, function (e) {
                    _this._previousSegment = previousSegment;
                    _this.navigating = false;
                    throw e;
                });
            };
            Router.prototype.generate = function (name, parameters, query) {
                var alias = name;
                name = this._Injector.convertDependency(name);
                if (name === __NOOP_INJECTOR) {
                    name = alias;
                }
                var router = this, prefix = '';
                while (!(isNull(router) || router._recognizer.exists(name))) {
                    router = router.parent;
                }
                if (isNull(router)) {
                    throw new Error('Route for ' + name + ' does not exist.');
                }
                var path = router._recognizer.generate(name, parameters), previous;
                while (!isNull(router = router.parent)) {
                    previous = router._previousSegment;
                    previous = (!isNull(previous) && previous !== '/') ? previous : '';
                    prefix = previous + prefix;
                }
                return prefix + path + serializeQuery(query);
            };
            /**
             * Configures a route mapping and registers it with the RouteRecognizer and the child
             * RouteRecognizer.
             * @param {plat.routing.IRouteMapping} route The mapping used to configure the route.
             */
            Router.prototype._configureRoute = function (route) {
                var view = this._Injector.convertDependency(route.view), alias = route.alias || view;
                if (view === __NOOP_INJECTOR) {
                    return;
                }
                route.view = view;
                route.alias = alias || view;
                var routeDelegate = {
                    pattern: route.pattern,
                    delegate: route
                }, childPattern = route.pattern + __CHILD_ROUTE, childDelegate = {
                    pattern: childPattern,
                    delegate: {
                        pattern: childPattern,
                        view: view,
                        alias: alias
                    }
                };
                this._recognizer.register([routeDelegate], { name: alias });
                this._childRecognizer.register([childDelegate]);
            };
            /**
             * Generic method for adding a param/queryParam handler to the registered handlers object.
             * @param {(value: any, query: any) => any} handler A method that will manipulate the registered parameter.
             * @param {string} parameter The parameter that the registered handler will modify.
             * @param {any} view The view used to match the route. If undefined, all routes will be matched.
             * @param {plat.IObject<plat.routing.IRouteTransforms>} handlers The object to which to add the handler.
             */
            Router.prototype._addHandler = function (handler, parameter, view, handlers) {
                if (isUndefined(view)) {
                    view = '*';
                }
                var alias = view;
                if (view !== '*') {
                    view = this._Injector.convertDependency(view);
                }
                if (view === __NOOP_INJECTOR) {
                    view = alias;
                }
                if (isEmpty(view) || isEmpty(parameter)) {
                    return this;
                }
                var viewHandlers = handlers[view];
                if (!isObject(viewHandlers)) {
                    viewHandlers = handlers[view] = {};
                }
                var transforms = viewHandlers[parameter];
                if (!isArray(transforms)) {
                    transforms = viewHandlers[parameter] = [];
                }
                transforms.push(handler);
                return this;
            };
            /**
             * Forces a navigation if possible.
             */
            Router.prototype._forceNavigate = function () {
                var _this = this;
                var resolve = this._resolve, query;
                if (this.navigating) {
                    return this.finishNavigating.then(function () {
                        return _this._forceNavigate();
                    });
                }
                if (this.isRoot && isEmpty(this._previousUrl)) {
                    var utils = this._browser.urlUtils();
                    this._previousUrl = utils.pathname;
                    query = utils.query;
                }
                if (!isEmpty(this._previousQuery)) {
                    query = deserializeQuery(this._previousQuery);
                }
                if (!isEmpty(this._previousUrl)) {
                    return this.navigate(this._previousUrl, query, true);
                }
                return resolve();
            };
            /**
             * Navigates the child routers.
             * @param {plat.routing.IRouteInfo} info The information necessary to build the childRoute for the child routers.
             */
            Router.prototype._navigateChildren = function (info, poll) {
                if (poll === void 0) { poll = true; }
                var childRoute = this._getChildRoute(info);
                if (isNull(childRoute)) {
                    return this._resolve();
                }
                return mapAsync(function (child) {
                    return child.navigate(childRoute, info.query, undefined, poll);
                }, this.children).then(noop);
            };
            /**
             * Parses out the child route from route information.
             * @param {plat.routing.IRouteInfo} info The information necessary to get the child route.
             */
            Router.prototype._getChildRoute = function (info) {
                if (isNull(info)) {
                    return;
                }
                var childRoute = info.parameters.childRoute;
                if (!isString(childRoute)) {
                    childRoute = '';
                }
                return '/' + childRoute;
            };
            /**
             * It is safe to navigate, so perform the navigation.
             * @param {plat.routing.IRouteInfo} info The route information.
             */
            Router.prototype._performNavigation = function (info) {
                var _this = this;
                var sameRoute = this._isSameRoute(this._nextRouteInfo);
                return this._performNavigateFrom(sameRoute).then(function () {
                    if (sameRoute) {
                        return;
                    }
                    return mapAsync(function (port) {
                        return port.navigateTo(info);
                    }, _this._ports);
                }).then(function () {
                    return _this._navigateChildren(info, false);
                });
            };
            /**
             * It is safe to navigate, so fire the navigateFrom events.
             * @param {boolean} ignorePorts? Ignores the ports if necessary.
             */
            Router.prototype._performNavigateFrom = function (ignorePorts) {
                var _this = this;
                return mapAsync(function (child) {
                    return child._performNavigateFrom();
                }, this.children)
                    .then(function () {
                    if (ignorePorts) {
                        return;
                    }
                    return mapAsync(function (port) {
                        return port.navigateFrom();
                    }, _this._ports);
                }).then(noop);
            };
            /**
             * Determines if we can navigate from the current state and navigate to the next state.
             * @param {plat.routing.IRouteInfo} info The route information.
             */
            Router.prototype._canNavigate = function (info, poll) {
                var _this = this;
                if (poll === void 0) { poll = true; }
                var sameRoute = this._isSameRoute(this._nextRouteInfo);
                if (!poll) {
                    return this._callAllHandlers(info.delegate.alias, info.parameters, info.query).then(function () {
                        return _this._callInterceptors(info);
                    }).then(function () {
                        return true;
                    }, function () {
                        return true;
                    });
                }
                return this._canNavigateFrom(sameRoute)
                    .then(function (canNavigateFrom) {
                    return canNavigateFrom && _this._canNavigateTo(info, sameRoute);
                });
            };
            /**
             * Determines if we can navigate from the current state and navigate to the next state.
             * @param {boolean} ignorePorts Ignores the ports if necessary.
             */
            Router.prototype._canNavigateFrom = function (ignorePorts) {
                var _this = this;
                return this._Promise.all(this.children.reduce(function (promises, child) {
                    return promises.concat(child._canNavigateFrom());
                }, []))
                    .then(booleanReduce)
                    .then(function (canNavigateFrom) {
                    if (!canNavigateFrom || ignorePorts) {
                        return [canNavigateFrom];
                    }
                    return mapAsync(function (port) {
                        return port.canNavigateFrom();
                    }, _this._ports);
                }).then(booleanReduce);
            };
            /**
             * Determines if we can navigate to the next state.
             * @param {plat.routing.IRouteInfo} info The route information.
             * @param {boolean} ignorePorts Ignores the ports if necessary.
             */
            Router.prototype._canNavigateTo = function (info, ignorePorts) {
                var _this = this;
                if (isEmpty(this._ports)) {
                    return this._resolve(true);
                }
                return this._callAllHandlers(info.delegate.alias, info.parameters, info.query).then(function () {
                    return _this._callInterceptors(info);
                }).then(function (canNavigateTo) {
                    if (canNavigateTo === false || ignorePorts) {
                        return [canNavigateTo];
                    }
                    return mapAsync(function (port) {
                        return port.canNavigateTo(info);
                    }, _this._ports);
                }).then(booleanReduce);
            };
            /**
             * Calls all the registered query and param transforms for a route.
             * @param {string} view The associated view for the route.
             * @param {any} parameters The route parameters.
             * @param {any} query? The query parameters.
             */
            Router.prototype._callAllHandlers = function (view, parameters, query) {
                var _this = this;
                return this._callHandlers(this._queryTransforms['*'], query)
                    .then(function () { return _this._callHandlers(_this._queryTransforms[view], query); })
                    .then(function () { return _this._callHandlers(_this._paramTransforms['*'], parameters, query); })
                    .then(function () { return _this._callHandlers(_this._paramTransforms[view], parameters, query); })
                    .then(noop);
            };
            /**
             * Calls the associated transform functions.
             * @param {plat.routing.IRouteTransforms} allHandlers The transform functions
             * @param {any} obj The parameters.
             * @param {any} query? The query parameters.
             */
            Router.prototype._callHandlers = function (allHandlers, obj, query) {
                var resolve = this._resolve;
                if (!isObject(obj)) {
                    obj = {};
                }
                return mapAsync(function (handlers, key) {
                    return mapAsyncInOrder(function (handler) {
                        return resolve(handler(obj[key], obj, query));
                    }, handlers);
                }, allHandlers)
                    .then(noop);
            };
            /**
             * Calls the interceptors for a particular route.
             * @param {plat.routing.IRouteInfo} info The route information.
             */
            Router.prototype._callInterceptors = function (info) {
                var _this = this;
                var resolve = this._resolve;
                return mapAsyncInOrder(function (handler) {
                    return resolve(handler(info));
                }, this._interceptors['*'])
                    .then(booleanReduce)
                    .then(function (canNavigate) {
                    if (!canNavigate) {
                        return [canNavigate];
                    }
                    return mapAsync(function (handler) {
                        return resolve(handler(info));
                    }, _this._interceptors[info.delegate.alias]);
                })
                    .then(booleanReduce);
            };
            /**
             * Checks a passed-in route against the current route to determine if it is the same.
             * @param {plat.routing.IRouteInfo} info The route information.
             */
            Router.prototype._isSameRoute = function (info) {
                var currentRouteInfo = _clone(this.currentRouteInfo, true);
                info = _clone(info, true);
                this._sanitizeRouteInfo(currentRouteInfo);
                this._sanitizeRouteInfo(info);
                if (!(isObject(currentRouteInfo) && isObject(info))) {
                    return false;
                }
                var currentDelegate = currentRouteInfo.delegate, delegate = info.delegate, currentParameters = serializeQuery(currentRouteInfo.parameters), parameters = serializeQuery(info.parameters), currentQuery = serializeQuery(currentRouteInfo.query), query = serializeQuery(info.query);
                return currentDelegate.view === delegate.view &&
                    currentDelegate.alias === delegate.alias &&
                    currentDelegate.pattern === delegate.pattern &&
                    currentParameters === parameters &&
                    currentQuery === query;
            };
            /**
             * Removes childRoute from routeInfo
             * @param {plat.routing.IRouteInfo} info The route information.
             */
            Router.prototype._sanitizeRouteInfo = function (info) {
                if (isObject(info)) {
                    if (info.parameters.hasOwnProperty('childRoute')) {
                        var delegate = info.delegate, pattern = delegate.pattern;
                        delegate.pattern = pattern.slice(0, pattern.length - __CHILD_ROUTE_LENGTH);
                        deleteProperty(info.parameters, 'childRoute');
                    }
                }
            };
            /**
             * Clears all the router information, essentially setting the router back to its initialized state.
             */
            Router.prototype._clearInfo = function () {
                this._previousSegment = undefined;
                this._previousPattern = undefined;
                this._previousUrl = undefined;
                this._previousQuery = undefined;
                this.currentRouteInfo = undefined;
                this.navigating = false;
                forEach(function (child) {
                    child._clearInfo();
                }, this.children);
            };
            Router._inject = {
                _Promise: __Promise,
                _Injector: __InjectorStatic,
                _EventManager: __EventManagerStatic,
                _browser: __Browser,
                _browserConfig: __BrowserConfig,
                _recognizer: __RouteRecognizerInstance,
                _childRecognizer: __RouteRecognizerInstance
            };
            return Router;
        }());
        routing.Router = Router;
        register.injectable(__Router, Router, null, __INSTANCE);
        /**
         */
        function IRouterStatic() {
            return Router;
        }
        routing.IRouterStatic = IRouterStatic;
        register.injectable(__RouterStatic, IRouterStatic);
    })(routing = plat_1.routing || (plat_1.routing = {}));
    /**
     * Holds all classes and interfaces related to attribute control components in platypus.
     */
    var controls;
    (function (controls) {
        /**
         * Allows for assigning a name to an Element or TemplateControl and referencing it
         * from parent controls.
         */
        var Name = (function (_super) {
            __extends(Name, _super);
            function Name() {
                _super.apply(this, arguments);
            }
            /**
             * Defines the property specified by the attribute value as the INamedElement
             * on all the ancestor controls, ignoring those that already have the property defined.
             */
            Name.prototype.initialize = function () {
                var attr = camelCase(this.type), name = this.attributes[attr];
                if (isEmpty(name) || this._isPrecompiled()) {
                    return;
                }
                this._label = name;
                this._define(name);
            };
            /**
             * Removes the INamedElement from the ancestor controls.
             */
            Name.prototype.dispose = function () {
                var name = this._label, control = this.parent;
                while (!isUndefined(name) && isObject(control)) {
                    if (isObject(control[name]) &&
                        isNode(control[name].element) &&
                        control[name].element === this.element) {
                        deleteProperty(control, name);
                    }
                    control = control.parent;
                }
            };
            /**
             * Defines the property specified by the attribute value as the INamedElement
             * on all the ancestor controls, ignoring those that already have the property defined.
             * @param {string} name The name to define on all the ancestor controls.
             */
            Name.prototype._define = function (name) {
                var templateControl = this.templateControl;
                if (!isNull(templateControl)) {
                    templateControl.name = name;
                }
                var control = this.parent, namedElement = {
                    element: this.element,
                    control: templateControl
                };
                while (isObject(control)) {
                    var obj = control[name];
                    if (!isObject(obj)) {
                        control[name] = namedElement;
                    }
                    control = control.parent;
                }
            };
            /**
             * Determines whether or not this control is part of a pre-compiled control tree. In the event
             * that it is, it shouldn't set itself on the ancestor controls.
             * @param {string} name The name to define on all the ancestor controls.
             */
            Name.prototype._isPrecompiled = function () {
                var control = this.parent;
                while (!isNull(control)) {
                    if (control.type.indexOf(__COMPILED) !== -1) {
                        return true;
                    }
                    control = control.parent;
                }
                return false;
            };
            return Name;
        }(AttributeControl));
        controls.Name = Name;
        register.control(__Name, Name);
        /**
         * An AttributeControl that binds to a specified DOM event handler.
         */
        var SimpleEventControl = (function (_super) {
            __extends(SimpleEventControl, _super);
            function SimpleEventControl() {
                _super.apply(this, arguments);
                /**
                 * A parsed form of the expression found in the attribute's value.
                 */
                this._expression = [];
                /**
                 * An array of the aliases used in the expression.
                 */
                this._aliases = [];
            }
            /**
             * Kicks off finding and setting the listener.
             */
            SimpleEventControl.prototype.loaded = function () {
                if (isNull(this.element)) {
                    return;
                }
                this.attribute = camelCase(this.type);
                this._setListener();
            };
            /**
             * Parses function args and sets the event listener.
             */
            SimpleEventControl.prototype._setListener = function () {
                var fn = this.attributes[this.attribute];
                if (isEmpty(this.event) || isEmpty(fn)) {
                    return;
                }
                this._parseArgs(fn);
                this._addEventListeners();
            };
            /**
             * Adds any and all necessary event listeners.
             */
            SimpleEventControl.prototype._addEventListeners = function () {
                this.addEventListener(this.element, this.event, this._onEvent, false);
            };
            /**
             * Constructs the function to evaluate with
             * the evaluated arguments taking resources
             * into account.
             */
            SimpleEventControl.prototype._buildExpression = function () {
                var expression = this._expression.slice(0), _parser = this._parser, parent = this.parent, listenerStr = expression.shift(), listener, context, fn, aliases, argContext;
                if (!isNull(parent)) {
                    aliases = parent.getResources(this._aliases);
                    argContext = parent.context;
                }
                if (listenerStr[0] !== '@') {
                    listener = this.findProperty(listenerStr);
                    if (isNull(listener)) {
                        this._log.warn('Could not find property ' + listenerStr + ' on any parent control.');
                        return {
                            fn: noop,
                            context: {},
                            args: []
                        };
                    }
                    var parsedExpression = listener.expresssion, identifiers = parsedExpression.identifiers;
                    if (identifiers.length > 1) {
                        this._log.warn('Cannot have more than one identifier in a ' + this.type +
                            '\'s expression.');
                        return {
                            fn: noop,
                            context: {},
                            args: []
                        };
                    }
                    var identifier = identifiers[0], split = identifier.split('.');
                    // pop key 
                    split.pop();
                    context = split.length === 0 ? listener.control : _parser.parse(split.join('.')).evaluate(listener.control);
                    fn = listener.value;
                }
                else {
                    fn = isNull(aliases) ? noop : (aliases[listenerStr] || noop);
                    context = undefined;
                }
                var length = expression.length, args = [];
                for (var i = 0; i < length; ++i) {
                    args.push(_parser.parse(expression[i]).evaluate(argContext, aliases));
                }
                return {
                    fn: fn,
                    context: context,
                    args: args
                };
            };
            /**
             * Calls the specified function when the DOM event is fired.
             * @param {Event} ev The event object.
             */
            SimpleEventControl.prototype._onEvent = function (ev) {
                var expression = this._buildExpression(), fn = expression.fn;
                if (!isFunction(fn)) {
                    this._log.warn('Cannot find registered event method ' +
                        this._expression[0] + ' for control: ' + this.type);
                    return;
                }
                fn.apply(expression.context, expression.args.concat(ev));
            };
            /**
             * Finds all alias contained within the expression.
             * @param {Array<string>} args The array of arguments as strings.
             */
            SimpleEventControl.prototype._findAliases = function (args) {
                var length = args.length, arg, hash = {}, aliases = [], parsedAliases = [], _parser = this._parser;
                while (length-- > 0) {
                    arg = args[length].trim();
                    parsedAliases = parsedAliases.concat(_parser.parse(arg).aliases);
                }
                while (parsedAliases.length > 0) {
                    arg = parsedAliases.pop();
                    if (!hash[arg]) {
                        aliases.push(arg);
                        hash[arg] = true;
                    }
                }
                return aliases;
            };
            /**
             * Parses the expression and separates the function
             * from its arguments.
             * @param {string} expression The expression to parse.
             */
            SimpleEventControl.prototype._parseArgs = function (expression) {
                if (isEmpty(expression)) {
                    return;
                }
                var exec = this._regex.argumentRegex.exec(expression);
                if (!isNull(exec)) {
                    this._expression = [expression.slice(0, exec.index)]
                        .concat((exec[1] !== '') ? exec[1].split(',') : []);
                }
                else {
                    this._expression.push(expression);
                }
                this._aliases = this._findAliases(this._expression);
            };
            SimpleEventControl._inject = {
                _parser: __Parser,
                _regex: __Regex
            };
            return SimpleEventControl;
        }(AttributeControl));
        controls.SimpleEventControl = SimpleEventControl;
        /**
         * A SimpleEventControl for the '$tap' event.
         */
        var Tap = (function (_super) {
            __extends(Tap, _super);
            function Tap() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __tap;
            }
            return Tap;
        }(SimpleEventControl));
        controls.Tap = Tap;
        /**
         * A SimpleEventControl for the 'blur' event.
         */
        var Blur = (function (_super) {
            __extends(Blur, _super);
            function Blur() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = 'blur';
            }
            return Blur;
        }(SimpleEventControl));
        controls.Blur = Blur;
        /**
         * A SimpleEventControl for the 'change' event.
         */
        var Change = (function (_super) {
            __extends(Change, _super);
            function Change() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = 'change';
            }
            return Change;
        }(SimpleEventControl));
        controls.Change = Change;
        /**
         * A SimpleEventControl for the 'copy' event.
         */
        var Copy = (function (_super) {
            __extends(Copy, _super);
            function Copy() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = 'copy';
            }
            return Copy;
        }(SimpleEventControl));
        controls.Copy = Copy;
        /**
         * A SimpleEventControl for the 'cut' event.
         */
        var Cut = (function (_super) {
            __extends(Cut, _super);
            function Cut() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = 'cut';
            }
            return Cut;
        }(SimpleEventControl));
        controls.Cut = Cut;
        /**
         * A SimpleEventControl for the 'paste' event.
         */
        var Paste = (function (_super) {
            __extends(Paste, _super);
            function Paste() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = 'paste';
            }
            return Paste;
        }(SimpleEventControl));
        controls.Paste = Paste;
        /**
         * A SimpleEventControl for the '$dbltap' event.
         */
        var DblTap = (function (_super) {
            __extends(DblTap, _super);
            function DblTap() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __dbltap;
            }
            return DblTap;
        }(SimpleEventControl));
        controls.DblTap = DblTap;
        /**
         * A SimpleEventControl for the 'focus' event.
         */
        var Focus = (function (_super) {
            __extends(Focus, _super);
            function Focus() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = 'focus';
            }
            return Focus;
        }(SimpleEventControl));
        controls.Focus = Focus;
        /**
         * A SimpleEventControl for the '$touchstart' event.
         */
        var TouchStart = (function (_super) {
            __extends(TouchStart, _super);
            function TouchStart() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __touchstart;
            }
            return TouchStart;
        }(SimpleEventControl));
        controls.TouchStart = TouchStart;
        /**
         * A SimpleEventControl for the '$touchend' event.
         */
        var TouchEnd = (function (_super) {
            __extends(TouchEnd, _super);
            function TouchEnd() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __touchend;
            }
            return TouchEnd;
        }(SimpleEventControl));
        controls.TouchEnd = TouchEnd;
        /**
         * A SimpleEventControl for the '$touchmove' event.
         */
        var TouchMove = (function (_super) {
            __extends(TouchMove, _super);
            function TouchMove() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __touchmove;
            }
            return TouchMove;
        }(SimpleEventControl));
        controls.TouchMove = TouchMove;
        /**
         * A SimpleEventControl for the '$touchcancel' event.
         */
        var TouchCancel = (function (_super) {
            __extends(TouchCancel, _super);
            function TouchCancel() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __touchcancel;
            }
            return TouchCancel;
        }(SimpleEventControl));
        controls.TouchCancel = TouchCancel;
        /**
         * A SimpleEventControl for the '$hold' event.
         */
        var Hold = (function (_super) {
            __extends(Hold, _super);
            function Hold() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __hold;
            }
            return Hold;
        }(SimpleEventControl));
        controls.Hold = Hold;
        /**
         * A SimpleEventControl for the '$release' event.
         */
        var Release = (function (_super) {
            __extends(Release, _super);
            function Release() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __release;
            }
            return Release;
        }(SimpleEventControl));
        controls.Release = Release;
        /**
         * A SimpleEventControl for the '$swipe' event.
         */
        var Swipe = (function (_super) {
            __extends(Swipe, _super);
            function Swipe() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __swipe;
            }
            return Swipe;
        }(SimpleEventControl));
        controls.Swipe = Swipe;
        /**
         * A SimpleEventControl for the '$swipeleft' event.
         */
        var SwipeLeft = (function (_super) {
            __extends(SwipeLeft, _super);
            function SwipeLeft() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __swipeleft;
            }
            return SwipeLeft;
        }(SimpleEventControl));
        controls.SwipeLeft = SwipeLeft;
        /**
         * A SimpleEventControl for the '$swiperight' event.
         */
        var SwipeRight = (function (_super) {
            __extends(SwipeRight, _super);
            function SwipeRight() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __swiperight;
            }
            return SwipeRight;
        }(SimpleEventControl));
        controls.SwipeRight = SwipeRight;
        /**
         * A SimpleEventControl for the '$swipeup' event.
         */
        var SwipeUp = (function (_super) {
            __extends(SwipeUp, _super);
            function SwipeUp() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __swipeup;
            }
            return SwipeUp;
        }(SimpleEventControl));
        controls.SwipeUp = SwipeUp;
        /**
         * A SimpleEventControl for the '$swipedown' event.
         */
        var SwipeDown = (function (_super) {
            __extends(SwipeDown, _super);
            function SwipeDown() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __swipedown;
            }
            return SwipeDown;
        }(SimpleEventControl));
        controls.SwipeDown = SwipeDown;
        /**
         * A SimpleEventControl for the '$track' event.
         */
        var Track = (function (_super) {
            __extends(Track, _super);
            function Track() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __track;
            }
            return Track;
        }(SimpleEventControl));
        controls.Track = Track;
        /**
         * A SimpleEventControl for the '$trackleft' event.
         */
        var TrackLeft = (function (_super) {
            __extends(TrackLeft, _super);
            function TrackLeft() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __trackleft;
            }
            return TrackLeft;
        }(SimpleEventControl));
        controls.TrackLeft = TrackLeft;
        /**
         * A SimpleEventControl for the '$trackright' event.
         */
        var TrackRight = (function (_super) {
            __extends(TrackRight, _super);
            function TrackRight() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __trackright;
            }
            return TrackRight;
        }(SimpleEventControl));
        controls.TrackRight = TrackRight;
        /**
         * A SimpleEventControl for the '$trackup' event.
         */
        var TrackUp = (function (_super) {
            __extends(TrackUp, _super);
            function TrackUp() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __trackup;
            }
            return TrackUp;
        }(SimpleEventControl));
        controls.TrackUp = TrackUp;
        /**
         * A SimpleEventControl for the '$trackdown' event.
         */
        var TrackDown = (function (_super) {
            __extends(TrackDown, _super);
            function TrackDown() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __trackdown;
            }
            return TrackDown;
        }(SimpleEventControl));
        controls.TrackDown = TrackDown;
        /**
         * A SimpleEventControl for the '$trackend' event.
         */
        var TrackEnd = (function (_super) {
            __extends(TrackEnd, _super);
            function TrackEnd() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __trackend;
            }
            return TrackEnd;
        }(SimpleEventControl));
        controls.TrackEnd = TrackEnd;
        /**
         * A SimpleEventControl for the 'submit' event.
         */
        var Submit = (function (_super) {
            __extends(Submit, _super);
            function Submit() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = 'submit';
            }
            /**
             * Prevents the default submit action unless
             * the "action" attribute is present.
             * @param {Event} ev The event object.
             */
            Submit.prototype._onEvent = function (ev) {
                if (!this.element.hasAttribute('action')) {
                    ev.preventDefault();
                }
                _super.prototype._onEvent.call(this, ev);
            };
            return Submit;
        }(SimpleEventControl));
        controls.Submit = Submit;
        /**
         * A SimpleEventControl for the 'input' event. If
         * 'input' is not an event, it will simulate an 'input' using other events like 'keydown',
         * 'cut', 'paste', etc. Also fires on the 'change' event.
         */
        var React = (function (_super) {
            __extends(React, _super);
            function React() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = 'input';
            }
            /**
             * Adds any and all necessary event listeners.
             */
            React.prototype._addEventListeners = function () {
                var _this = this;
                var element = this.element, _compat = this._compat, composing = false, inputFired = false, input = 'input', timeout, eventListener = function (ev) {
                    if (composing) {
                        return;
                    }
                    _this._onEvent(ev);
                }, postponedEventListener = function (ev) {
                    if (isFunction(timeout)) {
                        return;
                    }
                    timeout = postpone(function () {
                        eventListener(ev);
                        timeout = null;
                    });
                };
                if (isUndefined(_compat.ANDROID)) {
                    this.addEventListener(element, 'compositionstart', function () { composing = true; }, false);
                    this.addEventListener(element, 'compositionend', function (ev) {
                        composing = false;
                        eventListener(ev);
                    }, false);
                }
                this.addEventListener(element, input, function (ev) {
                    inputFired = true;
                    eventListener(ev);
                }, false);
                this.addEventListener(element, 'change', function (ev) {
                    if (inputFired) {
                        inputFired = false;
                        return;
                    }
                    eventListener(ev);
                }, false);
                if (_compat.hasEvent(input)) {
                    return;
                }
                this.addEventListener(element, 'keydown', function (ev) {
                    var key = ev.keyCode, codes = controls.KeyCodes;
                    if (key === codes.lwk ||
                        key === codes.rwk ||
                        (key >= codes.shift && key <= codes.escape) ||
                        (key > codes.space && key <= codes.down)) {
                        return;
                    }
                    postponedEventListener(ev);
                }, false);
                this.addEventListener(element, 'cut', postponedEventListener, false);
                this.addEventListener(element, 'paste', postponedEventListener, false);
            };
            React._inject = {
                _compat: __Compat
            };
            return React;
        }(SimpleEventControl));
        controls.React = React;
        register.control(__Tap, Tap);
        register.control(__Blur, Blur);
        register.control(__Change, Change);
        register.control(__Copy, Copy);
        register.control(__Cut, Cut);
        register.control(__Paste, Paste);
        register.control(__DblTap, DblTap);
        register.control(__Focus, Focus);
        register.control(__Submit, Submit);
        register.control(__TouchStart, TouchStart);
        register.control(__TouchEnd, TouchEnd);
        register.control(__TouchMove, TouchMove);
        register.control(__TouchCancel, TouchCancel);
        register.control(__Hold, Hold);
        register.control(__Release, Release);
        register.control(__Swipe, Swipe);
        register.control(__SwipeLeft, SwipeLeft);
        register.control(__SwipeRight, SwipeRight);
        register.control(__SwipeUp, SwipeUp);
        register.control(__SwipeDown, SwipeDown);
        register.control(__Track, Track);
        register.control(__TrackLeft, TrackLeft);
        register.control(__TrackRight, TrackRight);
        register.control(__TrackUp, TrackUp);
        register.control(__TrackDown, TrackDown);
        register.control(__TrackEnd, TrackEnd);
        register.control(__React, React);
        /**
         * A mapping of all keys to their equivalent keyCode.
         */
        controls.KeyCodes = {
            'backspace': 8,
            'tab': 9,
            'enter': 13,
            'shift': 16,
            'ctrl': 17,
            'alt': 18,
            'pause': 19, 'break': 19,
            'caps lock': 20,
            'escape': 27,
            'space': 32,
            'page up': 33,
            'page down': 34,
            'end': 35,
            'home': 36,
            'left': 37, 'left arrow': 37,
            'up': 38, 'up arrow': 38,
            'right': 39, 'right arrow': 39,
            'down': 40, 'down arrow': 40,
            'insert': 45,
            'delete': 46,
            '0': 48, 'zero': 48,
            ')': 48, 'right parenthesis': 48,
            '1': 49, 'one': 49,
            '!': 49, 'exclamation': 49, 'exclamation point': 49,
            '2': 50, 'two': 50,
            '@': 50, 'at': 50,
            '3': 51, 'three': 51,
            '#': 51, 'number sign': 51,
            'hash': 51, 'pound': 51,
            '4': 52, 'four': 52,
            '$': 52, 'dollar': 52, 'dollar sign': 52,
            '5': 53, 'five': 53,
            '%': 53, 'percent': 53, 'percent sign': 53,
            '6': 54, 'six': 54,
            '^': 54, 'caret': 54,
            '7': 55, 'seven': 55,
            '&': 55, 'ampersand': 55,
            '8': 56, 'eight': 56,
            '*': 56, 'asterisk': 56,
            '9': 57, 'nine': 57,
            '(': 57, 'left parenthesis': 57,
            'a': 65, 'b': 66, 'c': 67, 'd': 68, 'e': 69,
            'f': 70, 'g': 71, 'h': 72, 'i': 73, 'j': 74,
            'k': 75, 'l': 76, 'm': 77, 'n': 78, 'o': 79,
            'p': 80, 'q': 81, 'r': 82, 's': 83, 't': 84,
            'u': 85, 'v': 86, 'w': 87, 'x': 88, 'y': 89,
            'z': 90,
            'lwk': 91, 'left window key': 91,
            'rwk': 92, 'right window key': 92,
            'select': 93, 'select key': 93,
            'numpad 0': 96,
            'numpad 1': 97,
            'numpad 2': 98,
            'numpad 3': 99,
            'numpad 4': 100,
            'numpad 5': 101,
            'numpad 6': 102,
            'numpad 7': 103,
            'numpad 8': 104,
            'numpad 9': 105,
            'multiply': 106,
            'add': 107,
            'subtract': 109,
            'decimal point': 110,
            'divide': 111,
            'f1': 112, 'f2': 113, 'f3': 114, 'f4': 115,
            'f5': 116, 'f6': 117, 'f7': 118, 'f8': 119,
            'f9': 120, 'f10': 121, 'f11': 122, 'f12': 123,
            'num lock': 144,
            'scroll lock': 145,
            ';': 186, 'semi-colon': 186,
            ':': 186, 'colon': 186,
            '=': 187, 'equal': 187, 'equal sign': 187,
            '+': 187, 'plus': 187,
            ',': 188, 'comma': 188,
            '<': 188, 'lt': 188, 'less than': 188,
            'left angle bracket': 188,
            '-': 189, 'dash': 189,
            '_': 189, 'underscore': 189,
            '.': 190, 'period': 190,
            '>': 190, 'gt': 190, 'greater than': 190,
            'right angle bracket': 190,
            '/': 191, 'forward slash': 191,
            '?': 191, 'question mark': 191,
            '`': 192, 'grave accent': 192,
            '~': 192, 'tilde': 192,
            '[': 219, 'open bracket': 219,
            '{': 219, 'open brace': 219,
            '\\': 220, 'back slash': 220,
            '|': 220, 'pipe': 220,
            ']': 221, 'close bracket': 221,
            '}': 221, 'close brace': 221,
            '\'': 222, 'single quote': 222,
            '"': 222, 'double quote': 222
        };
        /**
         * Base class used for filtering keys on KeyboardEvents.
         */
        var KeyCodeEventControl = (function (_super) {
            __extends(KeyCodeEventControl, _super);
            function KeyCodeEventControl() {
                _super.apply(this, arguments);
                /**
                 * Holds the key mappings to filter for in a KeyboardEvent.
                 */
                this.keyCodes = {};
            }
            /**
             * Checks if the IKeyboardEventInput is an expression object
             * and sets the necessary listener.
             */
            KeyCodeEventControl.prototype._setListener = function () {
                var attr = this.attribute;
                if (isEmpty(this.event) || isEmpty(attr)) {
                    return;
                }
                var expression = this.attributes[attr].trim();
                if (expression[0] === '{') {
                    var eventObject = this.evaluateExpression(expression) || { method: '' }, keys = this._filterArgs(eventObject);
                    this._setKeyCodes(keys);
                    this.addEventListener(this.element, this.event, this._onEvent, false);
                    return;
                }
                _super.prototype._setListener.call(this);
            };
            /**
             * Parses the proper method args and finds any key code filters.
             */
            KeyCodeEventControl.prototype._filterArgs = function (input) {
                var key = input.key, keys = input.keys;
                this._parseArgs(input.method);
                if (isArray(keys)) {
                    return keys;
                }
                else if (isString(keys)) {
                    return [keys];
                }
                else if (isArray(key)) {
                    return key;
                }
                else if (isString(key)) {
                    return [key];
                }
                else {
                    if (!(isNull(input.char) && isNull(input.chars))) {
                        this._log.warn(this.type +
                            ' should be using the property key or keys to denote key codes or keys and not char codes or characters.');
                    }
                }
            };
            /**
             * Matches the event's keyCode if necessary and then handles the event if
             * a match is found or if there are no filter keyCodes.
             * @param {KeyboardEvent} ev The keyboard event object.
             */
            KeyCodeEventControl.prototype._onEvent = function (ev) {
                if (this._compareKeys(ev)) {
                    _super.prototype._onEvent.call(this, ev);
                }
            };
            /**
             * Matches the event's keyCode if necessary.
             * @param {KeyboardEvent} ev The keyboard event object.
             */
            KeyCodeEventControl.prototype._compareKeys = function (ev) {
                var keyCodes = this.keyCodes, keyCode = ev.keyCode || ev.which;
                return isEmpty(keyCodes) || keyCodes[keyCode] === true;
            };
            /**
             * Sets the defined key codes as they correspond to
             * the KeyCodes map.
             * @param {Array<string>} keys? The array of defined keys to satisfy the
             * key press condition.
             */
            KeyCodeEventControl.prototype._setKeyCodes = function (keys) {
                if (!isArray(keys)) {
                    keys = [];
                }
                var length = keys.length, key, keyCodes = this.keyCodes, index;
                for (var i = 0; i < length; ++i) {
                    key = keys[i];
                    index = isNumber(key) ? key : controls.KeyCodes[key.toLowerCase()];
                    keyCodes[index] = true;
                }
            };
            return KeyCodeEventControl;
        }(SimpleEventControl));
        controls.KeyCodeEventControl = KeyCodeEventControl;
        /**
         * Used for filtering keys on keydown events. Does not take capitalization into account.
         */
        var KeyDown = (function (_super) {
            __extends(KeyDown, _super);
            function KeyDown() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = 'keydown';
            }
            return KeyDown;
        }(KeyCodeEventControl));
        controls.KeyDown = KeyDown;
        /**
         * Used for filtering only printing keys (a-z, A-Z, 0-9, and special characters) on keydown events.
         * Does not take capitalization into account.
         */
        var KeyPress = (function (_super) {
            __extends(KeyPress, _super);
            function KeyPress() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = 'keydown';
            }
            /**
             * Filters only 'printing keys' (a-z, A-Z, 0-9, and special characters).
             * @param {KeyboardEvent} ev The KeyboardEvent object.
             */
            KeyPress.prototype._onEvent = function (ev) {
                var _this = this;
                var keyCode = ev.keyCode || ev.which;
                if (_super.prototype._compareKeys.call(this, ev) && ((keyCode >= 48 && keyCode <= 90) ||
                    (keyCode >= 186) || (keyCode >= 96 && keyCode <= 111))) {
                    var remove_1 = this.addEventListener(this.element, 'keypress', function (e) {
                        remove_1();
                        _super.prototype._onEvent.call(_this, e);
                    }, false);
                }
            };
            /**
             * Matches the event's keyCode if necessary.
             * @param {KeyboardEvent} ev The keyboard event object.
             */
            KeyPress.prototype._compareKeys = function (ev) {
                return true;
            };
            return KeyPress;
        }(KeyCodeEventControl));
        controls.KeyPress = KeyPress;
        /**
         * Used for filtering keys on keyup events. Does not take capitalization into account.
         */
        var KeyUp = (function (_super) {
            __extends(KeyUp, _super);
            function KeyUp() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = 'keyup';
            }
            return KeyUp;
        }(KeyCodeEventControl));
        controls.KeyUp = KeyUp;
        /**
         * Used for filtering keys on keypress events. Takes capitalization into account.
         */
        var CharPress = (function (_super) {
            __extends(CharPress, _super);
            function CharPress() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = 'keypress';
            }
            /**
             * Parses the proper method args and finds any char code filters.
             */
            CharPress.prototype._filterArgs = function (input) {
                var char = input.char, chars = input.chars;
                this._parseArgs(input.method);
                if (isArray(chars)) {
                    return chars;
                }
                else if (isString(chars)) {
                    return [chars];
                }
                else if (isArray(char)) {
                    return char;
                }
                else if (isString(char)) {
                    return [char];
                }
                else {
                    if (!(isNull(input.key) && isNull(input.keys))) {
                        this._log.warn(this.type +
                            ' should be using the property key or keys to denote key codes or keys and not char codes or characters.');
                    }
                }
            };
            /**
             * Matches the event's keyCode if necessary and then handles the event if
             * a match is found or if there are no filter keyCodes.
             * @param {KeyboardEvent} ev The keyboard event object.
             */
            CharPress.prototype._onEvent = function (ev) {
                var keyCodes = this.keyCodes, keyCode = ev.charCode || ev.which, key;
                if (!keyCode) {
                    key = ev.key;
                    if (!key) {
                        return;
                    }
                }
                else {
                    key = String.fromCharCode(keyCode);
                }
                if (isEmpty(keyCodes) || keyCodes[key] === true) {
                    _super.prototype._onEvent.call(this, ev);
                }
            };
            /**
             * Matches the event's keyCode if necessary.
             * @param {KeyboardEvent} ev The keyboard event object.
             */
            CharPress.prototype._compareKeys = function (ev) {
                return true;
            };
            /**
             * Sets the defined key codes as they correspond to
             * the KeyCodes map.
             * @param {Array<string>} keys? The array of defined keys to satisfy the
             * key press condition.
             */
            CharPress.prototype._setKeyCodes = function (keys) {
                if (!isArray(keys)) {
                    keys = [];
                }
                var length = keys.length, key, keyCodes = this.keyCodes, index;
                for (var i = 0; i < length; ++i) {
                    key = keys[i];
                    index = isNumber(key) ? String.fromCharCode(key) : key;
                    keyCodes[index] = true;
                }
            };
            return CharPress;
        }(KeyCodeEventControl));
        controls.CharPress = CharPress;
        register.control(__KeyDown, KeyDown);
        register.control(__KeyPress, KeyPress);
        register.control(__KeyUp, KeyUp);
        register.control(__CharPress, CharPress);
        /**
         * An AttributeControl that deals with binding to a specified property on its element.
         */
        var SetAttributeControl = (function (_super) {
            __extends(SetAttributeControl, _super);
            function SetAttributeControl() {
                _super.apply(this, arguments);
                /**
                 * The property to set on the associated element.
                 */
                this.property = '';
                /**
                 * The function to stop listening for the delayed attribute set.
                 */
                this._stopSetter = noop;
            }
            /**
             * Sets the corresponding attribute {property} value and
             * observes the attribute for changes.
             */
            SetAttributeControl.prototype.loaded = function () {
                if (isNull(this.element)) {
                    return;
                }
                this.attribute = camelCase(this.type);
                this.setter();
                this.__removeListener = this.attributes.observe(this.setter, this.attribute);
            };
            /**
             * Resets the corresponding attribute property value upon
             * a change of context.
             */
            SetAttributeControl.prototype.contextChanged = function () {
                if (isNull(this.element)) {
                    return;
                }
                this.setter();
            };
            /**
             * Stops listening to attribute changes.
             */
            SetAttributeControl.prototype.dispose = function () {
                this._stopSetter();
                if (isFunction(this.__removeListener)) {
                    this.__removeListener();
                    this.__removeListener = null;
                }
            };
            /**
             * The function for setting the corresponding
             * attribute property value.
             */
            SetAttributeControl.prototype.setter = function () {
                var _this = this;
                this._stopSetter();
                this._stopSetter = requestAnimationFrameGlobal(function () {
                    var element = _this.element, property = _this.property;
                    if (!isNode(element)) {
                        return;
                    }
                    switch (_this.attributes[_this.attribute]) {
                        case 'false':
                        case '0':
                        case 'null':
                        case '':
                            element.setAttribute(property, '');
                            element[property] = false;
                            element.removeAttribute(property);
                            break;
                        default:
                            element.setAttribute(property, property);
                            element[property] = true;
                            break;
                    }
                });
            };
            return SetAttributeControl;
        }(AttributeControl));
        controls.SetAttributeControl = SetAttributeControl;
        /**
         * A SetAttributeControl for the 'checked' attribute.
         */
        var Checked = (function (_super) {
            __extends(Checked, _super);
            function Checked() {
                _super.apply(this, arguments);
                /**
                 * The property to set on the associated template control.
                 */
                this.property = 'checked';
            }
            return Checked;
        }(SetAttributeControl));
        controls.Checked = Checked;
        /**
         * A SetAttributeControl for the 'disabled' attribute.
         */
        var Disabled = (function (_super) {
            __extends(Disabled, _super);
            function Disabled() {
                _super.apply(this, arguments);
                /**
                 * The property to set on the associated template control.
                 */
                this.property = 'disabled';
            }
            return Disabled;
        }(SetAttributeControl));
        controls.Disabled = Disabled;
        /**
         * A SetAttributeControl for the 'selected' attribute.
         */
        var Selected = (function (_super) {
            __extends(Selected, _super);
            function Selected() {
                _super.apply(this, arguments);
                /**
                 * The property to set on the associated template control.
                 */
                this.property = 'selected';
            }
            return Selected;
        }(SetAttributeControl));
        controls.Selected = Selected;
        /**
         * A SetAttributeControl for the 'readonly' attribute.
         */
        var ReadOnly = (function (_super) {
            __extends(ReadOnly, _super);
            function ReadOnly() {
                _super.apply(this, arguments);
                /**
                 * The property to set on the associated template control.
                 */
                this.property = 'readonly';
            }
            return ReadOnly;
        }(SetAttributeControl));
        controls.ReadOnly = ReadOnly;
        /**
         * A SetAttributeControl for the 'plat-hide' attribute.
         */
        var Visible = (function (_super) {
            __extends(Visible, _super);
            function Visible() {
                _super.apply(this, arguments);
                /**
                 * The property to set on the associated element.
                 */
                this.property = 'display';
                /**
                 * The value to associate with the property.
                 */
                this.value = 'none';
                /**
                 * The importance to set on the property.
                 */
                this.importance = 'important';
                /**
                 * The initial value of the property to be set.
                 */
                this._initialValue = '';
            }
            /**
             * Hides the element.
             */
            Visible.prototype.initialize = function () {
                var style = this.element.style || { getPropertyValue: noop }, initialValue = style.getPropertyValue(this.property);
                this._setValue(this.value, this.importance);
                if (isEmpty(initialValue) || initialValue === 'none') {
                    return;
                }
                this._initialValue = initialValue;
            };
            /**
             * Hides or shows the element depending upon the attribute value
             */
            Visible.prototype.setter = function () {
                var _this = this;
                this._stopSetter();
                this._stopSetter = requestAnimationFrameGlobal(function () {
                    if (!isNode(_this.element)) {
                        return;
                    }
                    switch (_this.attributes[_this.attribute]) {
                        case 'false':
                        case '0':
                        case 'null':
                        case '':
                            _this._setValue(_this.value, _this.importance);
                            break;
                        default:
                            _this._setValue(_this._initialValue);
                            break;
                    }
                });
            };
            /**
             * Sets the value of the property element with the given importance. If the
             * value is null or empty string, the property will be removed.
             * @param {string} value The value to set.
             * @param {string} importance? The priority or importance level to set.
             */
            Visible.prototype._setValue = function (value, importance) {
                var property = this.property, style = this.element.style || {
                    setProperty: noop,
                    removeProperty: noop,
                    getPropertyValue: noop,
                    getPropertyPriority: noop
                }, currentVal = style.getPropertyValue(property), currentPriority = style.getPropertyPriority(property);
                if (value === currentVal && importance === currentPriority) {
                    return;
                }
                else if (isEmpty(value)) {
                    style.removeProperty(property);
                    return;
                }
                style.setProperty(property, value, importance);
            };
            return Visible;
        }(SetAttributeControl));
        controls.Visible = Visible;
        /**
         * A SetAttributeControl for the 'style' attribute.
         */
        var Style = (function (_super) {
            __extends(Style, _super);
            function Style() {
                _super.apply(this, arguments);
                /**
                 * The property to set on the associated template control.
                 */
                this.property = 'style';
                /**
                 * A regular expression for separating style properties from style values in
                 * individual style declarations.
                 */
                this._styleRegex = /(.*?):(.*)/;
                /**
                 * A regular expression for temporarily finding and removing url declarations in the style attribute.
                 */
                this._urlRegex = /url\([^\)]*\)/gi;
                /**
                 * The temporary replace value of urls found in the style attribute.
                 */
                this._urlReplace = '[PLAT-STYLE-URL]';
                /**
                 * An object storing all the added styles.
                 */
                this.__addedStyles = [];
                /**
                 * An object storing all the old style values.
                 */
                this.__oldStyles = {};
            }
            /**
             * Sets the evaluated styles on the element.
             */
            Style.prototype.setter = function () {
                var _this = this;
                this._stopSetter();
                var element = this.element, expression = this.attributes[this.attribute];
                if (isEmpty(expression) || isNull(element)) {
                    return;
                }
                this._stopSetter = requestAnimationFrameGlobal(function () {
                    var urls = [], urlReplace = _this._urlReplace;
                    expression = expression.replace(_this._urlRegex, function (match) {
                        urls.push(match);
                        return urlReplace;
                    });
                    var style = element.style, addedStyles = _this.__addedStyles, oldStyles = _this.__oldStyles, newStyles = [], props = expression.split(';'), length = props.length, prop, val, styleRegex = _this._styleRegex, exec, styleChanges = {}, i;
                    for (i = 0; i < length; ++i) {
                        exec = styleRegex.exec(props[i]);
                        if (isNull(exec) || exec.length < 3) {
                            continue;
                        }
                        prop = exec[1].trim();
                        if (prop.length === 0 || isUndefined(style[prop])) {
                            continue;
                        }
                        else if (addedStyles.indexOf(prop) === -1) {
                            oldStyles[prop] = style[prop];
                        }
                        newStyles.push(prop);
                        val = exec[2].trim();
                        if (urls.length > 0 && val.indexOf(urlReplace) !== -1) {
                            val = val.replace(urlReplace, urls.shift());
                        }
                        styleChanges[prop] = val;
                    }
                    length = addedStyles.length;
                    while (length-- > 0) {
                        prop = addedStyles[length];
                        if (newStyles.indexOf(prop) === -1) {
                            styleChanges[prop] = oldStyles[prop];
                            addedStyles.splice(length, 1);
                        }
                    }
                    var keys = Object.keys(styleChanges);
                    length = keys.length;
                    while (length-- > 0) {
                        prop = keys[length];
                        style[prop] = styleChanges[prop];
                    }
                    _this.__addedStyles = addedStyles.concat(newStyles);
                });
            };
            return Style;
        }(SetAttributeControl));
        controls.Style = Style;
        register.control(__Checked, Checked);
        register.control(__Disabled, Disabled);
        register.control(__Selected, Selected);
        register.control(__ReadOnly, ReadOnly);
        register.control(__Visible, Visible);
        register.control(__Style, Style);
        /**
         * Base class used for setting the property of an element (e.g. href for anchor elements).
         */
        var ElementPropertyControl = (function (_super) {
            __extends(ElementPropertyControl, _super);
            function ElementPropertyControl() {
                _super.apply(this, arguments);
            }
            /**
             * The function for setting the corresponding
             * attribute property value to the evaluated expression.
             */
            ElementPropertyControl.prototype.setter = function () {
                var element = this.element, elementProperty = this.property, expression = this.attributes[this.attribute];
                if (isEmpty(expression) || isNull(element)) {
                    return;
                }
                if (!isUndefined(element[elementProperty])) {
                    element[elementProperty] = expression;
                }
            };
            return ElementPropertyControl;
        }(SetAttributeControl));
        controls.ElementPropertyControl = ElementPropertyControl;
        /**
         * A type of ElementPropertyControl used to set 'href' on an anchor tag.
         */
        var Href = (function (_super) {
            __extends(Href, _super);
            function Href() {
                _super.apply(this, arguments);
                /**
                 * Used to set the element's href property.
                 */
                this.property = 'href';
            }
            return Href;
        }(ElementPropertyControl));
        controls.Href = Href;
        /**
         * A type of ElementPropertyControl used to set 'src' on an anchor tag.
         */
        var Src = (function (_super) {
            __extends(Src, _super);
            function Src() {
                _super.apply(this, arguments);
                /**
                 * Used to set the element's src property.
                 */
                this.property = 'src';
            }
            /**
             * The function for setting the corresponding
             * attribute property value to the evaluated expression.
             */
            Src.prototype.setter = function () {
                var element = this.element, elementProperty = this.property, expression = this.attributes[this.attribute];
                if (isEmpty(expression) || isNull(element)) {
                    return;
                }
                if (!isUndefined(element[elementProperty])) {
                    element[elementProperty] = this._browser.urlUtils(expression);
                }
            };
            Src._inject = {
                _browser: __Browser
            };
            return Src;
        }(ElementPropertyControl));
        controls.Src = Src;
        register.control(__Href, Href);
        register.control(__Src, Src);
        /**
         * Facilitates two-way databinding for HTMLInputElements, HTMLSelectElements, and HTMLTextAreaElements.
         */
        var Bind = (function (_super) {
            __extends(Bind, _super);
            function Bind() {
                _super.apply(this, arguments);
                /**
                 * The priority of Bind is set high to precede
                 * other controls that may be listening to the same
                 * event.
                 */
                this.priority = 100;
                /**
                 * Whether or not Bind is being used in conjunction
                 * with a TemplateControl that implements the
                 * interface ISupportTwoWayBinding.
                 */
                this._supportsTwoWayBinding = false;
                /**
                 * Whether or not the File API is supported.
                 */
                this.__fileSupported = acquire(__Compat).fileSupported;
                /**
                 * Used to grab a filename from input[type="file"].
                 */
                this.__fileNameRegex = acquire(__Regex).fileNameRegex;
                /**
                 * Used to denote that a property change happened from within this control.
                 */
                this.__isSelf = false;
            }
            /**
             * Determines the type of Element being bound to
             * and sets the necessary handlers.
             */
            Bind.prototype.initialize = function () {
                this._determineType();
            };
            /**
             * Parses and watches the expression being bound to.
             */
            Bind.prototype.loaded = function () {
                var parent = this.parent;
                if (isNull(parent) || isNull(this.element)) {
                    return;
                }
                var attr = camelCase(this.type), _parser = this._parser, expression = this._expression = _parser.parse(this.attributes[attr]);
                var identifiers = expression.identifiers;
                if (identifiers.length !== 1) {
                    this._log.warn('Only 1 identifier allowed in a ' + this.type + ' expression.');
                    this._contextExpression = null;
                    return;
                }
                var split = identifiers[0].split('.');
                this._property = split.pop();
                if (expression.aliases.length > 0) {
                    var alias = expression.aliases[0], resourceObj_1 = parent.findResource(alias), type = void 0;
                    if (isObject(resourceObj_1)) {
                        type = resourceObj_1.resource.type;
                        if (type !== __OBSERVABLE_RESOURCE && type !== __LITERAL_RESOURCE) {
                            return;
                        }
                    }
                    else {
                        resourceObj_1 = { resource: {} };
                    }
                    if (alias === __CONTEXT_RESOURCE || alias === __ROOT_CONTEXT_RESOURCE) {
                        this._contextExpression = _parser.parse(split.join('.'));
                    }
                    else {
                        this._property = 'value';
                        this._contextExpression = {
                            evaluate: function () {
                                return resourceObj_1.resource;
                            },
                            aliases: [],
                            identifiers: [],
                            expression: ''
                        };
                    }
                }
                else if (split.length > 0) {
                    this._contextExpression = _parser.parse(split.join('.'));
                }
                else {
                    this._contextExpression = {
                        evaluate: function () {
                            return parent.context;
                        },
                        aliases: [],
                        identifiers: [],
                        expression: ''
                    };
                }
                if (this._supportsTwoWayBinding) {
                    this.templateControl.observeProperties(this);
                }
                this._watchExpression();
                if (isNull(this._addEventType)) {
                    return;
                }
                this._addEventType();
            };
            /**
             * Re-observes the expression with the new context.
             */
            Bind.prototype.contextChanged = function () {
                this._watchExpression();
            };
            /**
             * Removes all of the element's event listeners.
             */
            Bind.prototype.dispose = function () {
                this._addEventType = null;
            };
            /**
             * Gets the current value of the bound property.
             */
            Bind.prototype.evaluate = function () {
                var expression = this._expression;
                if (isUndefined(expression)) {
                    return;
                }
                return this.evaluateExpression(expression);
            };
            Bind.prototype.observeProperty = function (listener, identifier, autocast) {
                return this._observeProperty(listener, identifier, autocast);
            };
            Bind.prototype.observeArrayChange = function (listener, identifier) {
                return this._observeProperty(listener, identifier, false, true);
            };
            /**
             * Adds a text event as the event listener.
             * Used for textarea and input[type="text"].
             */
            Bind.prototype._addTextEventListener = function () {
                var _this = this;
                var element = this.element, _compat = this._compat, composing = false, input = 'input', timeout, eventListener = function () {
                    if (composing) {
                        return;
                    }
                    _this._propertyChanged();
                }, postponedEventListener = function () {
                    if (isFunction(timeout)) {
                        return;
                    }
                    timeout = postpone(function () {
                        eventListener();
                        timeout = null;
                    });
                };
                if (isUndefined(_compat.ANDROID)) {
                    this.addEventListener(element, 'compositionstart', function () { composing = true; }, false);
                    this.addEventListener(element, 'compositionend', function () {
                        composing = false;
                        eventListener();
                    }, false);
                }
                if (_compat.hasEvent(input)) {
                    this.addEventListener(element, input, eventListener, false);
                }
                else {
                    this.addEventListener(element, 'keydown', function (ev) {
                        var key = ev.keyCode || ev.which, codes = controls.KeyCodes;
                        if (key === codes.lwk ||
                            key === codes.rwk ||
                            (key >= codes.shift && key <= codes.escape) ||
                            (key > codes.space && key <= codes.down)) {
                            return;
                        }
                        postponedEventListener();
                    }, false);
                    this.addEventListener(element, 'cut', postponedEventListener, false);
                    this.addEventListener(element, 'paste', postponedEventListener, false);
                }
                this.addEventListener(element, 'change', eventListener, false);
            };
            /**
             * Adds a change event as the event listener.
             * Used for select, input[type="radio"], and input[type="range"].
             */
            Bind.prototype._addChangeEventListener = function () {
                this.addEventListener(this.element, 'change', this._propertyChanged, false);
            };
            /**
             * Adds a $tap event as the event listener.
             * Used for input[type="button"] and button.
             */
            Bind.prototype._addButtonEventListener = function () {
                this.addEventListener(this.element, __tap, this._propertyChanged, false);
            };
            /**
             * Adds a change event as the event listener.
             * Used for select, input[type="radio"], and input[type="range"].
             */
            Bind.prototype._addRangeEventListener = function () {
                var element = this.element, input = 'input';
                if (this._compat.hasEvent(input)) {
                    this.addEventListener(element, input, this._propertyChanged, false);
                }
                this.addEventListener(element, 'change', this._propertyChanged, false);
            };
            /**
             * Getter for input[type="checkbox"] and input[type="radio"].
             */
            Bind.prototype._getChecked = function () {
                return this.element.checked;
            };
            /**
             * Getter for input[type="text"], input[type="range"],
             * textarea, and select.
             */
            Bind.prototype._getValue = function () {
                return this.element.value;
            };
            /**
             * Getter for button.
             */
            Bind.prototype._getTextContent = function () {
                return this.element.textContent;
            };
            /**
             * Getter for input[type="file"]. Creates a partial IFile
             * element if file is not supported.
             */
            Bind.prototype._getFile = function () {
                var element = this.element, value = element.value;
                if (this.__fileSupported) {
                    if (element.files.length > 0) {
                        return element.files[0];
                    }
                    return null;
                }
                return {
                    name: value.replace(this.__fileNameRegex, ''),
                    path: value,
                    lastModifiedDate: undefined,
                    type: undefined,
                    size: undefined,
                    msDetachStream: noop,
                    msClose: noop,
                    slice: function () { return {}; }
                };
            };
            /**
             * Getter for input[type="file"]-multiple.
             */
            Bind.prototype._getFiles = function () {
                var element = this.element;
                if (this.__fileSupported) {
                    return Array.prototype.slice.call(element.files);
                }
                // this case should never be hit since ie9 does not support multi-file uploads, 
                // but kept in here for now for consistency's sake 
                var filelist = element.value.split(/,|;/g), length = filelist.length, files = [], fileValue, blobSlice = function () { return {}; };
                for (var i = 0; i < length; ++i) {
                    fileValue = filelist[i];
                    files.push({
                        name: fileValue.replace(this.__fileNameRegex, ''),
                        path: fileValue,
                        lastModifiedDate: undefined,
                        type: undefined,
                        size: undefined,
                        msDetachStream: noop,
                        msClose: noop,
                        slice: blobSlice
                    });
                }
                return files;
            };
            /**
             * Getter for select-multiple.
             */
            Bind.prototype._getSelectedValues = function () {
                var options = this.element.options, length = options.length, option, selectedValues = [];
                for (var i = 0; i < length; ++i) {
                    option = options[i];
                    if (option.selected) {
                        selectedValues.push(option.value);
                    }
                }
                return selectedValues;
            };
            /**
             * Setter for textarea, input[type="text"],
             * and input[type="button"], and select.
             * @param {any} newValue The new value to set
             * @param {any} oldValue The previously bound value
             * @param {boolean} firstTime? The context is being evaluated for the first time and
             * should thus change the property if null
             */
            Bind.prototype._setText = function (newValue, oldValue, firstTime) {
                if (this.__isSelf) {
                    return;
                }
                if (isNull(newValue)) {
                    newValue = '';
                    if (firstTime === true) {
                        if (isNull(this.element.value)) {
                            this._setValue(newValue);
                        }
                        this._propertyChanged();
                        return;
                    }
                }
                this._setValue(newValue);
            };
            /**
             * Setter for input[type="range"].
             * @param {any} newValue The new value to set
             * @param {any} oldValue The previously bound value
             * @param {boolean} firstTime? The context is being evaluated for the first time and
             * should thus change the property if null
             */
            Bind.prototype._setRange = function (newValue, oldValue, firstTime) {
                if (this.__isSelf) {
                    return;
                }
                if (isEmpty(newValue)) {
                    newValue = newValue === '' ? '0' : 0;
                    if (firstTime === true) {
                        if (isEmpty(this.element.value)) {
                            this._setValue(newValue);
                        }
                        this._propertyChanged();
                        return;
                    }
                }
                this._setValue(newValue);
            };
            /**
             * Setter for input[type="hidden"].
             * @param {any} newValue The new value to set
             * @param {any} oldValue The previously bound value
             * @param {boolean} firstTime? The context is being evaluated for the first time and
             * should thus change the property if null
             */
            Bind.prototype._setHidden = function (newValue, oldValue, firstTime) {
                if (this.__isSelf) {
                    return;
                }
                if (isEmpty(newValue)) {
                    newValue = '';
                    if (firstTime === true) {
                        if (isEmpty(this.element.value)) {
                            this._setValue(newValue);
                        }
                        this._propertyChanged();
                        return;
                    }
                }
                this._setValue(newValue);
            };
            /**
             * Sets the value on an element.
             * @param {any} newValue The new value to set
             */
            Bind.prototype._setValue = function (newValue) {
                var element = this.element;
                if (!isString(newValue)) {
                    if (isNumber(newValue)) {
                        this._propertyType = 'number';
                        newValue = newValue.toString();
                    }
                    else if (isBoolean(newValue)) {
                        this._propertyType = 'boolean';
                        newValue = newValue.toString();
                    }
                }
                if (element.value === newValue) {
                    return;
                }
                element.value = newValue;
            };
            /**
             * Setter for input[type="checkbox"]
             * @param {any} newValue The new value to set
             * @param {any} oldValue The previously bound value
             * @param {boolean} firstTime? The context is being evaluated for the first time and
             * should thus change the property if null
             */
            Bind.prototype._setChecked = function (newValue, oldValue, firstTime) {
                if (this.__isSelf) {
                    return;
                }
                else if (!isBoolean(newValue)) {
                    newValue = !!newValue;
                    if (firstTime === true) {
                        this.element.checked = newValue;
                        this._propertyChanged();
                        return;
                    }
                }
                this.element.checked = newValue;
            };
            /**
             * Setter for input[type="radio"]
             * @param {any} newValue The new value to set
             */
            Bind.prototype._setRadio = function (newValue) {
                var element = this.element;
                if (this.__isSelf) {
                    return;
                }
                else if (isNull(newValue)) {
                    if (element.checked) {
                        this._propertyChanged();
                    }
                    return;
                }
                else if (!isString(newValue)) {
                    if (isNumber(newValue)) {
                        this._propertyType = 'number';
                        newValue = newValue.toString();
                    }
                    else if (isBoolean(newValue)) {
                        this._propertyType = 'boolean';
                        newValue = newValue.toString();
                    }
                }
                element.checked = (element.value === newValue);
            };
            /**
             * Setter for select
             * @param {any} newValue The new value to set
             * @param {any} oldValue The previously bound value
             * @param {boolean} firstTime? The context is being evaluated for the first time and
             * should thus change the property if null
             */
            Bind.prototype._setSelectedIndex = function (newValue, oldValue, firstTime) {
                if (this.__isSelf) {
                    return;
                }
                var element = this.element, value = element.value;
                if (isNull(newValue)) {
                    if (firstTime === true || !this._document.body.contains(element)) {
                        this._propertyChanged();
                        return;
                    }
                    element.selectedIndex = -1;
                    return;
                }
                else if (!isString(newValue)) {
                    if (isNumber(newValue)) {
                        this._propertyType = 'number';
                        newValue = newValue.toString();
                    }
                    else if (isBoolean(newValue)) {
                        this._propertyType = 'boolean';
                        newValue = newValue.toString();
                    }
                    else {
                        this._log.info('Trying to bind an invalid value to a <select> element using a ' + this.type + '.');
                    }
                }
                if (value === newValue) {
                    return;
                }
                else if (!this._document.body.contains(element)) {
                    element.value = newValue;
                    if (element.value !== newValue) {
                        element.value = value;
                        this._propertyChanged();
                    }
                    return;
                }
                element.value = newValue;
                // check to make sure the user changed to a valid value 
                // second boolean argument is an ie fix for inconsistency 
                if (element.value !== newValue || element.selectedIndex === -1) {
                    element.selectedIndex = -1;
                }
            };
            /**
             * Setter for select-multiple
             * @param {any} newValue The new value to set
             * @param {any} oldValue The previously bound value
             * @param {boolean} firstTime? The context is being evaluated for the first time and
             * should thus change the property if null
             */
            Bind.prototype._setSelectedIndices = function (newValue, oldValue, firstTime) {
                if (this.__isSelf) {
                    return;
                }
                var options = this.element.options, length = isNull(options) ? 0 : options.length, option, nullValue = isNull(newValue);
                if (nullValue || !isArray(newValue)) {
                    if (firstTime === true) {
                        this._propertyChanged();
                    }
                    // unselects the options unless a match is found 
                    while (length-- > 0) {
                        option = options[length];
                        if (!nullValue && option.value === '' + newValue) {
                            option.selected = true;
                            return;
                        }
                        option.selected = false;
                    }
                    return;
                }
                var value, numberValue, index, highestIndex = Infinity;
                while (length-- > 0) {
                    option = options[length];
                    value = option.value;
                    if (newValue.indexOf(value) !== -1) {
                        option.selected = true;
                        continue;
                    }
                    numberValue = Number(value);
                    if (isNumber(numberValue) && (index = newValue.indexOf(numberValue)) !== -1) {
                        if (index < highestIndex) {
                            this._propertyType = 'number';
                            highestIndex = index;
                        }
                        option.selected = true;
                        continue;
                    }
                    else if ((value === 'true' && (index = newValue.indexOf(true)) !== -1) ||
                        value === 'false' && (index = newValue.indexOf(false)) !== -1) {
                        if (index < highestIndex) {
                            this._propertyType = 'boolean';
                            highestIndex = index;
                        }
                        option.selected = true;
                        continue;
                    }
                    option.selected = false;
                }
            };
            /**
             * Determines the type of Element being bound to
             * and sets the necessary handlers.
             */
            Bind.prototype._determineType = function () {
                if (this._observingBindableProperty()) {
                    return;
                }
                var element = this.element;
                if (isNull(element)) {
                    return;
                }
                switch (element.nodeName.toLowerCase()) {
                    case 'input':
                        switch (element.type) {
                            case 'button':
                            case 'submit':
                            case 'reset':
                            case 'image':
                                this._addEventType = this._addButtonEventListener;
                                this._getter = this._getValue;
                                break;
                            case 'checkbox':
                                this._addEventType = this._addChangeEventListener;
                                this._getter = this._getChecked;
                                this._setter = this._setChecked;
                                break;
                            case 'radio':
                                this._initializeRadio();
                                break;
                            case 'range':
                                this._addEventType = this._addRangeEventListener;
                                this._getter = this._getValue;
                                this._setter = this._setRange;
                                break;
                            case 'file':
                                var multi = element.multiple;
                                this._addEventType = this._addChangeEventListener;
                                this._getter = multi ? this._getFiles : this._getFile;
                                break;
                            case 'hidden':
                                this._getter = this._getValue;
                                this._setter = this._setHidden;
                                break;
                            default:
                                this._addEventType = this._addTextEventListener;
                                this._getter = this._getValue;
                                this._setter = this._setText;
                                break;
                        }
                        break;
                    case 'textarea':
                        this._addEventType = this._addTextEventListener;
                        this._getter = this._getValue;
                        this._setter = this._setText;
                        break;
                    case 'select':
                        this._initializeSelect();
                        break;
                    case 'button':
                        this._addEventType = this._addButtonEventListener;
                        this._getter = this._getTextContent;
                        break;
                }
            };
            /**
             * Observes the expression to bind to.
             */
            Bind.prototype._watchExpression = function () {
                var _this = this;
                var contextExpression = this._contextExpression, context = this.evaluateExpression(contextExpression);
                if (!isObject(context)) {
                    if (isNull(context) && contextExpression.identifiers.length > 0) {
                        context = this._createContext(contextExpression.identifiers[0]);
                    }
                    else {
                        this._log.warn(this.type + ' is trying to index into a primitive type. ' +
                            this._contextExpression.expression + ' is already defined and not ' +
                            'an object when trying to evaluate ' + this.type + '="' +
                            this._expression.expression + '"');
                        return;
                    }
                }
                var property;
                if (!isFunction(this._setter)) {
                    return;
                }
                else if (this._setter === this._setSelectedIndices) {
                    property = this._property;
                    if (isNull(context[property])) {
                        context[property] = [];
                    }
                    this.observeArray(function (arrayInfo) {
                        _this._setter(arrayInfo[0].object, null, true);
                    }, contextExpression + '.' + property);
                }
                var expression = this._expression;
                this.observeExpression(function (newValue, oldValue) {
                    _this._setter(newValue, oldValue);
                }, expression);
                this._setter(this.evaluateExpression(expression), undefined, true);
            };
            /**
             * Handles creating context with an identifier.
             * @param {string} identifier The identifier to base the created context off of.
             */
            Bind.prototype._createContext = function (identifier) {
                var split = identifier.split('.'), start = split.shift().slice(1), parent = this.parent;
                if (start === __ROOT_CONTEXT_RESOURCE) {
                    identifier = split.join('.');
                    parent = this.parent.root;
                }
                else if (start === __CONTEXT) {
                    identifier = split.join('.');
                }
                return this._ContextManager.createContext(parent, identifier);
            };
            /**
             * Handles casting the bound property back to its initial type if necessary.
             * @param {any} value The value to cast.
             * @param {any} type? The optional type to cast the value to.
             */
            Bind.prototype._castProperty = function (value, type) {
                var castValue;
                type = type || this._propertyType;
                if (isNull(type)) {
                    return value;
                }
                else if (isObject(value)) {
                    if (isArray(value)) {
                        var length_12 = value.length;
                        castValue = [];
                        for (var i = 0; i < length_12; ++i) {
                            castValue.push(this._castProperty(value[i], type));
                        }
                    }
                    else if (isDate(value) || isFile(value) || isPromise(value) || isWindow(value) || isNode(value)) {
                        castValue = value;
                    }
                    else {
                        var keys = Object.keys(value), key = void 0;
                        castValue = {};
                        while (keys.length > 0) {
                            key = keys.pop();
                            castValue[key] = value[key];
                        }
                    }
                }
                else {
                    switch (type) {
                        case 'string':
                            if (isString(value)) {
                                castValue = value;
                            }
                            else if (isFunction(value.toString)) {
                                castValue = value.toString();
                            }
                            else {
                                castValue = Object.prototype.toString.call(value);
                            }
                            break;
                        case 'number':
                            castValue = isEmpty(value) ? undefined : Number(value);
                            break;
                        case 'boolean':
                            switch (value) {
                                case 'true':
                                    castValue = true;
                                    break;
                                case 'false':
                                case '0':
                                case 'null':
                                case 'undefined':
                                    castValue = false;
                                    break;
                                default:
                                    castValue = !!value;
                                    break;
                            }
                            break;
                        default:
                            castValue = value;
                            break;
                    }
                }
                return castValue;
            };
            /**
             * Sets the context property being bound to when the
             * element's property is changed.
             */
            Bind.prototype._propertyChanged = function () {
                if (isNull(this._contextExpression)) {
                    return;
                }
                var context = this.evaluateExpression(this._contextExpression);
                if (!isObject(context)) {
                    return;
                }
                var property = this._property, newValue = this._castProperty(this._getter());
                if (context[property] === newValue) {
                    return;
                }
                // set flag to let setter functions know we changed the property 
                this.__isSelf = true;
                context[property] = newValue;
                this.__isSelf = false;
            };
            /**
             * Normalizes input[type="radio"] for cross-browser compatibility.
             */
            Bind.prototype._initializeRadio = function () {
                var element = this.element;
                this._addEventType = this._addChangeEventListener;
                this._getter = this._getValue;
                this._setter = this._setRadio;
                if (!element.hasAttribute('name')) {
                    var attr = camelCase(this.type), expression = this.attributes[attr];
                    element.setAttribute('name', expression);
                }
                if (element.hasAttribute('value')) {
                    return;
                }
                element.setAttribute('value', '');
            };
            /**
             * Normalizes HTMLSelectElements for cross-browser compatibility.
             */
            Bind.prototype._initializeSelect = function () {
                var element = this.element, multiple = element.multiple, options = element.options, length = options.length, option;
                this._addEventType = this._addChangeEventListener;
                if (multiple) {
                    this._getter = this._getSelectedValues;
                    this._setter = this._setSelectedIndices;
                }
                else {
                    this._getter = this._getValue;
                    this._setter = this._setSelectedIndex;
                }
                for (var i = 0; i < length; ++i) {
                    option = options[i];
                    if (!option.hasAttribute('value')) {
                        option.setAttribute('value', option.textContent);
                    }
                }
            };
            /**
             * Checks if the associated TemplateControl is implementing
             * ISupportTwoWayBinding and initializes all listeners accordingly.
             */
            Bind.prototype._observingBindableProperty = function () {
                var _this = this;
                var templateControl = this.templateControl;
                if (isObject(templateControl) && isFunction(templateControl.onInput) && isFunction(templateControl.observeProperties)) {
                    templateControl.onInput(function (newValue) {
                        _this._getter = function () { return newValue; };
                        _this._propertyChanged();
                    });
                    return (this._supportsTwoWayBinding = true);
                }
                return false;
            };
            /**
             * A function that allows a ISupportTwoWayBinding to observe either the
             * bound property specified by the identifier (as well as potential child properties if being bound to an object) or
             * Array mutations.
             * @param {Function} listener The listener function.
             * @param {any} identifier? The index off of the bound object to listen to for changes if the bound object is an Array.
             * If undefined or empty the listener will listen for changes to the bound Array itself.
             * @param {boolean} autocast? Will cast a primitive value to whatever it was set to in code.
             * @param {boolean} arrayMutations? Whether or not this is for Array mutation changes.
             */
            Bind.prototype._observeProperty = function (listener, identifier, autocast, arrayMutations) {
                var _this = this;
                var parsedIdentifier;
                if (isEmpty(identifier)) {
                    parsedIdentifier = this._expression.expression;
                }
                else if (isNumber(identifier)) {
                    parsedIdentifier = this._expression.expression + '.' + identifier;
                }
                else {
                    var _parser = this._parser, identifierExpression = _parser.parse(identifier), identifiers = identifierExpression.identifiers;
                    if (identifiers.length !== 1) {
                        this._log.warn('Only 1 identifier path allowed when observing changes to a bound property\'s child with a control ' +
                            'implementing observable.ISupportTwoWayBinding and working with ' + this.type);
                        return;
                    }
                    var expression = _parser.parse(this._expression.expression + '.' + identifiers[0]);
                    parsedIdentifier = expression.identifiers[0];
                    var split = parsedIdentifier.split('.');
                    split.pop();
                    var contextExpression = split.join('.'), context = this.evaluateExpression(contextExpression);
                    if (!isObject(context)) {
                        if (isNull(context)) {
                            context = this._ContextManager.createContext(this.parent, contextExpression);
                        }
                        else {
                            this._log.warn('A control implementing observable.ISupportTwoWayBinding is trying to index into a primitive type ' +
                                'when trying to evaluate ' + this.type + '="' + this._expression.expression + '"');
                            return;
                        }
                    }
                }
                listener = listener.bind(this.templateControl);
                autocast = autocast === true;
                var removeListener;
                if (arrayMutations === true) {
                    removeListener = this.observeArray(function (changes) {
                        listener(changes, identifier);
                    }, parsedIdentifier);
                }
                else {
                    removeListener = this.observe(function (newValue, oldValue) {
                        if (_this.__isSelf || newValue === oldValue) {
                            return;
                        }
                        else if (autocast) {
                            _this._propertyType = _this._getPropertyType(newValue);
                        }
                        listener(newValue, oldValue, identifier);
                    }, parsedIdentifier);
                    var value = this.evaluateExpression(parsedIdentifier);
                    if (autocast) {
                        this._propertyType = this._getPropertyType(value);
                    }
                    listener(value, undefined, identifier, true);
                }
                return removeListener;
            };
            /**
             * Gets the property type of the passed in argument.
             * @param {any} value The value to grab the property type from.
             */
            Bind.prototype._getPropertyType = function (value) {
                if (isObject(value)) {
                    return value;
                }
                else if (isString(value)) {
                    return 'string';
                }
                else if (isNumber(value)) {
                    return 'number';
                }
                else if (isBoolean(value)) {
                    return 'boolean';
                }
            };
            Bind._inject = {
                _parser: __Parser,
                _ContextManager: __ContextManagerStatic,
                _compat: __Compat,
                _document: __Document
            };
            return Bind;
        }(AttributeControl));
        controls.Bind = Bind;
        register.control(__Bind, Bind);
        /**
         * An AttributeControl that deals with observing changes for a specified property.
         */
        var ObservableAttributeControl = (function (_super) {
            __extends(ObservableAttributeControl, _super);
            function ObservableAttributeControl() {
                _super.apply(this, arguments);
                /**
                 * The property to set on the associated template control.
                 */
                this.property = '';
                /**
                 * This control needs to load before its templateControl
                 */
                this.priority = 200;
                /**
                 * The set of functions added by the Template Control that listens
                 * for property changes.
                 */
                this._listeners = [];
                /**
                 * The _addListener function bound to this control.
                 */
                this._boundAddListener = this._addListener.bind(this);
            }
            /**
             * Sets the initial value of the property on
             * the Template Control.
             */
            ObservableAttributeControl.prototype.initialize = function () {
                this.attribute = camelCase(this.type);
                this._setProperty(this._getValue());
            };
            /**
             * Observes the property and resets the value.
             */
            ObservableAttributeControl.prototype.loaded = function () {
                this._observeProperty();
                this._setProperty(this._getValue());
            };
            /**
             * Stops listening for changes to the evaluated
             * expression and removes references to the listeners
             * defined by the Template Control.
             */
            ObservableAttributeControl.prototype.dispose = function () {
                if (isFunction(this._removeListener)) {
                    this._removeListener();
                }
                this._listeners = [];
            };
            /**
             * Sets the property on the Template Control.
             * @param {any} value The new value of the evaluated expression.
             * @param {any} oldValue? The old value of the evaluated expression.
             */
            ObservableAttributeControl.prototype._setProperty = function (value, oldValue) {
                var templateControl = this.templateControl;
                if (isNull(templateControl)) {
                    return;
                }
                this._ContextManager.defineGetter(templateControl, this.property, {
                    value: value,
                    observe: this._boundAddListener
                }, true, true);
                this._callListeners(value, oldValue);
            };
            /**
             * Calls the listeners defined by the Template Control.
             * @param {any} value The new value of the evaluated expression.
             * @param {any} oldValue The old value of the evaluated expression.
             */
            ObservableAttributeControl.prototype._callListeners = function (newValue, oldValue) {
                var listeners = this._listeners, length = listeners.length;
                for (var i = 0; i < length; ++i) {
                    listeners[i](newValue, oldValue);
                }
            };
            /**
             * Adds a listener as defined by the Template Control.
             * @param {plat.IPropertyChangedListener} listener The listener added by the Template Control.
             */
            ObservableAttributeControl.prototype._addListener = function (listener) {
                var listeners = this._listeners;
                listener = listener.bind(this.templateControl);
                listeners.push(listener);
                return function () {
                    var index = listeners.indexOf(listener);
                    if (index === -1) {
                        return;
                    }
                    listeners.splice(index, 1);
                };
            };
            /**
             * Evaluates the attribute's value.
             */
            ObservableAttributeControl.prototype._getValue = function () {
                if (isNull(this.templateControl)) {
                    return;
                }
                return this.evaluateExpression(this.attributes[this.attribute]);
            };
            /**
             * Observes the attribute's value.
             */
            ObservableAttributeControl.prototype._observeProperty = function () {
                if (isNull(this.templateControl)) {
                    return;
                }
                this._removeListener = this.observeExpression(this._setProperty, this.attributes[this.attribute]);
            };
            ObservableAttributeControl._inject = {
                _ContextManager: __ContextManagerStatic
            };
            return ObservableAttributeControl;
        }(AttributeControl));
        controls.ObservableAttributeControl = ObservableAttributeControl;
        /**
         * An ObservableAttributeControl that sets 'options' as the
         * associated property.
         */
        var Options = (function (_super) {
            __extends(Options, _super);
            function Options() {
                _super.apply(this, arguments);
                /**
                 * The property to set on the associated template control.
                 */
                this.property = 'options';
            }
            return Options;
        }(ObservableAttributeControl));
        controls.Options = Options;
        register.control(__Options, Options);
    })(controls = plat_1.controls || (plat_1.controls = {}));
    /**
     * Class for every app. This class contains hooks for Application Lifecycle Events
     * as well as error handling.
     */
    var App = (function () {
        /**
         * Class for every app. This class contains hooks for Application Lifecycle Management (ALM)
         * as well as error handling and navigation events.
         */
        function App() {
            /**
             * A unique id, created during instantiation.
             */
            this.uid = uniqueId(__Plat);
            /**
             * Reference to the Log injectable.
             */
            this._log = App._log;
            var navigator = this.navigator = acquire(__NavigatorInstance);
            navigator.initialize(acquire(__RouterStatic).currentRouter());
        }
        /**
         * A static method for initiating the app startup.
         */
        App.start = function () {
            if (!App._compat.isCompatible) {
                return App._log.error(new Error('PlatypusTS only supports modern browsers where ' +
                    'Object.defineProperty is defined'));
            }
            App.__addPlatCss();
            var _EventManager = App._EventManager;
            _EventManager.dispose(__APP);
            _EventManager.on(__APP, __ready, App.__ready);
            _EventManager.on(__APP, __shutdown, App.__shutdown);
            _EventManager.initialize();
        };
        /**
         * A static method called upon app registration. Primarily used
         * to initiate a ready state in the case that amd is being used.
         * @param {plat.dependency.Injector<plat.App>} appInjector The injector for
         * injecting the app instance.
         */
        App.registerApp = function (appInjector) {
            if (!isNull(App.app) && isString(App.app.uid)) {
                App._EventManager.dispose(App.app.uid);
            }
            App.__injector = appInjector;
        };
        /**
         * Kicks off compilation of the DOM from the specified node. If no node is specified,
         * the default start node is document.body.
         * @param {Node} node The node at which DOM compilation begins.
         */
        App.load = function (node) {
            var _LifecycleEvent = App._LifecycleEvent, _compiler = App._compiler, body = App._document.body, head = App._document.head;
            _LifecycleEvent.dispatch(__beforeLoad, App);
            if (isNull(node)) {
                body.setAttribute(__Hide, '');
                postpone(function () {
                    _compiler.compile([head]);
                    _compiler.compile([body]);
                    body.removeAttribute(__Hide);
                });
                return;
            }
            if (isFunction(node.setAttribute)) {
                node.setAttribute(__Hide, '');
                postpone(function () {
                    _compiler.compile([node]);
                    node.removeAttribute(__Hide);
                });
                return;
            }
            postpone(function () {
                _compiler.compile([node]);
            });
        };
        /**
         * A static method called when the application is ready. It calls the app instance's
         * ready function as well as checks for the presence of a module loader. If one exists,
         * loading the DOM falls back to the app developer. If it doesn't, the DOM is loaded from
         * document.body.
         * @param {plat.events.LifecycleEvent} ev The LifecycleEvent for the app ready.
         */
        App.__ready = function (ev) {
            dependency.Injector.initialize();
            App.__registerAppEvents(ev);
            if (!ev.defaultPrevented) {
                App.load();
            }
        };
        /**
         * A static method called when the application wants to programmatically shutdown.
         */
        App.__shutdown = function () {
            var app = navigator.app, _LifecycleEvent = App._LifecycleEvent, ev;
            if (!isNull(app) && isFunction(app.exitApp)) {
                ev = _LifecycleEvent.dispatch(__exiting, App);
                if (ev.defaultPrevented) {
                    return;
                }
                app.exitApp();
            }
        };
        /**
         * A static method called to register all the LifecycleEvents for an app instance.
         */
        App.__registerAppEvents = function (ev) {
            var appInjector = App.__injector;
            if (isNull(appInjector) || !isFunction(appInjector.inject)) {
                return;
            }
            var app = App.app = appInjector.inject();
            app.on(__suspend, app.suspend);
            app.on(__resume, app.resume);
            app.on(__online, app.online);
            app.on(__offline, app.offline);
            app.on(__error, app.error);
            app.on(__exiting, app.exiting);
            if (isFunction(app.ready)) {
                app.ready(ev);
            }
        };
        /**
         * We need to add [plat-hide] as a css property if platypus.css doesn't exist so we can use it to temporarily
         * hide elements.
         */
        App.__addPlatCss = function () {
            var _document = App._document;
            if (App._compat.platCss) {
                return;
            }
            else if (!isNull(_document.styleSheets) && _document.styleSheets.length > 0) {
                _document.styleSheets[0].insertRule('[plat-hide] { display: none !important; }', 0);
                return;
            }
            var style = document.createElement('style');
            style.textContent = '[plat-hide] { display: none !important; }';
            document.head.appendChild(style);
        };
        /**
         * Event fired when the app is suspended.
         * @param {plat.events.LifecycleEvent} ev The LifecycleEvent object.
         */
        App.prototype.suspend = function (ev) { };
        /**
         * Event fired when the app resumes from the suspended state.
         * @param {plat.events.LifecycleEvent} ev The LifecycleEvent object.
         */
        App.prototype.resume = function (ev) { };
        /**
         * Event fired when an internal error occures.
         * @param {plat.events.ErrorEvent<Error>} ev The ErrorEvent object.
         */
        App.prototype.error = function (ev) { };
        /**
         * Event fired when the app is ready.
         * @param {plat.events.LifecycleEvent} ev The LifecycleEvent object.
         */
        App.prototype.ready = function (ev) { };
        /**
         * Event fired when the app has been programatically shutdown. This event is cancelable.
         * @param {plat.events.LifecycleEvent} ev The LifecycleEvent object.
         */
        App.prototype.exiting = function (ev) { };
        /**
         * Event fired when the app regains connectivity and is now in an online state.
         * @param {plat.events.LifecycleEvent} ev The LifecycleEvent object.
         */
        App.prototype.online = function (ev) { };
        /**
         * Event fired when the app loses connectivity and is now in an offline state.
         * @param {plat.events.LifecycleEvent} ev The LifecycleEvent object.
         */
        App.prototype.offline = function (ev) { };
        /**
         * Creates a new DispatchEvent and propagates it to all
         * listeners based on the DIRECT method. Propagation
         * will always start with the sender, so the sender can both produce and consume the same event.
         * @param {string} name The name of the event to send, cooincides with the name used in the
         * app.on() method.
         * @param {Array<any>} ...args Any number of arguments to send to all the listeners.
         */
        App.prototype.dispatchEvent = function (name) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _EventManager = App._EventManager || acquire(__EventManagerStatic);
            _EventManager.dispatch(name, this, _EventManager.DIRECT, args);
        };
        /**
         * Registers a listener for a DispatchEvent. The listener will be called when
         * a DispatchEvent is propagating over the app. Any number of listeners can exist for a single event name.
         * @param {string} name The name of the event, cooinciding with the DispatchEvent name.
         * @param {(ev: plat.events.DispatchEvent, ...args: Array<any>) => void} listener The method called when
         * the DispatchEvent is fired.
         */
        App.prototype.on = function (name, listener) {
            var _EventManager = App._EventManager || acquire(__EventManagerStatic);
            return _EventManager.on(this.uid, name, listener, this);
        };
        /**
         * Kicks off compilation of the DOM from the specified node. If no node is specified,
         * the default start node is document.body. This method should be called from the app when
         * using module loaders. If a module loader is in use, the app will delay loading until
         * this method is called.
         * @param {Node} node The node where at which DOM compilation begins.
         */
        App.prototype.load = function (node) {
            App.load(node);
        };
        /**
         * Calls to exit the application. Makes the necessary calls to the device is possible.
         */
        App.prototype.exit = function () {
            this.dispatchEvent(__shutdown);
        };
        /**
         * The instance of the registered IApp.
         */
        App.app = null;
        return App;
    }());
    plat_1.App = App;
    /**
     */
    function IAppStatic(_compat, _EventManager, _document, _compiler, _LifecycleEvent, _log) {
        App._compat = _compat;
        App._EventManager = _EventManager;
        App._document = _document;
        App._compiler = _compiler;
        App._LifecycleEvent = _LifecycleEvent;
        App._log = _log;
        return App;
    }
    plat_1.IAppStatic = IAppStatic;
    register.injectable(__AppStatic, IAppStatic, [
        __Compat,
        __EventManagerStatic,
        __Document,
        __Compiler,
        __LifecycleEventStatic,
        __Log
    ], __STATIC);
    /**
     */
    function IApp(_AppStatic) {
        return _AppStatic.app;
    }
    plat_1.IApp = IApp;
    register.injectable(__App, IApp, [__AppStatic], __INSTANCE);
})(plat || (plat = {}));
module.exports = plat;

},{}],15:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/* tslint:disable */
/**
 * PlatypusUI v0.14.6 (https://platypi.io)
 * Copyright 2015 Platypi, LLC. All rights reserved.
 *
 * PlatypusUI is licensed under the MIT license found at
 * https://github.com/Platypi/platypusui/blob/master/LICENSE
 *
 */
/**
 * The entry point into the platypus UI controls library.
 */
var platui;
(function (platui) {
    'use strict';
    /* tslint:disable:no-unused-variable */
    /*
     */
    var __prefix = '$', __Promise = __prefix + "Promise", __Compat = __prefix + "Compat", __Regex = __prefix + "Regex", __Window = __prefix + "Window", __Document = __prefix + "Document", __Utils = __prefix + "Utils", __Animator = __prefix + "Animator", __DomEventInstance = __prefix + "DomEventInstance", __TemplateControlFactory = __prefix + "TemplateControlFactory", __NodeManagerStatic = __prefix + "NodeManagerStatic", 
    /**
     */
    __CONTEXT = 'context', 
    /**
     */
    __PlatPrefix = 'plat', __Plat = __PlatPrefix + "-", __Button = __Plat + "button", __Checkbox = __Plat + "checkbox", __Drawer = __Plat + "drawer", __DrawerController = __Drawer + "-controller", __Modal = __Plat + "modal", __ProgressBar = __Plat + "progress", __ProgressRing = __Plat + "ring", __Radio = __Plat + "radio", __Toggle = __Plat + "toggle", __Slider = __Plat + "slider", __Range = __Plat + "range", __Select = __Plat + "select", __Input = __Plat + "input", __File = __Plat + "file", __Carousel = __Plat + "carousel", __Listview = __Plat + "listview", __Navbar = __Plat + "navbar", __Image = __Plat + "image", 
    /**
     */
    __Hide = __Plat + "hide", __Hidden = __Plat + "hidden", __Context = __Plat + __CONTEXT, __ForEach = __Plat + "foreach", __Html = __Plat + "html", __Disabled = __Plat + "disabled", __Readonly = __Plat + "readonly", __CamelContext = __PlatPrefix + "Context", __CamelChecked = __PlatPrefix + "Checked", __CamelBind = __PlatPrefix + "Bind", __CamelSrc = __PlatPrefix + "Src", 
    /**
     */
    __listviewAliasOptions = {
        index: 'index',
        even: 'even',
        odd: 'odd',
        first: 'first',
        last: 'last',
        group: 'group'
    }, 
    /**
     */
    __Transition = __Plat + "transition", __Enter = __Plat + "enter", __Leave = __Plat + "leave", 
    /**
     */
    __$tap = '$tap', __$touchstart = '$touchstart', __$touchend = '$touchend', __$touchcancel = '$touchcancel', __$swipe = '$swipe', __$track = '$track', __$trackend = '$trackend', __ButtonPrefix = '__plat-button-', __RadioPrefix = '__plat-radio-', __DrawerControllerInitEvent = '__platDrawerControllerInit', __DrawerControllerFetchEvent = '__platDrawerControllerFetch', __DrawerFoundEvent = '__platDrawerFound', 
    /**
     */
    __Reversed = '-reversed', __LITERAL_RESOURCE = 'literal', __transitionNegate = {
        right: 'left',
        left: 'right',
        up: 'down',
        down: 'up'
    }, __src = 'src', __preventDefault = function (ev) {
        ev.preventDefault();
        return false;
    }, noop = function () { };
    /* tslint:enable:no-unused-variable */
    if (typeof window !== 'undefined') {
        if (typeof window.platui === 'undefined') {
            window.platui = platui;
        }
        if (typeof window.module === 'undefined') {
            window.module = {};
        }
    }
    /**
     * An BindControl that standardizes an HTML5 button.
     */
    var Button = (function (_super) {
        __extends(Button, _super);
        function Button() {
            _super.apply(this, arguments);
            /**
             * Replaces the <plat-button> node with
             * a <button> node.
             */
            this.replaceWith = 'button';
            /**
             * A boolean value showing the selected state of this Button.
             */
            this._isSelected = false;
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        Button.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __Button + " " + (className || ''));
        };
        /**
         * Sets default classes.
         */
        Button.prototype.initialize = function () {
            this.setClasses();
        };
        /**
         * Wrap all inner text nodes in spans.
         */
        Button.prototype.setTemplate = function () {
            var _document = this._document, element = this.element, childNodes = Array.prototype.slice.call(element.childNodes), childNode, span, isEmpty = this.utils.isEmpty;
            while (childNodes.length > 0) {
                childNode = childNodes.shift();
                if (childNode.nodeType === Node.TEXT_NODE) {
                    if (!isEmpty(childNode.textContent.trim().match(/[^\r\n]/g))) {
                        span = _document.createElement('span');
                        span.insertBefore(childNode, null);
                        element.insertBefore(span, null);
                    }
                }
                else {
                    element.insertBefore(childNode, null);
                }
            }
        };
        /**
         * Determine the button style and apply the proper classes.
         */
        Button.prototype.loaded = function () {
            var element = this.element, optionObj = this.options || {}, options = optionObj.value || {}, group = options.group, isString = this.utils.isString;
            if (!isString(group)) {
                group = this.attributes[__CamelBind];
                if (isString(group)) {
                    this._group = group;
                    if (this.dom.hasClass(element, __Plat + "selected")) {
                        this._onTap();
                    }
                    this._addEventListeners();
                }
                return;
            }
            this._group = group;
            if (this.dom.hasClass(element, __Plat + "selected")) {
                this._onTap();
            }
            this._addEventListeners();
        };
        /**
         * A function that allows this control to observe both the bound property itself as well as
         * potential child properties if being bound to an object.
         * @param {plat.observable.IImplementTwoWayBinding} binder The control that facilitates the
         * databinding.
         */
        Button.prototype.observeProperties = function (binder) {
            binder.observeProperty(this._setBoundProperty);
        };
        /**
         * The function called when the bindable property is set externally.
         * @param {string} newValue The new value of the bindable property.
         * @param {string} oldValue The old value of the bindable property.
         * @param {string} identifier The identifier of the property being observed.
         * @param {boolean} firstTime? A boolean value indicating whether this is the first time its being set.
         */
        Button.prototype._setBoundProperty = function (newValue, oldValue, identifier, firstTime) {
            if (!this.utils.isString(newValue) || newValue !== this.element.textContent) {
                return;
            }
            this._onTap();
        };
        /**
         * Add event listeners for selection.
         */
        Button.prototype._addEventListeners = function () {
            var _this = this;
            this.addEventListener(this.element, __$tap, this._onTap, false);
            this.on(__ButtonPrefix + this._group, function () {
                if (_this._isSelected) {
                    _this.dom.removeClass(_this.element, __Plat + "selected");
                    _this._isSelected = false;
                }
            });
        };
        /**
         * Place the pushed button in a selected state.
         */
        Button.prototype._onTap = function () {
            if (this._isSelected) {
                return;
            }
            var element = this.element;
            this.dom.addClass(element, __Plat + "selected");
            this.dispatchEvent(__ButtonPrefix + this._group, plat.events.EventManager.DIRECT);
            this._isSelected = true;
            this.inputChanged(element.textContent);
        };
        Button._inject = {
            _document: __Document
        };
        return Button;
    }(plat.ui.BindControl));
    platui.Button = Button;
    plat.register.control(__Button, Button);
    /**
     * An BindControl that simulates a toggle switch.
     */
    var Toggle = (function (_super) {
        __extends(Toggle, _super);
        function Toggle() {
            _super.apply(this, arguments);
            /**
             * The HTML template represented as a string.
             */
            this.templateString = '<div class="plat-toggle-container">\n' +
                '    <div class="plat-knob"></div>\n' +
                '</div>\n';
            /**
             * A boolean value indicating whether the control is actively selected.
             */
            this.isActive = false;
            /**
             * The type of the control's activated element.
             */
            this._targetType = 'slide';
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        Toggle.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __Toggle + " " + (className || ''));
        };
        /**
         * Set the class name.
         */
        Toggle.prototype.initialize = function () {
            this.setClasses();
        };
        /**
         * Adds a listener for the tap event.
         */
        Toggle.prototype.loaded = function () {
            var element = this.element;
            this._targetElement = element.firstElementChild;
            this.addEventListener(element, __$tap, this._onTap);
            this._convertChecked();
        };
        /**
         * A function that allows this control to observe both the bound property itself as well as
         * potential child properties if being bound to an object.
         * @param {plat.observable.IImplementTwoWayBinding} binder The control that facilitates the
         * databinding.
         */
        Toggle.prototype.observeProperties = function (binder) {
            binder.observeProperty(this._setBoundProperty);
        };
        /**
         * The function called when the bindable property is set externally.
         * @param {any} newValue The new value of the bindable property.
         * @param {any} oldValue The old value of the bindable property.
         * @param {string} identifier The identifier of the property being observed.
         * @param {boolean} setProperty? A boolean value indicating whether we should set
         * the property if we need to toggle the state.
         */
        Toggle.prototype._setBoundProperty = function (newValue, oldValue, identifier, setProperty) {
            if (newValue === oldValue) {
                return;
            }
            else if (setProperty === true && this.utils.isNull(newValue)) {
                this.inputChanged(this.isActive);
                return;
            }
            var isActive = !!newValue;
            if (isActive === this.isActive) {
                return;
            }
            this._toggle(setProperty);
        };
        /**
         * A function for checking "checked" attributes and handling them accordingly.
         * @param {any} newValue The newValue of the attribute to convert.
         * @param {any} oldValue? The oldValue of the attribute to convert.
         */
        Toggle.prototype._convertChecked = function () {
            var element = this.element;
            if (!this.utils.isNull(this.attributes[__CamelChecked])) {
                this._convertAttribute(this.attributes[__CamelChecked]);
                this.attributes.observe(this._convertAttribute, __CamelChecked);
            }
            else if (element.hasAttribute('checked')) {
                this._convertAttribute(true);
            }
        };
        /**
         * A function for handling the attribute value conversion for updating the
         * bound property.
         * @param {any} newValue The newValue of the attribute to convert.
         * @param {any} oldValue? The oldValue of the attribute to convert.
         */
        Toggle.prototype._convertAttribute = function (newValue, oldValue) {
            var utils = this.utils;
            if (utils.isBoolean(newValue)) {
                return this._setBoundProperty(newValue, oldValue, null, true);
            }
            else if (!utils.isString(newValue)) {
                return;
            }
            this._setBoundProperty(newValue === 'true', oldValue === 'true', null, true);
        };
        /**
         * The callback for a tap event.
         * @param {plat.ui.IGestureEvent} ev The tap event object.
         */
        Toggle.prototype._onTap = function (ev) {
            this._toggle(true);
            this._trigger('change');
        };
        /**
         * Triggers an event starting from this control's element.
         * @param {string} event The event name to trigger.
         */
        Toggle.prototype._trigger = function (event) {
            var domEvent = plat.acquire(__DomEventInstance);
            domEvent.initialize(this.element, event);
            domEvent.trigger();
        };
        /**
         * Toggles the mark and updates the bindable property if needed.
         * @param {boolean} setProperty? A boolean value stating whether the bindable
         * property should be updated.
         */
        Toggle.prototype._toggle = function (setProperty) {
            var wasActive = this.isActive, isActive = !wasActive, element = this.element;
            this._activate(this._targetElement || (this._targetElement = element.firstElementChild));
            this.isActive = element.checked = isActive;
            if (isActive) {
                element.setAttribute('checked', 'checked');
            }
            else {
                element.removeAttribute('checked');
            }
            if (setProperty === true) {
                this.inputChanged(isActive, wasActive);
            }
        };
        /**
         * A function to activate the given element by toggling the
         * class specified as the target type.
         * @param {Element} element The element to activate.
         */
        Toggle.prototype._activate = function (element) {
            this.dom.toggleClass(element, __Plat + this._targetType);
        };
        return Toggle;
    }(plat.ui.BindControl));
    platui.Toggle = Toggle;
    plat.register.control(__Toggle, Toggle);
    /**
     * An IBindablePropertyControl that standardizes the HTML5 checkbox.
     */
    var Checkbox = (function (_super) {
        __extends(Checkbox, _super);
        function Checkbox() {
            _super.apply(this, arguments);
            /**
             * The HTML template represented as a string.
             */
            this.templateString = '<div class="plat-checkbox-container">\n' +
                '    <span class="plat-mark"></span>\n' +
                '</div>\n';
            /**
             * Whether the target type has been set already or not.
             */
            this._targetTypeSet = false;
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        Checkbox.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __Checkbox + " " + (className || ''));
        };
        /**
         * Adds the inner template to the DOM making sure to wrap text nodes in spans.
         */
        Checkbox.prototype.setTemplate = function () {
            var isNull = this.utils.isNull, innerTemplate = this.innerTemplate;
            if (isNull(innerTemplate)) {
                return;
            }
            var _document = this._document, element = this.element, childNodes = Array.prototype.slice.call(innerTemplate.childNodes), childNode, span, match;
            while (childNodes.length > 0) {
                childNode = childNodes.shift();
                if (childNode.nodeType === Node.TEXT_NODE) {
                    match = childNode.textContent.trim().match(/[^\r\n]/g);
                    if (match !== null && match.length > 0) {
                        span = _document.createElement('span');
                        span.insertBefore(childNode, null);
                        element.insertBefore(span, null);
                    }
                }
                else {
                    element.insertBefore(childNode, null);
                }
            }
        };
        /**
         * Checks for checked attributes and handles them accordingly. Also,
         * initializes the mark and adds a listener for the tap event.
         */
        Checkbox.prototype.loaded = function () {
            _super.prototype.loaded.call(this);
            var optionObj = this.options || {}, options = optionObj.value || {}, previousType = this._targetType, mark = this._targetType = options.mark || 'check';
            switch (mark.toLowerCase()) {
                case 'check':
                case 'x':
                    break;
                default:
                    this._log.debug("Invalid mark option specified for " + this.type + ". Defaulting to checkmark.");
                    this._targetType = 'check';
                    break;
            }
            if (this._targetTypeSet) {
                var target = this._targetElement;
                this.dom.removeClass(target, previousType);
                this._activate(target);
            }
            this._targetTypeSet = true;
        };
        /**
         * A function to activate the given element by toggling the
         * class specified as the target type.
         * @param {Element} element The element to activate.
         */
        Checkbox.prototype._activate = function (element) {
            if (this._targetTypeSet) {
                this.dom.toggleClass(element, __Plat + this._targetType);
                return;
            }
            this._targetTypeSet = true;
        };
        Checkbox._inject = {
            _document: __Document
        };
        return Checkbox;
    }(Toggle));
    platui.Checkbox = Checkbox;
    plat.register.control(__Checkbox, Checkbox);
    /**
     * An IBindablePropertyControl that standardizes the HTML5 radio button.
     */
    var Radio = (function (_super) {
        __extends(Radio, _super);
        function Radio() {
            _super.apply(this, arguments);
            /**
             * The HTML template represented as a string.
             */
            this.templateString = '<div class="plat-radio-container">\n' +
                '    <div class="plat-mark"></div>\n' +
                '</div>\n';
            /**
             * The radio groups name if a radio group is present.
             */
            this.groupName = '';
            /**
             * The check type to be placed in the element.
             */
            this._targetType = 'bullet';
            /**
             * Whether the target type has been set already or not.
             */
            this._targetTypeSet = true;
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        Radio.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __Radio + " " + (className || ''));
        };
        /**
         * Checks for a radio group and converts "checked" attributes.
         */
        Radio.prototype.loaded = function () {
            var element = this.element;
            this._targetElement = element.firstElementChild;
            this.addEventListener(element, __$tap, this._onTap);
            if (element.hasAttribute('name')) {
                this.groupName = element.getAttribute('name');
            }
            else if (!this.utils.isNull(this.attributes[__CamelBind])) {
                this.groupName = this.attributes[__CamelBind];
            }
            this._convertChecked();
        };
        /**
         * Checks if the radio has been selected and only notifies of a bindable
         * property changed if it has.
         * @param {any} newValue? The new value of the property after the change.
         * @param {any} oldValue? The old value of the property prior to the change.
         */
        Radio.prototype.inputChanged = function (newValue, oldValue) {
            if (this.isActive) {
                _super.prototype.inputChanged.call(this, this._getValue());
            }
        };
        /**
         * The function called when the bindable property is set externally.
         * @param {any} newValue The new value of the bindable property.
         * @param {any} oldValue The old value of the bindable property.
         * @param {string} identifier The identifier of the property being observed.
         * @param {boolean} setProperty? A boolean value indicating whether we should set
         * the property if we need to toggle the mark.
         */
        Radio.prototype._setBoundProperty = function (newValue, oldValue, identifier, setProperty) {
            if (newValue === oldValue) {
                return;
            }
            else if (setProperty === true && this.utils.isNull(newValue)) {
                this.inputChanged();
                return;
            }
            var isChecked = newValue === this._getValue(), wasChecked = this.isActive;
            if (isChecked === wasChecked) {
                return;
            }
            this._toggle(setProperty);
        };
        /**
         * The callback for a tap event. Only fires the event if the Radio
         * has been selected.
         * @param {plat.ui.IGestureEvent} ev The tap event object.
         */
        Radio.prototype._onTap = function (ev) {
            if (this.isActive) {
                return;
            }
            _super.prototype._onTap.call(this, ev);
        };
        /**
         * Toggles the mark and updates the bindable property if needed.
         * @param {boolean} setProperty? A boolean value stating whether the bindable
         * property should be updated.
         */
        Radio.prototype._toggle = function (setProperty) {
            var _this = this;
            _super.prototype._toggle.call(this, setProperty);
            if (this.utils.isFunction(this._removeListener)) {
                this._removeListener();
                this._removeListener = null;
            }
            if (this.isActive) {
                var name_1 = this.groupName;
                this.dispatchEvent(__RadioPrefix + name_1, plat.events.EventManager.DIRECT);
                var remover_1 = this._removeListener = this.on(__RadioPrefix + name_1, function () {
                    _this._toggle();
                    remover_1();
                });
            }
        };
        /**
         * A function for handling the attribute value conversion for updating the
         * bound property.
         * @param {any} newValue The newValue of the attribute to convert.
         * @param {any} oldValue? The oldValue of the attribute to convert.
         */
        Radio.prototype._convertAttribute = function (newValue, oldValue) {
            var utils = this.utils;
            if (utils.isBoolean(newValue)) {
                if (newValue) {
                    this._setBoundProperty(this._getValue(), null, null, true);
                }
                return;
            }
            else if (!utils.isString(newValue)) {
                return;
            }
            if (newValue === 'true') {
                this._setBoundProperty(this._getValue(), null, null, true);
            }
        };
        /**
         * Grabs the value of this Radio's bindable property. It first checks for
         * the "value" attribute, and defaults to the elements textContent if it's unavailable.
         */
        Radio.prototype._getValue = function () {
            var element = this.element;
            return element.hasAttribute('value') ? element.getAttribute('value').trim() : element.textContent.trim();
        };
        return Radio;
    }(Checkbox));
    platui.Radio = Radio;
    plat.register.control(__Radio, Radio);
    /**
     * An ITemplateControl for showing indeterminate progress.
     */
    var ProgressRing = (function (_super) {
        __extends(ProgressRing, _super);
        function ProgressRing() {
            _super.apply(this, arguments);
            /**
             * The HTML template represented as a string.
             */
            this.templateString = '<div class="plat-animated-ring"></div>';
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        ProgressRing.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __ProgressRing + " " + (className || ''));
        };
        /**
         * Set the class name.
         */
        ProgressRing.prototype.initialize = function () {
            this.setClasses();
        };
        /**
         * Set the animation.
         */
        ProgressRing.prototype.loaded = function () {
            var options = this.options, utils = this.utils, isObject = utils.isObject, style = 0;
            if (isObject(options) && isObject(options.value)) {
                style = options.value.style;
                if (!utils.isNumber(style)) {
                    style = 0;
                }
            }
            this.dom.addClass(this.element, __ProgressRing + "-" + style);
            if (style === 0) {
                return;
            }
            this._addAnimatedElements(style);
        };
        /**
         * Adds any needed DOM for the animation.
         */
        ProgressRing.prototype._addAnimatedElements = function (style) {
            var _document = plat.acquire(__Document), fragment = _document.createDocumentFragment(), count = style === 2 ? 12 : 4, div = 'div', classPrefix = __Plat + "animated-child " + __Plat + "animated-child-", child;
            for (var i = 0; i < count; ++i) {
                child = _document.createElement(div);
                child.className = classPrefix + i;
                fragment.insertBefore(child, null);
            }
            this.element.firstElementChild.insertBefore(fragment, null);
        };
        return ProgressRing;
    }(plat.ui.TemplateControl));
    platui.ProgressRing = ProgressRing;
    plat.register.control(__ProgressRing, ProgressRing);
    /**
     * An ITemplateControl for showing incremental progress.
     */
    var ProgressBar = (function (_super) {
        __extends(ProgressBar, _super);
        function ProgressBar() {
            _super.apply(this, arguments);
            /**
             * The HTML template represented as a string.
             */
            this.templateString = '<div class="plat-progress-container">\n' +
                '    <div class="plat-animated-bar"></div>\n' +
                '</div>\n';
            /**
             * A function that will stop listening for visibility if applicable.
             */
            this._removeVisibilityListener = noop;
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        ProgressBar.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __ProgressBar + " " + (className || ''));
        };
        /**
         * Set the class name.
         */
        ProgressBar.prototype.initialize = function () {
            this.setClasses();
        };
        /**
         * Grabs the bar element then sets any initial progress.
         */
        ProgressBar.prototype.loaded = function () {
            var _this = this;
            this._barElement = this.element.firstElementChild.firstElementChild;
            this.addEventListener(this._window, 'resize', function () {
                _this.setProgress(_this.context);
            });
            this.setProgress(this.context);
        };
        /**
         * Removes the visibility listener if applicable.
         */
        ProgressBar.prototype.dispose = function () {
            this._removeVisibilityListener();
        };
        /**
         * Animates the bar on a context changed.
         */
        ProgressBar.prototype.contextChanged = function () {
            this.setProgress(this.context);
        };
        /**
         * Sets the progress bar value.
         * @param {number} value The decimal number between 0 and 1 to set as the
         * bar percentage (e.g. - 0.5 would be 50% complete).
         */
        ProgressBar.prototype.setProgress = function (value) {
            var _this = this;
            return new this._Promise(function (resolve, reject) {
                if (!_this.utils.isNumber(value) || value > 1 || value < 0) {
                    var msg = "The value of a \"" + _this.type + "\" control must be a number between 0 and 1.";
                    _this._log.debug(msg);
                    reject(msg);
                    return;
                }
                var barElement = _this._barElement, barMax = barElement.parentElement.clientWidth;
                if (!barMax) {
                    _this._removeVisibilityListener();
                    _this._removeVisibilityListener = _this.dom.whenVisible(function () {
                        _this.setProgress(value).then(resolve);
                    }, _this.element);
                    return;
                }
                _this._animator.animate(barElement, __Transition, {
                    properties: {
                        width: Math.ceil(barMax * value) + "px"
                    }
                }).then(function () {
                    resolve();
                });
            });
        };
        ProgressBar._inject = {
            _window: __Window,
            _Promise: __Promise,
            _animator: __Animator
        };
        return ProgressBar;
    }(plat.ui.TemplateControl));
    platui.ProgressBar = ProgressBar;
    plat.register.control(__ProgressBar, ProgressBar);
    /**
     * An BindControl that acts as a global drawer.
     */
    var Drawer = (function (_super) {
        __extends(Drawer, _super);
        function Drawer() {
            _super.apply(this, arguments);
            /**
             * A promise that signifies the Drawer is ready for a pairing.
             */
            this.ready = this._Promise.resolve();
            /**
             * References to all the DrawerControllers used to control this Drawer.
             */
            this._controllers = [];
            /**
             * Whether or not the this control has been paired with a corresponding Drawer.
             */
            this._isInitialized = false;
            /**
             * A bound value that may have come through prior to initialization.
             */
            this._preInitializedValue = false;
            /**
             * A private variable that tells the Drawer its last open or closed state.
             */
            this.__state = false;
            /**
             * A private variable that tells the Drawer its next open or closed state.
             */
            this.__nextState = false;
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        Drawer.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __Drawer + " " + (className || ''));
        };
        /**
         * Set the class name and hides the element and
         * removes the innerHTML from the DOM and saves it.
         */
        Drawer.prototype.initialize = function () {
            this.setClasses();
        };
        /**
         * Removes the innerHTML from the DOM and saves it.
         */
        Drawer.prototype.setTemplate = function () {
            this.innerTemplate = this.dom.appendChildren(this.element.childNodes);
        };
        /**
         * Check for a position and initialize event handling.
         */
        Drawer.prototype.loaded = function () {
            var _this = this;
            var element = this.element, utils = this.utils, optionObj = this.options || {}, options = optionObj.value || {}, position = this._currentPosition = options.position || 'left', id = options.id || '', templateUrl = options.templateUrl, isElastic = options.elastic === true;
            element.setAttribute(__Hide, '');
            this.dom.addClass(element, __Plat + position);
            if (utils.isString(templateUrl)) {
                plat.ui.TemplateControl.determineTemplate(this, templateUrl).then(function (template) {
                    _this.innerTemplate = template;
                    _this._initializeEvents(id, position, isElastic);
                });
                return;
            }
            this._initializeEvents(id, position, isElastic);
        };
        /**
         * Opens the Drawer.
         */
        Drawer.prototype.open = function () {
            var controller = this._controllers[0];
            if (this.utils.isNull(controller)) {
                this._log.debug("No controller, such as a " + __DrawerController + ", found for the " + this.type + " attempting to open.");
                return this._Promise.resolve();
            }
            return controller.open();
        };
        /**
         * Closes the Drawer.
         */
        Drawer.prototype.close = function () {
            var controller = this._controllers[0];
            if (this.utils.isNull(controller)) {
                this._log.debug("No controller, such as a " + __DrawerController + ", found for the " + this.type + " attempting to close.");
                return this._Promise.resolve();
            }
            return controller.close();
        };
        /**
         * Toggles the Drawer's open/closed state.
         */
        Drawer.prototype.toggle = function () {
            var controller = this._controllers[0];
            if (this.utils.isNull(controller)) {
                this._log.debug("No controller, such as a " + __DrawerController + ", found for the " + this.type + " attempting to toggle.");
                return this._Promise.resolve();
            }
            return controller.toggle();
        };
        /**
         * Indicates whether the Drawer is currently open.
         */
        Drawer.prototype.isOpen = function () {
            var controller = this._controllers[0];
            if (this.utils.isNull(controller)) {
                this._log.debug("No controller, such as a " + __DrawerController + ", found for the " + this.type + " attempting to check if open.");
                return false;
            }
            return controller.isOpen();
        };
        /**
         * Adds and binds the added HTML template to this control's inherited context.
         * @param {string} name The template name to both add and bind.
         * @param {Node} node The node to add as a bindable template.
         */
        Drawer.prototype.bindTemplate = function (name, node) {
            var _this = this;
            var bindableTemplates = this.bindableTemplates;
            bindableTemplates.add(name, node);
            return bindableTemplates.bind(name).then(function (template) {
                var element = _this.element;
                _this.dom.clearNode(element);
                element.appendChild(template);
            }).catch(function (error) {
                _this._log.debug("Error binding template for " + _this.type + ": " + error);
            });
        };
        /**
         * Returns the number of DrawerControllers linked to this
         * Drawer.
         */
        Drawer.prototype.controllerCount = function () {
            return this._controllers.length;
        };
        /**
         * Removes a specified DrawerController from this control's Array of
         * linked DrawerControllers.
         * @param {platui.DrawerController} controller The DrawerController
         * to splice.
         */
        Drawer.prototype.spliceController = function (controller) {
            var controllers = this._controllers, index = controllers.indexOf(controller);
            if (index === -1) {
                return;
            }
            this.__state = this.__nextState = controllers[index].isOpen();
            controllers.splice(index, 1);
        };
        /**
         * A function that allows this control to observe both the bound property itself as well as
         * potential child properties if being bound to an object.
         * @param {plat.observable.IImplementTwoWayBinding} binder The control that facilitates the
         * databinding.
         */
        Drawer.prototype.observeProperties = function (binder) {
            binder.observeProperty(this._setBoundProperty);
        };
        /**
         * The function called when the bindable property is set externally.
         * @param {boolean} newValue The new value of the control state.
         * @param {boolean} oldValue The old value of the bindable control state.
         * @param {void} identifier The child identifier of the property being observed.
         * @param {boolean} firstTime? Whether or not this is the first call to bind the property.
         */
        Drawer.prototype._setBoundProperty = function (newValue, oldValue, identifier, firstTime) {
            var utils = this.utils, controller = this._controllers[0];
            if (firstTime === true && utils.isNull(newValue)) {
                this.inputChanged(utils.isNull(controller) ? false : controller.isOpen());
                return;
            }
            var drawerState = !!newValue;
            if (drawerState !== newValue) {
                this.inputChanged(drawerState);
            }
            if (!this._isInitialized) {
                this._preInitializedValue = drawerState;
            }
            else if (utils.isNull(controller)) {
                this.__nextState = drawerState;
            }
            else if (drawerState) {
                if (controller.isOpen()) {
                    return;
                }
                controller.open();
            }
            else if (controller.isOpen()) {
                controller.close();
            }
        };
        /**
         * Changes the placement and implied position of the Drawer.
         * @param {string} position The new position to change to.
         */
        Drawer.prototype._changeDirection = function (position) {
            if (this.utils.isNull(position) || position === this._currentPosition) {
                return;
            }
            var dom = this.dom, element = this.element;
            dom.removeClass(element, __Plat + this._currentPosition);
            dom.addClass(element, __Plat + position);
            this._currentPosition = position;
        };
        /**
         * Initializes and dispatches pub sub events.
         * @param {string} id The ID of this Drawer if used.
         * @param {string} position The position.
         * @param {boolean} isElastic Whether or not the Drawer has an
         * elastic transition effect.
         */
        Drawer.prototype._initializeEvents = function (id, position, isElastic) {
            var _this = this;
            var utils = this.utils, innerTemplate = this.innerTemplate;
            this.on(__DrawerControllerFetchEvent + "_" + id, function (event, controllerArg) {
                var control = controllerArg.control;
                if (utils.isNull(control)) {
                    return;
                }
                if (utils.isString(controllerArg.position)) {
                    position = controllerArg.position;
                    _this._changeDirection(position);
                }
                _this._controllers.unshift(control);
                if (!controllerArg.received) {
                    _this.ready.then(function () {
                        _this.dispatchEvent(__DrawerFoundEvent + "_" + id, plat.events.EventManager.DIRECT, {
                            control: _this,
                            received: true,
                            position: position,
                            template: utils.isNode(innerTemplate) ? innerTemplate.cloneNode(true) : null,
                            elastic: isElastic,
                            state: _this.__state,
                            nextState: _this.__nextState
                        });
                    });
                }
                _this._isInitialized = true;
                if (!controllerArg.useContext) {
                    _this.bindTemplate('drawer', innerTemplate.cloneNode(true)).then(function () {
                        _this._checkPreInit();
                    });
                    return;
                }
                _this._checkPreInit();
            });
            this.dispatchEvent(__DrawerFoundEvent + "_" + id, plat.events.EventManager.DIRECT, {
                control: this,
                received: false,
                position: position,
                template: utils.isNode(innerTemplate) ? innerTemplate.cloneNode(true) : null,
                elastic: isElastic,
                state: this.__state,
                nextState: this.__nextState
            });
        };
        /**
         * Checks the pre-initialized value and handles accordingly.
         */
        Drawer.prototype._checkPreInit = function () {
            var _this = this;
            if (this._preInitializedValue) {
                var utils_1 = this.utils;
                utils_1.postpone(function () {
                    var controller = _this._controllers[0];
                    if (!utils_1.isNull(controller)) {
                        controller.open();
                    }
                });
            }
        };
        Drawer._inject = {
            _Promise: __Promise
        };
        return Drawer;
    }(plat.ui.BindControl));
    platui.Drawer = Drawer;
    plat.register.control(__Drawer, Drawer);
    /**
     * An BindControl that manipulates and controls a global drawer.
     */
    var DrawerController = (function (_super) {
        __extends(DrawerController, _super);
        function DrawerController() {
            _super.apply(this, arguments);
            /**
             * Whether or not the user has swiped.
             */
            this._hasSwiped = false;
            /**
             * Whether or not the user has tapped.
             */
            this._hasTapped = false;
            /**
             * Whether or not the Drawer is open.
             */
            this._isOpen = false;
            /**
             * An enum denoting the current touch state of the user.
             */
            this._touchState = 0;
            /**
             * Whether the corresponding Drawer is vertical or horizontal.
             */
            this._isVertical = false;
            /**
             * A function for removing the click eater scroll listening event.
             */
            this._removeClickEaterListener = noop;
            /**
             * A function to remove the toggle delay if present.
             */
            this._toggleDelay = noop;
            /**
             * Whether or not the this control has been paired with a corresponding Drawer.
             */
            this._isInitialized = false;
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        DrawerController.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __DrawerController + " " + (className || ''));
        };
        /**
         * Sets the class name on the element.
         */
        DrawerController.prototype.initialize = function () {
            this.dom.addClass(this.element, __DrawerController);
        };
        /**
         * Initialize the track events on the element.
         */
        DrawerController.prototype.loaded = function () {
            var optionObj = this.options || {}, options = optionObj.value || {}, position = options.position, id = options.id || '';
            this._type = options.type || 'tap track';
            this._isElastic = options.elastic;
            this._useContext = options.useContext === true;
            this._templateUrl = options.templateUrl;
            this._initializeEvents(id, position);
        };
        /**
         * Remove the transition classes off the root element and reset the position and
         * zIndex properties if modified and only if this is the last DrawerController
         * referencing this Drawer.
         */
        DrawerController.prototype.dispose = function () {
            var _this = this;
            _super.prototype.dispose.call(this);
            var drawer = this._drawer;
            if (this.utils.isNull(drawer)) {
                return;
            }
            if (drawer.controllerCount() > 1) {
                drawer.spliceController(this);
                return;
            }
            else if (this._isOpen) {
                drawer.ready = this.close().then(function () {
                    drawer.spliceController(_this);
                    if (drawer.controllerCount() > 0) {
                        return;
                    }
                    _this._cleanRootElement();
                });
                return;
            }
            drawer.ready.then(function () {
                drawer.spliceController(_this);
                if (drawer.controllerCount() > 0) {
                    return;
                }
                _this._cleanRootElement();
            });
        };
        /**
         * Opens the Drawer.
         */
        DrawerController.prototype.open = function () {
            var _this = this;
            var wasClosed = !this._isOpen, utils = this.utils;
            this._toggleDelay();
            var promise = new this._Promise(function (resolve) {
                _this._toggleDelay = utils.requestAnimationFrame(function () {
                    _this._open().then(resolve);
                });
            });
            if (wasClosed) {
                var drawer = this._drawer;
                this.inputChanged(true);
                if (!utils.isNull(drawer)) {
                    drawer.inputChanged(true);
                }
            }
            return promise;
        };
        /**
         * Closes the Drawer.
         */
        DrawerController.prototype.close = function () {
            var _this = this;
            var wasOpen = this._isOpen, utils = this.utils;
            this._toggleDelay();
            var promise = new this._Promise(function (resolve) {
                _this._toggleDelay = utils.requestAnimationFrame(function () {
                    _this._close().then(resolve);
                });
            });
            if (wasOpen) {
                var drawer = this._drawer;
                this.inputChanged(false);
                if (!utils.isNull(drawer)) {
                    drawer.ready = promise;
                    drawer.inputChanged(false);
                }
            }
            return promise;
        };
        /**
         * Toggles the Drawer's open/closed state.
         */
        DrawerController.prototype.toggle = function () {
            if (this._isOpen) {
                return this.close();
            }
            return this.open();
        };
        /**
         * Indicates whether the Drawer is currently open.
         */
        DrawerController.prototype.isOpen = function () {
            return this._isOpen;
        };
        /**
         * Binds the added HTML template to this control's inherited context and
         * places the node into the Drawer.
         * @param {string} name The template name to bind.
         * @param {Node} node The node to add as a bindable template.
         */
        DrawerController.prototype.bindTemplate = function (name, node) {
            var _this = this;
            var bindableTemplates = this.bindableTemplates;
            bindableTemplates.add(name, node);
            return bindableTemplates.bind(name).then(function (template) {
                var element = _this._drawerElement;
                _this.dom.clearNode(element);
                element.appendChild(template);
            }).catch(function (error) {
                _this._log.debug("Error binding template for " + _this.type + ": " + error);
            });
        };
        /**
         * A function that allows this control to observe both the bound property itself as well as
         * potential child properties if being bound to an object.
         * @param {plat.observable.IImplementTwoWayBinding} binder The control that facilitates the
         * databinding.
         */
        DrawerController.prototype.observeProperties = function (binder) {
            binder.observeProperty(this._setBoundProperty);
        };
        /**
         * The function called when the bindable property is set externally.
         * @param {boolean} newValue The new value of the control's state.
         * @param {boolean} oldValue The old value of the bindable control state.
         * @param {void} identifier The child identifier of the property being observed.
         * @param {boolean} firstTime? Whether or not this is the first call to bind the property.
         */
        DrawerController.prototype._setBoundProperty = function (newValue, oldValue, identifier, firstTime) {
            var _this = this;
            var utils = this.utils;
            if (firstTime === true && utils.isNull(newValue)) {
                this.inputChanged(this._isOpen);
                return;
            }
            var drawerState = !!newValue;
            if (drawerState !== newValue) {
                this.inputChanged(drawerState);
            }
            if (!this._isInitialized) {
                this._preInitializedValue = drawerState;
            }
            else if (drawerState) {
                if (this._isOpen) {
                    return;
                }
                this._toggleDelay();
                this._toggleDelay = utils.requestAnimationFrame(function () {
                    _this._open();
                });
            }
            else if (this._isOpen) {
                this._toggleDelay();
                var promise = new this._Promise(function (resolve) {
                    _this._toggleDelay = utils.requestAnimationFrame(function () {
                        resolve(_this._close());
                    });
                }), drawer = this._drawer;
                if (!utils.isNull(drawer)) {
                    drawer.ready = promise;
                }
            }
        };
        /**
         * Opens the Drawer.
         * @param {boolean} reset? Whether the open is being called to reset the open state.
         */
        DrawerController.prototype._open = function (reset) {
            var _this = this;
            var rootElement = this._rootElement, isNode = this.utils.isNode, isOpen = this._isOpen, offset = this._getOffset();
            if ((isOpen && !reset) || !(offset && isNode(rootElement) && isNode(this._drawerElement))) {
                return this._Promise.resolve();
            }
            var translation;
            switch (this._position) {
                case 'left':
                    translation = "translate3d(" + offset + "px,0,0)";
                    break;
                case 'right':
                    translation = "translate3d(" + (-offset) + "px,0,0)";
                    break;
                case 'top':
                    translation = "translate3d(0," + offset + "px,0)";
                    break;
                case 'bottom':
                    translation = "translate3d(0," + (-offset) + "px,0)";
                    break;
                default:
                    return this._Promise.resolve();
            }
            this._isOpen = true;
            this.dom.addClass(rootElement, this._directionalTransitionPrep);
            if (!isOpen) {
                this._addClickEater();
            }
            var animationOptions = {};
            animationOptions[this._transform] = translation;
            return this._animationThenable = this._animator.animate(rootElement, __Transition, {
                properties: animationOptions
            }).then(function () {
                _this._animationThenable = null;
                _this._drawerElement.removeEventListener('selectstart', __preventDefault, false);
            });
        };
        /**
         * Closes the Drawer.
         * @param {boolean} reset? Whether the open is being called to reset the open state.
         */
        DrawerController.prototype._close = function (reset) {
            var _this = this;
            var rootElement = this._rootElement, isNode = this.utils.isNode, isClosed = !this._isOpen;
            if ((isClosed && !reset) || !(isNode(rootElement) && isNode(this._drawerElement))) {
                return this._Promise.resolve();
            }
            this._isOpen = false;
            var animationOptions = {};
            animationOptions[this._transform] = this._preTransform;
            return this._animationThenable = this._animator.animate(rootElement, __Transition, {
                properties: animationOptions
            }).then(function () {
                _this._animationThenable = null;
                _this._drawerElement.removeEventListener('selectstart', __preventDefault, false);
                if (_this._isOpen) {
                    return;
                }
                else if (_this._touchState < 2) {
                    _this._removeClickEater();
                }
            });
        };
        /**
         * Resets the Drawer to it's current open/closed state.
         */
        DrawerController.prototype._reset = function () {
            if (this._isOpen) {
                return this._open(true);
            }
            var promise = this._close(true), drawer = this._drawer;
            if (!this.utils.isNull(drawer)) {
                drawer.ready = promise;
            }
            return promise;
        };
        /**
         * Adds a click eater when tracking and closing an open Drawer.
         */
        DrawerController.prototype._addClickEater = function () {
            var _this = this;
            var clickEater = this._clickEater, style = clickEater.style, rootElement = this._rootElement;
            if (rootElement.contains(clickEater)) {
                return;
            }
            // align clickEater to fill the rootElement 
            style.top = rootElement.scrollTop + "px";
            style.left = rootElement.scrollLeft + "px";
            rootElement.insertBefore(clickEater, null);
            this.dom.addClass(this._rootElement, this._directionalTransitionPrep);
            var removeScroll, removeRequest = noop, ready = true;
            removeScroll = this.addEventListener(rootElement, 'scroll', function () {
                if (!ready) {
                    return;
                }
                ready = false;
                removeRequest = _this.utils.requestAnimationFrame(function () {
                    var style = clickEater.style;
                    ready = true;
                    // align clickEater to fill the rootElement 
                    style.top = rootElement.scrollTop + "px";
                    style.left = rootElement.scrollLeft + "px";
                });
            });
            this._removeClickEaterListener = function () {
                removeRequest();
                removeScroll();
            };
        };
        /**
         * Removes the click eater after closing an open Drawer.
         */
        DrawerController.prototype._removeClickEater = function () {
            var rootElement = this._rootElement, clickEater = this._clickEater;
            this._removeClickEaterListener();
            if (rootElement.contains(clickEater)) {
                rootElement.removeChild(clickEater);
            }
            this.dom.removeClass(rootElement, this._directionalTransitionPrep);
        };
        /**
         * Adds swipe events to the controller element.
         */
        DrawerController.prototype._addSwipeToggle = function () {
            var _this = this;
            var element = this.element, removeSwipeOpen = this.addEventListener(element, __$swipe + __transitionNegate[this._position], function () {
                _this._hasSwiped = true;
                _this.open();
            }, false), removeSwipeClose = this.addEventListener(element, __$swipe + this._position, function () {
                _this._hasSwiped = true;
                _this.close();
            }, false);
            this._removeSwipeToggle = function () {
                removeSwipeOpen();
                removeSwipeClose();
            };
        };
        /**
         * Adds swipe close event to the root element.
         */
        DrawerController.prototype._addSwipeClose = function () {
            var _this = this;
            this._openSwipeRemover = this.addEventListener(this._clickEater, __$swipe + this._position, function () {
                _this._hasSwiped = true;
                _this.close();
            }, false);
        };
        /**
         * Adds tap toggle event to the controller element.
         */
        DrawerController.prototype._addTapToggle = function () {
            var _this = this;
            this._removeTap = this.addEventListener(this.element, __$tap, function () {
                _this._hasTapped = true;
                _this.toggle();
            }, false);
        };
        /**
         * Adds tap close event to the root element.
         */
        DrawerController.prototype._addTapClose = function () {
            var _this = this;
            this._openTapRemover = this.addEventListener(this._clickEater, __$tap, function () {
                _this._hasTapped = true;
                _this.close();
            }, false);
        };
        /**
         * Adds primary and secondary tracking events to the DrawerController element.
         */
        DrawerController.prototype._addEventListeners = function () {
            var element = this.element, isNull = this.utils.isNull, types = this._type.split(' '), position = this._position;
            // remove event listeners here first if we want to later be able to dynamically change position of drawer. 
            // this._removeEventListeners(); 
            if (this._isTap = (types.indexOf('tap') !== -1)) {
                this._addTapToggle();
                this._addTapClose();
            }
            if (this._isSwipe = (types.indexOf('swipe') !== -1)) {
                this._addSwipeToggle();
                this._addSwipeClose();
            }
            if (this._isTrack = (types.indexOf('track') !== -1)) {
                var trackFn = this._track, trackDirection = void 0, clickEater = this._clickEater;
                switch (position) {
                    case 'left':
                    case 'right':
                        trackDirection = position;
                        break;
                    case 'top':
                        trackDirection = 'up';
                        break;
                    case 'bottom':
                        trackDirection = 'down';
                        break;
                    default:
                        return;
                }
                var primaryTrack = __$track + __transitionNegate[trackDirection], secondaryTrack = __$track + trackDirection, removePrimaryTrack_1 = this.addEventListener(element, primaryTrack, trackFn, false), removeSecondaryTrack_1 = this.addEventListener(element, secondaryTrack, trackFn, false), openTrackPrimaryRemover_1 = this.addEventListener(clickEater, primaryTrack, trackFn, false), openTrackSecondaryRemover_1 = this.addEventListener(clickEater, secondaryTrack, trackFn, false);
                this._removeTrack = function () {
                    removePrimaryTrack_1();
                    removeSecondaryTrack_1();
                };
                this._openTrackRemover = function () {
                    openTrackPrimaryRemover_1();
                    openTrackSecondaryRemover_1();
                };
                if (isNull(this._lastTouch)) {
                    var touchStart = this._touchStart, touchEnd = this._touchEnd;
                    this._lastTouch = { x: 0, y: 0 };
                    this.addEventListener(element, __$touchstart, touchStart, false);
                    this.addEventListener(element, __$touchend, touchEnd, false);
                    this.addEventListener(element, __$trackend, touchEnd, false);
                    this.addEventListener(clickEater, __$touchstart, touchStart, false);
                    this.addEventListener(clickEater, __$trackend, touchEnd, false);
                    this.addEventListener(clickEater, __$touchend, touchEnd, false);
                }
            }
            this.addEventListener(this._window, 'resize', this._handleResize, false);
        };
        /**
         * Handles a Window resize event by closing the Drawer immediately.
         */
        DrawerController.prototype._handleResize = function () {
            if (!this._isOpen) {
                return;
            }
            var isNull = this.utils.isNull, rootElement = this._rootElement, drawer = this._drawer;
            this._isOpen = false;
            this.inputChanged(false);
            if (!isNull(rootElement)) {
                rootElement.style[this._transform] = this._preTransform;
            }
            if (!isNull(drawer)) {
                drawer.inputChanged(false);
                this._drawerElement.removeEventListener('selectstart', __preventDefault, false);
            }
            if (this._touchState < 2) {
                this._removeClickEater();
            }
        };
        /**
         * Removes all event listeners.
         */
        DrawerController.prototype._removeEventListeners = function () {
            var isFunction = this.utils.isFunction;
            if (this._isTap) {
                if (isFunction(this._removeTap)) {
                    this._removeTap();
                    this._removeTap = null;
                }
                if (isFunction(this._openTapRemover)) {
                    this._openTapRemover();
                    this._openTapRemover = null;
                }
            }
            if (this._isTrack) {
                if (isFunction(this._removeTrack)) {
                    this._removeTrack();
                    this._removeTrack = null;
                }
                if (isFunction(this._openTrackRemover)) {
                    this._openTrackRemover();
                    this._openTrackRemover = null;
                }
            }
            if (this._isSwipe) {
                if (isFunction(this._removeSwipeToggle)) {
                    this._removeSwipeToggle();
                    this._removeSwipeToggle = null;
                }
                if (isFunction(this._openSwipeRemover)) {
                    this._openSwipeRemover();
                    this._openSwipeRemover = null;
                }
            }
        };
        /**
         * Log when the user touches the DrawerController.
         * @param {plat.ui.IGestureEvent} ev The touch event.
         */
        DrawerController.prototype._touchStart = function (ev) {
            if (this._touchState === 1) {
                return;
            }
            this._touchState = 1;
            this._lastTouch = {
                x: ev.clientX,
                y: ev.clientY
            };
        };
        /**
         * The $touchend and $trackend event handler.
         * @param {plat.ui.IGestureEvent} ev The touch event.
         */
        DrawerController.prototype._touchEnd = function (ev) {
            var noTouch = this._touchState === 0, hasSwiped = this._hasSwiped, hasTapped = this._hasTapped;
            this._hasSwiped = this._hasTapped = false;
            this._touchState = 0;
            if (hasTapped || noTouch || hasSwiped) {
                return;
            }
            var distanceMoved = this._isVertical ? ev.clientY - this._lastTouch.y : ev.clientX - this._lastTouch.x;
            if (this._isRightDirection(distanceMoved)) {
                var offset = this._getOffset();
                if (!offset) {
                    return;
                }
                else if (Math.abs(distanceMoved) > Math.ceil(offset / 2)) {
                    this.toggle();
                    return;
                }
                this._reset();
            }
            else if (this._isElastic) {
                if (Math.abs(distanceMoved) > 0) {
                    this._reset();
                }
            }
            else if (!this._isOpen) {
                this._removeClickEater();
            }
        };
        /**
         * The $track event handler. Used for tracking only horizontal or vertical tracking motions
         * depending on the defined position.
         * @param {plat.ui.IGestureEvent} ev The $tracking event.
         */
        DrawerController.prototype._track = function (ev) {
            var _this = this;
            var touchState = this._touchState;
            if (touchState === 0) {
                return;
            }
            else if (touchState === 1) {
                if (!this.utils.isNull(this._animationThenable)) {
                    this._animationThenable.cancel().then(function () {
                        _this._addClickEater();
                        if (_this.utils.isNode(_this._drawerElement)) {
                            _this._drawerElement.addEventListener('selectstart', __preventDefault, false);
                        }
                    });
                }
                else {
                    this._addClickEater();
                    if (this.utils.isNode(this._drawerElement)) {
                        this._drawerElement.addEventListener('selectstart', __preventDefault, false);
                    }
                }
                this._touchState = 2;
            }
            this.utils.requestAnimationFrame(function () {
                _this._rootElement.style[_this._transform] = _this._calculateTranslation(ev);
            });
        };
        /**
         * Checks to make sure the user has been tracking in the right direction to
         * toggle.
         * @param {number} distanceMoved The distance the user's pointer has moved.
         */
        DrawerController.prototype._isRightDirection = function (distanceMoved) {
            switch (this._position) {
                case 'left':
                case 'top':
                    return this._isOpen ? distanceMoved < 0 : distanceMoved > 0;
                case 'right':
                case 'bottom':
                    return this._isOpen ? distanceMoved > 0 : distanceMoved < 0;
                default:
                    return false;
            }
        };
        /**
         * Calculates the translation value for setting the transform value.
         * @param {plat.ui.IGestureEvent} ev The $tracking event.
         */
        DrawerController.prototype._calculateTranslation = function (ev) {
            var offset = this._getOffset(), distanceMoved;
            if (!offset) {
                return this._preTransform;
            }
            switch (this._position) {
                case 'left':
                    distanceMoved = this._checkElasticity(offset, ev.clientX - this._lastTouch.x);
                    if (distanceMoved === 0) {
                        return this._preTransform;
                    }
                    return "translate3d(" + distanceMoved + "px,0,0)";
                case 'right':
                    distanceMoved = this._checkElasticity(offset, this._lastTouch.x - ev.clientX);
                    if (distanceMoved === 0) {
                        return this._preTransform;
                    }
                    return "translate3d(" + (-distanceMoved) + "px,0,0)";
                case 'top':
                    distanceMoved = this._checkElasticity(offset, ev.clientY - this._lastTouch.y);
                    if (distanceMoved === 0) {
                        return this._preTransform;
                    }
                    return "translate3d(0," + distanceMoved + "px,0)";
                case 'bottom':
                    distanceMoved = this._checkElasticity(offset, this._lastTouch.y - ev.clientY);
                    if (distanceMoved === 0) {
                        return this._preTransform;
                    }
                    return "translate3d(0," + (-distanceMoved) + "px,0)";
                default:
                    return this._preTransform;
            }
        };
        /**
         * Checks for elasticity and potentially readjusts the user's
         * distance moved.
         * @param {number} maxOffset The maximum distance the corresponding Drawer can translate.
         * @param {number} delta The distance the user's finger moved.
         */
        DrawerController.prototype._checkElasticity = function (maxOffset, delta) {
            var distanceMoved = this._isOpen ? maxOffset + delta : delta;
            if (this._isElastic) {
                return distanceMoved;
            }
            if (distanceMoved < 0) {
                distanceMoved = 0;
            }
            else if (distanceMoved > maxOffset) {
                distanceMoved = maxOffset;
            }
            return distanceMoved;
        };
        /**
         * Initializes and dispatches pub sub events.
         * @param {string} id The ID of this DrawerController if used.
         * @param {string} position The position of the Drawer.
         */
        DrawerController.prototype._initializeEvents = function (id, position) {
            var _this = this;
            var useContext = this._useContext, eventRemover = this.on(__DrawerFoundEvent + "_" + id, function (event, drawerArg) {
                eventRemover();
                var utils = _this.utils, isString = utils.isString, isUndefined = utils.isUndefined, drawer = (_this._drawer = drawerArg.control) || {}, drawerElement = _this._drawerElement = drawer.element;
                if (!isString(position)) {
                    if (isString(drawerArg.position)) {
                        position = drawerArg.position;
                    }
                    else {
                        _this._log.debug(("\"position\" is incorrectly defined for a control such as \"" + __Drawer + "\" ") +
                            ("or \"" + _this.type + ".\" Please ensure it is a string."));
                        return;
                    }
                }
                drawerElement.removeAttribute(__Hide);
                if (!_this._controllerIsValid(position.toLowerCase())) {
                    return;
                }
                _this._setTransform();
                _this._addEventListeners();
                if (isUndefined(_this._isElastic)) {
                    _this._isElastic = drawerArg.elastic === true;
                }
                if (!drawerArg.received) {
                    _this.dispatchEvent(__DrawerControllerFetchEvent + "_" + id, plat.events.EventManager.DIRECT, {
                        control: _this,
                        received: true,
                        position: position,
                        useContext: useContext
                    });
                }
                if (drawerArg.state) {
                    _this._isOpen = true;
                    _this.inputChanged(true);
                    if (!drawerArg.nextState && utils.isNull(_this._preInitializedValue)) {
                        _this._preInitializedValue = false;
                    }
                }
                else if (drawerArg.nextState && utils.isNull(_this._preInitializedValue)) {
                    _this._preInitializedValue = true;
                }
                var finish = function () {
                    _this._isInitialized = true;
                    _this._checkPreInit();
                };
                if (!useContext) {
                    finish();
                    return;
                }
                _this._determineTemplate(drawerArg.template).then(finish);
            });
            this.dispatchEvent(__DrawerControllerFetchEvent + "_" + id, plat.events.EventManager.DIRECT, {
                control: this,
                received: false,
                position: position,
                useContext: useContext
            });
        };
        /**
         * Checks the pre-initialized value and handles accordingly.
         */
        DrawerController.prototype._checkPreInit = function () {
            var _this = this;
            var value = this._preInitializedValue, utils = this.utils, isNull = utils.isNull;
            if (isNull(value)) {
                return;
            }
            var isOpen = this._isOpen;
            if (isOpen && value || !(isOpen || value)) {
                return;
            }
            this._toggleDelay();
            if (value) {
                this._toggleDelay = utils.requestAnimationFrame(this._open.bind(this));
                return;
            }
            var promise = new this._Promise(function (resolve) {
                _this._toggleDelay = utils.requestAnimationFrame(function () {
                    resolve(_this._close());
                });
            }), drawer = this._drawer;
            if (!isNull(drawer)) {
                drawer.ready = promise;
            }
        };
        /**
         * Determines the proper HTML template, binds it, and inserts it if needed.
         * @param {Node} fragment? A Node to insert as the Drawer's HTML template
         * if no templateUrl is present on this DrawerController.
         */
        DrawerController.prototype._determineTemplate = function (fragment) {
            var _this = this;
            var utils = this.utils;
            if (utils.isString(this._templateUrl)) {
                return plat.ui.TemplateControl.determineTemplate(this, this._templateUrl).then(function (template) {
                    return _this.bindTemplate('drawer', template);
                });
            }
            else if (utils.isNode(fragment)) {
                return this.bindTemplate('drawer', fragment);
            }
            return this._Promise.resolve();
        };
        /**
         * Obtains the current browser's transform property value.
         */
        DrawerController.prototype._setTransform = function () {
            var style = this._rootElement.style, isUndefined = this.utils.isUndefined;
            var vendorPrefix = this._compat.vendorPrefix;
            if (!isUndefined(this._preTransform = style[(vendorPrefix.lowerCase + "Transform")])) {
                this._transform = vendorPrefix.lowerCase + "Transform";
            }
            else if (!isUndefined(this._preTransform = style[(vendorPrefix.upperCase + "Transform")])) {
                this._transform = vendorPrefix.upperCase + "Transform";
            }
            else {
                this._transform = 'transform';
            }
        };
        /**
         * Checks if this control has all valid properties.
         * @param {string} position The position of the Drawer.
         */
        DrawerController.prototype._controllerIsValid = function (position) {
            var utils = this.utils, isNull = utils.isNull;
            if (isNull(this._drawerElement)) {
                this._log.debug("Could not find a corresponding control such as \"" + __Drawer + "\" for this \"" + this.type + ".\"");
                return false;
            }
            switch (position) {
                case 'top':
                case 'bottom':
                    this._isVertical = true;
                case 'left':
                case 'right':
                    this._position = position;
                    break;
                default:
                    this._log.debug("Incorrect position: \"" + position + "\" defined for the a control such as a \"" + __Drawer + "\", or \"" + this.type + ".\"");
                    return false;
            }
            var rootElement = this._rootElement = this._getRootElement();
            if (isNull(rootElement)) {
                this._log.debug("Cannot have a \"" + this.type + "\" in a hierarchy above the corresponding control such as \"" + __Drawer + ".\"");
                return false;
            }
            var dom = this.dom;
            dom.addClass(rootElement, __Drawer + "-root");
            dom.addClass(this.element, (this._isVertical ? __Plat + "vertical" : __Plat + "horizontal"));
            this._directionalTransitionPrep = __Drawer + "-transition-" + position;
            this._clickEater = this._document.createElement('div');
            this._clickEater.className = __Plat + "clickeater";
            this._styleRootElement();
            return true;
        };
        /**
         * Obtains the root element to translate.
         */
        DrawerController.prototype._getRootElement = function () {
            var drawer = this._drawer, utils = this.utils;
            if (!utils.isNull(drawer.storedProperties)) {
                return drawer.storedProperties.rootElement;
            }
            var isNode = utils.isNode, root = this.root, element = utils.isObject(root) && isNode(root.element) ? root.element : this.element, drawerEl = this._drawerElement, parent;
            while (isNode(parent = element.parentElement) && !parent.contains(drawerEl)) {
                element = parent;
            }
            return element;
        };
        /**
         * Handles root element styling
         */
        DrawerController.prototype._styleRootElement = function () {
            var _window = this._window, utils = this.utils, drawer = this._drawer, rootElement = this._rootElement, parent = rootElement.parentElement, computedStyle = _window.getComputedStyle(rootElement), style = rootElement.style, position = computedStyle.position, zIndex = Number(computedStyle.zIndex), rootElementStyle = {
                rootElement: rootElement
            };
            if (position === 'static') {
                rootElementStyle.position = style.position;
                style.position = 'relative';
            }
            if (!utils.isNumber(zIndex) || zIndex < 1) {
                rootElementStyle.zIndex = style.zIndex;
                style.zIndex = '1';
            }
            if (utils.isNode(parent)) {
                var computedParentStyle = _window.getComputedStyle(parent), overflow = computedParentStyle.overflow;
                if (overflow !== 'hidden') {
                    var computedDirectionalOverflow = void 0, key = void 0;
                    if (this._isVertical) {
                        key = 'overflowY';
                        computedDirectionalOverflow = computedParentStyle.overflowY;
                    }
                    else {
                        key = 'overflowX';
                        computedDirectionalOverflow = computedParentStyle.overflowX;
                    }
                    if (computedDirectionalOverflow !== 'hidden') {
                        var parentStyle = parent.style;
                        rootElementStyle.parentOverflow = {
                            key: key,
                            value: parentStyle[key]
                        };
                        parentStyle[key] = 'hidden';
                    }
                }
            }
            drawer.storedProperties = rootElementStyle;
        };
        /**
         * Uninitializes the root element.
         */
        DrawerController.prototype._cleanRootElement = function () {
            var utils = this.utils, isObject = utils.isObject, isNode = utils.isNode, rootElement = this._rootElement, drawer = this._drawer;
            if (!isNode(rootElement)) {
                return;
            }
            this.dom.removeClass(rootElement, __Drawer + "-root " + this._directionalTransitionPrep);
            if (utils.isNull(drawer)) {
                return;
            }
            var storedStyle = drawer.storedProperties;
            if (!isObject(storedStyle)) {
                return;
            }
            var rootElementStyle = rootElement.style, parent = rootElement.parentElement, overflow = storedStyle.parentOverflow;
            rootElementStyle.position = storedStyle.position;
            rootElementStyle.zIndex = storedStyle.zIndex;
            if (isObject(overflow) && isNode(parent)) {
                parent.style[overflow.key] = overflow.value;
            }
            delete drawer.storedProperties;
            this._drawerElement.setAttribute(__Hide, '');
        };
        /**
         * Sets the max offset to translate the corresponding Drawer.
         */
        DrawerController.prototype._getOffset = function () {
            return this._isVertical ? this._drawerElement.offsetHeight : this._drawerElement.offsetWidth;
        };
        DrawerController._inject = {
            _document: __Document,
            _window: __Window,
            _compat: __Compat,
            _animator: __Animator,
            _Promise: __Promise
        };
        return DrawerController;
    }(plat.ui.BindControl));
    platui.DrawerController = DrawerController;
    plat.register.control(__DrawerController, DrawerController);
    /**
     * An BindControl for showing a templated and animated overlay.
     */
    var Modal = (function (_super) {
        __extends(Modal, _super);
        /**
         * The constructor for a Modal. Creates the modalLoaded Promise.
         */
        function Modal() {
            var _this = this;
            _super.call(this);
            /**
             * The HTML template represented as a string.
             */
            this.templateString = this.__templateString;
            /**
             * Whether or not the modal is currently visible.
             */
            this._isVisible = false;
            /**
             * A function to stop listening to scroll events.
             */
            this._scrollRemover = noop;
            /**
             * A function to stop listening for DOM presence.
             */
            this._presenceRemover = noop;
            /**
             * The current scroll position of the modal.
             */
            this._scrollTop = 0;
            /**
             * A hash for validating available transitions.
             */
            this._transitionHash = {
                up: true,
                down: true,
                left: true,
                right: true,
                fade: true
            };
            /**
             * The private template string used to check for a template overwrite.
             */
            this.__templateString = '<div class="plat-modal-container"></div>\n';
            this.modalLoaded = new this._Promise(function (resolve, reject) {
                _this.__resolveFn = resolve;
                _this.__rejectFn = reject;
            }).catch(noop);
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        Modal.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __Modal + " " + __Hide + " " + (className || ''));
        };
        /**
         * Check for templateUrl and set if needed then hide the control.
         */
        Modal.prototype.initialize = function () {
            var optionObj = this.options || (this.options = {}), options = optionObj.value || (optionObj.value = {});
            this.templateUrl = options.templateUrl || this.templateUrl;
            this.setClasses();
        };
        /**
         * Add the innerTemplate to the control's element.
         */
        Modal.prototype.setTemplate = function () {
            if (this.templateString !== this.__templateString || this.utils.isString(this.templateUrl)) {
                var dom = this.dom, fragment = dom.serializeHtml(this.__templateString), element = this.element, modalContainer = this._container = fragment.firstChild;
                this.innerTemplate = dom.appendChildren(element.childNodes);
                element.appendChild(fragment);
            }
        };
        /**
         * Check for a transition and initialize it if necessary.
         */
        Modal.prototype.loaded = function () {
            var options = this.options.value, transition = options.transition, element = this.element;
            // in case of cloning 
            this._container = this._container || element.firstElementChild;
            this._presenceRemover = this.dom.whenPresent(this._injectElement.bind(this), element);
            if (!this.utils.isString(transition) || transition === 'none') {
                this.dom.addClass(this._container, __Plat + "no-transition");
                return;
            }
            else if (!this._transitionHash[transition]) {
                this._log.debug("Custom transition: \"" + transition + "\" defined for \"" + this.type + ".\" Please ensure the transition is defined to avoid errors.");
            }
            var animationEvents = this._compat.animationEvents;
            if (this.utils.isNull(animationEvents)) {
                this._log.debug('This browser does not support CSS3 animations.');
                this.dom.addClass(this._container, __Plat + "no-transition");
                return;
            }
            this._transitionEnd = animationEvents.$transitionEnd;
            this.dom.addClass(this._container, (__Plat + transition) + " " + __Plat + "modal-transition");
        };
        /**
         * Clean up the auto scroll.
         */
        Modal.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._scrollRemover();
            this._presenceRemover();
            if (this.utils.isFunction(this.__rejectFn)) {
                this.__rejectFn();
                this.__rejectFn = this.__resolveFn = null;
            }
        };
        /**
         * Shows the Modal.
         */
        Modal.prototype.show = function () {
            var wasHidden = !this._isVisible, promise = this._show();
            if (wasHidden) {
                this.inputChanged(true);
            }
            return promise;
        };
        /**
         * Hides the Modal.
         */
        Modal.prototype.hide = function () {
            var wasVisible = this.isVisible, promise = this._hide();
            if (wasVisible) {
                this.inputChanged(false);
            }
            return promise;
        };
        /**
         * Toggles the visibility of the Modal.
         */
        Modal.prototype.toggle = function () {
            if (this._isVisible) {
                return this.hide();
            }
            return this.show();
        };
        /**
         * Whether or not the Modal is currently visible.
         */
        Modal.prototype.isVisible = function () {
            return this._isVisible;
        };
        /**
         * A function that allows this control to observe both the bound property itself as well as
         * potential child properties if being bound to an object.
         * @param {plat.observable.IImplementTwoWayBinding} binder The control that facilitates the
         * databinding.
         */
        Modal.prototype.observeProperties = function (binder) {
            binder.observeProperty(this._setBoundProperty);
        };
        /**
         * The function called when the bindable property is set externally.
         * @param {boolean} modalState The new value of the control state.
         * @param {boolean} oldValue The old value of the control state.
         * @param {void} identifier The child identifier of the property being observed.
         * @param {boolean} firstTime? Whether or not this is the first call to bind the property.
         */
        Modal.prototype._setBoundProperty = function (modalState, oldValue, identifier, firstTime) {
            var utils = this.utils;
            if (firstTime === true && utils.isNull(modalState)) {
                this.inputChanged(this._isVisible);
                return;
            }
            if (utils.isBoolean(modalState)) {
                if (modalState) {
                    if (this._isVisible) {
                        return;
                    }
                    this._show();
                    return;
                }
                if (this._isVisible) {
                    this._hide();
                }
                return;
            }
            this._log.debug("Attempting to show or hide a " + this.type + " with a bound value that is something other than a boolean.");
        };
        /**
         * Shows the Modal.
         */
        Modal.prototype._show = function () {
            var _this = this;
            var dom = this.dom, utils = this.utils;
            if (!utils.isNull(this.innerTemplate)) {
                return this._bindInnerTemplate();
            }
            this._isVisible = true;
            return new this._Promise(function (resolve) {
                utils.requestAnimationFrame(function () {
                    _this._alignModal();
                    dom.removeClass(_this.element, __Hide);
                    utils.defer(function () {
                        utils.requestAnimationFrame(function () {
                            dom.addClass(_this._container, __Plat + "activate");
                            resolve();
                        });
                    }, 20);
                });
            });
        };
        /**
         * Aligns the control to the top of the viewport.
         * @param {Event} ev? The scroll event object.
         */
        Modal.prototype._alignModal = function (ev) {
            var _this = this;
            var utils = this.utils, isNull = utils.isNull, _document = this._document, documentEl = _document.documentElement, scrollEl = isNull(documentEl) || !documentEl.scrollTop ? _document.body : documentEl, scrollTop = scrollEl.scrollTop;
            if (this._scrollTop === scrollTop) {
                return;
            }
            if (!isNull(ev)) {
                utils.requestAnimationFrame(function () {
                    _this.element.style.top = scrollTop + "px";
                });
            }
            else {
                this.element.style.top = scrollTop + "px";
                this._scrollRemover = this.addEventListener(this._window, 'scroll', this._alignModal, false);
            }
            this._scrollTop = scrollTop;
        };
        /**
         * Hides the Modal.
         */
        Modal.prototype._hide = function () {
            var _this = this;
            var dom = this.dom, utils = this.utils, promise;
            this._scrollRemover();
            this._scrollRemover = noop;
            this._isVisible = false;
            if (utils.isString(this._transitionEnd)) {
                promise = this._addHideOnTransitionEnd();
                utils.requestAnimationFrame(function () {
                    dom.removeClass(_this._container, __Plat + "activate");
                });
            }
            else {
                promise = new this._Promise(function (resolve) {
                    utils.requestAnimationFrame(function () {
                        dom.addClass(_this.element, __Hide);
                        dom.removeClass(_this._container, __Plat + "activate");
                        resolve();
                    });
                });
            }
            return promise;
        };
        /**
         * Adds the innerTemplate to BindableTemplates, binds it,
         * and adds it to the DOM.
         */
        Modal.prototype._bindInnerTemplate = function () {
            var _this = this;
            var innerTemplate = this.innerTemplate, bindableTemplates = this.bindableTemplates, modal = 'modal';
            bindableTemplates.add(modal, innerTemplate);
            this.innerTemplate = null;
            return bindableTemplates.bind(modal).then(function (template) {
                _this._container.insertBefore(template, null);
                if (_this.utils.isFunction(_this.__resolveFn)) {
                    _this.__resolveFn();
                    _this.__resolveFn = _this.__rejectFn = null;
                }
                return _this._show();
            });
        };
        /**
         * Removes itself from the DOM and inserts itself into the body to work with
         * absolute positioning.
         */
        Modal.prototype._injectElement = function () {
            var element = this.element, parentElement = element.parentElement, body = this._document.body;
            if (!this.utils.isNode(parentElement) || parentElement === body) {
                return;
            }
            body.insertBefore(element, null);
        };
        /**
         * Listens for the transition to end and hides the element after it is finished.
         */
        Modal.prototype._addHideOnTransitionEnd = function () {
            var _this = this;
            return new this._Promise(function (resolve) {
                var element = _this.element, remove = _this.addEventListener(element, _this._transitionEnd, function () {
                    remove();
                    _this.dom.addClass(element, __Hide);
                    resolve();
                }, false);
            });
        };
        Modal._inject = {
            _window: __Window,
            _document: __Document,
            _compat: __Compat,
            _Promise: __Promise
        };
        return Modal;
    }(plat.ui.BindControl));
    platui.Modal = Modal;
    plat.register.control(__Modal, Modal);
    /**
     * An BindControl that standardizes an HTML5 input[type="range"].
     */
    var Slider = (function (_super) {
        __extends(Slider, _super);
        function Slider() {
            _super.apply(this, arguments);
            /**
             * The HTML template represented as a string.
             */
            this.templateString = '<div class="plat-slider-container">\n' +
                '    <div class="plat-slider-track">\n' +
                '        <div class="plat-knob"></div>\n' +
                '    </div>\n' +
                '</div>\n';
            /**
             * Whether the control is vertical or horizontal.
             */
            this._isVertical = false;
            /**
             * The current knob offset.
             */
            this._knobOffset = 0;
            /**
             * An enum denoting the current touch state of the user.
             */
            this._touchState = 0;
            /**
             * A function that will stop listening for visibility if applicable.
             */
            this._removeVisibilityListener = noop;
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        Slider.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __Slider + " " + (className || ''));
        };
        /**
         * Set the proper classes for the control.
         */
        Slider.prototype.initialize = function () {
            this.setClasses();
        };
        /**
         * Determine the button type and apply the proper classes.
         */
        Slider.prototype.loaded = function () {
            var element = this.element, slider = this._slider = element.firstElementChild.firstElementChild, isNumber = this.utils.isNumber, optionObj = this.options || {}, options = optionObj.value || {}, optionValue = Number(options.value), optionMin = options.min, optionMax = options.max, step = options.step, reversed = this._reversed = (options.reverse === true), min = this.min = isNumber(optionMin) ? Math.floor(optionMin) : 0, max = this.max = isNumber(optionMax) ? Math.ceil(optionMax) : 100, value = isNumber(optionValue) ? Math.round(optionValue) : min, className = __Plat + this._validateOrientation(options.orientation);
            this._knob = slider.firstElementChild;
            if (reversed) {
                className += __Reversed;
            }
            this.dom.addClass(element, className);
            // reset value to minimum in case Bind set it to a value 
            this.value = min;
            this._step = isNumber(step) ? (step > 0 ? Math.round(step) : 1) : 1;
            if (min >= max) {
                this._log.debug("\"" + this.type + "'s\" min is greater than or equal to its max. Setting max to min + 1.");
                this.max = min + 1;
            }
            this._setLength();
            this._initializeEvents();
            this.setValue(value);
        };
        /**
         * Removes the visibility listener if applicable.
         */
        Slider.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._removeVisibilityListener();
            this._sliderVisible = null;
        };
        /**
         * Set the value of the Slider. If an invalid value is passed in
         * nothing will happen.
         * @param {number} value The value to set the Slider to.
         */
        Slider.prototype.setValue = function (value) {
            this._setValue(value, true);
        };
        /**
         * A function that allows this control to observe both the bound property itself as well as
         * potential child properties if being bound to an object.
         * @param {plat.observable.IImplementTwoWayBinding} binder The control that facilitates the
         * databinding.
         */
        Slider.prototype.observeProperties = function (binder) {
            binder.observeProperty(this._setBoundProperty);
        };
        /**
         * The function called when the bindable value is set externally.
         * @param {number} newValue The new value of the bindable value.
         * @param {number} oldValue The old value of the bindable index.
         * @param {void} identifier The child identifier of the property being observed.
         * @param {boolean} firstTime? Whether or not this is the first call to bind the property.
         */
        Slider.prototype._setBoundProperty = function (newValue, oldValue, identifier, firstTime) {
            this._setValue(newValue, false);
        };
        /**
         * Sets the value of the Slider.
         * @param {number} value The value to set.
         * @param {boolean} propertyChanged Whether or not we need to fire a propertyChanged event.
         */
        Slider.prototype._setValue = function (value, propertyChanged) {
            var utils = this.utils;
            if (this._touchState === 1) {
                this._log.debug("Cannot set the value of " + this.type + " while the user is manipulating it.");
                return;
            }
            else if (utils.isNull(value)) {
                value = this.min;
                propertyChanged = true;
            }
            if (!utils.isNumber(value)) {
                var numberVal = Number(value);
                if (utils.isNumber(numberVal)) {
                    value = numberVal;
                    propertyChanged = true;
                }
                else {
                    this._log.warn(this.type + " has its value bound to a property that cannot be interpreted as a Number.");
                    return;
                }
            }
            this._setValueProperty(value, true, propertyChanged);
        };
        /**
         * Initialize the proper tracking events.
         */
        Slider.prototype._initializeEvents = function () {
            var _this = this;
            var element = this.element, trackFn = this._track, touchEnd = this._touchEnd, track, reverseTrack;
            if (this._isVertical) {
                track = __$track + "down";
                reverseTrack = __$track + "up";
            }
            else {
                track = __$track + "right";
                reverseTrack = __$track + "left";
            }
            this.addEventListener(element, __$touchstart, this._touchStart, false);
            this.addEventListener(element, track, trackFn, false);
            this.addEventListener(element, reverseTrack, trackFn, false);
            this.addEventListener(element, __$touchend, touchEnd, false);
            this.addEventListener(element, __$trackend, touchEnd, false);
            this.addEventListener(this._window, 'resize', function () {
                if (!_this.utils.isNull(_this._sliderVisible)) {
                    return;
                }
                _this._setLength();
                _this._setKnob();
            }, false);
        };
        /**
         * Log the first touch.
         * @param {plat.ui.IGestureEvent} ev The touch event object.
         */
        Slider.prototype._touchStart = function (ev) {
            var _this = this;
            if (this._touchState === 1) {
                return;
            }
            this._touchState = 1;
            this._lastTouch = {
                x: ev.clientX,
                y: ev.clientY,
                value: this.value
            };
            var target = ev.target;
            if (target === this._knob) {
                return;
            }
            var offset;
            if (this._isVertical) {
                if (target === this.element) {
                    offset = this._reversed ? ev.offsetY - this._sliderOffset : this._maxOffset - (ev.offsetY - this._sliderOffset);
                }
                else if (target === this._slider) {
                    offset = this._reversed ? ev.offsetY : this._knobOffset - ev.offsetY;
                }
                else {
                    offset = this._reversed ? ev.offsetY : this._maxOffset - ev.offsetY;
                }
            }
            else {
                if (target === this.element) {
                    offset = this._reversed ? this._maxOffset - (ev.offsetX - this._sliderOffset) : ev.offsetX - this._sliderOffset;
                }
                else if (target === this._slider) {
                    offset = this._reversed ? this._knobOffset - ev.offsetX : ev.offsetX;
                }
                else {
                    offset = this._reversed ? this._maxOffset - ev.offsetX : ev.offsetX;
                }
            }
            this.utils.requestAnimationFrame(function () {
                _this._knobOffset = _this._setSliderProperties(offset);
            });
        };
        /**
         * Set the new slider offset.
         * @param {plat.ui.IGestureEvent} ev The $trackend event object.
         */
        Slider.prototype._touchEnd = function (ev) {
            var _this = this;
            if (this._touchState !== 1) {
                this._touchState = 0;
                return;
            }
            this._touchState = 2;
            var newOffset = this._calculateOffset(ev), maxOffset = this._maxOffset;
            this.utils.requestAnimationFrame(function () {
                _this._touchState = 0;
                if (_this._lastTouch.value !== _this.value) {
                    _this._trigger('change');
                }
                if (newOffset < 0) {
                    _this._knobOffset = 0;
                    return;
                }
                else if (newOffset > maxOffset) {
                    _this._knobOffset = maxOffset;
                    return;
                }
                _this._knobOffset = newOffset;
            });
        };
        /**
         * Track the knob movement.
         * @param {plat.ui.IGestureEvent} ev The $track event object.
         */
        Slider.prototype._track = function (ev) {
            var _this = this;
            if (this._touchState === 0) {
                return;
            }
            this.utils.requestAnimationFrame(function () {
                _this._setSliderProperties(_this._calculateOffset(ev));
            });
        };
        /**
         * Set the Slider's knob position and corresponding value.
         * @param {number} position The position value to set the knob to prior to
         * normalization.
         */
        Slider.prototype._setSliderProperties = function (position) {
            var maxOffset = this._maxOffset, value;
            if (position <= 0) {
                value = this.min;
                position = 0;
                if (value - this.value >= 0) {
                    return position;
                }
            }
            else if (position >= maxOffset) {
                value = this.max;
                position = maxOffset;
                if (value - this.value <= 0) {
                    return position;
                }
            }
            else {
                value = this._calculateValue(position);
            }
            this._setValueProperty(value, false, true);
            this._slider.style[this._lengthProperty] = position + "px";
            return position;
        };
        /**
         * Calculates the current value based on knob position and slider width.
         * @param {number} width The current width of the slider.
         */
        Slider.prototype._calculateValue = function (width) {
            var step = this._step;
            return (this.min + Math.round(width / this._increment / step) * step);
        };
        /**
         * Calculates knob position based on current value.
         * @param {number} value The current value of the {link platui.Slider|Slider}.
         */
        Slider.prototype._calculateKnobPosition = function (value) {
            return (value - this.min) * this._increment;
        };
        /**
         * Calculates the new offset of the slider based on the old offset and the distance moved.
         * @param {plat.ui.IGestureEvent} ev The $track or $trackend event object.
         */
        Slider.prototype._calculateOffset = function (ev) {
            if (this._isVertical) {
                return this._reversed ?
                    (this._knobOffset + ev.clientY - this._lastTouch.y) :
                    (this._knobOffset + this._lastTouch.y - ev.clientY);
            }
            else {
                return this._reversed ?
                    (this._knobOffset + this._lastTouch.x - ev.clientX) :
                    (this._knobOffset + ev.clientX - this._lastTouch.x);
            }
        };
        /**
         * Sets the property to use for length and sets the max length of the slider.
         */
        Slider.prototype._setLength = function () {
            var _this = this;
            var el = this._slider.parentElement;
            if (this._isVertical) {
                this._lengthProperty = 'height';
                this._maxOffset = el.clientHeight;
                this._sliderOffset = el.offsetTop;
            }
            else {
                this._lengthProperty = 'width';
                this._maxOffset = el.clientWidth;
                this._sliderOffset = el.offsetLeft;
            }
            if (!this._maxOffset) {
                this._sliderVisible = new this._Promise(function (resolve) {
                    _this._removeVisibilityListener = _this.dom.whenVisible(function () {
                        _this._sliderVisible = null;
                        _this._setLength();
                        resolve();
                    }, el);
                });
                return;
            }
            this._setIncrement();
        };
        /**
         * Sets the increment for sliding the {link platui.Slider|Slider}.
         */
        Slider.prototype._setIncrement = function () {
            return (this._increment = this._maxOffset / (this.max - this.min));
        };
        /**
         * Sets the value of the Slider.
         * @param {number} newValue The new value to set.
         * @param {boolean} setKnob Whether or not we need to set the knob position.
         * @param {boolean} propertyChanged Whether or not we need to fire a propertyChanged event.
         */
        Slider.prototype._setValueProperty = function (newValue, setKnob, propertyChanged) {
            var value = this.value;
            if (newValue === value) {
                return;
            }
            else if (newValue >= this.max) {
                newValue = this.max;
            }
            else if (newValue <= this.min) {
                newValue = this.min;
            }
            else if (Math.abs(newValue - value) < this._step) {
                return;
            }
            this.value = this.element.value = newValue;
            if (setKnob) {
                this._setKnob();
            }
            if (propertyChanged) {
                this.inputChanged(newValue, value);
            }
            this._trigger('input');
        };
        /**
         * Animates and sets the knob position.
         * @param {number} value? The value to use to calculate the knob position. If no value is
         * specified, the current Slider's value will be used.
         */
        Slider.prototype._setKnob = function (value) {
            var _this = this;
            this._Promise.resolve(this._sliderVisible).then(function () {
                var animationOptions = {}, length = _this._calculateKnobPosition((value || _this.value));
                if (length === _this._knobOffset) {
                    return;
                }
                animationOptions[_this._lengthProperty] = length + "px";
                _this._animator.animate(_this._slider, __Transition, {
                    properties: animationOptions
                });
                _this._knobOffset = length;
            });
        };
        /**
         * Triggers an event starting from this control's element.
         * @param {string} event The event name to trigger.
         */
        Slider.prototype._trigger = function (event) {
            var domEvent = plat.acquire(__DomEventInstance);
            domEvent.initialize(this.element, event);
            domEvent.trigger();
        };
        /**
         * Checks the orientation of the control and ensures it is valid.
         * Will default to "horizontal" if invalid.
         * @param {string} orientation The element to base the length off of.
         */
        Slider.prototype._validateOrientation = function (orientation) {
            if (this.utils.isUndefined(orientation)) {
                return 'horizontal';
            }
            var validOrientation;
            if (orientation === 'horizontal') {
                validOrientation = orientation;
            }
            else if (orientation === 'vertical') {
                validOrientation = orientation;
                this._isVertical = true;
            }
            else {
                this._log.debug("Invalid orientation \"" + orientation + "\" for " + this.type + ". Defaulting to \"horizontal.\"");
                validOrientation = 'horizontal';
            }
            return validOrientation;
        };
        Slider._inject = {
            _document: __Document,
            _window: __Window,
            _Promise: __Promise,
            _animator: __Animator
        };
        return Slider;
    }(plat.ui.BindControl));
    platui.Slider = Slider;
    plat.register.control(__Slider, Slider);
    /**
     * A BindControl that allows for a lower and upper value,
     * thus creating a variable range of included values.
     */
    var Range = (function (_super) {
        __extends(Range, _super);
        function Range() {
            _super.apply(this, arguments);
            /**
             * The HTML template represented as a string.
             */
            this.templateString = '<div class="plat-range-container">\n' +
                '    <div class="plat-range-track">\n' +
                '        <div class="plat-lower-knob"></div>\n' +
                '        <div class="plat-upper-knob"></div>\n' +
                '    </div>\n' +
                '</div>\n';
            /**
             * Whether the control is vertical or horizontal.
             */
            this._isVertical = false;
            /**
             * An enum denoting the current touch state of the user.
             */
            this._touchState = 0;
            /**
             * A function that will stop listening for visibility if applicable.
             */
            this._removeVisibilityListener = noop;
            /**
             * A boolean value that forces a one-time trigger upon the first bound value change.
             */
            this._forceFirstTime = false;
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        Range.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __Range + " " + (className || ''));
        };
        /**
         * Set the proper classes for the control.
         */
        Range.prototype.initialize = function () {
            this.setClasses();
        };
        /**
         * Determine the button type and apply the proper classes.
         */
        Range.prototype.loaded = function () {
            var element = this.element, slider = this._slider = element.firstElementChild.firstElementChild, isNumber = this.utils.isNumber, optionObj = this.options || {}, options = optionObj.value || {}, optionLower = Number(options.lower), optionUpper = Number(options.upper), identifiers = options.identifiers || {}, optionMin = options.min, optionMax = options.max, step = options.step, reversed = this._reversed = (options.reverse === true), min = this.min = isNumber(optionMin) ? Math.floor(optionMin) : 0, max = this.max = isNumber(optionMax) ? Math.ceil(optionMax) : 100, lower = isNumber(optionLower) ? Math.round(optionLower) : min, upper = isNumber(optionUpper) ? Math.round(optionUpper) : max, className = __Plat + this._validateOrientation(options.orientation);
            this._lowerKnob = slider.firstElementChild;
            this._upperKnob = slider.lastElementChild;
            this._lowerIdentifier = identifiers.lower || 'lower';
            this._upperIdentifier = identifiers.upper || 'upper';
            // if it's a reversed direction, swap knobs. 
            if (reversed) {
                var lowerKnob = this._lowerKnob;
                this._lowerKnob = this._upperKnob;
                this._upperKnob = lowerKnob;
                className += __Reversed;
            }
            this.dom.addClass(element, className);
            // reset value to minimum in case context is already set to a value 
            this.lower = min;
            this.upper = max;
            this._step = isNumber(step) ? (step > 0 ? Math.round(step) : 1) : 1;
            if (min >= max) {
                this._log.debug("\"" + this.type + "'s\" min is greater than or equal to its max. Setting max to min + 1.");
                this.max = min + 1;
            }
            this._setPositionAndLength();
            // must set this in case the value is not set and lower knob is never positioned due to setLower function. 
            this._setLowerKnobPosition(min);
            this._initializeEvents();
            this.setLower(lower);
            this.setUpper(upper);
        };
        /**
         * Sets the lower value of the Range. If an invalid value is passed in
         * nothing will happen.
         * @param {number} value The value to set the Range to.
         */
        Range.prototype.setLower = function (value) {
            this._setLower(value, true);
        };
        /**
         * Sets the upper value of the Range. If an invalid value is passed in
         * nothing will happen.
         * @param {number} value The value to set the Range to.
         */
        Range.prototype.setUpper = function (value) {
            this._setUpper(value, true);
        };
        /**
         * A function that allows this control to observe both the bound property itself as well as
         * potential child properties if being bound to an object.
         * @param {plat.observable.IImplementTwoWayBinding} binder The control that facilitates the
         * databinding.
         */
        Range.prototype.observeProperties = function (binder) {
            binder.observeProperty(this._setLowerBoundProperty, this._lowerIdentifier);
            binder.observeProperty(this._setUpperBoundProperty, this._upperIdentifier);
        };
        /**
         * The function called when the bindable lower value is set externally.
         * @param {number} newValue The new lower value.
         * @param {number} oldValue The old value of the bindable index.
         * @param {string} identifier The child identifier of the property being observed.
         * @param {boolean} firstTime? Whether or not this is the first call to bind the property.
         */
        Range.prototype._setLowerBoundProperty = function (newValue, oldValue, identifier, firstTime) {
            this._setLower(newValue, false, firstTime);
        };
        /**
         * The function called when the bindable upper value is set externally.
         * @param {number} newValue The new upper value.
         * @param {number} oldValue The old value of the bindable index.
         * @param {string} identifier The child identifier of the property being observed.
         * @param {boolean} firstTime? Whether or not this is the first call to bind the property.
         */
        Range.prototype._setUpperBoundProperty = function (newValue, oldValue, identifier, firstTime) {
            this._setUpper(newValue, false, firstTime);
        };
        /**
         * Sets the lower value of the Range. If an invalid value is passed in
         * nothing will happen.
         * @param {number} value The value to set the Range to.
         * @param {boolean} propertyChanged Whether or not the property was changed by the user.
         * @param {boolean} firstTime? Whether or not this is the first call to set the lower value.
         */
        Range.prototype._setLower = function (value, propertyChanged, firstTime) {
            var utils = this.utils;
            if (this._touchState === 2) {
                this._log.debug("Cannot set the value of the " + this.type + "'s lower knob while the user is manipulating it.");
                return;
            }
            else if (utils.isNull(value)) {
                value = this.min;
                if (firstTime === true) {
                    this._forceFirstTime = true;
                }
                else {
                    propertyChanged = true;
                }
            }
            if (!utils.isNumber(value)) {
                var numberVal = Number(value);
                if (utils.isNumber(numberVal)) {
                    value = numberVal;
                    if (firstTime === true) {
                        this._forceFirstTime = true;
                    }
                    else {
                        propertyChanged = true;
                    }
                }
                else {
                    this._log.warn(this.type + " has its lower value bound to a property that cannot be interpreted as a Number.");
                    return;
                }
            }
            this._setLowerValue(value, true, propertyChanged, true);
        };
        /**
         * Sets the uppper value of the Range. If an invalid value is passed in
         * nothing will happen.
         * @param {number} value The value to set the Range to.
         * @param {boolean} propertyChanged Whether or not the property was changed by the user.
         * @param {boolean} firstTime? Whether or not this is the first call to set the upper value.
         */
        Range.prototype._setUpper = function (value, propertyChanged, firstTime) {
            var utils = this.utils;
            if (this._touchState === 3) {
                this._log.debug("Cannot set the value of the " + this.type + "'s upper knob while the user is manipulating it.");
                return;
            }
            else if (utils.isNull(value)) {
                value = this.max;
                propertyChanged = true;
            }
            if (!utils.isNumber(value)) {
                var numberVal = Number(value);
                if (utils.isNumber(numberVal)) {
                    value = numberVal;
                    propertyChanged = true;
                }
                else {
                    this._log.warn(this.type + " has its upper value bound to a property that cannot be interpreted as a Number.");
                    return;
                }
            }
            this._setUpperValue(value, true, propertyChanged || (firstTime === true && this._forceFirstTime), true);
        };
        /**
         * Initialize the proper tracking events.
         */
        Range.prototype._initializeEvents = function () {
            var _this = this;
            var lowerKnob = this._lowerKnob, upperKnob = this._upperKnob, touchstart = this._touchStart, touchEnd = this._touchEnd, trackLower = this._trackLower, trackUpper = this._trackUpper, track, reverseTrack;
            if (this._isVertical) {
                track = __$track + "down";
                reverseTrack = __$track + "up";
            }
            else {
                track = __$track + "right";
                reverseTrack = __$track + "left";
            }
            this.addEventListener(lowerKnob, __$touchstart, touchstart, false);
            this.addEventListener(upperKnob, __$touchstart, touchstart, false);
            this.addEventListener(lowerKnob, track, trackLower, false);
            this.addEventListener(lowerKnob, reverseTrack, trackLower, false);
            this.addEventListener(upperKnob, track, trackUpper, false);
            this.addEventListener(upperKnob, reverseTrack, trackUpper, false);
            this.addEventListener(lowerKnob, __$touchend, touchEnd, false);
            this.addEventListener(upperKnob, __$touchend, touchEnd, false);
            this.addEventListener(lowerKnob, __$trackend, touchEnd, false);
            this.addEventListener(upperKnob, __$trackend, touchEnd, false);
            this.addEventListener(this._window, 'resize', function () {
                if (!_this.utils.isNull(_this._rangeVisible)) {
                    return;
                }
                _this._setPositionAndLength();
                _this._setLowerKnobPosition();
                _this._setUpperKnobPosition();
            }, false);
        };
        /**
         * Log the first touch.
         * @param {plat.ui.IGestureEvent} ev The touch event object.
         */
        Range.prototype._touchStart = function (ev) {
            var touchState = this._touchState;
            if (touchState === 1 || touchState === 2 || touchState === 3) {
                return;
            }
            this._touchState = 1;
            var target = ev.currentTarget, lastTouch = this._lastTouch;
            if (this.utils.isNull(lastTouch)) {
                this.dom.addClass(target, __Plat + "top");
            }
            else if (lastTouch.target !== target) {
                var dom = this.dom;
                dom.addClass(target, __Plat + "top");
                dom.removeClass(lastTouch.target, __Plat + "top");
            }
            this._lastTouch = {
                x: ev.clientX,
                y: ev.clientY,
                value: target === this._lowerKnob ? this.lower : this.upper,
                target: target
            };
        };
        /**
         * Set the new slider element offset.
         * @param {plat.ui.IGestureEvent} ev The $trackend event object.
         */
        Range.prototype._touchEnd = function (ev) {
            var _this = this;
            var touchState = this._touchState;
            if (touchState === 0 || touchState === 4) {
                this._touchState = 0;
                return;
            }
            this._touchState = 4;
            var lastTouch = this._lastTouch, target = ev.currentTarget;
            if (this.utils.isNull(lastTouch) || (lastTouch.target !== target)) {
                return;
            }
            this.utils.requestAnimationFrame(function () {
                _this._touchState = 0;
                var isLower = target === _this._lowerKnob, newOffset = _this._calculateOffset(ev, isLower);
                if (isLower) {
                    if (lastTouch.value !== _this.lower) {
                        _this._trigger('change');
                    }
                }
                else if (lastTouch.value !== _this.upper) {
                    _this._trigger('change');
                }
                _this._setOffset(newOffset, isLower);
            });
        };
        /**
         * Sets the designated knob element's offset to the given value.
         * @param {number} offset The new offset.
         * @param {boolean} isLower Whether we're setting the lower or upper knob.
         */
        Range.prototype._setOffset = function (offset, isLower) {
            var maxOffset = this._maxOffset;
            if (offset < 0) {
                return isLower ? (this._lowerKnobOffset = 0) :
                    (this._upperKnobOffset = 0);
            }
            else if (offset > maxOffset) {
                return isLower ? (this._lowerKnobOffset = maxOffset) :
                    (this._upperKnobOffset = maxOffset);
            }
            return isLower ? (this._lowerKnobOffset = offset) :
                (this._upperKnobOffset = offset);
        };
        /**
         * Track the lower knob movement.
         * @param {plat.ui.IGestureEvent} ev The $track event object.
         */
        Range.prototype._trackLower = function (ev) {
            var touchState = this._touchState;
            if (touchState !== 2) {
                if (touchState === 1) {
                    this._touchState = 2;
                }
                else if (touchState === 0 || touchState === 3) {
                    return;
                }
            }
            var maxOffset = this._maxOffset, position = this._calculateOffset(ev, true), value;
            if (position <= 0) {
                value = this.min;
                if (value - this.lower >= 0) {
                    value = null;
                }
                position = 0;
            }
            else if (position >= maxOffset) {
                value = this.max;
                if (value - this.lower <= 0) {
                    value = null;
                }
                position = maxOffset;
            }
            else {
                value = this._calculateValue(position);
                if (value - this.lower === 0) {
                    value = null;
                }
            }
            if (position > this._upperKnobOffset) {
                this._positionTogether(position, value);
                this._setOffset(position, false);
                return;
            }
            this._positionLower(position, value);
        };
        /**
         * Track the upper knob movement.
         * @param {plat.ui.IGestureEvent} ev The $track event object.
         */
        Range.prototype._trackUpper = function (ev) {
            var touchState = this._touchState;
            if (touchState !== 3) {
                if (touchState === 1) {
                    this._touchState = 3;
                }
                else if (touchState === 0 || touchState === 2) {
                    return;
                }
            }
            var maxOffset = this._maxOffset, position = this._calculateOffset(ev, false), value;
            if (position <= 0) {
                value = this.min;
                if (value - this.upper >= 0) {
                    value = null;
                }
                position = 0;
            }
            else if (position >= maxOffset) {
                value = this.max;
                if (value - this.upper <= 0) {
                    value = null;
                }
                position = maxOffset;
            }
            else {
                value = this._calculateValue(position);
                if (value - this.upper === 0) {
                    value = null;
                }
            }
            if (position < this._lowerKnobOffset) {
                this._positionTogether(position, value);
                this._setOffset(position, true);
                return;
            }
            this._positionUpper(position, value);
        };
        /**
         * Positions the slider element and adjusts it's length to account
         * for lower knob movement.
         * @param {number} position The new position of the lower knob.
         * @param {number} value? The new value to set if specified.
         */
        Range.prototype._positionLower = function (position, value) {
            var _this = this;
            this.utils.requestAnimationFrame(function () {
                var style = _this._slider.style;
                style[_this._positionProperty] = position + "px";
                style[_this._lengthProperty] = (_this._upperKnobOffset - position) + "px";
                if (value === null) {
                    return;
                }
                _this._setLowerValue(value, false, true, true);
            });
        };
        /**
         * Positions the slider element and adjusts it's length to account
         * for upper knob movement.
         * @param {number} position The new position of the upper knob.
         * @param {number} value? The new value to set if specified.
         */
        Range.prototype._positionUpper = function (position, value) {
            var _this = this;
            this.utils.requestAnimationFrame(function () {
                _this._slider.style[_this._lengthProperty] = (position - _this._lowerKnobOffset) + "px";
                if (value === null) {
                    return;
                }
                _this._setUpperValue(value, false, true, true);
            });
        };
        /**
         * Positions the slider element and adjusts it's length to account
         * for synchronized knob movement.
         * @param {number} position The new position of the knobs.
         * @param {number} value? The new value to set if specified.
         */
        Range.prototype._positionTogether = function (position, value) {
            var _this = this;
            this.utils.requestAnimationFrame(function () {
                var style = _this._slider.style;
                style[_this._positionProperty] = position + "px";
                style[_this._lengthProperty] = '0px';
                if (value === null) {
                    return;
                }
                _this._setLowerValue(value, false, false, false);
                _this._setUpperValue(value, false, true, true);
            });
        };
        /**
         * Calculates the current value based on knob position and slider element width.
         * @param {number} width The current width of the slider element.
         */
        Range.prototype._calculateValue = function (width) {
            var step = this._step;
            return (this.min + Math.round(width / this._increment / step) * step);
        };
        /**
         * Calculates the new offset of the slider element based on the old offset and the distance moved.
         * @param {plat.ui.IGestureEvent} ev The $track or $trackend event object.
         * @param {boolean} isLower Whether the current knob is the lower or the upper knob.
         */
        Range.prototype._calculateOffset = function (ev, isLower) {
            var currentOffset = isLower ? this._lowerKnobOffset : this._upperKnobOffset, displacement;
            if (this._isVertical) {
                displacement = this._reversed ? ev.clientY - this._lastTouch.y : this._lastTouch.y - ev.clientY;
            }
            else {
                displacement = this._reversed ? this._lastTouch.x - ev.clientX : ev.clientX - this._lastTouch.x;
            }
            return currentOffset + displacement;
        };
        /**
         * Calculates knob position based on current value.
         * @param {number} value The current value of the {link platui.Range|Range}.
         */
        Range.prototype._calculateKnobPosition = function (value) {
            return (value - this.min) * this._increment;
        };
        /**
         * Sets the lower value of the Range.
         * @param {number} newValue The new value to set.
         * @param {boolean} setKnob Whether or not we need to set the knob position.
         * @param {boolean} propertyChanged Whether or not the property was changed by the user.
         * @param {boolean} trigger Whether or not to trigger the 'input' event.
         */
        Range.prototype._setLowerValue = function (newValue, setKnob, propertyChanged, trigger) {
            var lower = this.lower;
            if (newValue === lower) {
                return;
            }
            else if (newValue >= this.max) {
                newValue = this.max;
            }
            else if (newValue <= this.min) {
                newValue = this.min;
            }
            else if (Math.abs(newValue - lower) < this._step) {
                return;
            }
            this.lower = newValue;
            if (setKnob) {
                this._setLowerKnobPosition();
            }
            if (propertyChanged) {
                this._fireChange();
            }
            if (trigger) {
                this._trigger('input');
            }
        };
        /**
         * Sets the value of the Range.
         * @param {number} newValue The new value to set.
         * @param {boolean} setKnob Whether or not we need to set the knob position.
         * @param {boolean} propertyChanged Whether or not the property was changed by the user.
         * @param {boolean} trigger Whether or not to trigger the 'input' event.
         */
        Range.prototype._setUpperValue = function (newValue, setKnob, propertyChanged, trigger) {
            var upper = this.upper;
            if (newValue === upper) {
                return;
            }
            else if (newValue >= this.max) {
                newValue = this.max;
            }
            else if (newValue <= this.min) {
                newValue = this.min;
            }
            else if (Math.abs(newValue - upper) < this._step) {
                return;
            }
            this.upper = newValue;
            if (setKnob) {
                this._setUpperKnobPosition();
            }
            if (propertyChanged) {
                this._fireChange();
            }
            if (trigger) {
                this._trigger('input');
            }
        };
        /**
         * Sets the increment for sliding the {link platui.Range|Range}.
         */
        Range.prototype._setIncrement = function () {
            return (this._increment = this._maxOffset / (this.max - this.min));
        };
        /**
         * Sets the properties to use for length and position and sets the max length of the sliding element.
         */
        Range.prototype._setPositionAndLength = function () {
            var _this = this;
            var el = this._slider.parentElement;
            if (this._isVertical) {
                this._lengthProperty = 'height';
                this._positionProperty = this._reversed ? 'top' : 'bottom';
                this._maxOffset = el.clientHeight;
            }
            else {
                this._lengthProperty = 'width';
                this._positionProperty = this._reversed ? 'right' : 'left';
                this._maxOffset = el.clientWidth;
            }
            if (!this._maxOffset) {
                this._rangeVisible = new this._Promise(function (resolve) {
                    _this._removeVisibilityListener = _this.dom.whenVisible(function () {
                        _this._rangeVisible = null;
                        _this._setPositionAndLength();
                        resolve();
                    }, el);
                });
                return;
            }
            this._setIncrement();
        };
        /**
         * Animates and sets the knob position.
         * @param {number} value? The value to use to calculate the knob position. If no value is
         * specified, the current Range's value will be used.
         */
        Range.prototype._setLowerKnobPosition = function (value) {
            var _this = this;
            this._Promise.resolve(this._rangeVisible).then(function () {
                var animationOptions = {}, upperKnobOffset = _this._upperKnobOffset, upperOffset = _this.utils.isNumber(upperKnobOffset) ?
                    upperKnobOffset :
                    _this._setOffset(_this._calculateKnobPosition(_this.upper), false), position = _this._calculateKnobPosition((value || _this.lower));
                if (position === _this._lowerKnobOffset) {
                    return;
                }
                animationOptions[_this._positionProperty] = position + "px";
                animationOptions[_this._lengthProperty] = (upperOffset - position) + "px";
                _this._animator.animate(_this._slider, __Transition, {
                    properties: animationOptions
                });
                _this._lowerKnobOffset = position;
            });
        };
        /**
         * Animates and sets the knob position.
         * @param {number} value? The value to use to calculate the knob position. If no value is
         * specified, the current Range's value will be used.
         */
        Range.prototype._setUpperKnobPosition = function (value) {
            var _this = this;
            this._Promise.resolve(this._rangeVisible).then(function () {
                var animationOptions = {}, length = _this._calculateKnobPosition((value || _this.upper));
                if (length === _this._upperKnobOffset) {
                    return;
                }
                animationOptions[_this._lengthProperty] = (length - _this._lowerKnobOffset) + "px";
                _this._animator.animate(_this._slider, __Transition, {
                    properties: animationOptions
                });
                _this._upperKnobOffset = length;
            });
        };
        /**
         * Fires an inputChanged event with the new bound value.
         */
        Range.prototype._fireChange = function () {
            var newProperty = {};
            newProperty[this._lowerIdentifier] = this.lower;
            newProperty[this._upperIdentifier] = this.upper;
            this.inputChanged(newProperty);
        };
        /**
         * Triggers an event starting from this control's element.
         * @param {string} event The event name to trigger.
         */
        Range.prototype._trigger = function (event) {
            var domEvent = plat.acquire(__DomEventInstance);
            domEvent.initialize(this.element, event);
            domEvent.trigger();
        };
        /**
         * Checks the orientation of the control and ensures it is valid.
         * Will default to "horizontal" if invalid.
         * @param {string} orientation The element to base the length off of.
         */
        Range.prototype._validateOrientation = function (orientation) {
            if (this.utils.isUndefined(orientation)) {
                return 'horizontal';
            }
            var validOrientation;
            if (orientation === 'horizontal') {
                validOrientation = orientation;
            }
            else if (orientation === 'vertical') {
                validOrientation = orientation;
                this._isVertical = true;
            }
            else {
                this._log.debug("Invalid orientation \"" + orientation + "\" for " + this.type + ". Defaulting to \"horizontal.\"");
                validOrientation = 'horizontal';
            }
            return validOrientation;
        };
        Range._inject = {
            _document: __Document,
            _window: __Window,
            _Promise: __Promise,
            _animator: __Animator
        };
        return Range;
    }(plat.ui.BindControl));
    platui.Range = Range;
    plat.register.control(__Range, Range);
    /**
     * An ITemplateControl that allows for databinding a select box and adds
     * custom styling to make it look consistent across all platforms.
     */
    var Select = (function (_super) {
        __extends(Select, _super);
        function Select() {
            _super.apply(this, arguments);
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        Select.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __Select + " " + (className || ''));
        };
        /**
         * Set the class name.
         */
        Select.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            this.setClasses();
        };
        return Select;
    }(plat.ui.controls.Select));
    platui.Select = Select;
    plat.register.control(__Select, Select);
    /**
     * An BindControl that standardizes and styles
     * an HTML input element of various types.
     */
    var Input = (function (_super) {
        __extends(Input, _super);
        function Input() {
            _super.apply(this, arguments);
            /**
             * Replaces the control's element with an HTMLInputElement.
             */
            this.replaceWith = 'input';
            /**
             * The current value.
             */
            this.value = '';
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        Input.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __Input + " " + (className || ''));
        };
        /**
         * Set the class name.
         */
        Input.prototype.initialize = function () {
            this.setClasses();
        };
        /**
         * Set all HTMLElement references and potential attribute controls.
         */
        Input.prototype.setTemplate = function () {
            this.dom.clearNode(this.element);
        };
        /**
         * Set the style and initialize the action.
         */
        Input.prototype.loaded = function () {
            var optionObj = this.options || {}, options = optionObj.value || {}, pattern = options.pattern, validation = options.validation, isString = this.utils.isString;
            this._type = this.attributes['type'] || options.type || 'text';
            if (isString(pattern) && pattern !== '') {
                if (pattern[0] === '/' && pattern[pattern.length - 1] === '/') {
                    pattern = pattern.slice(1, -1);
                }
                this._pattern = new RegExp(pattern);
            }
            if (isString(validation) && validation !== '') {
                if (validation[0] === '/' && validation[validation.length - 1] === '/') {
                    validation = validation.slice(1, -1);
                }
                this._validation = new RegExp(validation);
            }
            this._initializeType();
        };
        /**
         * A function to validate the user's input. For action="email" it returns
         * true if the email can be a valid email address. For all other
         * actions it returns true if the input is not empty.
         */
        Input.prototype.validate = function () {
            return this._validation.test(this.element.value);
        };
        /**
         * Clears the user's input.
         */
        Input.prototype.clear = function () {
            var element = this.element, value = element.value;
            if (value === '') {
                return;
            }
            element.value = this.value = '';
            this.inputChanged(this.value, value);
        };
        /**
         * Focuses the input.
         */
        Input.prototype.focus = function () {
            this.element.focus();
        };
        /**
         * Blurs the input.
         */
        Input.prototype.blur = function () {
            this.element.blur();
        };
        /**
         * A function that allows this control to observe both the bound property itself as well as
         * potential child properties if being bound to an object.
         * @param {plat.observable.IImplementTwoWayBinding} binder The control that facilitates the
         * databinding.
         */
        Input.prototype.observeProperties = function (binder) {
            binder.observeProperty(this._setBoundProperty, null, true);
        };
        /**
         * The function called when the bindable text is set externally.
         * @param {string} newValue The new value of the bindable text.
         * @param {string} oldValue The old value of the bindable text.
         * @param {void} identifier The child identifier of the property being observed.
         * @param {boolean} firstTime? Whether or not this is the first call to bind the property.
         */
        Input.prototype._setBoundProperty = function (newValue, oldValue, identifier, firstTime) {
            var value = this.element.value;
            if (this.utils.isNull(newValue)) {
                newValue = '';
                if (firstTime === true) {
                    if (this.utils.isNull(value)) {
                        this._onInputChanged(newValue);
                    }
                    return;
                }
            }
            else if (newValue === value) {
                return;
            }
            this._onInputChanged(newValue);
        };
        /**
         * Initializes the type.
         */
        Input.prototype._initializeType = function () {
            var inputType = this._type;
            switch (inputType) {
                case 'text':
                    this._pattern = this._pattern || /[\S\s]*/;
                    this._validation = this._validation || this._pattern;
                    break;
                case 'email':
                    this._pattern = this._pattern || /[\S\s]*/;
                    this._validation = this._validation || this._regex.validateEmail;
                    break;
                case 'password':
                    this._pattern = this._pattern || /[\S\s]*/;
                    this._validation = this._validation || this._pattern;
                    break;
                case 'telephone':
                    inputType = 'tel';
                case 'tel':
                    this._pattern = this._pattern || this._regex.validateTelephone;
                    this._validation = this._validation || this._pattern;
                    break;
                case 'number':
                    this._pattern = this._pattern || /^[0-9\.,]*$/;
                    this._validation = this._validation || this._pattern;
                    inputType = 'tel';
                    break;
                case 'hidden':
                    this.element.setAttribute(__Hide, '');
                    return;
                case 'radio':
                    this._log.debug(inputType + " is not supported by " + this.type + ". Please use a " + __Radio + " instead.");
                    return;
                case 'checkbox':
                    this._log.debug(inputType + " is not supported by " + this.type + ". Please use a " + __Checkbox + " instead.");
                    return;
                case 'range':
                    this._log.debug(inputType + " is not supported by " + this.type + ". Please use a " + __Slider + " instead.");
                    return;
                case 'file':
                    this._log.debug(inputType + " is not supported by " + this.type + ". Please use a " + __File + " instead.");
                    return;
                default:
                    this._log.debug(inputType + " is not yet fully supported by " + this.type + ". Defaulting to type=\"text\".");
                    inputType = 'text';
                    this._pattern = this._pattern || /[\S\s]*/;
                    this._validation = this._validation || this._pattern;
                    break;
            }
            this._addTextEventListener();
        };
        /**
         * Adds a text event listener to the input element.
         */
        Input.prototype._addTextEventListener = function () {
            var _this = this;
            var input = this.element, compat = this._compat, utils = this.utils, composing = false, timeout, eventListener = function () {
                if (composing) {
                    return;
                }
                _this._onInput();
            }, postponedEventListener = function () {
                if (utils.isFunction(timeout)) {
                    return;
                }
                timeout = utils.postpone(function () {
                    eventListener();
                    timeout = null;
                });
            };
            if (utils.isUndefined(compat.ANDROID)) {
                this.addEventListener(input, 'compositionstart', function () { return (composing = true); }, false);
                this.addEventListener(input, 'compositionend', function () {
                    composing = false;
                    eventListener();
                }, false);
            }
            if (compat.hasEvent('input')) {
                this.addEventListener(input, 'input', eventListener, false);
            }
            else {
                this.addEventListener(input, 'keydown', function (ev) {
                    var key = ev.keyCode;
                    if (key === 91 ||
                        key === 92 ||
                        (key > 15 && key < 28) ||
                        (key > 32 && key < 41)) {
                        return;
                    }
                    var pattern = _this._pattern, char = ev.char;
                    if (!(pattern.test(char) && pattern.test(input.value + char))) {
                        ev.preventDefault();
                        return;
                    }
                    postponedEventListener();
                }, false);
                this.addEventListener(input, 'cut', postponedEventListener, false);
                this.addEventListener(input, 'paste', postponedEventListener, false);
            }
            this.addEventListener(input, 'change', eventListener, false);
        };
        /**
         * The event handler upon user text input.
         */
        Input.prototype._onInput = function () {
            var element = this.element, value = element.value, strippedValue = this._stripInput(element.value);
            if (value !== strippedValue) {
                value = element.value = strippedValue;
            }
            if (value === this.value) {
                return;
            }
            this.value = element.value;
            this.inputChanged(this.value);
        };
        /**
         * The event handler upon bound text being changed.
         * @param {string} newValue The new value of the bound text.
         */
        Input.prototype._onInputChanged = function (newValue) {
            var element = this.element;
            newValue = this._stripInput(newValue);
            element.value = newValue;
            this.value = element.value;
        };
        /**
         * Parses the input and strips it of characters that don't fit its pattern.
         * @param {string} value The current value to parse.
         */
        Input.prototype._stripInput = function (value) {
            var newValue = '', revert = newValue, char, pattern = this._pattern, length = value.length;
            for (var i = 0; i < length; ++i) {
                char = value[i];
                if (pattern.test(char)) {
                    newValue += char;
                    if (pattern.test(newValue)) {
                        revert = newValue;
                    }
                    else {
                        newValue = revert;
                    }
                }
            }
            return newValue;
        };
        Input._inject = {
            _compat: __Compat,
            _regex: __Regex
        };
        return Input;
    }(plat.ui.BindControl));
    platui.Input = Input;
    plat.register.control(__Input, Input);
    /**
     * An BindControl that standardizes and styles
     * an HTML input[type="file"] element.
     */
    var File = (function (_super) {
        __extends(File, _super);
        function File() {
            _super.apply(this, arguments);
            /**
             * The HTML template represented as a string.
             */
            this.templateString = '<div class="plat-file-container">\n' +
                '    <input type="file" class="plat-file-hidden" />\n' +
                '    <input type="text" class="plat-file-input" plat-keydown="_onKeyDown" />\n' +
                '    <button class="plat-file-button" plat-tap="_selectFiles"></button>\n' +
                '</div>\n';
            /**
             * A function for removing the 'change' event listener.
             */
            this._removeListener = noop;
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        File.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __File + " " + (className || ''));
        };
        /**
         * Set the class name.
         */
        File.prototype.initialize = function () {
            this.setClasses();
        };
        /**
         * Set all HTMLElement references and potential attribute controls.
         */
        File.prototype.setTemplate = function () {
            var element = this.element, hiddenInput = this._hiddenInput = element.firstElementChild.firstElementChild, visibleInput = this._visibleInput = hiddenInput.nextElementSibling, buttonInput = visibleInput.nextElementSibling, attributes = this.attributes, keys = Object.keys(attributes), length = keys.length, controlInjectors = plat.dependency.injectors.control, attrRegex = /plat-(?:control|hide|context)|class|style/, hasMultiple = false, utils = this.utils, isNull = utils.isNull, delimit = utils.delimit, isString = utils.isString, key, name, value;
            for (var i = 0; i < length; ++i) {
                key = keys[i];
                name = delimit(key, '-');
                value = attributes[key];
                if (!isString(value) || attrRegex.test(name) || !isNull(controlInjectors[name])) {
                    if (name === __Disabled) {
                        hiddenInput.setAttribute(name, value);
                        visibleInput.setAttribute(name, value);
                        buttonInput.setAttribute(name, value);
                    }
                    continue;
                }
                else if (name === 'id') {
                    element.removeAttribute(name);
                    hiddenInput.setAttribute(name, value);
                }
                else if (name === 'multiple') {
                    hasMultiple = true;
                    hiddenInput.setAttribute(name, value);
                }
                else if (name === 'disabled') {
                    hiddenInput.setAttribute(name, value);
                    visibleInput.setAttribute(name, value);
                    buttonInput.setAttribute(name, value);
                }
                else {
                    hiddenInput.setAttribute(name, value);
                }
            }
            if (isNull(this.innerTemplate)) {
                buttonInput.textContent = hasMultiple ? 'Select files' : 'Select a file';
                return;
            }
            var buttonText = this.innerTemplate.textContent.replace(/\r|\n/g, '');
            if (utils.isEmpty(buttonText)) {
                buttonInput.textContent = hasMultiple ? 'Select files' : 'Select a file';
                return;
            }
            buttonInput.textContent = buttonText;
        };
        /**
         * Set the style and initialize the action.
         */
        File.prototype.loaded = function () {
            var hiddenInput = this._hiddenInput = this._hiddenInput || this.element.firstElementChild.firstElementChild;
            this._visibleInput = this._visibleInput || hiddenInput.nextElementSibling;
            this._addChangeListener();
        };
        /**
         * A function to validate the user's input. Returns true if the input is not empty.
         */
        File.prototype.validate = function () {
            return !this.utils.isEmpty(this._hiddenInput.value);
        };
        /**
         * Clears the user's input.
         */
        File.prototype.clear = function () {
            var hiddenInput = this._hiddenInput;
            if (this.utils.isEmpty(hiddenInput.value)) {
                return;
            }
            hiddenInput.value = null;
            var clone = this._hiddenInput = hiddenInput.cloneNode(true);
            this.element.firstElementChild.replaceChild(clone, hiddenInput);
            this._addChangeListener();
            this._visibleInput.value = '';
            this.inputChanged(null);
            this._trigger('change');
        };
        /**
         * Acts as a programmatic click for file selection.
         */
        File.prototype.click = function () {
            this._selectFiles();
        };
        /**
         * Returns the current value of File control.
         */
        File.prototype.value = function () {
            var hiddenInput = this._hiddenInput, files = hiddenInput.files;
            if (this.utils.isNull(files)) {
                return;
            }
            else if (!hiddenInput.multiple) {
                return files[0];
            }
            return Array.prototype.slice.call(files);
        };
        /**
         * Disables the control.
         */
        File.prototype.disable = function () {
            var disabled = 'disabled', visibleInput = this._visibleInput;
            this._hiddenInput.setAttribute(disabled, disabled);
            visibleInput.setAttribute(disabled, disabled);
            visibleInput.nextElementSibling.setAttribute(disabled, disabled);
            this.element.setAttribute(disabled, disabled);
        };
        /**
         * Enables the control.
         */
        File.prototype.enable = function () {
            var disabled = 'disabled', visibleInput = this._visibleInput;
            this._hiddenInput.removeAttribute(disabled);
            visibleInput.removeAttribute(disabled);
            visibleInput.nextElementSibling.removeAttribute(disabled);
            this.element.removeAttribute(disabled);
        };
        /**
         * A function that allows this control to observe both the bound property itself as well as
         * potential child properties if being bound to an object.
         * @param {plat.observable.IImplementTwoWayBinding} binder The control that facilitates the
         * databinding.
         */
        File.prototype.observeProperties = function (binder) {
            binder.observeProperty(this._setBoundProperty);
        };
        /**
         * The function called when the bindable text is set externally.
         * @param {any} newValue The new value of the bindable file(s).
         * @param {any} oldValue The old value of the bindable file(s).
         * @param {void} identifier The child identifier of the property being observed.
         * @param {boolean} firstTime? Whether or not this is the first call to bind the property.
         */
        File.prototype._setBoundProperty = function (newValue, oldValue, identifier, firstTime) {
            var utils = this.utils;
            if (!utils.isFile(newValue)) {
                this.clear();
                return;
            }
            var hiddenInput = this._hiddenInput, files = hiddenInput.files;
            if (utils.isNull(files)) {
                return;
            }
            if (!hiddenInput.multiple) {
                if (newValue !== files[0]) {
                    this.inputChanged(files[0]);
                    this._trigger('change');
                }
                return;
            }
            this.inputChanged(Array.prototype.slice.call(files));
            this._trigger('change');
        };
        /**
         * Adds the 'change' event listener to the hidden input[type=file].
         */
        File.prototype._addChangeListener = function () {
            this._removeListener();
            this._removeListener = this.addEventListener(this._hiddenInput, 'change', this._filesSelected, false);
        };
        /**
         * An event listener to handle a "keydown" event on the visible input.
         * @param {KeyboardEvent} ev The "keydown" event.
         */
        File.prototype._onKeyDown = function (ev) {
            var key = ev.keyCode, keyCodes = plat.controls.KeyCodes;
            if (key === keyCodes.tab) {
                return true;
            }
            else if (key === keyCodes.backspace || key === keyCodes.delete) {
                this.clear();
            }
            ev.preventDefault();
            return false;
        };
        /**
         * Kicks off the file selection process.
         */
        File.prototype._selectFiles = function () {
            this._hiddenInput.click();
        };
        /**
         * An event indicating that files have been selected.
         */
        File.prototype._filesSelected = function () {
            var hiddenInput = this._hiddenInput, visibleInput = this._visibleInput, files = hiddenInput.files;
            if (this.utils.isEmpty(files)) {
                this.clear();
                return;
            }
            else if (!hiddenInput.multiple) {
                var file = files[0];
                visibleInput.value = file.name;
                this.inputChanged(file);
            }
            else {
                var fileNames = [], length_1 = files.length;
                for (var i = 0; i < length_1; ++i) {
                    fileNames.push(files[i].name);
                }
                visibleInput.value = fileNames.join(', ');
                this.inputChanged(Array.prototype.slice.call(files));
            }
            this._trigger('change');
        };
        /**
         * Triggers an event starting from this control's element.
         * @param {string} event The event name to trigger.
         */
        File.prototype._trigger = function (event) {
            var domEvent = plat.acquire(__DomEventInstance);
            domEvent.initialize(this.element, event);
            domEvent.trigger();
        };
        File._inject = {
            _compat: __Compat
        };
        return File;
    }(plat.ui.BindControl));
    platui.File = File;
    plat.register.control(__File, File);
    /**
     * An extension of the ForEach that acts as a HTML template carousel
     * and can bind the selected index to a value.
     */
    var Carousel = (function (_super) {
        __extends(Carousel, _super);
        function Carousel() {
            _super.apply(this, arguments);
            /**
             * The HTML template represented as a string.
             */
            this.templateString = '<div class="plat-carousel-viewport">\n' +
                '    <div class="plat-carousel-container"></div>\n' +
                '</div>\n';
            /**
             * The set of functions added externally that listens
             * for property changes.
             */
            this._listeners = [];
            /**
             * Whether the control is vertical or horizontal.
             */
            this._isVertical = false;
            /**
             * Whether or not the user has swiped.
             */
            this._hasSwiped = false;
            /**
             * Whether or not the user is currently touching the screen.
             */
            this._inTouch = false;
            /**
             * Whether or not the user is currently touching the screen and has moved.
             */
            this._hasMoved = false;
            /**
             * The last touch start recorded.
             */
            this._lastTouch = { x: 0, y: 0 };
            /**
             * Whether or not the control has been loaded based on its context being an Array.
             */
            this._loaded = false;
            /**
             * The current index seen in the Carousel.
             */
            this._index = -1;
            /**
             * The previous index of the Carousel in relation to the item nodes.
             */
            this._previousIndex = -1;
            /**
             * The next index of the Carousel in relation to the item nodes.
             */
            this._nextIndex = -1;
            /**
             * The current offset of the translated Carousel's sliding element.
             */
            this._currentOffset = 0;
            /**
             * The function used to clear the auto scroll interval.
             */
            this._removeInterval = noop;
            /**
             * The function used to clear the suspended auto scroll interval.
             */
            this._removeSuspend = noop;
            /**
             * Whether or not automatic scrolling is enabled.
             */
            this._isAuto = false;
            /**
             * Whether or not automatic scrolling is currently paused.
             */
            this._isPaused = false;
            /**
             * Whether or not the control is responsible for pausing itself.
             */
            this._selfPause = false;
            /**
             * An Array of all the current nodes in the control.
             */
            this._itemNodes = [];
            /**
             * A collection of remove listeners to stop listening for events.
             */
            this._removeListeners = [];
            /**
             * Whether or not the start outer item node has been initialized.
             */
            this._outerStart = false;
            /**
             * Whether or not the end outer item node has been initialized.
             */
            this._outerEnd = false;
            /**
             * An interval constant used to regulate the speed of the auto scroll
             * when the goToIndex function is called and is not direct.
             */
            this._goToIntervalConstant = 125;
        }
        Object.defineProperty(Carousel.prototype, "index", {
            /**
             * The current index of the Carousel.
             */
            get: function () {
                return this._index;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        Carousel.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __Carousel + " " + (className || ''));
        };
        /**
         * Checks if the control has been initialized, otherwise it does so.
         * @param {Array<any>} newValue The new array context.
         * @param {Array<any>} oldValue The old array context.
         */
        Carousel.prototype.contextChanged = function (newValue, oldValue) {
            var utils = this.utils;
            if (utils.isFunction(this._onLoad)) {
                if (utils.isArray(newValue)) {
                    this._setListener();
                }
                else {
                    this._log.debug(this.type + " context set to something other than an Array.");
                    newValue = [];
                }
                this._executeEvent([{
                        object: newValue,
                        type: 'splice'
                    }]);
                this._initializeIndex(0);
                return;
            }
            this.loaded();
        };
        /**
         * Set the class name.
         */
        Carousel.prototype.initialize = function () {
            this.setClasses();
        };
        /**
         * Inserts the innerHTML of this control into a child ForEach control.
         */
        Carousel.prototype.setTemplate = function () {
            var itemContainer = this._document.createElement('div');
            itemContainer.className = __Carousel + "-item";
            itemContainer.appendChild(this.innerTemplate);
            this.bindableTemplates.add('item', itemContainer);
        };
        /**
         * Checks context and warns if not an Array, then initializes.
         */
        Carousel.prototype.loaded = function () {
            var _this = this;
            var utils = this.utils, context = this.context;
            if (!utils.isArray(context)) {
                this._log.warn("The context of a " + this.type + " must be an Array.");
                return;
            }
            // since we're extending the ForEach, we must set this animate to false as it refers to item manipulation. 
            this._animate = false;
            var optionObj = this.options || {}, options = optionObj.value || {}, index = options.index, isNumber = utils.isNumber, orientation = this._validateOrientation(options.orientation), interval = options.interval, intervalNum = this._interval = isNumber(interval) ? Math.abs(interval) : 3000, suspend = options.suspend, dom = this.dom, element = this.element, viewport = this._viewport = element.firstElementChild;
            this._container = viewport.firstElementChild;
            this._type = options.type || 'track swipe';
            this._isInfinite = options.infinite === true;
            this._suspend = Math.abs(isNumber(suspend) ? intervalNum - suspend : intervalNum - 3000);
            dom.addClass(element, __Plat + orientation);
            this._onLoad = function () {
                var setIndex = _this._index;
                index = isNumber(index) && index >= 0 ? index < context.length ? index : (context.length - 1) : null;
                _this._index = 0;
                dom.whenVisible(function () {
                    _this._initializeIndex(index === null ? setIndex : index);
                    _this._addEventListeners();
                    _this._loaded = true;
                }, element);
            };
            this._init();
        };
        /**
         * Advances the position of the Carousel to the next state.
         */
        Carousel.prototype.goToNext = function () {
            return this._goToNext(false);
        };
        /**
         * Changes the position of the Carousel to the previous state.
         */
        Carousel.prototype.goToPrevious = function () {
            return this._goToPrevious(false);
        };
        /**
         * Changes the position of the Carousel to the state
         * specified by the input index.
         * @param {number} index The new index of the Carousel.
         * @param {boolean} direct? If true, will go straight to the specified index without transitioning.
         */
        Carousel.prototype.goToIndex = function (index, direct) {
            return this._goToIndex(index, false, direct);
        };
        /**
         * Stops auto scrolling if auto scrolling is enabled.
         */
        Carousel.prototype.pause = function () {
            this._selfPause = false;
            if (!this._isAuto || this._isPaused) {
                return;
            }
            this._isPaused = true;
            this._removeSuspend();
            this._removeSuspend = noop;
            this._removeInterval();
            this._removeInterval = noop;
        };
        /**
         * Resumes auto scrolling if auto scrolling is enabled.
         */
        Carousel.prototype.resume = function () {
            if (!(this._isAuto && this._isPaused)) {
                return;
            }
            this._isPaused = this._selfPause = false;
            this._initiateInterval();
        };
        /**
         * Clean up the auto scroll interval if necessary.
         */
        Carousel.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._listeners = [];
            this._removeEventListeners();
        };
        /**
         * Adds a listener to be called when the bindable property changes.
         * @param {plat.IPropertyChangedListener<any>} listener The function that acts as a listener.
         */
        Carousel.prototype.onInput = function (listener) {
            var listeners = this._listeners;
            listeners.push(listener);
            return function () {
                var index = listeners.indexOf(listener);
                if (index === -1) {
                    return;
                }
                listeners.splice(index, 1);
            };
        };
        /**
         * A function that signifies when this control's bindable property has changed.
         * @param {any} newValue The new value of the property after the change.
         * @param {any} oldValue? The old value of the property prior to the change.
         */
        Carousel.prototype.inputChanged = function (newValue, oldValue) {
            if (newValue === oldValue) {
                return;
            }
            var listeners = this._listeners, length = listeners.length;
            for (var i = 0; i < length; ++i) {
                listeners[i](newValue, oldValue);
            }
        };
        /**
         * A function that allows this control to observe both the bound property itself as well as
         * potential child properties if being bound to an object.
         * @param {plat.observable.IImplementTwoWayBinding} binder The control that facilitates the
         * databinding.
         */
        Carousel.prototype.observeProperties = function (binder) {
            binder.observeProperty(this._setBoundProperty);
        };
        /**
         * The function called when the bindable index is set externally.
         * @param {number} index The new value of the bindable index.
         * @param {number} oldValue The old value of the bindable index.
         * @param {void} identifier The child identifier of the property being observed.
         * @param {boolean} firstTime? Whether or not this is the first call to bind the property.
         */
        Carousel.prototype._setBoundProperty = function (index, oldValue, identifier, firstTime) {
            var utils = this.utils;
            if (utils.isNull(index)) {
                if (firstTime === true) {
                    this._index = 0;
                    this.inputChanged(0, index);
                    return;
                }
            }
            else if (!utils.isNumber(index)) {
                index = Number(index);
                if (!utils.isNumber(index)) {
                    this._log.warn(this.type + " has its index bound to a property that cannot be interpreted as a Number.");
                    return;
                }
            }
            else if (index < 0) {
                this._index = 0;
                this.inputChanged(0, index);
                this._initializeIndex(0);
                return;
            }
            if (!this._loaded) {
                this._index = index;
                return;
            }
            this._goToIndex(index, true, firstTime === true);
        };
        /**
         * Resets the position of the Carousel to its current state.
         */
        Carousel.prototype._reset = function () {
            var animationOptions = {};
            animationOptions[this._transform] = this._calculateStaticTranslation(0);
            this._initiateAnimation({ properties: animationOptions });
        };
        /**
         * Verifies that the current length of the context aligns with the position of the Carousel.
         */
        Carousel.prototype._verifyLength = function () {
            var context = this.context, index = this._index;
            if (!this.utils.isArray(context) || context.length === 0) {
                if (!this.utils.isUndefined(index)) {
                    this.inputChanged((this._index = undefined), index);
                }
                this._container.style[this._transform] = this._calculateStaticTranslation(-this._currentOffset);
                this._removeEventListeners();
                this._checkArrows();
                return;
            }
            var maxIndex = context.length - 1;
            if (index > maxIndex) {
                this.goToIndex(maxIndex);
                return;
            }
            this._checkArrows();
        };
        /**
         * Sets the previous and next indices in relation to item nodes according to the current index.
         */
        Carousel.prototype._setIndexWindow = function () {
            var index = this._index, lastIndex = this._itemNodes.length - 1;
            if (lastIndex < 0) {
                this._previousIndex = this._nextIndex = lastIndex;
            }
            else if (index >= lastIndex) {
                if (index > lastIndex) {
                    index = this._index = lastIndex;
                }
                this._previousIndex = index - 1;
                this._nextIndex = this._isInfinite ? 0 : -1;
            }
            else if (index <= 0) {
                if (index < 0) {
                    index = this._index = 0;
                }
                this._previousIndex = this._isInfinite ? lastIndex : -1;
                this._nextIndex = index + 1;
            }
            else {
                this._previousIndex = index - 1;
                this._nextIndex = index + 1;
            }
        };
        /**
         * Advances the position of the Carousel to the next state.
         * @param {boolean} inputChanged Whether or not this was the result of a bound input change.
         */
        Carousel.prototype._goToNext = function (inputChanged) {
            var _this = this;
            return this._Promise.all(this._addQueue).then(function () {
                var index = _this._index, reset = false;
                if ((index >= _this._itemNodes.length - 1) && !(reset = _this._isInfinite)) {
                    if (_this._isAuto && !_this._isPaused) {
                        _this.pause();
                        _this._selfPause = true;
                    }
                    return _this._Promise.resolve(false);
                }
                var length = _this._getLength();
                if (!length) {
                    return _this.goToIndex(_this._nextIndex, true);
                }
                return _this._cancelCurrentAnimations().then(function () {
                    if (!_this._outerEnd) {
                        _this._initializeOuterNodes();
                    }
                    var animationOptions = {};
                    animationOptions[_this._transform] = _this._calculateStaticTranslation(-length);
                    var animation = _this._initiateAnimation({ properties: animationOptions }), nextIndex;
                    if (reset) {
                        _this._index = nextIndex = 0;
                    }
                    else {
                        nextIndex = ++_this._index;
                    }
                    if (!inputChanged) {
                        _this.inputChanged(_this._index, index);
                    }
                    return animation.then(function () {
                        _this._handleNext(nextIndex, length);
                        _this._checkArrows();
                        return true;
                    });
                });
            });
        };
        /**
         * Changes the position of the Carousel to the previous state.
         * @param {boolean} inputChanged Whether or not this was the result of a bound input change.
         */
        Carousel.prototype._goToPrevious = function (inputChanged) {
            var _this = this;
            return this._Promise.all(this._addQueue).then(function () {
                var index = _this._index, reset = false;
                if (index <= 0 && !(reset = _this._isInfinite)) {
                    return _this._Promise.resolve(false);
                }
                else if (_this._selfPause) {
                    _this.resume();
                }
                var length = _this._getLength();
                if (!length) {
                    return _this.goToIndex(_this._previousIndex, true);
                }
                return _this._cancelCurrentAnimations().then(function () {
                    if (!_this._outerStart) {
                        _this._initializeOuterNodes();
                    }
                    var animationOptions = {};
                    animationOptions[_this._transform] = _this._calculateStaticTranslation(length);
                    var animation = _this._initiateAnimation({ properties: animationOptions }), previousIndex;
                    if (reset) {
                        _this._index = previousIndex = _this._itemNodes.length - 1;
                    }
                    else {
                        previousIndex = --_this._index;
                    }
                    if (!inputChanged) {
                        _this.inputChanged(_this._index, index);
                    }
                    return animation.then(function () {
                        _this._handlePrevious(previousIndex, -length);
                        _this._checkArrows();
                        return true;
                    });
                });
            });
        };
        /**
         * Changes the position of the Carousel to the state
         * specified by the input index.
         * @param {number} index The new index of the Carousel.
         * @param {boolean} inputChanged Whether or not this was the result of a bound input change.
         * @param {boolean} direct? If true, will go straight to the specified index without transitioning.
         */
        Carousel.prototype._goToIndex = function (index, inputChanged, direct) {
            var _this = this;
            return this._Promise.all(this._addQueue).then(function () {
                var oldIndex = _this._index;
                if (_this.utils.isUndefined(oldIndex)) {
                    _this._initializeIndex(0);
                    _this.inputChanged(_this._index, index);
                    if (!_this._isInfinite) {
                        if (index < _this.context.length - 1) {
                            if (_this._selfPause) {
                                _this.resume();
                            }
                        }
                        else if (_this._isAuto && !_this._isPaused) {
                            _this.pause();
                            _this._selfPause = true;
                        }
                    }
                    return _this._Promise.resolve(true);
                }
                else if (index === oldIndex) {
                    return _this._Promise.resolve(false);
                }
                else if (direct === true) {
                    _this._initializeIndex(index);
                    _this.inputChanged(_this._index, index);
                    if (!_this._isInfinite) {
                        if (index < _this.context.length - 1) {
                            if (_this._selfPause) {
                                _this.resume();
                            }
                        }
                        else if (_this._isAuto && !_this._isPaused) {
                            _this.pause();
                            _this._selfPause = true;
                        }
                    }
                    return _this._Promise.resolve(true);
                }
                else if (index - oldIndex > 0 && index === _this._nextIndex) {
                    return _this._goToNext(inputChanged);
                }
                else if (index === _this._previousIndex) {
                    return _this._goToPrevious(inputChanged);
                }
                return _this._handleGoToIndex(index, inputChanged);
            });
        };
        /**
         * Changes the position of the Carousel to the state
         * specified by the input index.
         * @param {number} index The new index of the Carousel.
         * @param {boolean} inputChanged Whether or not this was the result of a bound input change.
         */
        Carousel.prototype._handleGoToIndex = function (index, inputChanged) {
            var oldIndex = this._index;
            if (index === oldIndex || index < 0 || index >= this.context.length) {
                return this._Promise.resolve(false);
            }
            else if (this._selfPause) {
                this.resume();
            }
            if (!this._getLength()) {
                this._initializeIndex(index);
                return this._Promise.resolve(true);
            }
            var _Promise = this._Promise, defer = this.utils.defer, move, diff, reverseDiff;
            if (index > oldIndex) {
                move = this._goToNext;
                diff = index - oldIndex;
                if (this._isInfinite) {
                    reverseDiff = this._itemNodes.length - index + oldIndex;
                    if (reverseDiff < diff) {
                        move = this._goToPrevious;
                        diff = reverseDiff;
                    }
                }
            }
            else {
                move = this._goToPrevious;
                diff = oldIndex - index;
                if (this._isInfinite) {
                    reverseDiff = this._itemNodes.length - oldIndex + index;
                    if (reverseDiff < diff) {
                        move = this._goToNext;
                        diff = reverseDiff;
                    }
                }
            }
            move = move.bind(this);
            var promises = [], removeListeners = this._removeListeners, constant = this._goToIntervalConstant, interval = 0, mover = function (resolve) {
                var remove = defer(function () {
                    var removeIndex = removeListeners.indexOf(remove);
                    if (removeIndex !== -1) {
                        removeListeners.splice(removeIndex, 1);
                    }
                    resolve(move(inputChanged));
                }, interval += Math.round(constant / diff));
                removeListeners.push(remove);
            };
            while (--diff > 0) {
                promises.push(new _Promise(mover));
            }
            promises.push(move(inputChanged));
            return _Promise.all(promises).then(function (results) {
                var result = false;
                while (results.length > 0) {
                    result = result || results.pop();
                    if (result) {
                        break;
                    }
                }
                return result;
            });
        };
        /**
         * Handles swapping and translating nodes for a "next" operation.
         * @param {number} index The new index at the time of the animation.
         * @param {number} length The length to statically transition back to.
         */
        Carousel.prototype._handleNext = function (index, length) {
            var isInfinite = this._isInfinite, itemNodes = this._itemNodes, nodeLength = itemNodes.length, isNode = this.utils.isNode;
            if (isInfinite && (nodeLength < 3 || isNode(this._preClonedNode) || isNode(this._postClonedNode))) {
                this._initializeIndex(index);
                return;
            }
            var container = this._container;
            if (this._outerStart) {
                if (isInfinite || index > 1) {
                    this.dom.insertBefore(itemNodes[this._previousIndex], Array.prototype.slice.call(container.childNodes, 0, 3));
                    container.style[this._transform] = this._calculateStaticTranslation(length);
                    this._forceRepaint(container);
                }
            }
            else {
                this._outerStart = true;
            }
            this._setIndexWindow();
            if (!(isInfinite || index < nodeLength - 1)) {
                return;
            }
            container.insertBefore(itemNodes[this._nextIndex], null);
        };
        /**
         * Handles swapping and translating nodes for a "previous" operation.
         * @param {number} index The new index at the time of the animation.
         * @param {number} length The length to statically transition back to.
         */
        Carousel.prototype._handlePrevious = function (index, length) {
            var isInfinite = this._isInfinite, itemNodes = this._itemNodes, nodeLength = itemNodes.length, isNode = this.utils.isNode;
            if (isInfinite && (nodeLength < 3 || isNode(this._preClonedNode) || isNode(this._postClonedNode))) {
                this._initializeIndex(index);
                return;
            }
            var container = this._container;
            if (this._outerEnd) {
                if (isInfinite || index < nodeLength - 2) {
                    this.dom.insertBefore(itemNodes[this._nextIndex], Array.prototype.slice.call(container.childNodes, -3));
                }
            }
            else {
                this._outerEnd = true;
            }
            this._setIndexWindow();
            if (!(isInfinite || index > 0)) {
                return;
            }
            container.insertBefore(itemNodes[this._previousIndex], container.firstChild);
            container.style[this._transform] = this._calculateStaticTranslation(length);
            this._forceRepaint(container);
        };
        /**
         * Clears all the inner nodes of the control.
         */
        Carousel.prototype._clearInnerNodes = function () {
            this._removeClones();
            this._outerStart = this._outerEnd = false;
            var itemNodes = this._itemNodes;
            if (itemNodes.length === 0) {
                return false;
            }
            var childNodes = Array.prototype.slice.call(this._container.childNodes), insertBefore = this.dom.insertBefore;
            switch (childNodes.length) {
                case 9:
                    insertBefore(itemNodes[this._previousIndex], childNodes.splice(0, 3));
                    insertBefore(itemNodes[this._nextIndex], childNodes.splice(-3, 3));
                    insertBefore(itemNodes[this._index], childNodes);
                    break;
                case 6:
                    var next = this._nextIndex, index = this._index;
                    if (next < 0 || next === index) {
                        insertBefore(itemNodes[index], childNodes.splice(-3, 3));
                        insertBefore(itemNodes[index === 0 ? this._previousIndex + 1 : index - 1], childNodes);
                        break;
                    }
                    insertBefore(itemNodes[next], childNodes.splice(-3, 3));
                    insertBefore(itemNodes[index], childNodes);
                    break;
                case 3:
                    insertBefore(itemNodes[this._index], childNodes);
                    break;
            }
            return true;
        };
        /**
         * Initializes item nodes at the given index.
         * @param {number} index The new index at the time of the animation.
         */
        Carousel.prototype._initializeIndex = function (index) {
            var innerNodesCleared = this._clearInnerNodes();
            if (this._itemNodes.length === 0) {
                index = -1;
            }
            else if (index < 0) {
                index = 0;
            }
            this._index = index;
            this._setIndexWindow();
            if (!innerNodesCleared) {
                return false;
            }
            var container = this._container;
            container.insertBefore(this._itemNodes[index], null);
            container.style[this._transform] = this._calculateStaticTranslation(-this._currentOffset);
            this._forceRepaint(container);
            this._initializeOuterNodes();
            this._checkArrows();
            return true;
        };
        /**
         * Initializes pre and post item nodes for the current index.
         */
        Carousel.prototype._initializeOuterNodes = function () {
            var length = this._getLength();
            if (!length) {
                this._outerStart = this._outerEnd = false;
                return;
            }
            var itemNodes = this._itemNodes, container = this._container, nodeLength = itemNodes.length, nodeToInsert;
            if (nodeLength <= 1) {
                if (this._isInfinite) {
                    this._cloneForInfinite(-length);
                    return;
                }
            }
            else {
                var isNode = this.utils.isNode;
                if (!this._outerEnd) {
                    nodeToInsert = itemNodes[this._nextIndex];
                    if (isNode(nodeToInsert)) {
                        container.insertBefore(nodeToInsert, null);
                        this._outerEnd = true;
                    }
                }
                if (nodeLength > 2) {
                    if (!this._outerStart && (this._isInfinite || this._index > 0)) {
                        nodeToInsert = itemNodes[this._previousIndex];
                        if (isNode(nodeToInsert)) {
                            container.insertBefore(nodeToInsert, container.firstChild);
                            container.style[this._transform] = this._calculateStaticTranslation(-length);
                            this._forceRepaint(container);
                            this._outerStart = true;
                        }
                    }
                }
                else if (this._isInfinite) {
                    this._cloneForInfinite(-length);
                }
            }
        };
        /**
         * Animates the carousel with a set of characteristics passed in as an argument.
         * @param {plat.IObject<string>} animationOptions An object containing key-value pairs
         * of properties to animate.
         */
        Carousel.prototype._initiateAnimation = function (animationOptions) {
            return this._animationThenable =
                this._animator.animate(this._container, __Transition, animationOptions);
        };
        /**
         * Initializes the control and adds all event listeners.
         */
        Carousel.prototype._init = function () {
            var _this = this;
            var addQueue = this._addQueue, itemCount = this.context.length;
            this._setAliases();
            var addPromise = this._addItems(0, itemCount, 0).then(function () {
                var index = addQueue.indexOf(addPromise);
                if (index !== -1) {
                    addQueue.splice(index, 1);
                }
                _this._onLoad();
            }).catch(function () {
                _this._log.debug("An error occurred while processing the " + _this.type + ". Please ensure you're context is correct.");
                _this._loaded = false;
                return;
            });
            addQueue.push(addPromise);
            this._setListener();
            this._setTransform();
        };
        /**
         * Adds all event listeners on this control's element.
         */
        Carousel.prototype._addEventListeners = function () {
            var _this = this;
            var types = this._type.split(' ');
            if (types.indexOf('tap') !== -1) {
                this._initializeTap();
            }
            if (types.indexOf('swipe') !== -1) {
                this._initializeSwipe();
            }
            if (types.indexOf('track') !== -1) {
                this._initializeTrack();
            }
            if (types.indexOf('auto') !== -1) {
                this._initializeAuto();
            }
            var fired = false;
            this.addEventListener(this._window, 'resize', function () {
                if (fired) {
                    return;
                }
                fired = true;
                _this.utils.requestAnimationFrame(function () {
                    fired = false;
                    var currentLength = _this._length, length = _this._getLength();
                    if (!length || currentLength === length || (!_this._isInfinite && _this._index === 0)) {
                        return;
                    }
                    _this._container.style[_this._transform] = _this._calculateStaticTranslation(currentLength - length);
                });
            }, false);
        };
        /**
         * Removes all event listeners on this control's element.
         */
        Carousel.prototype._removeEventListeners = function () {
            var removeListeners = this._removeListeners;
            while (removeListeners.length > 0) {
                removeListeners.pop()();
            }
            this._removeInterval();
            this._removeSuspend();
            if (this._isInfinite) {
                this._removeClones();
            }
            this._onLoad = noop;
        };
        /**
         * Create the clones case where item length is less than 3.
         * @param {number} length The length to translate the offset clone.
         */
        Carousel.prototype._cloneForInfinite = function (length) {
            this._removeClones();
            var context = this.context;
            if (!this.utils.isArray(context) || context.length === 0) {
                return;
            }
            var outerStart = this._outerStart, outerEnd = this._outerEnd;
            if (outerStart && outerEnd) {
                return;
            }
            var container = this._container;
            if (!outerEnd) {
                var postClone = this._postClonedNode = container.firstElementChild.cloneNode(true);
                container.insertBefore(postClone, null);
                this._outerEnd = true;
            }
            if (!outerStart) {
                var preClone = this._preClonedNode = container.lastElementChild.cloneNode(true);
                container.insertBefore(preClone, container.firstChild);
                container.style[this._transform] = this._calculateStaticTranslation(length);
                this._forceRepaint(container);
                this._outerStart = true;
            }
        };
        /**
         * Removes the clones for infinite scrolling.
         */
        Carousel.prototype._removeClones = function () {
            var container = this._container, preClone = this._preClonedNode, postClone = this._postClonedNode, isNode = this.utils.isNode;
            if (isNode(preClone) && container.contains(preClone)) {
                container.removeChild(preClone);
            }
            if (isNode(postClone) && container.contains(postClone)) {
                container.removeChild(postClone);
            }
            this._preClonedNode = this._postClonedNode = null;
        };
        /**
         * Adds all necessary elements and event listeners to setup auto scroll.
         */
        Carousel.prototype._initializeAuto = function () {
            this._isAuto = true;
            this._initiateInterval();
        };
        /**
         * Begins auto scrolling.
         */
        Carousel.prototype._initiateInterval = function () {
            this._removeInterval = this.utils.setInterval(this.goToNext, this._interval, null, this);
        };
        /**
         * Checks for automatic scrolling and suspends if necessary.
         */
        Carousel.prototype._suspendInterval = function () {
            var _this = this;
            if (!this._isAuto || this._isPaused) {
                return;
            }
            this._removeSuspend();
            this._removeInterval();
            this._removeSuspend = this.utils.defer(function () {
                _this._initiateInterval();
                _this._removeSuspend = noop;
            }, this._suspend);
        };
        /**
         * Adds all necessary elements and event listeners to handle tap events.
         */
        Carousel.prototype._initializeTap = function () {
            var _this = this;
            if (!this.utils.isNode(this._forwardArrow)) {
                this._createArrowElements();
            }
            var removeListeners = this._removeListeners;
            removeListeners.push(this.addEventListener(this._backArrow, __$tap, function () {
                _this._suspendInterval();
                _this.goToPrevious();
            }, false));
            removeListeners.push(this.addEventListener(this._forwardArrow, __$tap, function () {
                _this._suspendInterval();
                _this.goToNext();
            }, false));
            this._checkArrows();
        };
        /**
         * Creates the arrow elements for type `tap` and places them in the DOM.
         */
        Carousel.prototype._createArrowElements = function () {
            var _document = this._document, viewport = this._viewport, backArrowContainer = this._backArrow = _document.createElement('div'), forwardArrowContainer = this._forwardArrow = _document.createElement('div'), backArrow = _document.createElement('span'), forwardArrow = _document.createElement('span');
            if (this._isVertical) {
                backArrow.className = __Plat + "icon-arrow-up";
                forwardArrow.className = __Plat + "icon-arrow-down";
            }
            else {
                backArrow.className = __Plat + "icon-arrow-left";
                forwardArrow.className = __Plat + "icon-arrow-right";
            }
            backArrowContainer.className = __Plat + "back-arrow";
            forwardArrowContainer.className = __Plat + "forward-arrow";
            backArrowContainer.appendChild(backArrow);
            forwardArrowContainer.appendChild(forwardArrow);
            viewport.appendChild(backArrowContainer);
            viewport.appendChild(forwardArrowContainer);
        };
        /**
         * Checks the validity of the visibility of the forward and back arrows.
         */
        Carousel.prototype._checkArrows = function () {
            var utils = this.utils, isNode = utils.isNode;
            if (this._isInfinite || !(isNode(this._forwardArrow) && isNode(this._backArrow))) {
                return;
            }
            var contextLength = this.context.length, index = this._index;
            if (utils.isNull(index)) {
                this._backArrow.setAttribute(__Hide, '');
                this._forwardArrow.setAttribute(__Hide, '');
                return;
            }
            if (index <= 0) {
                this._backArrow.setAttribute(__Hide, '');
            }
            else {
                this._backArrow.removeAttribute(__Hide);
            }
            if (index >= contextLength - 1) {
                this._forwardArrow.setAttribute(__Hide, '');
            }
            else {
                this._forwardArrow.removeAttribute(__Hide);
            }
        };
        /**
         * Adds all event listeners to handle swipe events.
         */
        Carousel.prototype._initializeSwipe = function () {
            var container = this._viewport, swipeFn = this._handleSwipe, swipe, reverseSwipe;
            if (this._isVertical) {
                swipe = __$swipe + "up";
                reverseSwipe = __$swipe + "down";
            }
            else {
                swipe = __$swipe + "left";
                reverseSwipe = __$swipe + "right";
            }
            var removeListeners = this._removeListeners;
            removeListeners.push(this.addEventListener(container, swipe, swipeFn, false));
            removeListeners.push(this.addEventListener(container, reverseSwipe, swipeFn, false));
        };
        /**
         * Adds all event listeners to handle tracking events.
         */
        Carousel.prototype._initializeTrack = function () {
            var viewport = this._viewport, trackFn = this._track, touchEnd = this._touchEnd, track, reverseTrack;
            if (this._isVertical) {
                track = __$track + "up";
                reverseTrack = __$track + "down";
            }
            else {
                track = __$track + "left";
                reverseTrack = __$track + "right";
            }
            var removeListeners = this._removeListeners;
            removeListeners.push(this.addEventListener(viewport, track, trackFn, false));
            removeListeners.push(this.addEventListener(viewport, reverseTrack, trackFn, false));
            removeListeners.push(this.addEventListener(viewport, __$touchstart, this._touchStart, false));
            removeListeners.push(this.addEventListener(viewport, __$trackend, touchEnd, false));
            removeListeners.push(this.addEventListener(viewport, __$touchend, touchEnd, false));
        };
        /**
         * Handles a swipe event.
         */
        Carousel.prototype._handleSwipe = function (ev) {
            var direction = ev.direction.primary, hasSwiped = false;
            switch (direction) {
                case 'left':
                    if (!this._isVertical && (this._isInfinite || this._index < this.context.length - 1)) {
                        this._suspendInterval();
                        hasSwiped = true;
                        this.goToNext();
                    }
                    break;
                case 'right':
                    if (!this._isVertical && (this._isInfinite || this._index > 0)) {
                        this._suspendInterval();
                        hasSwiped = true;
                        this.goToPrevious();
                    }
                    break;
                case 'up':
                    if (this._isVertical && (this._isInfinite || this._index < this.context.length - 1)) {
                        this._suspendInterval();
                        hasSwiped = true;
                        this.goToNext();
                    }
                    break;
                case 'down':
                    if (this._isVertical && (this._isInfinite || this._index > 0)) {
                        this._suspendInterval();
                        hasSwiped = true;
                        this.goToPrevious();
                    }
                    break;
                default:
                    return;
            }
            this._hasSwiped = hasSwiped;
        };
        /**
         * Log when the user touches the Carousel.
         * @param {plat.ui.IGestureEvent} ev The touch event.
         */
        Carousel.prototype._touchStart = function (ev) {
            if (this._inTouch) {
                return;
            }
            else if (this._isAuto) {
                this._removeInterval();
                this._removeInterval = noop;
            }
            this._inTouch = true;
            this._hasMoved = false;
            this._lastTouch = {
                x: ev.clientX,
                y: ev.clientY
            };
        };
        /**
         * The $touchend and $trackend event handler.
         * @param {plat.ui.IGestureEvent} ev The touch event.
         */
        Carousel.prototype._touchEnd = function (ev) {
            var _this = this;
            var inTouch = this._inTouch, hasMoved = this._hasMoved, hasSwiped = this._hasSwiped;
            this._inTouch = this._hasSwiped = this._hasMoved = false;
            if (!inTouch || hasSwiped) {
                return;
            }
            else if (this._isAuto && !this._isPaused) {
                this._initiateInterval();
            }
            if (!hasMoved) {
                return;
            }
            var distanceMoved = this._isVertical ? (ev.clientY - this._lastTouch.y) : (ev.clientX - this._lastTouch.x), length = this._getLength();
            if (!length) {
                this._reset();
                return;
            }
            else if (Math.abs(distanceMoved) > Math.ceil(length / 2)) {
                if (distanceMoved < 0) {
                    this.goToNext().then(function (success) {
                        if (!success) {
                            _this._reset();
                        }
                    });
                    return;
                }
                this.goToPrevious().then(function (success) {
                    if (!success) {
                        _this._reset();
                    }
                });
                return;
            }
            this._reset();
        };
        /**
         * The $track event handler. Used for tracking only horizontal or vertical tracking motions
         * depending on the defined orientation.
         * @param {plat.ui.IGestureEvent} ev The $tracking event.
         */
        Carousel.prototype._track = function (ev) {
            var _this = this;
            if (!this._inTouch) {
                return;
            }
            else if (!this._hasMoved) {
                this._cancelCurrentAnimations().then(function () {
                    if (!(_this._outerStart && _this._outerEnd)) {
                        _this._initializeOuterNodes();
                    }
                });
            }
            this._hasMoved = true;
            this.utils.requestAnimationFrame(function () {
                var translation = _this._calculateDynamicTranslation(ev);
                if (translation === null) {
                    return;
                }
                _this._container.style[_this._transform] = translation;
            });
        };
        /**
         * Calculates the translation value for setting the transform value during a static index set.
         * @param {number} interval The interval change.
         */
        Carousel.prototype._calculateStaticTranslation = function (interval) {
            return this._isVertical ? "translate3d(0," + (this._currentOffset += interval) + "px,0)" :
                "translate3d(" + (this._currentOffset += interval) + "px,0,0)";
        };
        /**
         * Calculates the translation value for setting the transform value during tracking.
         * @param {plat.ui.IGestureEvent} ev The $tracking event.
         */
        Carousel.prototype._calculateDynamicTranslation = function (ev) {
            var offset;
            if (this._isVertical) {
                offset = ev.clientY - this._lastTouch.y;
                if (Math.abs(offset) > this._getLength()) {
                    this._touchEnd(ev);
                    return null;
                }
                return "translate3d(0," + (this._currentOffset + offset) + "px,0)";
            }
            offset = ev.clientX - this._lastTouch.x;
            if (Math.abs(offset) > this._getLength()) {
                this._touchEnd(ev);
                return null;
            }
            return "translate3d(" + (this._currentOffset + offset) + "px,0,0)";
        };
        /**
         * Obtains the current browser's transform property value.
         */
        Carousel.prototype._setTransform = function () {
            var style = this._container.style, isUndefined = this.utils.isUndefined;
            var vendorPrefix = this._compat.vendorPrefix;
            if (!isUndefined(style[(vendorPrefix.lowerCase + "Transform")])) {
                this._transform = vendorPrefix.lowerCase + "Transform";
            }
            else if (!isUndefined(style[(vendorPrefix.upperCase + "Transform")])) {
                this._transform = vendorPrefix.upperCase + "Transform";
            }
            else {
                this._transform = 'transform';
            }
        };
        /**
         * Gets the interval length of the sliding container.
         */
        Carousel.prototype._getLength = function () {
            return this._length = (this._isVertical ? this._viewport.offsetHeight : this._viewport.offsetWidth);
        };
        /**
         * Checks the orientation of the control and ensures it is valid.
         * Will default to "horizontal" if invalid.
         * @param {string} orientation The element to base the length off of.
         */
        Carousel.prototype._validateOrientation = function (orientation) {
            if (this.utils.isUndefined(orientation)) {
                return 'horizontal';
            }
            var validOrientation;
            if (orientation === 'horizontal') {
                validOrientation = orientation;
            }
            else if (orientation === 'vertical') {
                validOrientation = orientation;
                this._isVertical = true;
            }
            else {
                this._log.debug("Invalid orientation \"" + orientation + "\" for " + this.type + ". Defaulting to \"horizontal.\"");
                validOrientation = 'horizontal';
            }
            return validOrientation;
        };
        /**
         * Adds an Array of items to the element without animating.
         * @param {Array<Node>} items The Array of items to add.
         */
        Carousel.prototype._appendItems = function (items) {
            this._itemNodes = this._itemNodes.concat(items);
            if (this._loaded) {
                var index = this._index;
                // if no remove listeners exist we know that we had previously removed them. 
                if (this._removeListeners.length === 0) {
                    this._addEventListeners();
                    this._initializeIndex(0);
                    this.inputChanged(0, index);
                    return;
                }
                if (index >= this._itemNodes.length - 2) {
                    this._initializeIndex(index);
                }
            }
        };
        /**
         * Removes items from the control's element.
         * @param {number} index The index to start disposing from.
         * @param {number} numberOfItems The number of items to remove.
         */
        Carousel.prototype._removeItems = function (index, numberOfItems) {
            var dispose = this._TemplateControlFactory.dispose, controls = this.controls, itemNodes = this._itemNodes, last = index + numberOfItems;
            while (last-- > index) {
                dispose(controls[last]);
                itemNodes.pop();
            }
            this._updateResource(controls.length - 1);
            this._verifyLength();
        };
        /**
         * Cancels the current animation.
         */
        Carousel.prototype._cancelCurrentAnimations = function () {
            if (this.utils.isNull(this._animationThenable)) {
                return this._Promise.resolve();
            }
            return this._animationThenable.cancel();
        };
        /**
         * Forces a repaint / reflow.
         * @param {HTMLElement} element The element to force the repaint / reflow on.
         */
        Carousel.prototype._forceRepaint = function (element) {
            var style = element.style, display = style.display, none = 'none';
            if (style.display === none) {
                element.offsetWidth;
                return;
            }
            style.display = none;
            element.offsetWidth;
            style.display = display;
        };
        Carousel._inject = {
            _document: __Document,
            _window: __Window,
            _compat: __Compat,
            _TemplateControlFactory: __TemplateControlFactory
        };
        return Carousel;
    }(plat.ui.controls.ForEach));
    platui.Carousel = Carousel;
    plat.register.control(__Carousel, Carousel);
    /**
     * An ITemplateControl for creating a complex list of items with
     * extensive functionality.
     */
    var Listview = (function (_super) {
        __extends(Listview, _super);
        /**
         * The constructor for a Listview. Creates the itemsLoaded Promise.
         */
        function Listview() {
            var _this = this;
            _super.call(this);
            /**
             * The HTML template represented as a string.
             */
            this.templateString = this.__templateString;
            /**
             * Used to hold the alias tokens for the built-in aliases. You
             * can overwrite these with the options for
             * the Listview control.
             */
            this._aliases = {
                index: __listviewAliasOptions.index,
                even: __listviewAliasOptions.even,
                odd: __listviewAliasOptions.odd,
                first: __listviewAliasOptions.first,
                last: __listviewAliasOptions.last,
                group: __listviewAliasOptions.group
            };
            /**
             * An object containing the node names of the Listview's defined templates and
             * their corresponding template node.
             */
            this._templates = {};
            /**
             * Whether the control is vertical or horizontal.
             */
            this._isVertical = true;
            /**
             * Whether or not the scroll function is ready to be handled.
             */
            this._scrollReady = true;
            /**
             * Whether or not the user is currently performing a load operation.
             */
            this._isLoading = false;
            /**
             * The current scroll position of the container.
             */
            this._scrollPosition = 0;
            /**
             * A function that removes the scroll event listener.
             */
            this._removeScroll = noop;
            /**
             * Whether or not the user is currently performing a refresh operation.
             */
            this._isRefreshing = false;
            /**
             * An enumeration value signifying the current touch state.
             */
            this._touchState = 0;
            /**
             * Whether the user is tracking in a fashion that attempts to refresh the list.
             */
            this._hasMoved = false;
            /**
             * The last touch start recorded.
             */
            this._lastTouch = { x: 0, y: 0 };
            /**
             * A regular expression for normalizing a node name by removing potential special characters.
             */
            this._nodeNormalizeRegex = /-|\.|_/g;
            /**
             * Whether or not the select is grouped.
             */
            this._isGrouped = false;
            /**
             * A set of functions to remove all visibility listeners.
             */
            this._visibilityRemoveListeners = [];
            /**
             * The private template string used to check for a template overwrite.
             */
            this.__templateString = '<div class="plat-listview-viewport">\n' +
                '    <div class="plat-scroll-container">\n' +
                '        <div class="plat-listview-container"></div>\n' +
                '    </div>\n' +
                '</div>\n';
            /**
             * Whether or not the main Array listener has been set.
             */
            this.__listenerSet = false;
            this.itemsLoaded = new this._Promise(function (resolve, reject) {
                _this.__resolveFn = resolve;
                _this.__rejectFn = reject;
            }).catch(noop);
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        Listview.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __Listview + " " + (className || ''));
        };
        /**
         * Check for templateUrl and set if needed.
         */
        Listview.prototype.initialize = function () {
            var optionObj = this.options || (this.options = {}), options = optionObj.value || (optionObj.value = {});
            this.templateUrl = options.templateUrl || this.templateUrl;
            this.setClasses();
        };
        /**
         * Parse the innerTemplate and add it to the control's element.
         */
        Listview.prototype.setTemplate = function () {
            if (this.templateString !== this.__templateString || this.utils.isString(this.templateUrl)) {
                var fragment = this.dom.serializeHtml(this.__templateString), element = this.element;
                this.innerTemplate = this.dom.appendChildren(element.childNodes);
                element.appendChild(fragment);
            }
        };
        /**
         * Re-syncs the Listview child controls and DOM with the new
         * array.
         * @param {Array<any>} newValue? The new Array
         * @param {Array<any>} oldValue? The old Array
         */
        Listview.prototype.contextChanged = function (newValue, oldValue) {
            if (this.utils.isArray(newValue)) {
                this._setListener();
            }
            else {
                this._log.debug(this.type + " context set to something other than an Array.");
                newValue = [];
            }
            this._executeEvent([{
                    object: newValue,
                    type: 'splice'
                }]);
        };
        /**
         * Determine item templates and kick off rendering.
         */
        Listview.prototype.loaded = function () {
            var options = this.options.value, utils = this.utils, isString = utils.isString, element = this.element, viewport = this._viewport = element.firstElementChild, scrollContainer = this._scrollContainer = viewport.firstElementChild, loading = this._loading = options.loading, animate = this._animate = options.animate === true, requestItems = options.onItemsRequested, refresh = options.onRefresh, itemTemplate = options.itemTemplate, scrollElement = options.scrollElement;
            this._container = scrollContainer.firstElementChild;
            this.dom.addClass(element, __Plat + this._validateOrientation(options.orientation) +
                (animate ? (" " + __Plat + "animated") : ''));
            if (isString(scrollElement)) {
                scrollElement = this._document.querySelector(scrollElement);
            }
            if (utils.isNode(scrollElement)) {
                this._scrollContainer = scrollElement;
                this.dom.addClass(element, __Plat + "no-scroller");
            }
            if (!isString(itemTemplate)) {
                this._log.debug("No item template or item template selector specified for " + this.type + ".");
                return;
            }
            var normalizedItemTemplate = this._normalizeTemplateName(itemTemplate), headerTemplate = options.headerTemplate, normalizedGroupTemplate = isString(headerTemplate) ? this._normalizeTemplateName(headerTemplate) : null;
            this._parseInnerTemplate(normalizedItemTemplate, normalizedGroupTemplate);
            this._determineTemplates(itemTemplate, normalizedItemTemplate, normalizedGroupTemplate);
            this._defaultGroup = {
                name: null,
                control: this,
                itemContainer: this._container,
                element: element,
                index: null,
                itemCount: 0,
                addQueue: [],
                animationQueue: []
            };
            var isRefreshing = false;
            if (isString(loading)) {
                if (isString(requestItems)) {
                    this._determineLoading(requestItems, options.infiniteProgress !== false);
                }
                else {
                    this._log.debug(this.type + " loading type specified as \"" + loading + "\" but no option specifying an onItemsRequested handler.");
                }
            }
            if (isString(refresh)) {
                isRefreshing = true;
                this._initializeRefresh(refresh);
            }
            this._initializeTracking(loading === 'incremental', isRefreshing);
            if (!utils.isArray(this.context)) {
                if (!utils.isNull(this.context)) {
                    this._log.debug(this.type + "'s context must be an Array.");
                }
                return;
            }
            this._setAliases();
            this._setContainerHeight();
            this.render();
            this._setListener();
        };
        /**
         * Removes any potentially held memory.
         */
        Listview.prototype.dispose = function () {
            var visibilityRemovers = this._visibilityRemoveListeners;
            while (visibilityRemovers.length > 0) {
                visibilityRemovers.pop()();
            }
            this._removeScroll();
            if (this.utils.isFunction(this.__rejectFn)) {
                this.__rejectFn();
                this.__resolveFn = this.__rejectFn = null;
            }
        };
        /**
         * Blow out the DOM starting at the index, determine how to render, and render the count accordingly.
         * @param {number} index? The starting index to render. If not specified, it will start at currentCount.
         * @param {number} count? The number of items to render. If not specified, the whole context
         * from the specified index will be rendered.
         * @param {platui.IGroupHash} group? The group we're rendering.
         */
        Listview.prototype.render = function (index, count, group) {
            var isNumber = this.utils.isNumber, opGroup = group || this._defaultGroup, control = opGroup.control, context = this === control ? this.context : control.context.items;
            if (!isNumber(index)) {
                index = 0;
            }
            var maxCount = context.length - index, itemCount = isNumber(count) && maxCount >= count ? count : maxCount;
            this._createItems(index, itemCount, opGroup, 0);
        };
        /**
         * Blow out all the DOM, determine how to render, and render accordingly.
         * @param {platui.IGroupHash} group? The group we're rerendering.
         */
        Listview.prototype.rerender = function (group) {
            this.render(0, null, group);
        };
        /**
         * Re-syncs the Listview child items and DOM with the new items
         * array.
         * @param {string} groupName The group name of the currently changing Array.
         * @param {any} newValue? The new child array of items
         * @param {any} oldValue? The old child array of items
         */
        Listview.prototype._childContextChanged = function (groupName, newValue, oldValue) {
            this._executeChildEvent(groupName, [{
                    object: newValue || [],
                    type: 'splice'
                }]);
        };
        /**
         * Sets a listener for the changes to the array.
         */
        Listview.prototype._setListener = function () {
            if (!this.__listenerSet) {
                this.observeArray(this._executeEvent);
                this.__listenerSet = true;
            }
        };
        /**
         * Sets the alias tokens to use for all the items in the Listview context array.
         */
        Listview.prototype._setAliases = function () {
            var aliases = this.options.value.aliases, utils = this.utils;
            if (!utils.isObject(aliases)) {
                return;
            }
            var _aliases = this._aliases, isString = utils.isString, keys = Object.keys(_aliases), length = keys.length, value;
            for (var i = 0; i < length; ++i) {
                value = aliases[keys[i]];
                if (isString(value)) {
                    _aliases[keys[i]] = value;
                }
            }
        };
        /**
         * Determine the proper item template or method of item template selection.
         * @param {string} itemTemplate The pre-normalized property for indicating either the item template or the
         * item template selector.
         * @param {string} itemTemplateKey The normalized property for indicating the item template.
         * @param {string} headerTemplate The property for indicating the group header template.
         */
        Listview.prototype._determineTemplates = function (itemTemplate, itemTemplateKey, headerTemplate) {
            var utils = this.utils, bindableTemplates = this.bindableTemplates, templates = this._templates, template;
            if (utils.isString(headerTemplate)) {
                this._isGrouped = true;
                this.dom.addClass(this._container, __Plat + "grouped");
                template = templates[headerTemplate];
                if (utils.isNode(template)) {
                    this._headerTemplate = headerTemplate;
                    this.bindableTemplates.add(headerTemplate, template);
                    delete templates[headerTemplate];
                }
                else {
                    this._log.debug(__Listview + " group header template \"" + headerTemplate + "\" was not a template defined in the DOM.");
                }
                this._headerTemplatePromise = this._createGroupTemplate();
            }
            template = templates[itemTemplateKey];
            if (utils.isNode(template)) {
                this._itemTemplate = itemTemplateKey;
                this.bindableTemplates.add(itemTemplateKey, template);
                delete templates[itemTemplateKey];
                return;
            }
            var controlProperty = this.findProperty(itemTemplate) || {};
            if (!utils.isFunction(controlProperty.value)) {
                this._log.debug(__Listview + " item template \"" + itemTemplate + "\" was neither a template defined in the DOM nor a template selector function in its control hiearchy.");
                return;
            }
            this._templateSelector = controlProperty.value.bind(controlProperty.control);
            this._templateSelectorKeys = {};
            var keys = Object.keys(templates), key;
            while (keys.length > 0) {
                key = keys.pop();
                bindableTemplates.add(key, templates[key]);
                delete templates[key];
            }
        };
        /**
         * Construct the group template and add it to bindable templates.
         */
        Listview.prototype._createGroupTemplate = function () {
            var _this = this;
            var _document = this._document, bindableTemplates = this.bindableTemplates, headerTemplate = this._headerTemplate, listviewGroup = __Listview + "-group", group = _document.createElement('div'), itemContainer = _document.createElement('div'), headerPromise;
            group.className = listviewGroup;
            itemContainer.className = __Listview + "-items";
            if (this.utils.isString(headerTemplate)) {
                headerPromise = bindableTemplates.templates[headerTemplate].then(function (headerTemplate) {
                    group.insertBefore(headerTemplate.cloneNode(true), null);
                });
            }
            return this._Promise.resolve(headerPromise).then(function () {
                group.insertBefore(itemContainer, null);
                bindableTemplates.add(listviewGroup, group);
            }).then(null, function (error) {
                _this._log.debug(_this.type + " error: " + error);
            });
        };
        /**
         * Adds new groups to the control's element when items are added to
         * the context.
         * @param {number} numberOfGroups The number of groups to add.
         * @param {number} index The point in the array to start adding groups.
         * @param {number} animateItems The number of groups to animate.
         */
        Listview.prototype._addGroups = function (numberOfGroups, index, animateItems) {
            var _this = this;
            var initialIndex = index, max = +(index + numberOfGroups), promises = [];
            while (index < max) {
                promises.push(this._bindGroup(index++));
            }
            return this._Promise.all(promises).then(function (fragments) {
                var length = fragments.length;
                for (var i = 0; i < length; ++i) {
                    _this._addGroup(i + initialIndex, fragments[i], i < animateItems);
                }
            });
        };
        /**
         * Adds new group to the control's element.
         * @param {number} index The index of the group.
         * @param {DocumentFragment} fragment The group fragment to add to the DOM.
         * @param {boolean} animate Whether or not to animate the group.
         */
        Listview.prototype._addGroup = function (index, fragment, animate) {
            var _this = this;
            var utils = this.utils, context = this.context, groups = this._groups || (this._groups = {}), group = context[index], name = group.group, groupContainer = fragment.childNodes[1], itemContainer = groupContainer.lastElementChild, control = this.controls[index], groupHash = groups[name] = {
                name: name,
                index: index,
                element: groupContainer,
                itemContainer: itemContainer,
                control: control,
                itemCount: 0,
                addQueue: [],
                animationQueue: []
            }, items = 'items', removeArrayListener, removeMutationListener;
            control.dispose = function () {
                _super.prototype.dispose.call(_this);
                delete groups[name];
            };
            control.observe(function (newValue, oldValue) {
                var newName = newValue.group;
                if (newName === name || !utils.isObject(newValue)) {
                    return;
                }
                var temp = groups[name];
                delete groups[name];
                temp.name = newName;
                groups[newName] = temp;
                name = newName;
                removeArrayListener();
                removeMutationListener();
                removeArrayListener = control.observe(_this._childContextChanged.bind(_this, name), items);
                removeMutationListener = control.observeArray(_this._executeChildEvent.bind(_this, name), items);
            });
            removeArrayListener = control.observe(this._childContextChanged.bind(this, name), items);
            removeMutationListener = control.observeArray(this._executeChildEvent.bind(this, name), items);
            this._createItems(0, (group.items || []).length, groupHash, 0);
            if (animate) {
                var animationQueue_1 = this._defaultGroup.animationQueue, animation_1 = {
                    animation: this._animator.enter(fragment, __Enter, this._container).then(function () {
                        var index = animationQueue_1.indexOf(animation_1);
                        if (index > -1) {
                            animationQueue_1.splice(index, 1);
                        }
                        utils.requestAnimationFrame(_this._setGroupContainerPadding.bind(_this, groupContainer));
                    }),
                    op: null
                };
                animationQueue_1.push(animation_1);
                return;
            }
            this._container.insertBefore(fragment, null);
            utils.requestAnimationFrame(this._setGroupContainerPadding.bind(this, groupContainer));
        };
        /**
         * Handle binding of a single group.
         * @param {number} index The index of the group in context.
         */
        Listview.prototype._bindGroup = function (index) {
            return this.bindableTemplates.bind(__Listview + "-group", index, this._getAliases(this.context, index));
        };
        /**
         * Creates a specified number of items.
         * @param {number} index The index to start creating items.
         * @param {number} count The number of items to create.
         * @param {platui.IGroupHash} group The group for which we're creating items.
         * @param {number} animateItems The number of items to animate.
         */
        Listview.prototype._createItems = function (index, count, group, animateItems) {
            var _this = this;
            var utils = this.utils, opGroup = group || this._defaultGroup, control = opGroup.control, isVertical = this._isVertical, isControl = this === control;
            if (isControl) {
                if (this._isGrouped) {
                    this._headerTemplatePromise.then(function () {
                        _this._addGroups(count, index, animateItems);
                    }).then(null, function (error) {
                        _this._log.debug(_this.type + " error: " + error);
                    });
                    return;
                }
            }
            var addQueue = opGroup.addQueue, addPromise, postLoad = function () {
                var indexOf = addQueue.indexOf(addPromise);
                if (indexOf !== -1) {
                    addQueue.splice(indexOf, 1);
                }
                if (isControl) {
                    return;
                }
                opGroup.element.removeAttribute(__Hide);
                if (isVertical || isControl || !_this._isGrouped) {
                    return;
                }
                // set width for flexbox container 
                utils.requestAnimationFrame(_this._setGroupContainerWidth.bind(_this, opGroup.itemContainer));
            }, onError = function (error) {
                _this._log.debug(_this.type + " error: " + (utils.isString(error.message) ? error.message : error));
            };
            if (utils.isFunction(this._templateSelector)) {
                var promises = [];
                opGroup.itemCount += count;
                for (var i = 0; i < count; ++i, ++index) {
                    promises.push(this._renderUsingFunction(index, opGroup));
                }
                var itemsLoaded = this.itemsLoaded = this._Promise.all(promises)
                    .then(function (nodes) {
                    var length = nodes.length;
                    for (var ii = 0; ii < length; ++ii) {
                        _this._appendRenderedItem(nodes[ii], opGroup, ii < animateItems);
                    }
                }).then(postLoad, onError);
                addQueue.push(itemsLoaded);
                return;
            }
            var key = this._itemTemplate;
            if (utils.isUndefined(this.bindableTemplates.templates[key])) {
                return;
            }
            this._disposeFromIndex(index, opGroup);
            opGroup.itemCount += count;
            addPromise = this._addItems(index, count, opGroup, animateItems).then(postLoad, onError);
            addQueue.push(addPromise);
        };
        /**
         * Adds new items to the control's element when items are added to
         * the array.
         * @param {number} index The point in the array to start adding items.
         * @param {number} numberOfItems The number of items to add.
         * @param {platui.IGroupHash} group The group that we're performing this operation on.
         * @param {number} animateItems The number of items to animate.
         */
        Listview.prototype._addItems = function (index, numberOfItems, group, animateItems) {
            var _this = this;
            var opGroup = group || this._defaultGroup, control = opGroup.control, container = opGroup.itemContainer, max = +(index + numberOfItems), promises = [], itemTemplate = this._itemTemplate, bindableTemplates = control.bindableTemplates, initialIndex = index, identifier, context;
            if (this === control) {
                identifier = '';
                context = this.context;
            }
            else {
                identifier = 'items.';
                context = control.context.items;
            }
            while (index < max) {
                promises.push(bindableTemplates.bind(itemTemplate, identifier + index, this._getAliases(context, index++)));
            }
            if (promises.length > 0) {
                this.itemsLoaded = this._Promise.all(promises).then(function (templates) {
                    if (animateItems > 0) {
                        var length_2 = templates.length;
                        for (var i = 0; i < length_2; ++i) {
                            if (i < animateItems) {
                                _this._appendAnimatedItem(templates[i], opGroup);
                            }
                            else {
                                container.insertBefore(templates[i], null);
                            }
                        }
                    }
                    else {
                        _this._appendItems(templates, container);
                    }
                    _this._updateResource(initialIndex - 1, control);
                    if (_this.utils.isFunction(_this.__resolveFn)) {
                        _this.__resolveFn();
                        _this.__resolveFn = _this.__rejectFn = null;
                    }
                }).catch(function (error) {
                    _this.utils.postpone(function () {
                        _this._log.debug(error);
                    });
                });
            }
            return this.itemsLoaded;
        };
        /**
         * Render items using a defined render function starting at a given index and continuing
         * through for a set number of items. If undefined or null is returned from the function,
         * rendering will stop.
         * @param {number} index The starting index to render.
         * @param {platui.IGroupHash} group? The group that we're performing this operation on.
         */
        Listview.prototype._renderUsingFunction = function (index, group) {
            var _this = this;
            var _Promise = this._Promise, utils = this.utils, opGroup = group || this._defaultGroup, control = opGroup.control, identifier, context, groupName;
            if (this === control) {
                identifier = index;
                context = this.context;
            }
            else {
                identifier = "items." + index;
                context = control.context.items;
                groupName = opGroup.name;
            }
            return _Promise.resolve(this._templateSelectorPromise).then(function () {
                return _this._templateSelectorPromise = _Promise.resolve(_this._templateSelector(context[index], index, groupName));
            }).then(function (selectedTemplate) {
                var bindableTemplates = control.bindableTemplates, templates = bindableTemplates.templates, controls = control.controls, key = _this._normalizeTemplateName(selectedTemplate), name = opGroup.name, templateKeys = _this._templateSelectorKeys[name], controlExists = index < controls.length;
                if (utils.isUndefined(templateKeys)) {
                    templateKeys = _this._templateSelectorKeys[name] = {};
                }
                if (!utils.isUndefined(templates[key])) {
                    if (controlExists) {
                        if (key === templateKeys[index]) {
                            return;
                        }
                        templateKeys[index] = key;
                        return bindableTemplates.replace(index, key, identifier, _this._getAliases(context, index));
                    }
                    templateKeys[index] = key;
                    return bindableTemplates.bind(key, identifier, _this._getAliases(context, index));
                }
                else {
                    _this._log.debug(_this.type + " template \"" + selectedTemplate + "\" was not found.");
                    if (controlExists) {
                        _this._TemplateControlFactory.dispose(controls[index]);
                    }
                }
            });
        };
        /**
         * Appends the rendered item from the defined render function.
         * @param {any} node The node to place into the item container if available.
         * @param {platui.IGroupHash} group? The group that we're performing this operation on.
         * @param {boolean} animate? Whether or not to animate the new item.
         */
        Listview.prototype._appendRenderedItem = function (node, group, animate) {
            var utils = this.utils, opGroup = group || this._defaultGroup;
            if (utils.isNull(node) || utils.isArray(node)) {
                return;
            }
            else if (animate === true) {
                var animationQueue_2 = opGroup.animationQueue, animation_2 = {
                    animation: this._animator.enter(node, __Enter, opGroup.itemContainer).then(function () {
                        var animationIndex = animationQueue_2.indexOf(animation_2);
                        if (animationIndex === -1) {
                            return;
                        }
                        animationQueue_2.splice(animationIndex, 1);
                    }),
                    op: null
                };
                animationQueue_2.push(animation_2);
            }
            else {
                opGroup.itemContainer.insertBefore(node, null);
            }
            if (utils.isFunction(this.__resolveFn)) {
                this.__resolveFn();
                this.__resolveFn = null;
            }
        };
        /**
         * Updates the control's children resource objects when
         * the array changes.
         * @param {number} index? The index to begin updating.
         * @param {number} count? The number of resources to update.
         * @param {plat.ui.TemplateControl} control The control whose resources are to be updated.
         */
        Listview.prototype._updateResource = function (index, control) {
            var controls = control.controls;
            if (index < 0 || index >= controls.length) {
                return;
            }
            controls[index].resources.add(this._getAliases(this === control ? this.context : control.context.items, index));
        };
        /**
         * Returns a resource alias object for an item in the array. The
         * resource object contains index:number, even:boolean, odd:boolean,
         * first:boolean, and last:boolean.
         * @param {any} context The context to get the aliases for.
         * @param {number} index The index used to create the resource aliases.
         */
        Listview.prototype._getAliases = function (context, index) {
            var isEven = (index & 1) === 0, aliases = {}, _aliases = this._aliases, type = __LITERAL_RESOURCE;
            aliases[_aliases.index] = {
                value: index,
                type: type
            };
            aliases[_aliases.even] = {
                value: isEven,
                type: type
            };
            aliases[_aliases.odd] = {
                value: !isEven,
                type: type
            };
            aliases[_aliases.first] = {
                value: index === 0,
                type: type
            };
            aliases[_aliases.last] = {
                value: index === (context.length - 1),
                type: type
            };
            return aliases;
        };
        /**
         * Adds an Array of items to the element without animating.
         * @param {Array<Node>} items The Array of items to add.
         * @param {Element} container THe container to add the items to.
         */
        Listview.prototype._appendItems = function (items, container) {
            this.dom.appendChildren(items, container);
        };
        /**
         * Adds an item to the control's element animating its elements.
         * @param {DocumentFragment} item The HTML fragment representing a single item.
         * @param {platui.IGroupHash} group The group items are being added to.
         */
        Listview.prototype._appendAnimatedItem = function (item, group) {
            if (!this.utils.isNode(item)) {
                return;
            }
            var animationQueue = group.animationQueue, animation = {
                animation: this._animator.enter(item, __Enter, group.itemContainer).then(function () {
                    var index = animationQueue.indexOf(animation);
                    if (index === -1) {
                        return;
                    }
                    animationQueue.splice(index, 1);
                }),
                op: null
            };
            animationQueue.push(animation);
        };
        /**
         * Removes items from the control's element.
         * @param {number} index The index to start disposing from.
         * @param {number} numberOfItems The number of items to remove.
         * @param {platui.IGroupHash} group The group for which we're disposing items.
         */
        Listview.prototype._removeItems = function (index, numberOfItems, group) {
            var dispose = this._TemplateControlFactory.dispose, control = group.control, controls = control.controls, last = index + numberOfItems, controlDisposed = last > index;
            while (last-- > index) {
                dispose(controls[last]);
            }
            this._updateResource(controls.length - 1, control);
            if (this === control) {
                return;
            }
            else if (controls.length === 0) {
                group.element.setAttribute(__Hide, '');
            }
            else if (controlDisposed && this._isGrouped && !this._isVertical) {
                this.utils.requestAnimationFrame(this._setGroupContainerWidth.bind(this, group.itemContainer));
            }
        };
        /**
         * Dispose of the controls and DOM starting at a given index.
         * @param {number} index The starting index to dispose.
         * @param {platui.IGroupHash} group? The group for which we're disposing items.
         */
        Listview.prototype._disposeFromIndex = function (index, group) {
            var opGroup = group || this._defaultGroup, control = opGroup.control, controls = control.controls, dispose = this._TemplateControlFactory.dispose, last = controls.length, controlDisposed = last > index;
            while (last-- > index) {
                dispose(controls[last]);
            }
            if (this === control) {
                return;
            }
            else if (controls.length === 0) {
                group.element.setAttribute(__Hide, '');
            }
            else if (controlDisposed && this._isGrouped && !this._isVertical) {
                this.utils.requestAnimationFrame(this._setGroupContainerWidth.bind(this, group.itemContainer));
            }
        };
        /**
         * Find and determine the proper loading function.
         * @param {string} requestItems The property for indicating the function for requesting more items.
         * @param {boolean} hideRing? Whether or not to hide the progress ring for "incremental" loading.
         */
        Listview.prototype._determineLoading = function (requestItems, showRing) {
            var _this = this;
            var controlProperty = this.findProperty(requestItems) || {};
            if (!this.utils.isFunction(controlProperty.value)) {
                this._log.debug(__Listview + " onItemsRequested function \"" + requestItems + "\" was not found.");
                return;
            }
            this._requestItems = controlProperty.value.bind(controlProperty.control);
            var progressRingContainer;
            switch (this._loading) {
                case 'infinite':
                    var removeScroll_1, removeRequest_1 = noop;
                    removeScroll_1 = this.addEventListener(this._scrollContainer, 'scroll', function () {
                        if (!_this._scrollReady) {
                            return;
                        }
                        _this._scrollReady = false;
                        removeRequest_1 = _this.utils.requestAnimationFrame(function () {
                            _this._scrollReady = true;
                            _this._onScroll();
                        });
                    }, false);
                    this._removeScroll = function () {
                        _this._scrollReady = false;
                        removeRequest_1();
                        removeScroll_1();
                    };
                    if (showRing) {
                        progressRingContainer = this._loadingProgressRing = this._document.createElement('div');
                        progressRingContainer.className = __Plat + "infinite";
                        progressRingContainer.insertBefore(this._generateProgressRing(), null);
                    }
                    this.itemsLoaded.then(this._onScroll.bind(this));
                    break;
                case 'incremental':
                    progressRingContainer = this._loadingProgressRing = this._document.createElement('div');
                    progressRingContainer.className = __Plat + "incremental";
                    progressRingContainer.setAttribute(__Hide, '');
                    progressRingContainer.insertBefore(this._generateProgressRing(), null);
                    this.element.insertBefore(progressRingContainer, null);
                    break;
                default:
                    break;
            }
        };
        /**
         * The scroll event listener.
         */
        Listview.prototype._onScroll = function () {
            var scrollContainer = this._scrollContainer, scrollPos = this._scrollPosition, scrollPosition = this._isVertical ?
                scrollContainer.scrollTop + scrollContainer.offsetHeight :
                scrollContainer.scrollLeft + scrollContainer.offsetWidth;
            if (scrollPos > scrollPosition) {
                this._scrollPosition = scrollPosition;
                return;
            }
            else if (scrollPos + 5 > scrollPosition) {
                // debounce excessive scroll event calls 
                return;
            }
            this._scrollPosition = scrollPosition;
            this._handleScroll();
        };
        /**
         * Checks if the scrolling has hit the proper threshold and requests more items if it has.
         */
        Listview.prototype._handleScroll = function () {
            var _this = this;
            // infinite scrolling set to load items at 80% of scroll length 
            var scrollContainer = this._scrollContainer, scrollLength = 0.8 * (this._isVertical ? scrollContainer.scrollHeight : scrollContainer.scrollWidth);
            if (scrollLength === 0) {
                return;
            }
            else if (this._scrollPosition >= scrollLength) {
                var utils_2 = this.utils, itemsRemain = this._requestItems();
                if (itemsRemain === false) {
                    this._removeScroll();
                }
                else if (utils_2.isPromise(itemsRemain)) {
                    var progressRing_1 = this._loadingProgressRing, showProgress_1 = !utils_2.isNull(progressRing_1), container_1 = this._container;
                    this._scrollReady = false;
                    if (showProgress_1) {
                        utils_2.requestAnimationFrame(function () {
                            container_1.insertBefore(progressRing_1, null);
                        });
                    }
                    itemsRemain.then(function (moreItemsRemain) {
                        if (showProgress_1) {
                            utils_2.requestAnimationFrame(function () {
                                container_1.removeChild(progressRing_1);
                            });
                        }
                        if (moreItemsRemain === false) {
                            return;
                        }
                        _this._scrollReady = true;
                    });
                }
                else {
                    utils_2.postpone(function () {
                        _this.itemsLoaded.then(function () {
                            if (_this._scrollReady) {
                                _this._handleScroll();
                            }
                        });
                    });
                }
            }
        };
        /**
         * Find and determine the pull-to-refresh function.
         * @param {string} pullRefresh The property for indicating the pull-to-refresh function.
         */
        Listview.prototype._initializeRefresh = function (refresh) {
            var controlProperty = this.findProperty(refresh) || {};
            if (!this.utils.isFunction(controlProperty.value)) {
                this._log.debug(__Listview + " onRefresh function \"" + refresh + "\" was not found.");
                return;
            }
            this._refresh = controlProperty.value.bind(controlProperty.control);
            var progressRingContainer = this._refreshProgressRing = this._document.createElement('div');
            progressRingContainer.className = __Plat + "refresh";
            progressRingContainer.setAttribute(__Hide, '');
            progressRingContainer.insertBefore(this._generateProgressRing(), null);
            this.element.insertBefore(progressRingContainer, null);
        };
        /**
         * Initializes the proper tracking events.
         * @param {boolean} loading Whether or not to initialize the loading tracking events.
         * @param {boolean} refresh Whether or not to initialize the refresh tracking events.
         */
        Listview.prototype._initializeTracking = function (loading, refresh) {
            if (!(loading || refresh)) {
                return;
            }
            this._setTransform();
            var track, reverseTrack;
            if (this._isVertical) {
                track = __$track + "down";
                reverseTrack = __$track + "up";
            }
            else {
                track = __$track + "right";
                reverseTrack = __$track + "left";
            }
            var viewport = this._viewport, touchEnd, trackFn;
            this.addEventListener(viewport, __$touchstart, this._touchStart, false);
            if (loading) {
                touchEnd = this._touchEndLoad;
                trackFn = this._trackLoad;
                this.addEventListener(viewport, __$touchend, touchEnd, false);
                this.addEventListener(viewport, __$trackend, touchEnd, false);
                this.addEventListener(viewport, __$touchcancel, touchEnd, false);
                this.addEventListener(viewport, track, trackFn, false);
                this.addEventListener(viewport, reverseTrack, trackFn, false);
            }
            if (refresh) {
                touchEnd = this._touchEndRefresh;
                trackFn = this._trackRefresh;
                this.addEventListener(viewport, __$touchend, touchEnd, false);
                this.addEventListener(viewport, __$trackend, touchEnd, false);
                this.addEventListener(viewport, __$touchcancel, touchEnd, false);
                this.addEventListener(viewport, track, trackFn, false);
                this.addEventListener(viewport, reverseTrack, trackFn, false);
            }
        };
        /**
         * The touch start event listener for when looking for a refresh.
         * @param {plat.ui.IGestureEvent} ev The $touchstart event object.
         */
        Listview.prototype._touchStart = function (ev) {
            var _this = this;
            if (this._touchState !== 0) {
                return;
            }
            else if (!this._isVertical) {
                var pos = Math.ceil(ev.offsetY), 
                // we're going to decrease the threshold by 20 to buffer the scrollbar 
                threshold = this._viewport.offsetHeight - 20;
                if (pos >= threshold) {
                    return;
                }
            }
            this._touchState = 1;
            this._lastTouch = {
                x: ev.clientX,
                y: ev.clientY
            };
            if (!this.utils.isNull(this._touchAnimationThenable)) {
                this._touchAnimationThenable.cancel().then(function () {
                    _this._touchAnimationThenable = null;
                    _this._touchState = 2;
                });
                return;
            }
            this._touchState = 2;
        };
        /**
         * The touch end event listener for when looking for an incremental load.
         * @param {plat.ui.IGestureEvent} ev The $touchend event object.
         */
        Listview.prototype._touchEndLoad = function (ev) {
            var isLoading = this._isLoading;
            this._isLoading = false;
            if (!isLoading) {
                if (!this._isRefreshing) {
                    this._touchState = 0;
                }
                return;
            }
            var scrollContainer = this._scrollContainer, scrollLength, threshold;
            if (this._isVertical) {
                scrollLength = scrollContainer.scrollTop + scrollContainer.offsetHeight;
                threshold = scrollContainer.scrollHeight;
            }
            else {
                scrollLength = scrollContainer.scrollLeft + scrollContainer.offsetWidth;
                threshold = scrollContainer.scrollWidth;
            }
            // do plus 1 here for browser pixel inconsistency 
            if (scrollLength + 1 < threshold) {
                this._touchState = 0;
                return;
            }
            this._touchEnd(ev, false);
        };
        /**
         * The touch end event listener for when looking for a refresh.
         * @param {plat.ui.IGestureEvent} ev The $touchend event object.
         */
        Listview.prototype._touchEndRefresh = function (ev) {
            var isRefreshing = this._isRefreshing;
            this._isRefreshing = false;
            if (!isRefreshing) {
                if (!this._isLoading) {
                    this._touchState = 0;
                }
                return;
            }
            else if ((this._isVertical ? this._scrollContainer.scrollTop : this._scrollContainer.scrollLeft) > 0) {
                this._touchState = 0;
                return;
            }
            this._touchEnd(ev, true);
        };
        /**
         * A common touch end event listener for both refresh and incremental loading.
         * @param {plat.ui.IGestureEvent} ev The $touchend event object.
         * @param {boolean} refreshing Whether this translation is for refresh or incremental loading.
         */
        Listview.prototype._touchEnd = function (ev, refreshing) {
            var _this = this;
            var state = this._touchState, hasMoved = this._hasMoved;
            this._hasMoved = false;
            if (state < 2 || !hasMoved) {
                return;
            }
            var animationOptions = {}, dom = this.dom, viewport = this._viewport, progressRing = refreshing ? this._refreshProgressRing : this._loadingProgressRing, isActionState = state === 3, nextTranslation;
            if (isActionState) {
                var offset = void 0;
                if (this._isVertical) {
                    offset = refreshing ? progressRing.offsetHeight : -progressRing.offsetHeight;
                    nextTranslation = "translate3d(0," + offset + "px,0)";
                }
                else {
                    offset = refreshing ? progressRing.offsetWidth : -progressRing.offsetWidth;
                    nextTranslation = "translate3d(" + offset + "px,0,0)";
                }
            }
            else {
                nextTranslation = this._preTransform;
            }
            animationOptions[this._transform] = nextTranslation;
            this._touchAnimationThenable = this._animator.animate(viewport, __Transition, {
                properties: animationOptions
            }).then(function () {
                _this._touchState = 4;
                _this._hasMoved = false;
                _this._touchAnimationThenable = null;
                if (isActionState) {
                    return _this._Promise.resolve(refreshing ? _this._refresh() : _this._requestItems());
                }
                dom.removeClass(viewport, __Plat + "manipulation-prep");
                progressRing.setAttribute(__Hide, '');
                return _this._Promise.resolve();
            }).then(function () {
                if (!isActionState) {
                    _this._touchState = 0;
                    return;
                }
                dom.removeClass(progressRing, __Plat + "play");
                animationOptions[_this._transform] = _this._preTransform;
                return _this._touchAnimationThenable = _this._animator.animate(viewport, __Transition, {
                    properties: animationOptions
                }).then(function () {
                    _this._touchState = 0;
                    _this._touchAnimationThenable = null;
                    dom.removeClass(viewport, __Plat + "manipulation-prep");
                    progressRing.setAttribute(__Hide, '');
                });
            }).then(null, function (error) {
                _this._touchState = 0;
                _this._log.debug(_this.type + " error: " + error);
            });
        };
        /**
         * The tracking event listener for looking for a load.
         * @param {plat.ui.IGestureEvent} ev The $track[direction] event object.
         */
        Listview.prototype._trackLoad = function (ev) {
            if (this._isRefreshing) {
                return;
            }
            if (!this._isLoading) {
                var scrollContainer = this._scrollContainer, scrollLength = void 0, threshold = void 0;
                if (this._isVertical) {
                    if (ev.direction.y !== 'up') {
                        return;
                    }
                    scrollLength = scrollContainer.scrollTop + scrollContainer.offsetHeight;
                    threshold = scrollContainer.scrollHeight;
                }
                else {
                    if (ev.direction.x !== 'left') {
                        return;
                    }
                    scrollLength = scrollContainer.scrollLeft + scrollContainer.offsetWidth;
                    threshold = scrollContainer.scrollWidth;
                }
                // do plus 1 here for browser pixel inconsistency 
                if (scrollLength + 1 < threshold) {
                    return;
                }
                this._isLoading = true;
            }
            this._track(ev, false);
        };
        /**
         * The tracking event listener for looking for a refresh.
         * @param {plat.ui.IGestureEvent} ev The $track[direction] event object.
         */
        Listview.prototype._trackRefresh = function (ev) {
            if (this._isLoading) {
                return;
            }
            if (!this._isRefreshing) {
                if (this._isVertical) {
                    if (ev.direction.y !== 'down' || this._scrollContainer.scrollTop > 0) {
                        return;
                    }
                }
                else if (ev.direction.x !== 'right' || this._scrollContainer.scrollLeft > 0) {
                    return;
                }
                this._isRefreshing = true;
            }
            this._track(ev, true);
        };
        /**
         * Handles the translation of the viewport while tracking.
         * @param {plat.ui.IGestureEvent} ev The $track[direction] event object.
         * @param {boolean} refreshing Whether this translation is for refresh or incremental loading.
         */
        Listview.prototype._track = function (ev, refreshing) {
            var _this = this;
            var touchState = this._touchState;
            if (!(touchState === 2 || touchState === 3)) {
                return;
            }
            var translation = this._calculateTranslation(ev, refreshing);
            this.utils.requestAnimationFrame(function () {
                _this._viewport.style[_this._transform] = translation;
            });
        };
        /**
         * Calculates the translation value for setting the transform value during tracking.
         * @param {plat.ui.IGestureEvent} ev The $tracking event.
         * @param {boolean} refreshing Whether this translation is for refresh or incremental loading.
         */
        Listview.prototype._calculateTranslation = function (ev, refreshing) {
            var isVertical = this._isVertical, progressRing = refreshing ? this._refreshProgressRing : this._loadingProgressRing, diff, threshold;
            if (isVertical) {
                diff = ev.clientY - this._lastTouch.y;
                threshold = progressRing.offsetHeight;
            }
            else {
                diff = ev.clientX - this._lastTouch.x;
                threshold = progressRing.offsetWidth;
            }
            if ((refreshing && diff < 0) || (!refreshing && diff > 0)) {
                diff = 0;
            }
            else if (!this._hasMoved) {
                this._hasMoved = true;
                this.dom.addClass(this._viewport, __Plat + "manipulation-prep");
                progressRing.removeAttribute(__Hide);
            }
            else if (Math.abs(diff) >= threshold) {
                if (this._touchState < 3) {
                    this._touchState = 3;
                    this.dom.addClass(progressRing, __Plat + "play");
                }
            }
            else if (this._touchState === 3) {
                this._touchState = 2;
                this.dom.removeClass(progressRing, __Plat + "play");
            }
            if (isVertical) {
                return "translate3d(0," + diff + "px,0)";
            }
            return "translate3d(" + diff + "px,0,0)";
        };
        /**
         * Obtains the current browser's transform property value.
         */
        Listview.prototype._setTransform = function () {
            var style = this._viewport.style, isUndefined = this.utils.isUndefined;
            var vendorPrefix = this._compat.vendorPrefix;
            if (!isUndefined(this._preTransform = style[(vendorPrefix.lowerCase + "Transform")])) {
                this._transform = vendorPrefix.lowerCase + "Transform";
            }
            else if (!isUndefined(this._preTransform = style[(vendorPrefix.upperCase + "Transform")])) {
                this._transform = vendorPrefix.upperCase + "Transform";
            }
            else {
                this._preTransform = style.transform;
                this._transform = 'transform';
            }
        };
        /**
         * Clones and parses thes innerTemplate and creates the templates object.
         * @param {string} itemTemplate The normalized item template name from the options.
         * @param {string} headerTemplate? The normalized group header template name from the options.
         */
        Listview.prototype._parseInnerTemplate = function (itemTemplate, headerTemplate) {
            var templates = this._templates, slice = Array.prototype.slice, appendChildren = this.dom.appendChildren, _document = this._document, validGroupTemplate = !this.utils.isNull(headerTemplate), childNodes = slice.call(this.innerTemplate.childNodes), childNode, templateName, container;
            while (childNodes.length > 0) {
                childNode = childNodes.pop();
                if (childNode.nodeType !== Node.ELEMENT_NODE) {
                    continue;
                }
                templateName = this._normalizeTemplateName(childNode.nodeName);
                if (validGroupTemplate && templateName === headerTemplate) {
                    container = _document.createElement('div');
                    container.className = __Plat + "header";
                }
                else {
                    container = _document.createDocumentFragment();
                }
                appendChildren(childNode.childNodes, container);
                templates[templateName] = container;
            }
        };
        /**
         * Receives an event when a method has been called on an array and maps the array
         * method to its associated method handler.
         * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
         */
        Listview.prototype._executeEvent = function (changes) {
            var method = "_" + changes[0].type;
            if (this.utils.isFunction(this[method])) {
                this[method](changes);
            }
        };
        /**
         * Adds new group to the control's element.
         * @param {string} groupName The group name of the currently changing Array.
         * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array change information.
         */
        Listview.prototype._executeChildEvent = function (groupName, changes) {
            var utils = this.utils, method = "_" + changes[0].type;
            if (utils.isFunction(this[method])) {
                var group = this._groups[groupName];
                if (utils.isNull(group)) {
                    return;
                }
                this[method](changes, group);
            }
        };
        /**
         * First checks if the push will do anything, then handles items being pushed into the array.
         * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array change information.
         * @param {platui.IGroupHash} group? The group that we're performing this operation on.
         */
        Listview.prototype._push = function (changes, group) {
            var change = changes[0], addedCount = change.addedCount;
            this._createItems(change.index, addedCount, group, this._animate ? addedCount : 0);
        };
        /**
         * Handles items being popped off the array.
         * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array change information.
         * @param {platui.IGroupHash} group? The group that we're performing this operation on.
         */
        Listview.prototype._pop = function (changes, group) {
            var _this = this;
            var opGroup = group || this._defaultGroup, addQueue = opGroup.addQueue, change = changes[0], start = change.object.length;
            if (change.removed.length === 0) {
                return;
            }
            var removeIndex = change.object.length;
            if (opGroup.itemCount > 0) {
                opGroup.itemCount--;
            }
            this._Promise.all(addQueue).then(function () {
                if (_this._animate) {
                    _this._animateItems(start, 1, __Leave, opGroup, 'leave', false).then(function () {
                        _this._removeItems(removeIndex, 1, opGroup);
                    });
                    return;
                }
                _this._removeItems(removeIndex, 1, opGroup);
            });
        };
        /**
         * Handles items being unshifted into the array.
         * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array change information.
         * @param {platui.IGroupHash} group? The group that we're performing this operation on.
         */
        Listview.prototype._unshift = function (changes, group) {
            if (this.utils.isFunction(this._templateSelector)) {
                this.rerender(group);
                return;
            }
            var opGroup = group || this._defaultGroup, change = changes[0], addedCount = change.addedCount;
            if (this._animate) {
                var animationQueue = opGroup.animationQueue, animationLength = animationQueue.length;
                this._animateItems(0, addedCount, __Enter, opGroup, null, animationLength > 0 && animationQueue[animationLength - 1].op === 'clone');
            }
            this._createItems(change.object.length - addedCount, addedCount, opGroup, 0);
        };
        /**
         * Handles items being shifted off the array.
         * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array change information.
         * @param {platui.IGroupHash} group? The group that we're performing this operation on.
         */
        Listview.prototype._shift = function (changes, group) {
            var _this = this;
            var opGroup = group || this._defaultGroup, addQueue = opGroup.addQueue, change = changes[0];
            if (change.removed.length === 0) {
                return;
            }
            else if (this._animate) {
                if (addQueue.length === 0) {
                    addQueue = addQueue.concat([this._animateItems(0, 1, __Leave, opGroup, 'clone', true)]);
                }
            }
            var removeIndex = change.object.length;
            if (opGroup.itemCount > 0) {
                opGroup.itemCount--;
            }
            this._Promise.all(addQueue).then(function () {
                _this._removeItems(removeIndex, 1, opGroup);
            });
        };
        /**
         * Handles adding/removing items when an array is spliced.
         * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array change information.
         * @param {platui.IGroupHash} group? The group that we're performing this operation on.
         */
        Listview.prototype._splice = function (changes, group) {
            var _this = this;
            var utils = this.utils, change = changes[0], opGroup = group || this._defaultGroup, addCount = change.addedCount, currentLength = opGroup.itemCount, control = opGroup.control, addQueue = opGroup.addQueue, animating = this._animate;
            if (utils.isNull(addCount)) {
                if (animating) {
                    this._cancelCurrentAnimations();
                }
                var newLength = change.object.length, itemCount_1 = currentLength - newLength;
                if (newLength > currentLength) {
                    if (utils.isFunction(this._templateSelector)) {
                        if (utils.isNull(change.index)) {
                            this.rerender(opGroup);
                        }
                        else {
                            this.render(change.index, addCount, opGroup);
                        }
                        return;
                    }
                    // itemCount will be negative 
                    this._createItems(currentLength, -itemCount_1, opGroup, 0);
                }
                else if (currentLength > newLength) {
                    if (opGroup.itemCount >= itemCount_1) {
                        opGroup.itemCount -= itemCount_1;
                    }
                    else {
                        opGroup.itemCount = 0;
                    }
                    this._Promise.all(addQueue).then(function () {
                        _this._removeItems(currentLength - itemCount_1, itemCount_1, opGroup);
                    });
                }
                return;
            }
            var removeCount = change.removed.length, animationQueue = opGroup.animationQueue;
            if (addCount > removeCount) {
                var itemAddCount = addCount - removeCount, animationCount = void 0;
                if (utils.isFunction(this._templateSelector)) {
                    if (utils.isNull(change.index)) {
                        this.rerender(opGroup);
                    }
                    else {
                        this.render(change.index, addCount, opGroup);
                    }
                    return;
                }
                if (animating) {
                    animationCount = addCount;
                    var animationLength = animationQueue.length, startIndex = change.index;
                    if (currentLength < addCount - startIndex) {
                        animationCount = currentLength - startIndex;
                    }
                    this._animateItems(startIndex, animationCount, __Enter, opGroup, null, animationLength > 0 && animationQueue[animationLength - 1].op === 'clone');
                    animationCount = addCount - animationCount;
                }
                else {
                    animationCount = 0;
                }
                this._createItems(change.object.length - itemAddCount, itemAddCount, opGroup, animationCount);
            }
            else if (removeCount > addCount) {
                var adding_1 = addCount > 0;
                if (animating && !adding_1 && addQueue.length === 0) {
                    addQueue = addQueue.concat([this._animateItems(change.index, removeCount, __Leave, opGroup, 'clone', true)]);
                }
                var deleteCount_1 = removeCount - addCount;
                if (opGroup.itemCount >= deleteCount_1) {
                    opGroup.itemCount -= deleteCount_1;
                }
                else {
                    opGroup.itemCount = 0;
                }
                this._Promise.all(addQueue).then(function () {
                    if (animating && adding_1) {
                        var animLength = animationQueue.length;
                        _this._animateItems(change.index, addCount, __Enter, opGroup, null, animLength > 0 && animationQueue[animLength - 1].op === 'clone');
                    }
                    _this._removeItems(currentLength - deleteCount_1, deleteCount_1, opGroup);
                });
            }
        };
        /**
         * Animates the indicated items.
         * @param {number} startIndex The starting index of items to animate.
         * @param {number} numberOfItems The number of consecutive items to animate.
         * @param {string} key The animation key/type.
         * @param {IGroupHash} group The group performing the animation.
         * @param {string} animationOp Denotes animation operation.
         * @param {boolean} cancel Whether or not to cancel the current animation before beginning this one.
         */
        Listview.prototype._animateItems = function (startIndex, numberOfItems, key, group, animationOp, cancel) {
            switch (animationOp) {
                case 'clone':
                    return this._handleClonedContainerAnimation(this._getAnimatedNodes(startIndex, numberOfItems, group), key, group, cancel === true);
                case 'leave':
                    return this._handleLeave(this._getAnimatedNodes(startIndex, numberOfItems, group), key, group);
                default:
                    return this._handleSimpleAnimation(this._getAnimatedNodes(startIndex, numberOfItems, group), key, group, cancel === true);
            }
        };
        /**
         * Translates the items to be animated into the nodes to be animated.
         * @param {number} startIndex The starting index of items to animate.
         * @param {number} numberOfItems The number of consecutive items to animate.
         * @param {IGroupHash} group The group performing the animation.
         */
        Listview.prototype._getAnimatedNodes = function (startIndex, numberOfItems, group) {
            if (this._isGrouped && group === this._defaultGroup) {
                // we are animating a group so block length === 3 (one element node and two comment nodes) 
                var blockLength = 3, start = startIndex * blockLength;
                return Array.prototype.slice.call(group.itemContainer.childNodes, start, numberOfItems * blockLength + start);
            }
            var utils = this.utils, isNode = utils.isNode, nodes = Array.prototype.slice.call(group.itemContainer.childNodes), endIndex = startIndex + numberOfItems - 1, controls = group.control.controls;
            if (controls.length <= endIndex) {
                endIndex = controls.length - 1;
            }
            var startNode = controls[startIndex].startNode, endNode = controls[endIndex].endNode;
            if (!(isNode(startNode) && isNode(endNode))) {
                return [];
            }
            var startNodeIndex = nodes.indexOf(startNode), endNodeIndex = nodes.indexOf(endNode);
            if (startNodeIndex === -1 || endNodeIndex === -1) {
                return [];
            }
            return nodes.slice(startNodeIndex, endNodeIndex + 1);
        };
        /**
         * Handles a simple animation of a block of elements.
         * @param {Array<Node>} nodes The Array of nodes to animate.
         * @param {string} key The animation key/type.
         * @param {IGroupHash} group The group performing the animation.
         * @param {boolean} cancel Whether or not to cancel the current animation before beginning this one.
         */
        Listview.prototype._handleSimpleAnimation = function (nodes, key, group, cancel) {
            if (nodes.length === 0) {
                return this._Promise.resolve();
            }
            var container = group.itemContainer, animationQueue = group.animationQueue, animationCreation = this._animator.create(nodes, key), animation, animationPromise = animationCreation.current.then(function () {
                var index = animationQueue.indexOf(animation);
                if (index === -1) {
                    return;
                }
                animationQueue.splice(index, 1);
            }), callback = function () {
                animationCreation.previous.then(function () {
                    animationPromise.start();
                });
                return animationPromise;
            };
            animation = {
                animation: animationPromise,
                op: null
            };
            if (cancel && animationQueue.length > 0) {
                var cancelPromise = this._cancelCurrentAnimations().then(callback);
                animationQueue.push(animation);
                return cancelPromise;
            }
            animationQueue.push(animation);
            return callback();
        };
        /**
         * Handles a simple animation of a block of elements.
         * @param {Array<Node>} nodes The Array of nodes to animate.
         * @param {string} key The animation key/type.
         * @param {IGroupHash} group The group performing the animation.
         */
        Listview.prototype._handleLeave = function (nodes, key, group) {
            if (nodes.length === 0) {
                return this._Promise.resolve();
            }
            var container = group.itemContainer, animationQueue = group.animationQueue, animation, animationPromise = this._animator.leave(nodes, key).then(function () {
                var index = animationQueue.indexOf(animation);
                if (index === -1) {
                    return;
                }
                animationQueue.splice(index, 1);
            });
            animation = {
                animation: animationPromise,
                op: 'leave'
            };
            animationQueue.push(animation);
            return animationPromise;
        };
        /**
         * Handles a simple animation of a block of elements.
         * @param {Array<Node>} nodes The Array of nodes to animate.
         * @param {string} key The animation key/type.
         * @param {IGroupHash} group The group performing the animation.
         * @param {boolean} cancel Whether or not to cancel the current animation before beginning this one.
         */
        Listview.prototype._handleClonedContainerAnimation = function (nodes, key, group, cancel) {
            if (nodes.length === 0) {
                return this._Promise.resolve();
            }
            var container = group.itemContainer, clonedContainer = container.cloneNode(true), parentNode, animationQueue = group.animationQueue, isNull = this.utils.isNull, animationCreation = this._animator.create(nodes, key), animation, animationPromise = animationCreation.current.then(function () {
                var index = animationQueue.indexOf(animation);
                if (index > -1) {
                    animationQueue.splice(index, 1);
                }
                if (isNull(parentNode)) {
                    return;
                }
                parentNode.replaceChild(container, clonedContainer);
            }), callback = function () {
                parentNode = container.parentNode;
                if (isNull(parentNode) || animationPromise.isCanceled()) {
                    return animationPromise;
                }
                parentNode.replaceChild(clonedContainer, container);
                animationCreation.previous.then(function () {
                    animationPromise.start();
                });
                return animationPromise;
            };
            animation = {
                animation: animationPromise,
                op: 'clone'
            };
            if (cancel && animationQueue.length > 0) {
                var cancelPromise = this._cancelCurrentAnimations().then(callback);
                animationQueue.push(animation);
                return cancelPromise;
            }
            animationQueue.push(animation);
            return callback();
        };
        /**
         * Cancels all current animations.
         * @param {platui.IGroupHash} The object representing the current group.
         */
        Listview.prototype._cancelCurrentAnimations = function (group) {
            var animationQueue = (group || this._defaultGroup).animationQueue, animations = [], length = animationQueue.length;
            for (var i = 0; i < length; ++i) {
                animations.push(animationQueue[i].animation.cancel());
            }
            return this._Promise.all(animations);
        };
        /**
         * Normalizes template names by removing special characters.
         * @param {string} templateName The name to normalize.
         */
        Listview.prototype._normalizeTemplateName = function (templateName) {
            if (this.utils.isString(templateName)) {
                return templateName.toLowerCase().replace(this._nodeNormalizeRegex, '');
            }
        };
        /**
         * Creates a progress ring element.
         */
        Listview.prototype._generateProgressRing = function () {
            var _document = this._document, control = _document.createElement('div'), ring = _document.createElement('div');
            control.className = __Listview + "-ring " + __Plat + "ring " + __Plat + "ring-0";
            ring.className = __Plat + "animated-ring";
            control.insertBefore(ring, null);
            return control;
        };
        /**
         * Checks the orientation of the control and ensures it is valid.
         * Will default to "horizontal" if invalid.
         * @param {string} orientation The element to base the length off of.
         */
        Listview.prototype._validateOrientation = function (orientation) {
            if (this.utils.isUndefined(orientation)) {
                return 'vertical';
            }
            var validOrientation;
            if (orientation === 'vertical') {
                validOrientation = orientation;
            }
            else if (orientation === 'horizontal') {
                validOrientation = orientation;
                this._isVertical = false;
            }
            else {
                this._log.debug("Invalid orientation \"" + orientation + "\" for " + this.type + ". Defaulting to \"vertical.\"");
                validOrientation = 'vertical';
            }
            return validOrientation;
        };
        /**
         * Sets the height of a horizontally grouped Listview's container.
         */
        Listview.prototype._setContainerHeight = function () {
            if (this._isVertical || !this._isGrouped) {
                return;
            }
            var element = this.element, height = element.offsetHeight;
            if (!height) {
                this._addVisibilityListener(this._setContainerHeight.bind(this), element);
                return;
            }
            // account for scroll bar height even if scroll bar isn't visible 
            // allows for transition of scroll bar in and out of page in browsers where scroll bar affects height 
            height = height - this._getScrollBarWidth();
            if (height < 0) {
                height = 0;
            }
            this._container.style.height = height + "px";
        };
        /**
         * Sets the width of a group container based on the scroll width of the group's item container.
         * @param {HTMLElement} itemContainer The item container element whose parent we're going to set its scroll width on.
         */
        Listview.prototype._setGroupContainerWidth = function (itemContainer) {
            var width = itemContainer.scrollWidth;
            if (!width) {
                this._addVisibilityListener(this._setGroupContainerWidth.bind(this, itemContainer), itemContainer);
                return;
            }
            itemContainer.parentElement.style.width = width + "px";
        };
        /**
         * Sets the padding of a group's element.
         * @param {HTMLElement} element The group container element who we're setting padding on.
         */
        Listview.prototype._setGroupContainerPadding = function (element) {
            var elementHeight = element.offsetHeight;
            if (!elementHeight) {
                this._addVisibilityListener(this._setGroupContainerPadding.bind(this, element), element);
                return;
            }
            var header = element.firstElementChild, headerHeight = header.offsetHeight;
            if (!headerHeight) {
                this._addVisibilityListener(this._setGroupContainerPadding.bind(this, element), header);
                return;
            }
            element.style.paddingTop = headerHeight + "px";
        };
        /**
         * Calcuates the width of the horizontal scroll bar in the current browser.
         */
        Listview.prototype._getScrollBarWidth = function () {
            var _document = this._document, body = _document.body, inner = _document.createElement('div'), outer = _document.createElement('div'), innerStyle = inner.style, outerStyle = outer.style;
            innerStyle.width = innerStyle.height = outerStyle.height = '100px';
            outerStyle.width = '50px';
            outerStyle.position = 'absolute';
            outerStyle.top = outerStyle.left = '0px';
            outerStyle.visibility = outerStyle.overflow = 'hidden';
            outer.insertBefore(inner, null);
            body.insertBefore(outer, null);
            var w1 = inner.offsetHeight;
            outerStyle.overflow = 'scroll';
            var w2 = inner.offsetHeight;
            if (w1 === w2) {
                w2 = outer.clientHeight;
            }
            body.removeChild(outer);
            return (w1 - w2);
        };
        /**
         * Adds a visibility listener and hides and shows element accordingly
         * @param {() => void} listener The listener to fire when visible.
         * @param {HTMLElement} element The element to listen for visibility.
         */
        Listview.prototype._addVisibilityListener = function (listener, element) {
            var _this = this;
            var visibilityRemovers = this._visibilityRemoveListeners, remove, cb = function () {
                listener();
                var i = visibilityRemovers.indexOf(remove);
                if (i !== -1) {
                    visibilityRemovers.splice(i, 1);
                }
                if (visibilityRemovers.length === 0) {
                    _this.element.removeAttribute(__Hidden);
                }
            };
            remove = this.dom.whenVisible(this.utils.requestAnimationFrame.bind(this, cb), element);
            if (visibilityRemovers.length === 0) {
                this.element.setAttribute(__Hidden, '');
            }
            visibilityRemovers.push(remove);
        };
        Listview._inject = {
            _document: __Document,
            _window: __Window,
            _compat: __Compat,
            _animator: __Animator,
            _Promise: __Promise,
            _TemplateControlFactory: __TemplateControlFactory
        };
        return Listview;
    }(plat.ui.TemplateControl));
    platui.Listview = Listview;
    plat.register.control(__Listview, Listview);
    /**
     * An ITemplateControl that acts as a global navigation bar that defines its own context.
     */
    var Navbar = (function (_super) {
        __extends(Navbar, _super);
        function Navbar() {
            _super.apply(this, arguments);
            /**
             * The HTML template represented as a string.
             */
            this.templateString = '<div class="plat-navbar-left">\n' +
                '    <div class="plat-navbar-items" plat-control="' + __ForEach + '" plat-context="left">\n' +
                '        <div class="plat-navbar-item" plat-control="' + __Html + '" plat-options="{ html: content, compile: true }" plat-tap="leftAction(@index)"></div>\n' +
                '    </div>\n' +
                '</div>\n' +
                '<div class="plat-navbar-center">\n' +
                '    <div class="plat-navbar-items" plat-control="' + __ForEach + '" plat-context="center">\n' +
                '        <div class="plat-navbar-item" plat-control="' + __Html + '" plat-options="{ html: content, compile: true }" plat-tap="centerAction(@index)"></div>\n' +
                '    </div>\n' +
                '</div>\n' +
                '<div class="plat-navbar-right">\n' +
                '    <div class="plat-navbar-items" plat-control="' + __ForEach + '" plat-context="right">\n' +
                '        <div class="plat-navbar-item" plat-control="' + __Html + '" plat-options="{ html: content, compile: true }" plat-tap="rightAction(@index)"></div>\n' +
                '    </div>\n' +
                '</div>\n';
            /**
             * The Navbar control's context.
             */
            this.context = {
                left: [{
                        content: '',
                        action: noop
                    }],
                center: [{
                        content: '',
                        action: noop
                    }],
                right: [{
                        content: '',
                        action: noop
                    }]
            };
            /**
             * Specifies that the Navbar defines it's own context.
             */
            this.hasOwnContext = true;
            /**
             * An object specifying whether a particular section of the Navbar
             * has been overridden.
             */
            this._overrides = {
                left: false,
                center: false,
                right: false
            };
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        Navbar.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __Navbar + " " + (className || ''));
        };
        /**
         * Set the class name.
         */
        Navbar.prototype.initialize = function () {
            this.setClasses();
        };
        /**
         * Looks for and applies overwritten components.
         */
        Navbar.prototype.setTemplate = function () {
            var isNull = this.utils.isNull, innerTemplate = this.innerTemplate;
            if (isNull(innerTemplate)) {
                return;
            }
            var doc = this._document, overrides = this._overrides, slice = Array.prototype.slice, appendChildren = this.dom.appendChildren, childNodes = slice.call(innerTemplate.childNodes), childNode, newNode, element = this.element, elementNodes = slice.call(element.children);
            while (childNodes.length > 0) {
                childNode = childNodes.shift();
                if (childNode.nodeType !== Node.ELEMENT_NODE) {
                    continue;
                }
                switch (childNode.nodeName.toLowerCase()) {
                    case 'left':
                        overrides.left = true;
                        newNode = doc.createElement('div');
                        newNode.className = __Navbar + "-left";
                        newNode.setAttribute(__Context, 'left');
                        element.replaceChild(appendChildren(slice.call(childNode.childNodes), newNode), elementNodes[0]);
                        break;
                    case 'center':
                        overrides.center = true;
                        newNode = doc.createElement('div');
                        newNode.className = __Navbar + "-center";
                        newNode.setAttribute(__Context, 'center');
                        element.replaceChild(appendChildren(slice.call(childNode.childNodes), newNode), elementNodes[1]);
                        break;
                    case 'right':
                        overrides.right = true;
                        newNode = doc.createElement('div');
                        newNode.className = __Navbar + "-right";
                        newNode.setAttribute(__Context, 'right');
                        element.replaceChild(appendChildren(slice.call(childNode.childNodes), newNode), elementNodes[2]);
                        break;
                }
            }
        };
        /**
         * Initializes all options.
         */
        Navbar.prototype.loaded = function () {
            var optionObj = this.options || {}, options = optionObj.value || {}, position = this.utils.isString(options.position) && options.position.toLowerCase() === 'bottom' ? '-bottom' : '-top';
            this.dom.addClass(this.element, __Navbar + position);
        };
        Navbar.prototype.setLeft = function (components) {
            this._setComponent('left', components);
        };
        Navbar.prototype.setCenter = function (components) {
            this._setComponent('center', components);
        };
        Navbar.prototype.setRight = function (components) {
            this._setComponent('right', components);
        };
        /**
         * The defined action of the left part of the Navbar when tapped.
         * @param {number} index? The index of the action tapped.
         * @param {plat.ui.IGestureEvent} ev? The "$tap" event.
         */
        Navbar.prototype.leftAction = function (index, ev) {
            this._executeAction(ev, 'left', index);
        };
        /**
         * The defined action of the center part of the Navbar when tapped.
         * @param {number} index? The index of the action tapped.
         * @param {plat.ui.IGestureEvent} ev? The "$tap" event.
         */
        Navbar.prototype.centerAction = function (index, ev) {
            this._executeAction(ev, 'center', index);
        };
        /**
         * The defined action of the right part of the Navbar when tapped.
         * @param {number} index? The index of the action tapped.
         * @param {plat.ui.IGestureEvent} ev? The "$tap" event.
         */
        Navbar.prototype.rightAction = function (index, ev) {
            this._executeAction(ev, 'right', index);
        };
        Navbar.prototype._setComponent = function (position, components) {
            var context = this.context;
            if (!this.utils.isArray(components)) {
                if (this._overrides[position]) {
                    this._parseComponent(components);
                    context[position] = components;
                    return;
                }
                components = [components];
            }
            var curr = components.length;
            while (curr-- > 0) {
                this._parseComponent(components[curr], context[position][curr]);
            }
            context[position] = components;
        };
        /**
         * Sets default component parameters and grabs custom actions from it.
         * @param {platui.INavbarComponent} newComponent The new INavbarComponent
         * to parse.
         * @param {platui.INavbarComponent} oldComponent? The old INavbarComponent
         * whose place is being taken.
         */
        Navbar.prototype._parseComponent = function (newComponent, oldComponent) {
            var utils = this.utils, isObject = utils.isObject, oldComponentExists = isObject(oldComponent), customActions, keys, key, currKey;
            if (oldComponentExists && utils.isUndefined(newComponent.content)) {
                newComponent.content = oldComponent.content;
            }
            if (!utils.isFunction(newComponent.action)) {
                newComponent.action = oldComponentExists ? oldComponent.action : noop;
            }
            customActions = newComponent.customActions;
            if (isObject(customActions)) {
                keys = Object.keys(customActions);
                currKey = keys.length;
                while (currKey-- > 0) {
                    key = keys[currKey];
                    this[key] = customActions[key];
                }
            }
        };
        /**
         * Executes the proper action associated with a Navbar component.
         * @param {plat.ui.IGestureEvent} ev The executed event.
         * @param {string} position The part of the Navbar whose action is being executed.
         * @param {any} property? The indexing property. Will by default be an index into the component Array.
         */
        Navbar.prototype._executeAction = function (ev, position, property) {
            var utils = this.utils, component = this.context[position];
            if (utils.isArray(component) && !utils.isNull(property)) {
                component = component[property];
            }
            if (utils.isFunction(component.action)) {
                component.action(ev);
                return;
            }
            this._log.debug("An action function is not defined for the component " + component + ".");
        };
        Navbar._inject = {
            _document: __Document
        };
        return Navbar;
    }(plat.ui.TemplateControl));
    platui.Navbar = Navbar;
    plat.register.control(__Navbar, Navbar, null, true);
    /**
     * An TemplateControl that keeps track of a loading image.
     */
    var Image = (function (_super) {
        __extends(Image, _super);
        function Image() {
            _super.apply(this, arguments);
            /**
             * The HTML template represented as a string.
             */
            this.templateString = '<div plat-control="' + __ProgressRing + '" class="plat-image-ring"></div>\n';
            /**
             * The image is a CSS background image. Defaults to false.
             */
            this._isBackground = false;
            /**
             * The HTMLImageElement use to source the image.
             */
            this._img = this._document.createElement('img');
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        Image.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __Image + " " + (className || ''));
        };
        /**
         * Set the class name.
         */
        Image.prototype.initialize = function () {
            this.setClasses();
        };
        /**
         * Set the style and initialize the action.
         */
        Image.prototype.loaded = function () {
            var element = this.element, utils = this.utils, isString = utils.isString, isObject = utils.isObject, attributes = this.attributes, options = this.options, url;
            if (isString(url = attributes[__CamelSrc])) {
                attributes.observe(this._setSrc, __CamelSrc);
            }
            else if (isString(url = attributes[__src])) {
                attributes.observe(this._setSrc, __src);
            }
            else {
                return;
            }
            if (isObject(options) && isObject(options.value)) {
                this._isBackground = options.value.isBackground === true;
            }
            if (this._isBackground) {
                this.dom.addClass(element, __Plat + "background");
            }
            this._loader = element.firstElementChild;
            if (this._NodeManagerStatic.hasMarkup(url)) {
                return;
            }
            this._setSrc(url);
        };
        /**
         * Sets and sources the image to display.
         * @param {string} url The source URL to display.
         * @param {string} oldUrl? The old source URL that was being displayed.
         */
        Image.prototype._setSrc = function (url, oldUrl) {
            var _this = this;
            var img = this._img, element = this.element, dom = this.dom, imageLoad = __Plat + "load-image", imageError = __Image + "-error", loader = this._loader;
            dom.addClass(img, imageLoad);
            img.src = url;
            img.onload = function () {
                _this.utils.requestAnimationFrame(function () {
                    // remove error class in case image failed and then decides to load 
                    dom.removeClass(element, imageError);
                    if (_this._isBackground) {
                        element.style.backgroundImage = "url(\"" + url + "\")";
                        if (element.contains(img)) {
                            element.removeChild(img);
                        }
                        if (element.contains(loader)) {
                            element.removeChild(loader);
                        }
                        return;
                    }
                    dom.removeClass(img, imageLoad);
                    if (element.contains(loader)) {
                        element.removeChild(loader);
                    }
                });
            };
            img.onerror = function () {
                _this.utils.requestAnimationFrame(function () {
                    dom.addClass(element, imageError);
                    if (element.contains(img)) {
                        element.removeChild(img);
                    }
                    if (element.contains(loader)) {
                        element.removeChild(loader);
                    }
                });
            };
            element.insertBefore(loader, null);
            element.insertBefore(img, null);
        };
        Image._inject = {
            _compat: __Compat,
            _document: __Document,
            _NodeManagerStatic: __NodeManagerStatic
        };
        return Image;
    }(plat.ui.TemplateControl));
    platui.Image = Image;
    plat.register.control(__Image, Image);
})(platui || (platui = {}));
module.exports = platui;

},{}]},{},[2])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJhcHAvc3JjL2FwcC9hcHAuanMiLCJhcHAvc3JjL21haW4uanMiLCJhcHAvc3JjL3JlcG9zaXRvcmllcy9iYXNlL2Jhc2UucmVwby5qcyIsImFwcC9zcmMvcmVwb3NpdG9yaWVzL3Bvc3RzL3Bvc3RzLnJlcG8uanMiLCJhcHAvc3JjL3NlcnZpY2VzL2Jhc2UvYmFzZS5zdmMuanMiLCJhcHAvc3JjL3NlcnZpY2VzL2VudHJpZXMvZW50cmllcy5zdmMuanMiLCJhcHAvc3JjL3ZpZXdjb250cm9scy9iYXNlL2Jhc2UudmMuanMiLCJhcHAvc3JjL3ZpZXdjb250cm9scy9ob21lL2hvbWUudmMuaHRtbCIsImFwcC9zcmMvdmlld2NvbnRyb2xzL2hvbWUvaG9tZS52Yy5qcyIsImFwcC9zcmMvdmlld2NvbnRyb2xzL25ld2VudHJ5L25ld2VudHJ5LnZjLmh0bWwiLCJhcHAvc3JjL3ZpZXdjb250cm9scy9uZXdlbnRyeS9uZXdlbnRyeS52Yy5qcyIsImFwcC9zcmMvdmlld2NvbnRyb2xzL3NpbmdsZXBvc3Qvc2luZ2xlcG9zdC52Yy5odG1sIiwiYXBwL3NyYy92aWV3Y29udHJvbHMvc2luZ2xlcG9zdC9zaW5nbGVwb3N0LnZjLmpzIiwibm9kZV9tb2R1bGVzL3BsYXR5cHVzL2Rpc3QvcGxhdHlwdXMuanMiLCJub2RlX21vZHVsZXMvcGxhdHlwdXN1aS9kaXN0L3BsYXR5cHVzdWkuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzM2bUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBwbGF0eXB1c18xID0gcmVxdWlyZSgncGxhdHlwdXMnKTtcbnZhciBob21lX3ZjXzEgPSByZXF1aXJlKCcuLi92aWV3Y29udHJvbHMvaG9tZS9ob21lLnZjJyk7XG52YXIgbmV3ZW50cnlfdmNfMSA9IHJlcXVpcmUoJy4uL3ZpZXdjb250cm9scy9uZXdlbnRyeS9uZXdlbnRyeS52YycpO1xudmFyIE15QXBwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTXlBcHAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTXlBcHAocm91dGVyLCBjb25maWcpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGNvbmZpZy5yb3V0aW5nVHlwZSA9IGNvbmZpZy5TVEFURTtcbiAgICAgICAgcm91dGVyLmNvbmZpZ3VyZShbXG4gICAgICAgICAgICB7IHBhdHRlcm46ICcnLCB2aWV3OiBob21lX3ZjXzEuZGVmYXVsdCB9LFxuICAgICAgICAgICAgeyBwYXR0ZXJuOiAnbmV3ZW50cnknLCB2aWV3OiBuZXdlbnRyeV92Y18xLmRlZmF1bHQgfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgTXlBcHAucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGV2LmVycm9yKTtcbiAgICB9O1xuICAgIHJldHVybiBNeUFwcDtcbn0ocGxhdHlwdXNfMS5BcHApKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IE15QXBwO1xucGxhdHlwdXNfMS5yZWdpc3Rlci5hcHAoJ2FwcCcsIE15QXBwLCBbXG4gICAgcGxhdHlwdXNfMS5yb3V0aW5nLlJvdXRlcixcbiAgICBwbGF0eXB1c18xLndlYi5JQnJvd3NlckNvbmZpZ1xuXSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnJlcXVpcmUoJ3BsYXR5cHVzJyk7XG5yZXF1aXJlKCdwbGF0eXB1c3VpJyk7XG5yZXF1aXJlKCcuL2FwcC9hcHAnKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHBsYXR5cHVzXzEgPSByZXF1aXJlKCdwbGF0eXB1cycpO1xudmFyIEJhc2VSZXBvc2l0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXNlUmVwb3NpdG9yeSgpIHtcbiAgICB9XG4gICAgQmFzZVJlcG9zaXRvcnkuX2luamVjdCA9IHtcbiAgICAgICAgdXRpbHM6IHBsYXR5cHVzXzEuVXRpbHNcbiAgICB9O1xuICAgIHJldHVybiBCYXNlUmVwb3NpdG9yeTtcbn0oKSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBCYXNlUmVwb3NpdG9yeTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgcGxhdHlwdXNfMSA9IHJlcXVpcmUoJ3BsYXR5cHVzJyk7XG52YXIgYmFzZV9yZXBvXzEgPSByZXF1aXJlKCcuLi9iYXNlL2Jhc2UucmVwbycpO1xudmFyIGVudHJpZXNfc3ZjXzEgPSByZXF1aXJlKCcuLi8uLi9zZXJ2aWNlcy9lbnRyaWVzL2VudHJpZXMuc3ZjJyk7XG52YXIgUG9zdHNSZXBvc2l0b3J5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUG9zdHNSZXBvc2l0b3J5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBvc3RzUmVwb3NpdG9yeShlbnRyaWVzU2VydmljZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5lbnRyaWVzU2VydmljZSA9IGVudHJpZXNTZXJ2aWNlO1xuICAgIH1cbiAgICBQb3N0c1JlcG9zaXRvcnkucHJvdG90eXBlLmdldFBvc3RzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnRyaWVzU2VydmljZS5nZXRQb3N0cygpO1xuICAgIH07XG4gICAgUG9zdHNSZXBvc2l0b3J5LnByb3RvdHlwZS5zdWJtaXRQb3N0ID0gZnVuY3Rpb24gKHBvc3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllc1NlcnZpY2Uuc3VibWl0UG9zdChwb3N0KTtcbiAgICB9O1xuICAgIFBvc3RzUmVwb3NpdG9yeS5wcm90b3R5cGUuZ2V0UG9zdCA9IGZ1bmN0aW9uIChwb3N0SWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllc1NlcnZpY2UuZ2V0UG9zdChwb3N0SWQpO1xuICAgIH07XG4gICAgcmV0dXJuIFBvc3RzUmVwb3NpdG9yeTtcbn0oYmFzZV9yZXBvXzEuZGVmYXVsdCkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gUG9zdHNSZXBvc2l0b3J5O1xucGxhdHlwdXNfMS5yZWdpc3Rlci5pbmplY3RhYmxlKCdwb3N0cy1yZXBvJywgUG9zdHNSZXBvc2l0b3J5LCBbZW50cmllc19zdmNfMS5kZWZhdWx0XSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBwbGF0eXB1c18xID0gcmVxdWlyZSgncGxhdHlwdXMnKTtcbnZhciBCYXNlU2VydmljZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFzZVNlcnZpY2UoKSB7XG4gICAgICAgIHRoaXMuaG9zdCA9ICdodHRwOi8vbG9jYWxob3N0OjQwMDAvYXBpJztcbiAgICB9XG4gICAgQmFzZVNlcnZpY2UuX2luamVjdCA9IHtcbiAgICAgICAgaHR0cDogcGxhdHlwdXNfMS5hc3luYy5IdHRwLFxuICAgICAgICBQcm9taXNlOiBwbGF0eXB1c18xLmFzeW5jLklQcm9taXNlLFxuICAgICAgICB1dGlsczogcGxhdHlwdXNfMS5VdGlsc1xuICAgIH07XG4gICAgcmV0dXJuIEJhc2VTZXJ2aWNlO1xufSgpKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJhc2VTZXJ2aWNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBwbGF0eXB1c18xID0gcmVxdWlyZSgncGxhdHlwdXMnKTtcbnZhciBiYXNlX3N2Y18xID0gcmVxdWlyZSgnLi4vYmFzZS9iYXNlLnN2YycpO1xudmFyIEVudHJpZXNTZXJ2aWNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRW50cmllc1NlcnZpY2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRW50cmllc1NlcnZpY2UoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBFbnRyaWVzU2VydmljZS5wcm90b3R5cGUuZ2V0UG9zdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmh0dHAuanNvbih7XG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgdXJsOiB0aGlzLmhvc3QgKyAnL3Bvc3RzJyxcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3MucmVzcG9uc2U7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRW50cmllc1NlcnZpY2UucHJvdG90eXBlLnN1Ym1pdFBvc3QgPSBmdW5jdGlvbiAoYmxvZ1Bvc3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cC5qc29uKHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgdXJsOiB0aGlzLmhvc3QgKyAnL3Bvc3RzJyxcbiAgICAgICAgICAgIGRhdGE6IGJsb2dQb3N0XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWNjZXNzLnJlc3BvbnNlO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEVudHJpZXNTZXJ2aWNlLnByb3RvdHlwZS5nZXRQb3N0ID0gZnVuY3Rpb24gKHBvc3RJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5odHRwLmpzb24oe1xuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIHVybDogdGhpcy5ob3N0ICsgJy9wb3N0cy8nICsgcG9zdElkXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWNjZXNzLnJlc3BvbnNlO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBFbnRyaWVzU2VydmljZTtcbn0oYmFzZV9zdmNfMS5kZWZhdWx0KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBFbnRyaWVzU2VydmljZTtcbnBsYXR5cHVzXzEucmVnaXN0ZXIuaW5qZWN0YWJsZSgnZW50cmllcy1zdmMnLCBFbnRyaWVzU2VydmljZSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIHBsYXR5cHVzXzEgPSByZXF1aXJlKCdwbGF0eXB1cycpO1xudmFyIEJhc2VWaWV3Q29udHJvbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJhc2VWaWV3Q29udHJvbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCYXNlVmlld0NvbnRyb2woKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIEJhc2VWaWV3Q29udHJvbDtcbn0ocGxhdHlwdXNfMS51aS5WaWV3Q29udHJvbCkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQmFzZVZpZXdDb250cm9sO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxzcGFuIGNsYXNzPVxcXCJidXR0b24tY29udGFpbmVyXFxcIj5cXG4gICAgPHBsYXQtYnV0dG9uIGNsYXNzPVxcXCJidXR0b24tcHJpbWFyeSBidXR0b24tb3V0bGluZVxcXCIgcGxhdC10YXA9XFxcIm5ld1Bvc3QoKVxcXCI+TmV3IFBvc3Q8L3BsYXQtYnV0dG9uPlxcbjwvc3Bhbj5cXG48cGxhdC1mb3JlYWNoIHBsYXQtY29udGV4dD1cXFwicG9zdHNcXFwiIGNsYXNzPVxcXCJwb3N0LWxpc3RcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJwb3N0XFxcIj5cXG4gICAgICAgIDxoMT57e3RpdGxlfX08L2gxPlxcbiAgICAgICAgPGgzPnt7YXV0aG9yfX08L2gzPlxcbiAgICAgICAgPGgzPnt7Y3JlYXRlZEF0fX08L2gzPlxcbiAgICAgICAgPHBsYXQtYnV0dG9uIGNsYXNzPVxcXCJidXR0b24tcHJpbWFyeSBidXR0b24tb3V0bGluZVxcXCIgcGxhdC10YXA9XFxcInNpbmdsZVBvc3QoKVxcXCI+UmVhZCBNb3JlPC9wbGF0LWJ1dHRvbj5cXG4gICAgPC9kaXY+XFxuPC9wbGF0LWZvcmVhY2g+XFxuXCI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIHBsYXR5cHVzXzEgPSByZXF1aXJlKCdwbGF0eXB1cycpO1xudmFyIGJhc2VfdmNfMSA9IHJlcXVpcmUoJy4uL2Jhc2UvYmFzZS52YycpO1xudmFyIHBvc3RzX3JlcG9fMSA9IHJlcXVpcmUoJy4uLy4uL3JlcG9zaXRvcmllcy9wb3N0cy9wb3N0cy5yZXBvJyk7XG52YXIgbmV3ZW50cnlfdmNfMSA9IHJlcXVpcmUoJy4uL25ld2VudHJ5L25ld2VudHJ5LnZjJyk7XG52YXIgc2luZ2xlcG9zdF92Y18xID0gcmVxdWlyZSgnLi4vc2luZ2xlcG9zdC9zaW5nbGVwb3N0LnZjJyk7XG52YXIgSG9tZVZpZXdDb250cm9sID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSG9tZVZpZXdDb250cm9sLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhvbWVWaWV3Q29udHJvbChwb3N0UmVwbykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5wb3N0UmVwbyA9IHBvc3RSZXBvO1xuICAgICAgICB0aGlzLnRlbXBsYXRlU3RyaW5nID0gcmVxdWlyZSgnLi9ob21lLnZjLmh0bWwnKTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0ge1xuICAgICAgICAgICAgcG9zdHM6IFtdLFxuICAgICAgICAgICAgY29tcG9zZVZpZXc6IG5ld2VudHJ5X3ZjXzEuZGVmYXVsdFxuICAgICAgICB9O1xuICAgIH1cbiAgICA7XG4gICAgSG9tZVZpZXdDb250cm9sLnByb3RvdHlwZS5uYXZpZ2F0ZWRUbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5wb3N0UmVwby5nZXRQb3N0cygpLnRoZW4oZnVuY3Rpb24gKHBvc3RzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhwb3N0cyk7XG4gICAgICAgICAgICBfdGhpcy5jb250ZXh0LnBvc3RzID0gcG9zdHM7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSG9tZVZpZXdDb250cm9sLnByb3RvdHlwZS5uZXdQb3N0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm5hdmlnYXRvci5uYXZpZ2F0ZShuZXdlbnRyeV92Y18xLmRlZmF1bHQpO1xuICAgIH07XG4gICAgSG9tZVZpZXdDb250cm9sLnByb3RvdHlwZS5zaW5nbGVQb3N0ID0gZnVuY3Rpb24gKHBvc3RJZCkge1xuICAgICAgICBjb25zb2xlLmxvZygnVGhpcyBpcyB3b3JraW5nJyk7XG4gICAgICAgIHRoaXMubmF2aWdhdG9yLm5hdmlnYXRlKHNpbmdsZXBvc3RfdmNfMS5kZWZhdWx0LCB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgc29tZUlkOiBwb3N0SWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gSG9tZVZpZXdDb250cm9sO1xufShiYXNlX3ZjXzEuZGVmYXVsdCkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gSG9tZVZpZXdDb250cm9sO1xucGxhdHlwdXNfMS5yZWdpc3Rlci52aWV3Q29udHJvbCgnaG9tZS12YycsIEhvbWVWaWV3Q29udHJvbCwgW3Bvc3RzX3JlcG9fMS5kZWZhdWx0XSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXAtY29udGFpbmVyXFxcIiBpZD1cXFwicG9zdC1jb250YWluZXJcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJpbnB1dC1ncm91cFxcXCIgaWQ9XFxcIm5ldy1ibG9nXFxcIj5cXG4gICAgICAgIDxwbGF0LWlucHV0IHR5cGU9XFxcInRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCJUaXRsZVxcXCIgcGxhdC1iaW5kPVxcXCJ0aXRsZVxcXCI+PC9wbGF0LWlucHV0PlxcbiAgICAgICAgPHBsYXQtaW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgcGxhY2Vob2xkZXI9XFxcIkF1dGhvclxcXCIgcGxhdC1iaW5kPVxcXCJhdXRob3JcXFwiPjwvcGxhdC1pbnB1dD5cXG4gICAgICAgIDxwbGF0LWlucHV0IHR5cGU9XFxcInRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCJXaGF0J3MgaGFwcGVuaW5nP1xcXCIgcGxhdC1iaW5kPVxcXCJjb250ZW50XFxcIj48L3BsYXQtaW5wdXQ+XFxuICAgICAgICA8cGxhdC1idXR0b24gcGxhdC10YXA9XFxcInN1Ym1pdCgpXFxcIiBjbGFzcz1cXFwiYnV0dG9uLXByaW1hcnkgYnV0dG9uLW91dGxpbmVcXFwiPlN1Ym1pdDwvcGxhdC1idXR0b24+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBwbGF0eXB1c18xID0gcmVxdWlyZSgncGxhdHlwdXMnKTtcbnZhciBiYXNlX3ZjXzEgPSByZXF1aXJlKCcuLi9iYXNlL2Jhc2UudmMnKTtcbnZhciBwb3N0c19yZXBvXzEgPSByZXF1aXJlKCcuLi8uLi9yZXBvc2l0b3JpZXMvcG9zdHMvcG9zdHMucmVwbycpO1xudmFyIGhvbWVfdmNfMSA9IHJlcXVpcmUoJy4uL2hvbWUvaG9tZS52YycpO1xudmFyIE5ld2VudHJ5Vmlld0NvbnRyb2wgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOZXdlbnRyeVZpZXdDb250cm9sLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5ld2VudHJ5Vmlld0NvbnRyb2wocG9zdFJlcG8pIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMucG9zdFJlcG8gPSBwb3N0UmVwbztcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVN0cmluZyA9IHJlcXVpcmUoJy4vbmV3ZW50cnkudmMuaHRtbCcpO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSB7XG4gICAgICAgICAgICB0aXRsZTogJycsXG4gICAgICAgICAgICBhdXRob3I6ICcnLFxuICAgICAgICAgICAgY29udGVudDogJydcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTmV3ZW50cnlWaWV3Q29udHJvbC5wcm90b3R5cGUuc3VibWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjb25zb2xlLmxvZygnV2UgYXJlIHBvc3RpbmchJyk7XG4gICAgICAgIHZhciBibG9nUG9zdCA9IHtcbiAgICAgICAgICAgIHRpdGxlOiB0aGlzLmNvbnRleHQudGl0bGUsXG4gICAgICAgICAgICBhdXRob3I6IHRoaXMuY29udGV4dC5hdXRob3IsXG4gICAgICAgICAgICBjb250ZW50OiB0aGlzLmNvbnRleHQuY29udGVudFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBvc3RSZXBvLnN1Ym1pdFBvc3QoYmxvZ1Bvc3QpLnRoZW4oZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHN1Y2Nlc3MpO1xuICAgICAgICAgICAgX3RoaXMubmF2aWdhdG9yLm5hdmlnYXRlKGhvbWVfdmNfMS5kZWZhdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTmV3ZW50cnlWaWV3Q29udHJvbDtcbn0oYmFzZV92Y18xLmRlZmF1bHQpKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IE5ld2VudHJ5Vmlld0NvbnRyb2w7XG5wbGF0eXB1c18xLnJlZ2lzdGVyLnZpZXdDb250cm9sKCduZXdlbnRyeS12YycsIE5ld2VudHJ5Vmlld0NvbnRyb2wsIFtwb3N0c19yZXBvXzEuZGVmYXVsdF0pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxoMT57e3Bvc3QudGl0bGV9fTwvaDE+XFxuPGgyPnt7cG9zdC5hdXRob3J9fTwvaDI+XFxuPGgzPnt7cG9zdC5jcmVhdGVkQXR9fTwvaDM+XFxuPHA+e3twb3N0LmNvbnRlbnR9fTwvcD5cIjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgcGxhdHlwdXNfMSA9IHJlcXVpcmUoJ3BsYXR5cHVzJyk7XG52YXIgYmFzZV92Y18xID0gcmVxdWlyZSgnLi4vYmFzZS9iYXNlLnZjJyk7XG52YXIgcG9zdHNfcmVwb18xID0gcmVxdWlyZSgnLi4vLi4vcmVwb3NpdG9yaWVzL3Bvc3RzL3Bvc3RzLnJlcG8nKTtcbnZhciBTaW5nbGVwb3N0Vmlld0NvbnRyb2wgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTaW5nbGVwb3N0Vmlld0NvbnRyb2wsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2luZ2xlcG9zdFZpZXdDb250cm9sKHBvc3RSZXBvKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnBvc3RSZXBvID0gcG9zdFJlcG87XG4gICAgICAgIHRoaXMudGVtcGxhdGVTdHJpbmcgPSByZXF1aXJlKCcuL3NpbmdsZXBvc3QudmMuaHRtbCcpO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSB7XG4gICAgICAgICAgICBwb3N0OiB7fVxuICAgICAgICB9O1xuICAgIH1cbiAgICBTaW5nbGVwb3N0Vmlld0NvbnRyb2wucHJvdG90eXBlLm5hdmlnYXRlZFRvID0gZnVuY3Rpb24gKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGlkVmFsdWUgPSBwYXJhbWV0ZXJzLnNvbWVpZDtcbiAgICAgICAgdGhpcy5wb3N0UmVwby5nZXRQb3N0KGlkVmFsdWUpLnRoZW4oZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIF90aGlzLmNvbnRleHQucG9zdCA9IHN1Y2Nlc3M7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFNpbmdsZXBvc3RWaWV3Q29udHJvbDtcbn0oYmFzZV92Y18xLmRlZmF1bHQpKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFNpbmdsZXBvc3RWaWV3Q29udHJvbDtcbnBsYXR5cHVzXzEucmVnaXN0ZXIudmlld0NvbnRyb2woJ3NpbmdsZXBvc3QtdmMnLCBTaW5nbGVwb3N0Vmlld0NvbnRyb2wsIFtwb3N0c19yZXBvXzEuZGVmYXVsdF0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbi8qIHRzbGludDpkaXNhYmxlICovXHJcbi8qKlxyXG4gKiBQbGF0eXB1c1RTIHYwLjIwLjQgKGh0dHBzOi8vcGxhdHlwaS5pbylcclxuICogQ29weXJpZ2h0IDIwMTUgUGxhdHlwaSwgTExDLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBQbGF0eXB1c1RTIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBhdFxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vUGxhdHlwaS9wbGF0eXB1c3RzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcclxuICpcclxuICovXHJcbi8qKlxyXG4gKiBUaGUgZW50cnkgcG9pbnQgaW50byB0aGUgcGxhdHlwdXMgbGlicmFyeS5cclxuICovXHJcbnZhciBwbGF0O1xyXG4oZnVuY3Rpb24gKHBsYXRfMSkge1xyXG4gICAgJ3VzZSBzdHJpY3Q7JztcclxuICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLXVudXNlZC12YXJpYWJsZSAqL1xyXG4gICAgLypcclxuICAgICAqL1xyXG4gICAgdmFyIF9fcHJlZml4ID0gJyQnLCBfX0NPTlRFWFQgPSAnY29udGV4dCcsIF9fQXBwU3RhdGljID0gX19wcmVmaXggKyAnQXBwU3RhdGljJywgX19BcHAgPSBfX3ByZWZpeCArICdBcHAnLCBfX0h0dHAgPSBfX3ByZWZpeCArICdIdHRwJywgX19IdHRwUmVxdWVzdEluc3RhbmNlID0gX19wcmVmaXggKyAnSHR0cFJlcXVlc3RJbnN0YW5jZScsIF9fSHR0cENvbmZpZyA9IF9fcHJlZml4ICsgJ0h0dHBDb25maWcnLCBfX1Byb21pc2UgPSBfX3ByZWZpeCArICdQcm9taXNlJywgX19Db21wYXQgPSBfX3ByZWZpeCArICdDb21wYXQnLCBfX0NvbnRyb2xGYWN0b3J5ID0gX19wcmVmaXggKyAnQ29udHJvbEZhY3RvcnknLCBfX0F0dHJpYnV0ZUNvbnRyb2xGYWN0b3J5ID0gX19wcmVmaXggKyAnQXR0cmlidXRlQ29udHJvbEZhY3RvcnknLCBfX0RvY3VtZW50ID0gX19wcmVmaXggKyAnRG9jdW1lbnQnLCBfX0Rpc3BhdGNoRXZlbnRJbnN0YW5jZSA9IF9fcHJlZml4ICsgJ0Rpc3BhdGNoRXZlbnRJbnN0YW5jZScsIF9fRXJyb3JFdmVudFN0YXRpYyA9IF9fcHJlZml4ICsgJ0Vycm9yRXZlbnRTdGF0aWMnLCBfX0V2ZW50TWFuYWdlclN0YXRpYyA9IF9fcHJlZml4ICsgJ0V2ZW50TWFuYWdlclN0YXRpYycsIF9fTGlmZWN5Y2xlRXZlbnRTdGF0aWMgPSBfX3ByZWZpeCArICdMaWZlY3ljbGVFdmVudFN0YXRpYycsIF9fTGlmZWN5Y2xlRXZlbnRJbnN0YW5jZSA9IF9fcHJlZml4ICsgJ0xpZmVjeWNsZUV2ZW50SW5zdGFuY2UnLCBfX0xvZyA9IF9fcHJlZml4ICsgJ0xvZycsIF9fUGFyc2VyID0gX19wcmVmaXggKyAnUGFyc2VyJywgX19SZWdleCA9IF9fcHJlZml4ICsgJ1JlZ2V4JywgX19Ub2tlbml6ZXIgPSBfX3ByZWZpeCArICdUb2tlbml6ZXInLCBfX05hdmlnYXRvckluc3RhbmNlID0gX19wcmVmaXggKyAnTmF2aWdhdG9ySW5zdGFuY2UnLCBfX0NvbnRleHRNYW5hZ2VyU3RhdGljID0gX19wcmVmaXggKyAnQ29udGV4dE1hbmFnZXJTdGF0aWMnLCBfX0NvbnRleHRNYW5hZ2VySW5zdGFuY2UgPSBfX3ByZWZpeCArICdDb250ZXh0TWFuYWdlckluc3RhbmNlJywgX19Db21waWxlciA9IF9fcHJlZml4ICsgJ0NvbXBpbGVyJywgX19Db21tZW50TWFuYWdlckZhY3RvcnkgPSBfX3ByZWZpeCArICdDb21tZW50TWFuYWdlckZhY3RvcnknLCBfX0NvbW1lbnRNYW5hZ2VySW5zdGFuY2UgPSBfX3ByZWZpeCArICdDb21tZW50TWFuYWdlckluc3RhbmNlJywgX19FbGVtZW50TWFuYWdlckZhY3RvcnkgPSBfX3ByZWZpeCArICdFbGVtZW50TWFuYWdlckZhY3RvcnknLCBfX0VsZW1lbnRNYW5hZ2VySW5zdGFuY2UgPSBfX3ByZWZpeCArICdFbGVtZW50TWFuYWdlckluc3RhbmNlJywgX19Ob2RlTWFuYWdlclN0YXRpYyA9IF9fcHJlZml4ICsgJ05vZGVNYW5hZ2VyU3RhdGljJywgX19UZXh0TWFuYWdlckZhY3RvcnkgPSBfX3ByZWZpeCArICdUZXh0TWFuYWdlckZhY3RvcnknLCBfX1RleHRNYW5hZ2VySW5zdGFuY2UgPSBfX3ByZWZpeCArICdUZXh0TWFuYWdlckluc3RhbmNlJywgX19DYWNoZUZhY3RvcnkgPSBfX3ByZWZpeCArICdDYWNoZUZhY3RvcnknLCBfX01hbmFnZXJDYWNoZSA9IF9fcHJlZml4ICsgJ01hbmFnZXJDYWNoZScsIF9fVGVtcGxhdGVDYWNoZSA9IF9fcHJlZml4ICsgJ1RlbXBsYXRlQ2FjaGUnLCBfX0FuaW1hdG9yID0gX19wcmVmaXggKyAnQW5pbWF0b3InLCBfX0F0dHJpYnV0ZXNGYWN0b3J5ID0gX19wcmVmaXggKyAnQXR0cmlidXRlc0ZhY3RvcnknLCBfX0F0dHJpYnV0ZXNJbnN0YW5jZSA9IF9fcHJlZml4ICsgJ0F0dHJpYnV0ZXNJbnN0YW5jZScsIF9fQmluZGFibGVUZW1wbGF0ZXNGYWN0b3J5ID0gX19wcmVmaXggKyAnQmluZGFibGVUZW1wbGF0ZXNGYWN0b3J5JywgX19Eb20gPSBfX3ByZWZpeCArICdEb20nLCBfX0RvbUV2ZW50cyA9IF9fcHJlZml4ICsgJ0RvbUV2ZW50cycsIF9fSURvbUV2ZW50c0NvbmZpZyA9IF9fcHJlZml4ICsgJ0lEb21FdmVudHNDb25maWcnLCBfX0RvbUV2ZW50SW5zdGFuY2UgPSBfX3ByZWZpeCArICdEb21FdmVudEluc3RhbmNlJywgX19SZXNvdXJjZXNGYWN0b3J5ID0gX19wcmVmaXggKyAnUmVzb3VyY2VzRmFjdG9yeScsIF9fUmVzb3VyY2VzSW5zdGFuY2UgPSBfX3ByZWZpeCArICdSZXNvdXJjZXNJbnN0YW5jZScsIF9fVGVtcGxhdGVDb250cm9sRmFjdG9yeSA9IF9fcHJlZml4ICsgJ1RlbXBsYXRlQ29udHJvbEZhY3RvcnknLCBfX1RlbXBsYXRlQ29udHJvbEluc3RhbmNlID0gX19wcmVmaXggKyAnVGVtcGxhdGVDb250cm9sSW5zdGFuY2UnLCBfX1V0aWxzID0gX19wcmVmaXggKyAnVXRpbHMnLCBfX0Jyb3dzZXIgPSBfX3ByZWZpeCArICdCcm93c2VyJywgX19Ccm93c2VyQ29uZmlnID0gX19wcmVmaXggKyAnQnJvd3NlckNvbmZpZycsIF9fUm91dGVyID0gX19wcmVmaXggKyAnUm91dGVyJywgX19Sb3V0ZXJTdGF0aWMgPSBfX3ByZWZpeCArICdSb3V0ZXJTdGF0aWMnLCBfX1VybFV0aWxzSW5zdGFuY2UgPSBfX3ByZWZpeCArICdVcmxVdGlsc0luc3RhbmNlJywgX19XaW5kb3cgPSBfX3ByZWZpeCArICdXaW5kb3cnLCBfX0xvY2FsU3RvcmFnZSA9IF9fcHJlZml4ICsgJ0xvY2FsU3RvcmFnZScsIF9fU2Vzc2lvblN0b3JhZ2UgPSBfX3ByZWZpeCArICdTZXNzaW9uU3RvcmFnZScsIF9fR2VvbG9jYXRpb24gPSBfX3ByZWZpeCArICdHZW9sb2NhdGlvbicsIF9fQmFzZVNlZ21lbnRGYWN0b3J5ID0gX19wcmVmaXggKyAnQmFzZVNlZ21lbnRGYWN0b3J5JywgX19CYXNlU2VnbWVudEluc3RhbmNlID0gX19wcmVmaXggKyAnQmFzZVNlZ21lbnRJbnN0YW5jZScsIF9fU3RhdGljU2VnbWVudEluc3RhbmNlID0gX19wcmVmaXggKyAnU3RhdGljU2VnbWVudEluc3RhbmNlJywgX19WYXJpYWJsZVNlZ21lbnRJbnN0YW5jZSA9IF9fcHJlZml4ICsgJ1ZhcmlhYmxlU2VnbWVudEluc3RhbmNlJywgX19EeW5hbWljU2VnbWVudEluc3RhbmNlID0gX19wcmVmaXggKyAnRHluYW1pY1NlZ21lbnRJbnN0YW5jZScsIF9fU3BsYXRTZWdtZW50SW5zdGFuY2UgPSBfX3ByZWZpeCArICdTcGxhdFNlZ21lbnRJbnN0YW5jZScsIF9fU3RhdGVTdGF0aWMgPSBfX3ByZWZpeCArICdTdGF0ZVN0YXRpYycsIF9fU3RhdGVJbnN0YW5jZSA9IF9fcHJlZml4ICsgJ1N0YXRlSW5zdGFuY2UnLCBfX1JvdXRlUmVjb2duaXplckluc3RhbmNlID0gX19wcmVmaXggKyAnUm91dGVSZWNvZ25pemVySW5zdGFuY2UnLCBfX0luamVjdG9yU3RhdGljID0gX19wcmVmaXggKyAnSW5qZWN0b3JTdGF0aWMnLCBfX0hpc3RvcnkgPSBfX3ByZWZpeCArICdIaXN0b3J5JywgX19Mb2NhdGlvbiA9IF9fcHJlZml4ICsgJ0xvY2F0aW9uJywgXHJcbiAgICAvKipcclxuICAgICAqL1xyXG4gICAgX19QbGF0ID0gJ3BsYXQtJywgX19CaW5kID0gX19QbGF0ICsgJ2JpbmQnLCBfX0hyZWYgPSBfX1BsYXQgKyAnaHJlZicsIF9fU3JjID0gX19QbGF0ICsgJ3NyYycsIF9fS2V5RG93biA9IF9fUGxhdCArICdrZXlkb3duJywgX19LZXlQcmVzcyA9IF9fUGxhdCArICdrZXlwcmVzcycsIF9fS2V5VXAgPSBfX1BsYXQgKyAna2V5dXAnLCBfX0NoYXJQcmVzcyA9IF9fUGxhdCArICdjaGFycHJlc3MnLCBfX05hbWUgPSBfX1BsYXQgKyAnbmFtZScsIF9fT3B0aW9ucyA9IF9fUGxhdCArICdvcHRpb25zJywgX19DaGVja2VkID0gX19QbGF0ICsgJ2NoZWNrZWQnLCBfX0Rpc2FibGVkID0gX19QbGF0ICsgJ2Rpc2FibGVkJywgX19TZWxlY3RlZCA9IF9fUGxhdCArICdzZWxlY3RlZCcsIF9fUmVhZE9ubHkgPSBfX1BsYXQgKyAncmVhZG9ubHknLCBfX1Zpc2libGUgPSBfX1BsYXQgKyAndmlzaWJsZScsIF9fU3R5bGUgPSBfX1BsYXQgKyAnc3R5bGUnLCBfX1RhcCA9IF9fUGxhdCArICd0YXAnLCBfX0JsdXIgPSBfX1BsYXQgKyAnYmx1cicsIF9fQ2hhbmdlID0gX19QbGF0ICsgJ2NoYW5nZScsIF9fQ29weSA9IF9fUGxhdCArICdjb3B5JywgX19DdXQgPSBfX1BsYXQgKyAnY3V0JywgX19QYXN0ZSA9IF9fUGxhdCArICdwYXN0ZScsIF9fRGJsVGFwID0gX19QbGF0ICsgJ2RibHRhcCcsIF9fRm9jdXMgPSBfX1BsYXQgKyAnZm9jdXMnLCBfX1N1Ym1pdCA9IF9fUGxhdCArICdzdWJtaXQnLCBfX1RvdWNoU3RhcnQgPSBfX1BsYXQgKyAndG91Y2hzdGFydCcsIF9fVG91Y2hFbmQgPSBfX1BsYXQgKyAndG91Y2hlbmQnLCBfX1RvdWNoTW92ZSA9IF9fUGxhdCArICd0b3VjaG1vdmUnLCBfX1RvdWNoQ2FuY2VsID0gX19QbGF0ICsgJ3RvdWNoY2FuY2VsJywgX19Ib2xkID0gX19QbGF0ICsgJ2hvbGQnLCBfX1JlbGVhc2UgPSBfX1BsYXQgKyAncmVsZWFzZScsIF9fU3dpcGUgPSBfX1BsYXQgKyAnc3dpcGUnLCBfX1N3aXBlTGVmdCA9IF9fUGxhdCArICdzd2lwZWxlZnQnLCBfX1N3aXBlUmlnaHQgPSBfX1BsYXQgKyAnc3dpcGVyaWdodCcsIF9fU3dpcGVVcCA9IF9fUGxhdCArICdzd2lwZXVwJywgX19Td2lwZURvd24gPSBfX1BsYXQgKyAnc3dpcGVkb3duJywgX19UcmFjayA9IF9fUGxhdCArICd0cmFjaycsIF9fVHJhY2tMZWZ0ID0gX19QbGF0ICsgJ3RyYWNrbGVmdCcsIF9fVHJhY2tSaWdodCA9IF9fUGxhdCArICd0cmFja3JpZ2h0JywgX19UcmFja1VwID0gX19QbGF0ICsgJ3RyYWNrdXAnLCBfX1RyYWNrRG93biA9IF9fUGxhdCArICd0cmFja2Rvd24nLCBfX1RyYWNrRW5kID0gX19QbGF0ICsgJ3RyYWNrZW5kJywgX19SZWFjdCA9IF9fUGxhdCArICdyZWFjdCcsIF9fTGluayA9IF9fUGxhdCArICdsaW5rJywgX19Gb3JFYWNoID0gX19QbGF0ICsgJ2ZvcmVhY2gnLCBfX0h0bWwgPSBfX1BsYXQgKyAnaHRtbCcsIF9fSWYgPSBfX1BsYXQgKyAnaWYnLCBfX0lnbm9yZSA9IF9fUGxhdCArICdpZ25vcmUnLCBfX1NlbGVjdCA9IF9fUGxhdCArICdzZWxlY3QnLCBfX1RlbXBsYXRlID0gX19QbGF0ICsgJ3RlbXBsYXRlJywgX19Sb3V0ZXBvcnQgPSBfX1BsYXQgKyAncm91dGVwb3J0JywgX19WaWV3cG9ydCA9IF9fUGxhdCArICd2aWV3cG9ydCcsIF9fQ29udHJvbCA9IF9fUGxhdCArICdjb250cm9sJywgX19WaWV3Q29udHJvbCA9IF9fUGxhdCArICd2aWV3Y29udHJvbCcsIF9fUmVzb3VyY2VzID0gX19QbGF0ICsgJ3Jlc291cmNlcycsIF9fQ29udGV4dCA9IF9fUGxhdCArIF9fQ09OVEVYVCwgX19UZW1wbGF0ZUNvbnRleHQgPSBfX1RlbXBsYXRlICsgJy0nICsgX19DT05URVhULCBfX0NhbGxiYWNrID0gX19QbGF0ICsgJ2NhbGxiYWNrJywgX19BdHRyaWJ1dGVQcmVmaXggPSAnZGF0YS0nLCBcclxuICAgIC8qKlxyXG4gICAgICovXHJcbiAgICBfX1RlbXBsYXRlQ29udHJvbENhY2hlID0gJ19fdGVtcGxhdGVDb250cm9sQ2FjaGUnLCBfX0hlYWQgPSAnaGVhZCcsIF9fTWV0YSA9ICdtZXRhJywgX19UaXRsZSA9ICd0aXRsZScsIF9fRGVzY3JpcHRpb24gPSAnZGVzY3JpcHRpb24nLCBfX0F1dGhvciA9ICdhdXRob3InLCBfX0NyZWF0b3IgPSAnY3JlYXRvcicsIF9fTWV0YUxpbmsgPSAnbGluaycsIF9fTWV0YUhyZWYgPSAnaHJlZicsIF9fTWV0YU5hbWUgPSAnbmFtZScsIF9fTWV0YVByb3BlcnR5ID0gJ3Byb3BlcnR5JywgX19NZXRhSW1hZ2UgPSAnaW1hZ2UnLCBfX01ldGFWaWRlbyA9ICd2aWRlbycsIF9fTWV0YVR5cGUgPSAndHlwZScsIF9fUmVsID0gJ3JlbCcsIF9fVXJsID0gJ3VybCcsIF9fQXJ0aWNsZSA9ICdhcnRpY2xlOicsIF9fT3BlbkdyYXBoID0gJ29nOicsIF9fVHdpdHRlciA9ICd0d2l0dGVyOicsIF9fQ29udGVudCA9ICdjb250ZW50JywgXHJcbiAgICAvKipcclxuICAgICAqL1xyXG4gICAgX19yZWFkeSA9ICdyZWFkeScsIF9fc3VzcGVuZCA9ICdzdXNwZW5kJywgX19yZXN1bWUgPSAncmVzdW1lJywgX19vbmxpbmUgPSAnb25saW5lJywgX19vZmZsaW5lID0gJ29mZmxpbmUnLCBfX2Vycm9yID0gJ2Vycm9yJywgX19zaHV0ZG93biA9ICdzaHV0ZG93bicsIF9fZXhpdGluZyA9ICdleGl0aW5nJywgX19iZWZvcmVMb2FkID0gJ2JlZm9yZUxvYWQnLCBcclxuICAgIC8qKlxyXG4gICAgICovXHJcbiAgICBfX2JlZm9yZU5hdmlnYXRlID0gJ2JlZm9yZU5hdmlnYXRlJywgX19uYXZpZ2F0ZWQgPSAnbmF2aWdhdGVkJywgX19uYXZpZ2F0aW5nID0gJ25hdmlnYXRpbmcnLCBfX2JlZm9yZVJvdXRlQ2hhbmdlID0gJ2JlZm9yZVJvdXRlQ2hhbmdlJywgX19yb3V0ZUNoYW5nZWQgPSAncm91dGVDaGFuZ2VkJywgX191cmxDaGFuZ2VkID0gJ3VybENoYW5nZWQnLCBcclxuICAgIC8qKlxyXG4gICAgICovXHJcbiAgICBfX3BhdXNlID0gJ3BhdXNlJywgX19kZXZpY2VSZWFkeSA9ICdkZXZpY2VSZWFkeScsIF9fYmFja0J1dHRvbiA9ICdiYWNrYnV0dG9uJywgX19iYWNrQ2xpY2sgPSAnYmFja2NsaWNrJywgX19iYWNrQnV0dG9uUHJlc3NlZCA9ICdiYWNrQnV0dG9uUHJlc3NlZCcsIFxyXG4gICAgLyoqXHJcbiAgICAgKi9cclxuICAgIF9fSGlkZSA9IF9fUGxhdCArICdoaWRlJywgX19BbmltYXRpbmcgPSBfX1BsYXQgKyAnYW5pbWF0aW5nJywgX19TaW1wbGVBbmltYXRpb24gPSBfX1BsYXQgKyAnYW5pbWF0aW9uJywgX19TaW1wbGVUcmFuc2l0aW9uID0gX19QbGF0ICsgJ3RyYW5zaXRpb24nLCBfX0VudGVyID0gX19QbGF0ICsgJ2VudGVyJywgX19MZWF2ZSA9IF9fUGxhdCArICdsZWF2ZScsIF9fTW92ZSA9IF9fUGxhdCArICdtb3ZlJywgX19GYWRlSW4gPSBfX1BsYXQgKyAnZmFkZWluJywgX19GYWRlT3V0ID0gX19QbGF0ICsgJ2ZhZGVvdXQnLCBfX05hdmlnYXRpbmdCYWNrID0gX19QbGF0ICsgJ2JhY2stbmF2JywgXHJcbiAgICAvKipcclxuICAgICAqL1xyXG4gICAgX19ldmVudF9wcmVmaXggPSAnJCcsIF9fdGFwID0gX19ldmVudF9wcmVmaXggKyAndGFwJywgX19kYmx0YXAgPSBfX2V2ZW50X3ByZWZpeCArICdkYmx0YXAnLCBfX3RvdWNoc3RhcnQgPSBfX2V2ZW50X3ByZWZpeCArICd0b3VjaHN0YXJ0JywgX190b3VjaGVuZCA9IF9fZXZlbnRfcHJlZml4ICsgJ3RvdWNoZW5kJywgX190b3VjaG1vdmUgPSBfX2V2ZW50X3ByZWZpeCArICd0b3VjaG1vdmUnLCBfX3RvdWNoY2FuY2VsID0gX19ldmVudF9wcmVmaXggKyAndG91Y2hjYW5jZWwnLCBfX2hvbGQgPSBfX2V2ZW50X3ByZWZpeCArICdob2xkJywgX19yZWxlYXNlID0gX19ldmVudF9wcmVmaXggKyAncmVsZWFzZScsIF9fc3dpcGUgPSBfX2V2ZW50X3ByZWZpeCArICdzd2lwZScsIF9fc3dpcGVsZWZ0ID0gX19ldmVudF9wcmVmaXggKyAnc3dpcGVsZWZ0JywgX19zd2lwZXJpZ2h0ID0gX19ldmVudF9wcmVmaXggKyAnc3dpcGVyaWdodCcsIF9fc3dpcGV1cCA9IF9fZXZlbnRfcHJlZml4ICsgJ3N3aXBldXAnLCBfX3N3aXBlZG93biA9IF9fZXZlbnRfcHJlZml4ICsgJ3N3aXBlZG93bicsIF9fdHJhY2sgPSBfX2V2ZW50X3ByZWZpeCArICd0cmFjaycsIF9fdHJhY2tsZWZ0ID0gX19ldmVudF9wcmVmaXggKyAndHJhY2tsZWZ0JywgX190cmFja3JpZ2h0ID0gX19ldmVudF9wcmVmaXggKyAndHJhY2tyaWdodCcsIF9fdHJhY2t1cCA9IF9fZXZlbnRfcHJlZml4ICsgJ3RyYWNrdXAnLCBfX3RyYWNrZG93biA9IF9fZXZlbnRfcHJlZml4ICsgJ3RyYWNrZG93bicsIF9fdHJhY2tlbmQgPSBfX2V2ZW50X3ByZWZpeCArICd0cmFja2VuZCcsIFxyXG4gICAgLyoqXHJcbiAgICAgKi9cclxuICAgIF9fZXJyb3JTdWZmaXggPSAnRXJyb3InLCBfX3BsYXRFcnJvciA9ICdQbGF0JyArIF9fZXJyb3JTdWZmaXgsIF9fcGFyc2VFcnJvciA9ICdQYXJzaW5nJyArIF9fZXJyb3JTdWZmaXgsIF9fYmluZEVycm9yID0gJ0JpbmRpbmcnICsgX19lcnJvclN1ZmZpeCwgX19jb21waWxlRXJyb3IgPSAnQ29tcGlsaW5nJyArIF9fZXJyb3JTdWZmaXgsIF9fbmFtZUVycm9yID0gJ1BsYXROYW1lJyArIF9fZXJyb3JTdWZmaXgsIF9fbmF2aWdhdGlvbkVycm9yID0gJ05hdmlnYXRpbmcnICsgX19lcnJvclN1ZmZpeCwgX190ZW1wbGF0ZUVycm9yID0gJ1RlbXBsYXRpbmcnICsgX19lcnJvclN1ZmZpeCwgX19jb250ZXh0RXJyb3IgPSAnQ29udGV4dCcgKyBfX2Vycm9yU3VmZml4LCBfX2V2ZW50RXJyb3IgPSAnRGlzcGF0Y2hFdmVudCcgKyBfX2Vycm9yU3VmZml4LCBfX2luamVjdGFibGVFcnJvciA9ICdJbmplY3RhYmxlJyArIF9fZXJyb3JTdWZmaXgsIF9fQ29tcGF0RXJyb3IgPSAnQ29tcGF0aWJpbGl0eScgKyBfX2Vycm9yU3VmZml4LCBcclxuICAgIC8qKlxyXG4gICAgICovXHJcbiAgICBfX2ZvckVhY2hBbGlhc09wdGlvbnMgPSB7XHJcbiAgICAgICAgaW5kZXg6ICdpbmRleCcsXHJcbiAgICAgICAgZXZlbjogJ2V2ZW4nLFxyXG4gICAgICAgIG9kZDogJ29kZCcsXHJcbiAgICAgICAgZmlyc3Q6ICdmaXJzdCcsXHJcbiAgICAgICAgbGFzdDogJ2xhc3QnXHJcbiAgICB9LCBcclxuICAgIC8qKlxyXG4gICAgICovXHJcbiAgICBfX0JBU0VfU0VHTUVOVF9UWVBFID0gJ2Jhc2UnLCBfX1ZBUklBQkxFX1NFR01FTlRfVFlQRSA9ICd2YXJpYWJsZScsIF9fU1RBVElDX1NFR01FTlRfVFlQRSA9ICdzdGF0aWMnLCBfX1NQTEFUX1NFR01FTlRfVFlQRSA9ICdzcGxhdCcsIF9fRFlOQU1JQ19TRUdNRU5UX1RZUEUgPSAnZHluYW1pYycsIFxyXG4gICAgLyoqXHJcbiAgICAgKi9cclxuICAgIF9fQ09OVEVYVF9DSEFOR0VEX1BSSU9SSVRZID0gMTAwMCwgX19zdGFydFN5bWJvbCA9ICd7eycsIF9fZW5kU3ltYm9sID0gJ319JywgX19TVEFUSUMgPSAnc3RhdGljJywgX19TSU5HTEVUT04gPSAnc2luZ2xldG9uJywgX19JTlNUQU5DRSA9ICdpbnN0YW5jZScsIF9fRkFDVE9SWSA9ICdmYWN0b3J5JywgX19DTEFTUyA9ICdjbGFzcycsIF9fQ1NTID0gJ2NzcycsIF9fQ09NUElMRUQgPSAnLWNvbXBpbGVkJywgX19CT1VORF9QUkVGSVggPSAnLUAnLCBfX0lOSVRfU1VGRklYID0gJy1pbml0JywgX19TVEFSVF9OT0RFID0gJzogc3RhcnQgbm9kZScsIF9fRU5EX05PREUgPSAnOiBlbmQgbm9kZScsIF9fUE9QU1RBVEUgPSAncG9wc3RhdGUnLCBfX0hBU0hDSEFOR0UgPSAnaGFzaGNoYW5nZScsIF9fV1JBUFBFRF9JTkpFQ1RPUiA9ICd3cmFwcGVkJywgX19KU09OUF9DQUxMQkFDSyA9ICdwbGF0X2NhbGxiYWNrJywgX19KUyA9ICdqcycsIF9fTk9PUF9JTkpFQ1RPUiA9ICdub29wJywgX19BUFAgPSAnX19hcHBfXycsIF9fUkVTT1VSQ0UgPSAncmVzb3VyY2UnLCBfX1JFU09VUkNFUyA9IF9fUkVTT1VSQ0UgKyAncycsIF9fQUxJQVMgPSAnYWxpYXMnLCBfX0FMSUFTRVMgPSBfX0FMSUFTICsgJ2VzJywgX19PQlNFUlZBQkxFX1JFU09VUkNFID0gJ29ic2VydmFibGUnLCBfX0lOSkVDVEFCTEVfUkVTT1VSQ0UgPSAnaW5qZWN0YWJsZScsIF9fT0JKRUNUX1JFU09VUkNFID0gJ29iamVjdCcsIF9fRlVOQ1RJT05fUkVTT1VSQ0UgPSAnZnVuY3Rpb24nLCBfX0xJVEVSQUxfUkVTT1VSQ0UgPSAnbGl0ZXJhbCcsIF9fUk9PVF9SRVNPVVJDRSA9ICdyb290JywgX19ST09UX0NPTlRFWFRfUkVTT1VSQ0UgPSAncm9vdENvbnRleHQnLCBfX0NPTlRST0xfUkVTT1VSQ0UgPSAnY29udHJvbCcsIF9fQ09OVEVYVF9SRVNPVVJDRSA9IF9fQ09OVEVYVDtcclxuICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLXVudXNlZC12YXJpYWJsZSAqL1xyXG4gICAgdmFyIF9fX1Byb21pc2UsIF9fX2NvbXBhdCwgX19jYW1lbENhc2VSZWdleCwgX19jYXBpdGFsQ2FzZVJlZ2V4LCBfX25hdGl2ZUlzQXJyYXkgPSAhIUFycmF5LmlzQXJyYXk7XHJcbiAgICB2YXIgX191aWRzID0ge30sIF9fb2JqVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLCBfX3RvU3RyaW5nQ2xhc3MgPSAnW29iamVjdCAnLCBfX2Vycm9yQ2xhc3MgPSBfX3RvU3RyaW5nQ2xhc3MgKyAnRXJyb3JdJywgX19maWxlQ2xhc3MgPSBfX3RvU3RyaW5nQ2xhc3MgKyAnRmlsZV0nLCBfX2FycmF5Q2xhc3MgPSBfX3RvU3RyaW5nQ2xhc3MgKyAnQXJyYXldJywgX19ib29sQ2xhc3MgPSBfX3RvU3RyaW5nQ2xhc3MgKyAnQm9vbGVhbl0nLCBfX2RhdGVDbGFzcyA9IF9fdG9TdHJpbmdDbGFzcyArICdEYXRlXScsIF9fZnVuY0NsYXNzID0gX190b1N0cmluZ0NsYXNzICsgJ0Z1bmN0aW9uXScsIF9fbnVtYmVyQ2xhc3MgPSBfX3RvU3RyaW5nQ2xhc3MgKyAnTnVtYmVyXScsIF9fb2JqZWN0Q2xhc3MgPSBfX3RvU3RyaW5nQ2xhc3MgKyAnT2JqZWN0XScsIF9fcmVnZXhwQ2xhc3MgPSBfX3RvU3RyaW5nQ2xhc3MgKyAnUmVnRXhwXScsIF9fc3RyaW5nQ2xhc3MgPSBfX3RvU3RyaW5nQ2xhc3MgKyAnU3RyaW5nXScsIF9fcHJvbWlzZUNsYXNzID0gX190b1N0cmluZ0NsYXNzICsgJ1Byb21pc2VdJywgX19vYmplY3RUeXBlcyA9IHtcclxuICAgICAgICAnYm9vbGVhbic6IGZhbHNlLFxyXG4gICAgICAgICdmdW5jdGlvbic6IHRydWUsXHJcbiAgICAgICAgJ29iamVjdCc6IHRydWUsXHJcbiAgICAgICAgJ251bWJlcic6IGZhbHNlLFxyXG4gICAgICAgICdzdHJpbmcnOiBmYWxzZSxcclxuICAgICAgICAndW5kZWZpbmVkJzogZmFsc2VcclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBub29wKCkgeyB9XHJcbiAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlLCBlbnVtZXJhYmxlLCBjb25maWd1cmFibGUsIHdyaXRhYmxlKSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XHJcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogZW51bWVyYWJsZSA9PT0gdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBjb25maWd1cmFibGUgPT09IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB3cml0YWJsZSA9PT0gdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gX2RlZmluZUdldHRlcihvYmosIGtleSwgdmFsdWUsIGVudW1lcmFibGUsIGNvbmZpZ3VyYWJsZSkge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlOyB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBlbnVtZXJhYmxlID09PSB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGNvbmZpZ3VyYWJsZSA9PT0gdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gX2V4dGVuZChkZWVwLCByZWRlZmluZSwgZGVzdGluYXRpb24pIHtcclxuICAgICAgICB2YXIgc291cmNlcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMzsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHNvdXJjZXNbX2kgLSAzXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc051bGwoZGVzdGluYXRpb24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkZXN0aW5hdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGtleXMsIHByb3BlcnR5LCBkZWZpbmU7XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ocmVkZWZpbmUpKSB7XHJcbiAgICAgICAgICAgIGRlZmluZSA9IHJlZGVmaW5lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyZWRlZmluZSkge1xyXG4gICAgICAgICAgICBkZWZpbmUgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRlZmluZSA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0VtcHR5KHNvdXJjZXMpKSB7XHJcbiAgICAgICAgICAgIHNvdXJjZXMucHVzaChkZXN0aW5hdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSwgaykge1xyXG4gICAgICAgICAgICBpZiAoIWlzT2JqZWN0KHNvdXJjZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcclxuICAgICAgICAgICAgZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHNvdXJjZVtrZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlZXApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShwcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2V4dGVuZChkZWVwLCBkZWZpbmUsIGRlc3RpbmF0aW9uW2tleV0gfHwgKGRlc3RpbmF0aW9uW2tleV0gPSBbXSksIHByb3BlcnR5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0RhdGUocHJvcGVydHkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluZShkZXN0aW5hdGlvbiwga2V5LCBuZXcgRGF0ZShwcm9wZXJ0eS5nZXRUaW1lKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1JlZ0V4cChwcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lKGRlc3RpbmF0aW9uLCBrZXksIG5ldyBSZWdFeHAocHJvcGVydHkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc05vZGUocHJvcGVydHkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluZShkZXN0aW5hdGlvbiwga2V5LCBwcm9wZXJ0eS5jbG9uZU5vZGUodHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRmlsZShwcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lKGRlc3RpbmF0aW9uLCBrZXksIHByb3BlcnR5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc09iamVjdChwcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2V4dGVuZChkZWVwLCBkZWZpbmUsIGRlc3RpbmF0aW9uW2tleV0gfHwgKGRlc3RpbmF0aW9uW2tleV0gPSB7fSksIHByb3BlcnR5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlZmluZShkZXN0aW5hdGlvbiwga2V5LCBwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgIH0sIGtleXMpO1xyXG4gICAgICAgIH0sIHNvdXJjZXMpO1xyXG4gICAgICAgIHJldHVybiBkZXN0aW5hdGlvbjtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIF9jbG9uZShvYmosIGRlZXApIHtcclxuICAgICAgICBpZiAoIWlzT2JqZWN0KG9iaikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNEYXRlKG9iaikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG9iai5nZXRUaW1lKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1JlZ0V4cChvYmopKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzTm9kZShvYmopKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmouY2xvbmVOb2RlKGRlZXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0ZpbGUob2JqKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0Vycm9yKG9iaikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBvYmouY29uc3RydWN0b3Iob2JqLm1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdHlwZSA9IHt9O1xyXG4gICAgICAgIGlmIChpc0FycmF5KG9iaikpIHtcclxuICAgICAgICAgICAgdHlwZSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNCb29sZWFuKGRlZXApICYmIGRlZXApIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9leHRlbmQodHJ1ZSwgZmFsc2UsIHR5cGUsIG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfZXh0ZW5kKGZhbHNlLCBmYWxzZSwgdHlwZSwgb2JqKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzRXJyb3Iob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fb2JqVG9TdHJpbmcuY2FsbChvYmopID09PSBfX2Vycm9yQ2xhc3M7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcclxuICAgICAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCc7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc1dpbmRvdyhvYmopIHtcclxuICAgICAgICByZXR1cm4gISEob2JqICYmIG9iai5kb2N1bWVudCAmJiBvYmouc2V0SW50ZXJ2YWwpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNEb2N1bWVudChvYmopIHtcclxuICAgICAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzTm9kZShvYmopIHtcclxuICAgICAgICByZXR1cm4gISEob2JqICYmIHR5cGVvZiBvYmoubm9kZVR5cGUgPT09ICdudW1iZXInKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzRG9jdW1lbnRGcmFnbWVudChvYmopIHtcclxuICAgICAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzRmlsZShvYmopIHtcclxuICAgICAgICByZXR1cm4gaXNPYmplY3Qob2JqKSAmJiBfX29ialRvU3RyaW5nLmNhbGwob2JqKSA9PT0gX19maWxlQ2xhc3M7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ3N0cmluZycgfHwgaXNPYmplY3Qob2JqKSAmJiBfX29ialRvU3RyaW5nLmNhbGwob2JqKSA9PT0gX19zdHJpbmdDbGFzcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzUmVnRXhwKG9iaikge1xyXG4gICAgICAgIHJldHVybiBpc09iamVjdChvYmopICYmIF9fb2JqVG9TdHJpbmcuY2FsbChvYmopID09PSBfX3JlZ2V4cENsYXNzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNQcm9taXNlKG9iaikge1xyXG4gICAgICAgIHJldHVybiBpc09iamVjdChvYmopICYmIChfX29ialRvU3RyaW5nLmNhbGwob2JqKSA9PT0gX19wcm9taXNlQ2xhc3MgfHwgaXNGdW5jdGlvbihvYmoudGhlbikpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcclxuICAgICAgICBpZiAoaXNOdWxsKG9iaikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1N0cmluZyhvYmopIHx8IGlzQXJyYXkob2JqKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc09iamVjdChvYmopKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKG9iaikge1xyXG4gICAgICAgIHJldHVybiBvYmogPT09IHRydWUgfHwgb2JqID09PSBmYWxzZSB8fCBpc09iamVjdChvYmopICYmIF9fb2JqVG9TdHJpbmcuY2FsbChvYmopID09PSBfX2Jvb2xDbGFzcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKG9iaikge1xyXG4gICAgICAgIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ251bWJlcicgfHwgaXNPYmplY3Qob2JqKSAmJiBfX29ialRvU3RyaW5nLmNhbGwob2JqKSA9PT0gX19udW1iZXJDbGFzcykgJiYgIWlzTmFOKG9iaik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNOdWxsKG9iaikge1xyXG4gICAgICAgIHJldHVybiBvYmogPT09IG51bGwgfHwgb2JqID09PSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZChvYmopIHtcclxuICAgICAgICByZXR1cm4gb2JqID09PSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc0FycmF5KG9iaikge1xyXG4gICAgICAgIGlmIChfX25hdGl2ZUlzQXJyYXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9fb2JqVG9TdHJpbmcuY2FsbChvYmopID09PSBfX2FycmF5Q2xhc3M7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc0FycmF5TGlrZShvYmopIHtcclxuICAgICAgICBpZiAoaXNOdWxsKG9iaikgfHwgaXNXaW5kb3cob2JqKSB8fCBpc0Z1bmN0aW9uKG9iaikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaXNTdHJpbmcob2JqKSB8fCBvYmoubGVuZ3RoID49IDA7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc0RhdGUob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIF9fb2JqVG9TdHJpbmcuY2FsbChvYmopID09PSBfX2RhdGVDbGFzcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZpbHRlcihpdGVyYXRvciwgb2JqLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGFyciA9IFtdO1xyXG4gICAgICAgIGlmIChpc051bGwob2JqKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihvYmouZmlsdGVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqLmZpbHRlcihpdGVyYXRvciwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXksIG9iaikge1xyXG4gICAgICAgICAgICBpZiAoaXRlcmF0b3IodmFsdWUsIGtleSwgb2JqKSkge1xyXG4gICAgICAgICAgICAgICAgYXJyLnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgb2JqKTtcclxuICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gd2hlcmUocHJvcGVydGllcywgb2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuICFzb21lKGZ1bmN0aW9uIChwcm9wZXJ0eSwga2V5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVba2V5XSAhPT0gcHJvcGVydHk7XHJcbiAgICAgICAgICAgIH0sIHByb3BlcnRpZXMpO1xyXG4gICAgICAgIH0sIG9iaik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmb3JFYWNoKGl0ZXJhdG9yLCBvYmosIGNvbnRleHQpIHtcclxuICAgICAgICBpZiAoaXNOdWxsKG9iaikgfHwgIShpc09iamVjdChvYmopIHx8IGlzQXJyYXlMaWtlKG9iaikpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpLCBrZXksIGxlbmd0aDtcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihvYmouZm9yRWFjaCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XHJcbiAgICAgICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB3aGlsZSAoa2V5cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXlzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXksIG9iaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1hcChpdGVyYXRvciwgb2JqLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGFyciA9IFtdO1xyXG4gICAgICAgIGlmIChpc051bGwob2JqKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihvYmoubWFwKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqLm1hcChpdGVyYXRvciwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcclxuICAgICAgICAgICAgYXJyLnB1c2goaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwga2V5LCBvYmopKTtcclxuICAgICAgICB9LCBvYmopO1xyXG4gICAgICAgIHJldHVybiBhcnI7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBtYXBBc3luYyhpdGVyYXRvciwgb2JqLCBjb250ZXh0KSB7XHJcbiAgICAgICAgX19fUHJvbWlzZSA9IF9fX1Byb21pc2UgfHwgcGxhdC5hY3F1aXJlKF9fUHJvbWlzZSk7XHJcbiAgICAgICAgcmV0dXJuIF9fX1Byb21pc2UuYWxsKG1hcChpdGVyYXRvciwgb2JqLCBjb250ZXh0KSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBtYXBBc3luY1dpdGhPcmRlcihpdGVyYXRvciwgYXJyYXksIGNvbnRleHQsIGRlc2NlbmRpbmcpIHtcclxuICAgICAgICBfX19Qcm9taXNlID0gX19fUHJvbWlzZSB8fCBwbGF0LmFjcXVpcmUoX19Qcm9taXNlKTtcclxuICAgICAgICB2YXIgaW5pdGlhbFZhbHVlID0gX19fUHJvbWlzZS5yZXNvbHZlKFtdKTtcclxuICAgICAgICBpZiAoIWlzQXJyYXkoYXJyYXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbml0aWFsVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGl0ZXJhdG9yID0gaXRlcmF0b3IuYmluZChjb250ZXh0KTtcclxuICAgICAgICB2YXIgaW5PcmRlciA9IGZ1bmN0aW9uIChwcmV2aW91c1ZhbHVlLCBuZXh0VmFsdWUsIG5leHRJbmRleCwgYXJyYXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzVmFsdWUudGhlbihmdW5jdGlvbiAoaXRlbXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcihuZXh0VmFsdWUsIG5leHRJbmRleCwgYXJyYXkpLnRoZW4oZnVuY3Rpb24gKG1vcmVJdGVtcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtcy5jb25jYXQobW9yZUl0ZW1zKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChkZXNjZW5kaW5nID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcnJheS5yZWR1Y2VSaWdodChpbk9yZGVyLCBpbml0aWFsVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJyYXkucmVkdWNlKGluT3JkZXIsIGluaXRpYWxWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBtYXBBc3luY0luT3JkZXIoaXRlcmF0b3IsIGFycmF5LCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIG1hcEFzeW5jV2l0aE9yZGVyKGl0ZXJhdG9yLCBhcnJheSwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBtYXBBc3luY0luRGVzY2VuZGluZ09yZGVyKGl0ZXJhdG9yLCBhcnJheSwgY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiBtYXBBc3luY1dpdGhPcmRlcihpdGVyYXRvciwgYXJyYXksIGNvbnRleHQsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcGx1Y2soa2V5LCBvYmopIHtcclxuICAgICAgICByZXR1cm4gbWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfSwgb2JqKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNvbWUoaXRlcmF0b3IsIG9iaiwgY29udGV4dCkge1xyXG4gICAgICAgIGlmIChpc051bGwob2JqKSB8fCBpc0Z1bmN0aW9uKG9iaikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaSwga2V5LCBsZW5ndGgsIHJldDtcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihvYmouc29tZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9iai5zb21lKGl0ZXJhdG9yLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHJldCA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XHJcbiAgICAgICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB3aGlsZSAoa2V5cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXlzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICByZXQgPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXksIG9iaik7XHJcbiAgICAgICAgICAgICAgICBpZiAocmV0ID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcG9zdHBvbmUobWV0aG9kLCBhcmdzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmVyKG1ldGhvZCwgMCwgYXJncywgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkZWZlcihtZXRob2QsIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQpIHtcclxuICAgICAgICBmdW5jdGlvbiBleGVjRGVmZXIoKSB7XHJcbiAgICAgICAgICAgIG1ldGhvZC5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZXhlY0RlZmVyLCB0aW1lb3V0KTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2V0SW50ZXJ2YWxHbG9iYWwobWV0aG9kLCBpbnRlcnZhbCwgYXJncywgY29udGV4dCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGV4ZWNJbnRlcnZhbCgpIHtcclxuICAgICAgICAgICAgbWV0aG9kLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKGV4ZWNJbnRlcnZhbCwgaW50ZXJ2YWwpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlcXVlc3RBbmltYXRpb25GcmFtZUdsb2JhbChtZXRob2QsIGNvbnRleHQpIHtcclxuICAgICAgICBfX19jb21wYXQgPSBfX19jb21wYXQgfHwgKHBsYXQuYWNxdWlyZShfX0NvbXBhdCkpO1xyXG4gICAgICAgIHZhciByZXF1ZXN0QW5pbUZyYW1lID0gX19fY29tcGF0LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcclxuICAgICAgICBpZiAoaXNVbmRlZmluZWQocmVxdWVzdEFuaW1GcmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBvc3Rwb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZC5jYWxsKGNvbnRleHQsIERhdGUubm93KCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFuaW1hdGlvbklkID0gcmVxdWVzdEFuaW1GcmFtZShtZXRob2QuYmluZChjb250ZXh0KSksIGNhbmNlbEFuaW1GcmFtZSA9IF9fX2NvbXBhdC5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCBub29wO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNhbmNlbEFuaW1GcmFtZShhbmltYXRpb25JZCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xyXG4gICAgICAgIGlmIChpc051bGwocHJlZml4KSkge1xyXG4gICAgICAgICAgICBwcmVmaXggPSAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHB1aWQgPSBfX3VpZHNbcHJlZml4XTtcclxuICAgICAgICBpZiAoaXNOdWxsKHB1aWQpKSB7XHJcbiAgICAgICAgICAgIHB1aWQgPSBfX3VpZHNbcHJlZml4XSA9IFsnMCcsICcvJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpbmRleCA9IHB1aWQubGVuZ3RoLCBjaGFyQ29kZTtcclxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xyXG4gICAgICAgICAgICBjaGFyQ29kZSA9IHB1aWRbaW5kZXhdLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgICAgIC8vICc5JyBcclxuICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09PSA1Nykge1xyXG4gICAgICAgICAgICAgICAgcHVpZFtpbmRleF0gPSAnQSc7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gam9pbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vICdaJyBcclxuICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09PSA5MCkge1xyXG4gICAgICAgICAgICAgICAgcHVpZFtpbmRleF0gPSAnYSc7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gam9pbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vICd6JyBcclxuICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09PSAxMjIpIHtcclxuICAgICAgICAgICAgICAgIHB1aWRbaW5kZXhdID0gJzAnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcHVpZFtpbmRleF0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlICsgMSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gam9pbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1aWQudW5zaGlmdCgnMCcpO1xyXG4gICAgICAgIGZ1bmN0aW9uIGpvaW4oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyBwdWlkLmpvaW4oJycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gam9pbigpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2FtZWxDYXNlKHN0cikge1xyXG4gICAgICAgIGlmICghaXNTdHJpbmcoc3RyKSB8fCBpc0VtcHR5KHN0cikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RyID0gc3RyLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xyXG4gICAgICAgIF9fY2FtZWxDYXNlUmVnZXggPSBfX2NhbWVsQ2FzZVJlZ2V4IHx8IHBsYXQuYWNxdWlyZShfX1JlZ2V4KS5jYW1lbENhc2VSZWdleDtcclxuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoX19jYW1lbENhc2VSZWdleCwgZnVuY3Rpb24gKG1hdGNoLCBkZWxpbWl0ZXIsIGNoYXIsIGluZGV4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleCA/IGNoYXIudG9VcHBlckNhc2UoKSA6IGNoYXI7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkZWxpbWl0KHN0ciwgZGVsaW1pdGVyKSB7XHJcbiAgICAgICAgaWYgKCFpc1N0cmluZyhzdHIpIHx8IGlzRW1wdHkoc3RyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc051bGwoZGVsaW1pdGVyKSkge1xyXG4gICAgICAgICAgICBkZWxpbWl0ZXIgPSAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgX19jYXBpdGFsQ2FzZVJlZ2V4ID0gX19jYXBpdGFsQ2FzZVJlZ2V4IHx8IHBsYXQuYWNxdWlyZShfX1JlZ2V4KS5jYXBpdGFsQ2FzZVJlZ2V4O1xyXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShfX2NhcGl0YWxDYXNlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCwgaW5kZXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGluZGV4ID8gZGVsaW1pdGVyICsgbWF0Y2gudG9Mb3dlckNhc2UoKSA6IG1hdGNoLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkZWxldGVQcm9wZXJ0eShvYmosIHByb3BlcnR5KSB7XHJcbiAgICAgICAgaWYgKCFpc051bGwob2JqKSkge1xyXG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby11bnVzZWQtZXhwcmVzc2lvbiAqL1xyXG4gICAgICAgICAgICBkZWxldGUgb2JqW3Byb3BlcnR5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFjY2VzcyhvYmosIHByb3BlcnR5KSB7XHJcbiAgICAgICAgaWYgKGlzTnVsbChvYmopKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYmpbcHJvcGVydHldO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZGVzZXJpYWxpemVRdWVyeShzZWFyY2gpIHtcclxuICAgICAgICBpZiAoaXNFbXB0eShzZWFyY2gpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNwbGl0ID0gc2VhcmNoLnNwbGl0KCcmJyksIHF1ZXJ5ID0ge30sIGxlbmd0aCA9IHNwbGl0Lmxlbmd0aCwgaXRlbTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGl0ZW0gPSBzcGxpdFtpXS5zcGxpdCgnPScpO1xyXG4gICAgICAgICAgICBxdWVyeVtpdGVtWzBdXSA9IGl0ZW1bMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBxdWVyeTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZVF1ZXJ5KHF1ZXJ5KSB7XHJcbiAgICAgICAgdmFyIHEgPSAnJztcclxuICAgICAgICBxICs9IG1hcChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4ga2V5ICsgJz0nICsgdmFsdWU7XHJcbiAgICAgICAgfSwgcXVlcnkpLmpvaW4oJyYnKTtcclxuICAgICAgICBpZiAoIWlzRW1wdHkocSkpIHtcclxuICAgICAgICAgICAgcSA9ICc/JyArIHE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBxO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYm9vbGVhblJlZHVjZSh2YWx1ZXMpIHtcclxuICAgICAgICBpZiAoIWlzQXJyYXkodmFsdWVzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNCb29sZWFuKHZhbHVlcykgPyB2YWx1ZXMgOiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWVzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VycmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJldiAmJiBjdXJyZW50ICE9PSBmYWxzZTtcclxuICAgICAgICB9LCB0cnVlKTtcclxuICAgIH1cclxuICAgIC8qIHRzbGludDplbmFibGU6bm8tdW51c2VkLXZhcmlhYmxlICovXHJcbiAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby11bnVzZWQtdmFyaWFibGUgKi9cclxuICAgIHZhciBfX19kb2N1bWVudCwgX19fdGVtcGxhdGVDYWNoZSwgX19faHR0cCwgX19fbG9nO1xyXG4gICAgdmFyIF9fbm9kZU5hbWVSZWdleCA9IC88KFtcXHc6XSspLywgX193aGl0ZVNwYWNlUmVnZXggPSAvXFxzKy9nLCBfX29wdGlvbiA9IFsxLCAnPHNlbGVjdCBtdWx0aXBsZT1cIm11bHRpcGxlXCI+JywgJzwvc2VsZWN0PiddLCBfX3RhYmxlID0gWzEsICc8dGFibGU+JywgJzwvdGFibGU+J10sIF9fdGFibGVEYXRhID0gWzMsICc8dGFibGU+PHRib2R5Pjx0cj4nLCAnPC90cj48L3Rib2R5PjwvdGFibGU+J10sIF9fc3ZnID0gWzEsICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2ZXJzaW9uPVwiMS4xXCI+JywgJzwvc3ZnPiddLCBfX2lubmVyVGFibGVXcmFwcGVycyA9IHtcclxuICAgICAgICB0aGVhZDogX190YWJsZSxcclxuICAgICAgICB0Ym9keTogX190YWJsZSxcclxuICAgICAgICB0Zm9vdDogX190YWJsZSxcclxuICAgICAgICBjb2xncm91cDogX190YWJsZSxcclxuICAgICAgICBjYXB0aW9uOiBfX3RhYmxlLFxyXG4gICAgICAgIHRyOiBbMiwgJzx0YWJsZT48dGJvZHk+JywgJzwvdGJvZHk+PC90YWJsZT4nXSxcclxuICAgICAgICBjb2w6IFsyLCAnPHRhYmxlPjx0Ym9keT48L3Rib2R5Pjxjb2xncm91cD4nLCAnPC9jb2xncm91cD48L3RhYmxlPiddLFxyXG4gICAgICAgIHRkOiBfX3RhYmxlRGF0YSxcclxuICAgICAgICB0aDogX190YWJsZURhdGFcclxuICAgIH0sIF9faW5uZXJIdG1sV3JhcHBlcnMgPSBfZXh0ZW5kKGZhbHNlLCBmYWxzZSwge30sIF9faW5uZXJUYWJsZVdyYXBwZXJzLCB7XHJcbiAgICAgICAgb3B0aW9uOiBfX29wdGlvbixcclxuICAgICAgICBvcHRncm91cDogX19vcHRpb24sXHJcbiAgICAgICAgbGVnZW5kOiBbMSwgJzxmaWVsZHNldD4nLCAnPC9maWVsZHNldD4nXSxcclxuICAgICAgICBhcmVhOiBbMSwgJzxtYXA+JywgJzwvbWFwPiddLFxyXG4gICAgICAgIHBhcmFtOiBbMSwgJzxvYmplY3Q+JywgJzwvb2JqZWN0PiddLFxyXG4gICAgICAgIHRleHQ6IF9fc3ZnLFxyXG4gICAgICAgIGNpcmNsZTogX19zdmcsXHJcbiAgICAgICAgZWxsaXBzZTogX19zdmcsXHJcbiAgICAgICAgbGluZTogX19zdmcsXHJcbiAgICAgICAgcGF0aDogX19zdmcsXHJcbiAgICAgICAgcG9seWdvbjogX19zdmcsXHJcbiAgICAgICAgcG9seWxpbmU6IF9fc3ZnLFxyXG4gICAgICAgIHJlY3Q6IF9fc3ZnLFxyXG4gICAgICAgIF9kZWZhdWx0OiBbMCwgJycsICcnXVxyXG4gICAgfSk7XHJcbiAgICBmdW5jdGlvbiBhcHBlbmRDaGlsZHJlbihub2RlTGlzdCwgcm9vdCwgY2xvbmUpIHtcclxuICAgICAgICB2YXIgaXNGcmFnbWVudCA9IGlzRG9jdW1lbnRGcmFnbWVudChyb290KSwgbnVsbFJvb3QgPSAhaXNOb2RlKHJvb3QpLCBmcmFnbWVudCA9IGlzRnJhZ21lbnQgP1xyXG4gICAgICAgICAgICByb290IDpcclxuICAgICAgICAgICAgKF9fX2RvY3VtZW50IHx8IChfX19kb2N1bWVudCA9IHBsYXQuYWNxdWlyZShfX0RvY3VtZW50KSkpLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgICAgICBpZiAobnVsbFJvb3QpIHtcclxuICAgICAgICAgICAgcm9vdCA9IGZyYWdtZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbGlzdCA9IGlzQXJyYXkobm9kZUxpc3QpID8gbm9kZUxpc3QgOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChub2RlTGlzdCksIGxlbmd0aCA9IGxpc3QubGVuZ3RoLCBpO1xyXG4gICAgICAgIGlmIChjbG9uZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICB2YXIgaXRlbSA9IHZvaWQgMDtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtID0gbGlzdFtpXS5jbG9uZU5vZGUodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBmcmFnbWVudC5pbnNlcnRCZWZvcmUoaXRlbSwgbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuaW5zZXJ0QmVmb3JlKGxpc3RbaV0sIG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKGlzRnJhZ21lbnQgfHwgbnVsbFJvb3QpKSB7XHJcbiAgICAgICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcm9vdDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNsZWFyTm9kZShub2RlKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChub2RlLmNoaWxkTm9kZXMpO1xyXG4gICAgICAgIHdoaWxlIChjaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzLnBvcCgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjbGVhck5vZGVCbG9jayhub2RlTGlzdCwgcGFyZW50KSB7XHJcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKG5vZGVMaXN0LnB1c2gpKSB7XHJcbiAgICAgICAgICAgIG5vZGVMaXN0ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobm9kZUxpc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzTnVsbChwYXJlbnQpKSB7XHJcbiAgICAgICAgICAgIGNsZWFyTm9kZUJsb2NrV2l0aFBhcmVudChub2RlTGlzdCwgcGFyZW50KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbm9kZTtcclxuICAgICAgICB3aGlsZSAobm9kZUxpc3QubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBub2RlID0gbm9kZUxpc3QucG9wKCk7XHJcbiAgICAgICAgICAgIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgaWYgKGlzTnVsbChwYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2xlYXJOb2RlQmxvY2tXaXRoUGFyZW50KG5vZGVMaXN0LCBwYXJlbnQpIHtcclxuICAgICAgICB3aGlsZSAobm9kZUxpc3QubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQobm9kZUxpc3QucG9wKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHN0cmluZ1RvTm9kZShodG1sKSB7XHJcbiAgICAgICAgLy8gX19fY29tcGF0IGlzIGEgZ2xvYmFsIHZhcmlhYmxlIGluIHV0aWxzZ2xvYmFsIFxyXG4gICAgICAgIF9fX2NvbXBhdCA9IF9fX2NvbXBhdCB8fCAoX19fY29tcGF0ID0gcGxhdC5hY3F1aXJlKF9fQ29tcGF0KSk7XHJcbiAgICAgICAgX19fZG9jdW1lbnQgPSBfX19kb2N1bWVudCB8fCAoX19fZG9jdW1lbnQgPSBwbGF0LmFjcXVpcmUoX19Eb2N1bWVudCkpO1xyXG4gICAgICAgIHZhciBub2RlTmFtZSA9IF9fbm9kZU5hbWVSZWdleC5leGVjKGh0bWwpLCBlbGVtZW50ID0gX19fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgaWYgKGlzTnVsbChub2RlTmFtZSkpIHtcclxuICAgICAgICAgICAgZWxlbWVudCA9IGlubmVySHRtbChlbGVtZW50LCBodG1sKTtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQucmVtb3ZlQ2hpbGQoZWxlbWVudC5sYXN0Q2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0cmltIGh0bWwgc3RyaW5nIFxyXG4gICAgICAgIGh0bWwgPSBodG1sLnRyaW0oKTtcclxuICAgICAgICB2YXIgbWFwVGFnID0gbm9kZU5hbWVbMV07XHJcbiAgICAgICAgaWYgKF9fX2NvbXBhdC5wdXNoU3RhdGUgJiYgaXNVbmRlZmluZWQoX19pbm5lclRhYmxlV3JhcHBlcnNbbWFwVGFnXSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlubmVySHRtbChlbGVtZW50LCBodG1sKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobWFwVGFnID09PSAnYm9keScpIHtcclxuICAgICAgICAgICAgZWxlbWVudCA9IGlubmVySHRtbChfX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdodG1sJyksIGh0bWwpO1xyXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5yZW1vdmVDaGlsZChlbGVtZW50Lmxhc3RDaGlsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB3cmFwcGVyID0gX19pbm5lckh0bWxXcmFwcGVyc1ttYXBUYWddIHx8IF9faW5uZXJIdG1sV3JhcHBlcnMuX2RlZmF1bHQsIGRlcHRoID0gd3JhcHBlclswXSwgcGFyZW50U3RhcnQgPSB3cmFwcGVyWzFdLCBwYXJlbnRFbmQgPSB3cmFwcGVyWzJdO1xyXG4gICAgICAgIGVsZW1lbnQgPSBpbm5lckh0bWwoZWxlbWVudCwgcGFyZW50U3RhcnQgKyBodG1sICsgcGFyZW50RW5kKTtcclxuICAgICAgICB3aGlsZSAoZGVwdGgtLSA+IDApIHtcclxuICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQubGFzdENoaWxkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNldElubmVySHRtbChub2RlLCBodG1sKSB7XHJcbiAgICAgICAgY2xlYXJOb2RlKG5vZGUpO1xyXG4gICAgICAgIGlmIChpc0VtcHR5KGh0bWwpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBzdHJpbmdUb05vZGUoaHRtbCk7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGFwcGVuZENoaWxkcmVuKGVsZW1lbnQuY2hpbGROb2Rlcywgbm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBub2RlLmluc2VydEJlZm9yZShlbGVtZW50LCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpbnNlcnRCZWZvcmUocGFyZW50LCBub2RlcywgZW5kTm9kZSkge1xyXG4gICAgICAgIGlmIChpc051bGwocGFyZW50KSB8fCAhaXNPYmplY3Qobm9kZXMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNVbmRlZmluZWQoZW5kTm9kZSkpIHtcclxuICAgICAgICAgICAgZW5kTm9kZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmcmFnbWVudDtcclxuICAgICAgICBpZiAoaXNOb2RlKG5vZGVzKSkge1xyXG4gICAgICAgICAgICBmcmFnbWVudCA9IG5vZGVzO1xyXG4gICAgICAgICAgICBub2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyYWdtZW50LmNoaWxkTm9kZXMpO1xyXG4gICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGZyYWdtZW50LCBlbmROb2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24obm9kZXMucHVzaCkpIHtcclxuICAgICAgICAgICAgbm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChub2Rlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9fX2RvY3VtZW50ID0gX19fZG9jdW1lbnQgfHwgKF9fX2RvY3VtZW50ID0gcGxhdC5hY3F1aXJlKF9fRG9jdW1lbnQpKTtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xyXG4gICAgICAgIGZyYWdtZW50ID0gX19fZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgZnJhZ21lbnQuaW5zZXJ0QmVmb3JlKG5vZGVzW2ldLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShmcmFnbWVudCwgZW5kTm9kZSk7XHJcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVwbGFjZShub2RlKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZSwgbm9kZXMgPSBpbnNlcnRCZWZvcmUocGFyZW50LCBub2RlLmNoaWxkTm9kZXMsIG5vZGUpO1xyXG4gICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChub2RlKTtcclxuICAgICAgICByZXR1cm4gbm9kZXM7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZXBsYWNlV2l0aChub2RlLCBuZXdOb2RlKSB7XHJcbiAgICAgICAgaWYgKGlzTnVsbChuZXdOb2RlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3Tm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XHJcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzLCBsZW5ndGhfMSA9IGF0dHJpYnV0ZXMubGVuZ3RoLCBhdHRyaWJ1dGUgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoXzE7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlID0gYXR0cmlidXRlc1tpXTtcclxuICAgICAgICAgICAgICAgIG5ld05vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZS5uYW1lLCBhdHRyaWJ1dGUudmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XHJcbiAgICAgICAgaW5zZXJ0QmVmb3JlKG5ld05vZGUsIG5vZGUuY2hpbGROb2Rlcyk7XHJcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZChuZXdOb2RlLCBub2RlKTtcclxuICAgICAgICByZXR1cm4gbmV3Tm9kZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZUh0bWwoaHRtbCkge1xyXG4gICAgICAgIF9fX2RvY3VtZW50ID0gX19fZG9jdW1lbnQgfHwgKF9fX2RvY3VtZW50ID0gcGxhdC5hY3F1aXJlKF9fRG9jdW1lbnQpKTtcclxuICAgICAgICB2YXIgdGVtcGxhdGVFbGVtZW50ID0gX19fZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG4gICAgICAgIGlmICghaXNFbXB0eShodG1sKSkge1xyXG4gICAgICAgICAgICBzZXRJbm5lckh0bWwodGVtcGxhdGVFbGVtZW50LCBodG1sKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlRWxlbWVudDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbW92ZUJldHdlZW4oc3RhcnROb2RlLCBlbmROb2RlKSB7XHJcbiAgICAgICAgaWYgKGlzTnVsbChzdGFydE5vZGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gc3RhcnROb2RlLm5leHRTaWJsaW5nLCBwYXJlbnROb2RlID0gc3RhcnROb2RlLnBhcmVudE5vZGUsIHRlbXBOb2RlO1xyXG4gICAgICAgIGlmIChpc051bGwoZW5kTm9kZSkpIHtcclxuICAgICAgICAgICAgZW5kTm9kZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc051bGwocGFyZW50Tm9kZSkgfHwgKCFpc051bGwoZW5kTm9kZSkgJiYgZW5kTm9kZS5wYXJlbnROb2RlICE9PSBwYXJlbnROb2RlKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSAhPT0gZW5kTm9kZSkge1xyXG4gICAgICAgICAgICB0ZW1wTm9kZSA9IGN1cnJlbnROb2RlLm5leHRTaWJsaW5nO1xyXG4gICAgICAgICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKGN1cnJlbnROb2RlKTtcclxuICAgICAgICAgICAgY3VycmVudE5vZGUgPSB0ZW1wTm9kZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW1vdmVBbGwoc3RhcnROb2RlLCBlbmROb2RlKSB7XHJcbiAgICAgICAgaWYgKGlzTnVsbChzdGFydE5vZGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVtb3ZlQmV0d2VlbihzdGFydE5vZGUsIGVuZE5vZGUpO1xyXG4gICAgICAgIHJlbW92ZU5vZGUoc3RhcnROb2RlKTtcclxuICAgICAgICByZW1vdmVOb2RlKGVuZE5vZGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlubmVySHRtbChlbGVtZW50LCBodG1sKSB7XHJcbiAgICAgICAgX19fY29tcGF0ID0gX19fY29tcGF0IHx8IChfX19jb21wYXQgPSBwbGF0LmFjcXVpcmUoX19Db21wYXQpKTtcclxuICAgICAgICBpZiAoX19fY29tcGF0Lm1zQXBwKSB7XHJcbiAgICAgICAgICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IGh0bWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbGVtZW50O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVtb3ZlTm9kZShub2RlKSB7XHJcbiAgICAgICAgaWYgKCFpc05vZGUobm9kZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcclxuICAgICAgICBpZiAoIWlzTnVsbChwYXJlbnROb2RlKSkge1xyXG4gICAgICAgICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xyXG4gICAgICAgIHZhciBjTmFtZSA9IChlbGVtZW50IHx8IHt9KS5jbGFzc05hbWU7XHJcbiAgICAgICAgaWYgKCFpc1N0cmluZyhjTmFtZSkgfHwgIWlzU3RyaW5nKGNsYXNzTmFtZSkgfHwgY2xhc3NOYW1lID09PSAnJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzcGxpdCA9IGNsYXNzTmFtZS5zcGxpdChfX3doaXRlU3BhY2VSZWdleCksIG5hbWUsIGNsYXNzTmFtZVJlZ2V4O1xyXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZChlbGVtZW50LmNsYXNzTGlzdCkpIHtcclxuICAgICAgICAgICAgaWYgKGlzRW1wdHkoY05hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlsZSAoc3BsaXQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IHNwbGl0LnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZSAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVSZWdleCA9IG5ldyBSZWdFeHAoJ14nICsgbmFtZSArICdcXFxccyt8XFxcXHMrJyArIG5hbWUgKyAnJHxcXFxccysnICsgbmFtZSArICdcXFxccysnLCAnZycpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY2xhc3NOYW1lUmVnZXgudGVzdChjTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgKz0gJyAnICsgbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoc3BsaXQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBuYW1lID0gc3BsaXQuc2hpZnQoKTtcclxuICAgICAgICAgICAgaWYgKG5hbWUgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQobmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcclxuICAgICAgICB2YXIgY05hbWUgPSAoZWxlbWVudCB8fCB7fSkuY2xhc3NOYW1lO1xyXG4gICAgICAgIGlmICghaXNTdHJpbmcoY05hbWUpIHx8ICFpc1N0cmluZyhjbGFzc05hbWUpIHx8IGNsYXNzTmFtZSA9PT0gJycpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3BsaXQgPSBjbGFzc05hbWUuc3BsaXQoX193aGl0ZVNwYWNlUmVnZXgpLCBuYW1lO1xyXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZChlbGVtZW50LmNsYXNzTGlzdCkpIHtcclxuICAgICAgICAgICAgaWYgKGNOYW1lID09PSBjbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gJyc7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUgKHNwbGl0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBzcGxpdC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBjTmFtZSA9IGNOYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoJ14nICsgbmFtZSArICdcXFxccyt8XFxcXHMrJyArIG5hbWUgKyAnJHxcXFxccysnICsgbmFtZSArICdcXFxccysnLCAnZycpLCAnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoc3BsaXQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBuYW1lID0gc3BsaXQuc2hpZnQoKTtcclxuICAgICAgICAgICAgaWYgKG5hbWUgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB0b2dnbGVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcclxuICAgICAgICB2YXIgY05hbWUgPSAoZWxlbWVudCB8fCB7fSkuY2xhc3NOYW1lO1xyXG4gICAgICAgIGlmICghaXNTdHJpbmcoY05hbWUpIHx8ICFpc1N0cmluZyhjbGFzc05hbWUpIHx8IGNsYXNzTmFtZSA9PT0gJycpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3BsaXQgPSBjbGFzc05hbWUuc3BsaXQoX193aGl0ZVNwYWNlUmVnZXgpLCBuYW1lO1xyXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZChlbGVtZW50LmNsYXNzTGlzdCkpIHtcclxuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZVJlZ2V4ID0gdm9pZCAwO1xyXG4gICAgICAgICAgICBpZiAoY05hbWUgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjTmFtZSA9PT0gY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlIChzcGxpdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gc3BsaXQuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChuYW1lICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZVJlZ2V4ID0gbmV3IFJlZ0V4cCgnXicgKyBuYW1lICsgJ1xcXFxzK3xcXFxccysnICsgbmFtZSArICckfFxcXFxzKycgKyBuYW1lICsgJ1xcXFxzKycsICdnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsYXNzTmFtZVJlZ2V4LnRlc3QoY05hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gY05hbWUgPSBjTmFtZS5yZXBsYWNlKGNsYXNzTmFtZVJlZ2V4LCAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSArPSAnICcgKyBuYW1lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKHNwbGl0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgbmFtZSA9IHNwbGl0LnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIGlmIChuYW1lICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVwbGFjZUNsYXNzKGVsZW1lbnQsIG9sZENsYXNzLCBuZXdDbGFzcykge1xyXG4gICAgICAgIHZhciBjTmFtZSA9IChlbGVtZW50IHx8IHt9KS5jbGFzc05hbWU7XHJcbiAgICAgICAgaWYgKCFpc1N0cmluZyhjTmFtZSkgfHwgIWlzU3RyaW5nKG5ld0NsYXNzKSB8fCBuZXdDbGFzcyA9PT0gJycpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNVbmRlZmluZWQoZWxlbWVudC5jbGFzc0xpc3QpKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFydFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXicgKyBvbGRDbGFzcyArICdcXFxccysnLCAnZycpLCBtaWRSZWdleCA9IG5ldyBSZWdFeHAoJ1xcXFxzKycgKyBvbGRDbGFzcyArICdcXFxccysnLCAnZycpLCBlbmRSZWdleCA9IG5ldyBSZWdFeHAoJ1xcXFxzKycgKyBvbGRDbGFzcyArICckJywgJ2cnKTtcclxuICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBjTmFtZS5yZXBsYWNlKHN0YXJ0UmVnZXgsIG5ld0NsYXNzICsgJyAnKVxyXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UobWlkUmVnZXgsICcgJyArIG5ld0NsYXNzICsgJyAnKVxyXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoZW5kUmVnZXgsICcgJyArIG5ld0NsYXNzKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQobmV3Q2xhc3MpO1xyXG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShvbGRDbGFzcyk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBoYXNDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcclxuICAgICAgICB2YXIgY05hbWUgPSAoZWxlbWVudCB8fCB7fSkuY2xhc3NOYW1lO1xyXG4gICAgICAgIGlmICghaXNTdHJpbmcoY05hbWUpIHx8ICFpc1N0cmluZyhjbGFzc05hbWUpIHx8IGNsYXNzTmFtZSA9PT0gJycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3BsaXQgPSBjbGFzc05hbWUuc3BsaXQoX193aGl0ZVNwYWNlUmVnZXgpO1xyXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZChlbGVtZW50LmNsYXNzTGlzdCkpIHtcclxuICAgICAgICAgICAgaWYgKGNOYW1lID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNOYW1lID09PSBjbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBuYW1lXzE7XHJcbiAgICAgICAgICAgIHdoaWxlIChzcGxpdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lXzEgPSBzcGxpdC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCEobmFtZV8xID09PSAnJyB8fCBuZXcgUmVnRXhwKCdeJyArIG5hbWVfMSArICdcXFxcc3xcXFxccycgKyBuYW1lXzEgKyAnJHxcXFxccycgKyBuYW1lXzEgKyAnXFxcXHMnLCAnZycpLnRlc3QoY05hbWUpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKHNwbGl0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgbmFtZSA9IHNwbGl0LnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIGlmICghKG5hbWUgPT09ICcnIHx8IGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0VGVtcGxhdGUodGVtcGxhdGVVcmwpIHtcclxuICAgICAgICBfX190ZW1wbGF0ZUNhY2hlID0gX19fdGVtcGxhdGVDYWNoZSB8fCAoX19fdGVtcGxhdGVDYWNoZSA9IHBsYXQuYWNxdWlyZShfX1RlbXBsYXRlQ2FjaGUpKTtcclxuICAgICAgICBfX19odHRwID0gX19faHR0cCB8fCAoX19faHR0cCA9IHBsYXQuYWNxdWlyZShfX0h0dHApKTtcclxuICAgICAgICByZXR1cm4gX19fdGVtcGxhdGVDYWNoZS5wdXQodGVtcGxhdGVVcmwsIF9fX3RlbXBsYXRlQ2FjaGUucmVhZCh0ZW1wbGF0ZVVybClcclxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICBpZiAoaXNOdWxsKGVycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fX2h0dHAuYWpheCh7IHVybDogdGVtcGxhdGVVcmwgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChzdWNjZXNzKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0RvY3VtZW50RnJhZ21lbnQoc3VjY2VzcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfX190ZW1wbGF0ZUNhY2hlLnB1dCh0ZW1wbGF0ZVVybCwgc3VjY2Vzcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0KHN1Y2Nlc3MpIHx8ICFpc1N0cmluZyhzdWNjZXNzLnJlc3BvbnNlKSkge1xyXG4gICAgICAgICAgICAgICAgX19fbG9nID0gX19fbG9nIHx8IChfX19sb2cgPSBwbGF0LmFjcXVpcmUoX19Mb2cpKTtcclxuICAgICAgICAgICAgICAgIF9fX2xvZy53YXJuKCdObyB0ZW1wbGF0ZSBmb3VuZCBhdCAnICsgdGVtcGxhdGVVcmwpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fX3RlbXBsYXRlQ2FjaGUucHV0KHRlbXBsYXRlVXJsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVTdHJpbmcgPSBzdWNjZXNzLnJlc3BvbnNlO1xyXG4gICAgICAgICAgICBpZiAoaXNFbXB0eSh0ZW1wbGF0ZVN0cmluZy50cmltKCkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX19fdGVtcGxhdGVDYWNoZS5wdXQodGVtcGxhdGVVcmwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfX190ZW1wbGF0ZUNhY2hlLnB1dCh0ZW1wbGF0ZVVybCwgdGVtcGxhdGVTdHJpbmcpO1xyXG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICBwb3N0cG9uZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfX19sb2cgPSBfX19sb2cgfHwgKF9fX2xvZyA9IHBsYXQuYWNxdWlyZShfX0xvZykpO1xyXG4gICAgICAgICAgICAgICAgX19fbG9nLmVycm9yKG5ldyBFcnJvcignRmFpbHVyZSB0byBnZXQgdGVtcGxhdGUgZnJvbSAnICsgdGVtcGxhdGVVcmwgKyAnLicpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB3aGVuUHJlc2VudChjYiwgZWxlbWVudCkge1xyXG4gICAgICAgIGlmICghaXNOb2RlKGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIF9fX2xvZyA9IF9fX2xvZyB8fCAoX19fbG9nID0gcGxhdC5hY3F1aXJlKF9fTG9nKSk7XHJcbiAgICAgICAgICAgIF9fX2xvZy5lcnJvcihuZXcgRXJyb3IoJ0F0dGVtcHRpbmcgdG8gY2hlY2sgRE9NIHByZXNlbmNlIG9mIHNvbWV0aGluZyB0aGF0IGlzblxcJ3QgYSBOb2RlLicpKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9fX2RvY3VtZW50ID0gX19fZG9jdW1lbnQgfHwgKF9fX2RvY3VtZW50ID0gcGxhdC5hY3F1aXJlKF9fRG9jdW1lbnQpKTtcclxuICAgICAgICB2YXIgYm9keSA9IF9fX2RvY3VtZW50LmJvZHk7XHJcbiAgICAgICAgaWYgKGlzTm9kZShlbGVtZW50LnBhcmVudEVsZW1lbnQpICYmIGJvZHkuY29udGFpbnMoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgY2IoKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZW1vdmUgPSBzZXRJbnRlcnZhbEdsb2JhbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChpc05vZGUoZWxlbWVudC5wYXJlbnRFbGVtZW50KSAmJiBib2R5LmNvbnRhaW5zKGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgIGNiKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCAxMDApO1xyXG4gICAgICAgIHJldHVybiByZW1vdmU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB3aGVuVmlzaWJsZShjYiwgZWxlbWVudCkge1xyXG4gICAgICAgIGlmICghaXNOb2RlKGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIF9fX2xvZyA9IF9fX2xvZyB8fCAoX19fbG9nID0gcGxhdC5hY3F1aXJlKF9fTG9nKSk7XHJcbiAgICAgICAgICAgIF9fX2xvZy5lcnJvcihuZXcgRXJyb3IoJ0F0dGVtcHRpbmcgdG8gY2hlY2sgdmlzaWJpbGl0eSBvZiBzb21ldGhpbmcgdGhhdCBpc25cXCd0IGEgTm9kZS4nKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBub29wO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY2xpZW50V2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcclxuICAgICAgICBpZiAoIShpc051bWJlcihjbGllbnRXaWR0aCkgJiYgaXNOdW1iZXIoY2xpZW50SGVpZ2h0KSkpIHtcclxuICAgICAgICAgICAgX19fbG9nID0gX19fbG9nIHx8IChfX19sb2cgPSBwbGF0LmFjcXVpcmUoX19Mb2cpKTtcclxuICAgICAgICAgICAgX19fbG9nLmVycm9yKG5ldyBFcnJvcignQXR0ZW1wdGluZyB0byBjaGVjayB2aXNpYmlsaXR5IG9mIHNvbWV0aGluZyB0aGF0IGlzblxcJ3QgYW4gRWxlbWVudC4nKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBub29wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2xpZW50V2lkdGggPiAwICYmIGNsaWVudEhlaWdodCA+IDApIHtcclxuICAgICAgICAgICAgY2IoKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZW1vdmUgPSBzZXRJbnRlcnZhbEdsb2JhbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmNsaWVudFdpZHRoID4gMCAmJiBlbGVtZW50LmNsaWVudEhlaWdodCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgY2IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIDEwMCk7XHJcbiAgICAgICAgcmV0dXJuIHJlbW92ZTtcclxuICAgIH1cclxuICAgIC8qIHRzbGludDplbmFibGU6bm8tdW51c2VkLXZhcmlhYmxlICovXHJcbiAgICB2YXIgY29udHJvbEluamVjdG9ycyA9IHt9LCB2aWV3Q29udHJvbEluamVjdG9ycyA9IHt9LCBpbnN0YW5jZUluamVjdG9yRGVwZW5kZW5jaWVzID0ge30sIGluamVjdGFibGVJbmplY3RvcnMgPSB7fSwgdW5yZWdpc3RlcmVkSW5qZWN0b3JzID0ge30sIHN0YXRpY0luamVjdG9ycyA9IHt9LCBhbmltYXRpb25JbmplY3RvcnMgPSB7fSwganNBbmltYXRpb25JbmplY3RvcnMgPSB7fTtcclxuICAgIC8qKlxyXG4gICAgICogSG9sZHMgYWxsIHRoZSBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIHJlbGF0ZWQgdG8gcmVnaXN0ZXJpbmcgY29tcG9uZW50cyBmb3IgcGxhdHlwdXMuXHJcbiAgICAgKi9cclxuICAgIHZhciByZWdpc3RlcjtcclxuICAgIChmdW5jdGlvbiAocmVnaXN0ZXIpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZW5lcmljIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhbiBJbmplY3RvciBhbmRcclxuICAgICAgICAgKiBhZGRpbmcgaXQgdG8gYW4gSW5qZWN0b3JPYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LmRlcGVuZGVuY3kuSW5qZWN0b3JPYmplY3Q8YW55Pn0gb2JqIFRoZSBJbmplY3Rvck9iamVjdFxyXG4gICAgICAgICAqIHRvIHdoaWNoIHRvIGFkZCBhbiBJbmplY3Rvci5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSB1c2VkIHRvIHNldC9nZXQgdGhlIEluamVjdG9yIGZyb20gdGhlXHJcbiAgICAgICAgICogSW5qZWN0b3JPYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IFR5cGUgVGhlIGNvbnN0cnVjdG9yIG9yIGZ1bmN0aW9uIGRlZmluaXRpb24gZm9yIHRoZSBJbmplY3Rvci5cclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGRlcGVuZGVuY2llcz8gQW4gYXJyYXkgb2Ygc3RyaW5ncyByZXByZXNlbnRpbmcgdGhlIGRlcGVuZGVuY2llcyBuZWVkZWQgZm9yIHRoZVxyXG4gICAgICAgICAqIEluamVjdG9yLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbmplY3RhYmxlVHlwZT8gVGhlIGluamVjdGFibGUgdHlwZS5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3RhdGljIFRoZSBpbmplY3RhYmxlIHR5cGUgaXMgYSBzdGF0aWMgdHlwZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBhZGQob2JqLCBuYW1lLCBUeXBlLCBkZXBlbmRlbmNpZXMsIGluamVjdGFibGVUeXBlLCBpc1N0YXRpYykge1xyXG4gICAgICAgICAgICB2YXIgaW5qZWN0b3IgPSBvYmpbbmFtZV0gPSBuZXcgZGVwZW5kZW5jeS5JbmplY3RvcihuYW1lLCBUeXBlLCBkZXBlbmRlbmNpZXMsIGluamVjdGFibGVUeXBlKTtcclxuICAgICAgICAgICAgaWYgKGlzU3RhdGljID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0aWNJbmplY3RvcnNbbmFtZV0gPSBpbmplY3RvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVnaXN0ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZ2lzdGVycyB0aGUgSUFwcCB3aXRoIHRoZSBmcmFtZXdvcmsuIFRoZSBmcmFtZXdvcmsgd2lsbCBpbnN0YW50aWF0ZSB0aGUgSUFwcFxyXG4gICAgICAgICAqIHdoZW4gbmVlZGVkLCBhbmQgd2lyZSB1cCB0aGUgQXBwbGljYXRpb24gTGlmZWN5Y2xlIGV2ZW50cy4gVGhlIGRlcGVuZGVuY2llcyBhcnJheSBjb3JyZXNwb25kcyB0byBpbmplY3RhYmxlcyB0aGF0IHdpbGwgYmVcclxuICAgICAgICAgKiBwYXNzZWQgaW50byB0aGUgQ29uc3RydWN0b3Igb2YgdGhlIGFwcC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB5b3VyIGFwcC5cclxuICAgICAgICAgKiBAcGFyYW0ge25ldyAoLi4uYXJnczogYW55W10pID0+IHBsYXQuQXBwfSBUeXBlIFRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIElBcHAuXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBkZXBlbmRlbmNpZXM/IEFuIGFycmF5IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIHRoZSBkZXBlbmRlbmNpZXMgbmVlZGVkIGZvciB0aGUgYXBwIGluamVjdG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGFwcChuYW1lLCBUeXBlLCBkZXBlbmRlbmNpZXMpIHtcclxuICAgICAgICAgICAgdmFyIF9JbmplY3RvciA9IGFjcXVpcmUoX19JbmplY3RvclN0YXRpYyksIF9BcHBTdGF0aWMgPSBhY3F1aXJlKF9fQXBwU3RhdGljKTtcclxuICAgICAgICAgICAgX0FwcFN0YXRpYy5yZWdpc3RlckFwcChuZXcgX0luamVjdG9yKG5hbWUsIFR5cGUsIGRlcGVuZGVuY2llcykpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVnaXN0ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlZ2lzdGVyLmFwcCA9IGFwcDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWdpc3RlcnMgYW4gQ29udHJvbCB3aXRoIHRoZSBmcmFtZXdvcmsuIFRoZSBmcmFtZXdvcmsgd2lsbCBpbnN0YW50aWF0ZSB0aGVcclxuICAgICAgICAgKiBDb250cm9sIHdoZW4gbmVlZGVkLiBUaGUgZGVwZW5kZW5jaWVzIGFycmF5IGNvcnJlc3BvbmRzIHRvIGluamVjdGFibGVzIHRoYXRcclxuICAgICAgICAgKiB3aWxsIGJlIHBhc3NlZCBpbnRvIHRoZSBDb25zdHJ1Y3RvciBvZiB0aGUgY29udHJvbC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgY29udHJvbCB0eXBlLCBjb3JyZXNwb25kaW5nIHRvIHRoZSBIVE1MIG5vdGF0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBDb250cm9sIChlLmcuICdwbGF0LWZvcmVhY2gnKS5cclxuICAgICAgICAgKiBAcGFyYW0ge25ldyAoLi4uYXJnczogYW55W10pID0+IHBsYXQuQ29udHJvbH0gVHlwZSBUaGUgY29uc3RydWN0b3IgZm9yIHRoZSBDb250cm9sLlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gZGVwZW5kZW5jaWVzPyBBbiBhcnJheSBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyB0aGUgZGVwZW5kZW5jaWVzIG5lZWRlZCBmb3IgdGhlIENvbnRyb2xcclxuICAgICAgICAgKiBpbmplY3Rvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBjb250cm9sKG5hbWUsIFR5cGUsIGRlcGVuZGVuY2llcywgaXNTdGF0aWMpIHtcclxuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIENvbnRyb2wgbXVzdCBiZSByZWdpc3RlcmVkIHdpdGggYSBzdHJpbmcgbmFtZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnaGVhZCcpIHtcclxuICAgICAgICAgICAgICAgIGlzU3RhdGljID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYWRkKGNvbnRyb2xJbmplY3RvcnMsIG5hbWUsIFR5cGUsIGRlcGVuZGVuY2llcywgaXNTdGF0aWMgPyBfX1NUQVRJQyA6IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2wgPSBjb250cm9sO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZ2lzdGVycyBhbiBWaWV3Q29udHJvbCB3aXRoIHRoZSBmcmFtZXdvcmsuIFRoZSBmcmFtZXdvcmsgd2lsbFxyXG4gICAgICAgICAqIGluc3RhbnRpYXRlIHRoZSBjb250cm9sIHdoZW4gbmVlZGVkLiBUaGUgZGVwZW5kZW5jaWVzIGFycmF5IGNvcnJlc3BvbmRzIHRvIGluamVjdGFibGVzIHRoYXQgd2lsbCBiZVxyXG4gICAgICAgICAqIHBhc3NlZCBpbnRvIHRoZSBDb25zdHJ1Y3RvciBvZiB0aGUgY29udHJvbC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgY29udHJvbCB0eXBlLCBjb3JyZXNwb25kaW5nIHRvIHRoZSBIVE1MIG5vdGF0aW9uIGZvciBjcmVhdGluZyBhIG5ld1xyXG4gICAgICAgICAqIFZpZXdDb250cm9sLiBVc2VkIGZvciBuYXZpZ2F0aW9uIHRvIHRoZSBzcGVjaWZpZWQgVmlld0NvbnRyb2wuXHJcbiAgICAgICAgICogQHBhcmFtIHtuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBwbGF0LnVpLlZpZXdDb250cm9sfSBUeXBlIFRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIFZpZXdDb250cm9sLlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gZGVwZW5kZW5jaWVzPyBBbiBvcHRpb25hbCBhcnJheSBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyB0aGUgZGVwZW5kZW5jaWVzIG5lZWRlZCBmb3IgdGhlXHJcbiAgICAgICAgICogVmlld0NvbnRyb2wgaW5qZWN0b3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gdmlld0NvbnRyb2wobmFtZSwgVHlwZSwgZGVwZW5kZW5jaWVzKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBWaWV3Q29udHJvbCBtdXN0IGJlIHJlZ2lzdGVyZWQgd2l0aCBhIHN0cmluZyBuYW1lJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFkZCh2aWV3Q29udHJvbEluamVjdG9ycywgbmFtZSwgVHlwZSwgZGVwZW5kZW5jaWVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVnaXN0ZXIudmlld0NvbnRyb2wgPSB2aWV3Q29udHJvbDtcclxuICAgICAgICBmdW5jdGlvbiBpbmplY3RhYmxlKG5hbWUsIFR5cGUsIGRlcGVuZGVuY2llcywgaW5qZWN0YWJsZVR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKCFpc1N0cmluZyhpbmplY3RhYmxlVHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIGluamVjdGFibGVUeXBlID0gX19TSU5HTEVUT047XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpbmplY3RhYmxlVHlwZSA9IGluamVjdGFibGVUeXBlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5qZWN0YWJsZVR5cGUgPT09IF9fRkFDVE9SWSB8fCBpbmplY3RhYmxlVHlwZSA9PT0gX19TVEFUSUMgfHwgaW5qZWN0YWJsZVR5cGUgPT09IF9fQ0xBU1MpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkKGluamVjdGFibGVJbmplY3RvcnMsIG5hbWUsIFR5cGUsIGRlcGVuZGVuY2llcywgaW5qZWN0YWJsZVR5cGUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIShpbmplY3RhYmxlVHlwZSA9PT0gX19TSU5HTEVUT04gfHwgaW5qZWN0YWJsZVR5cGUgPT09IF9fSU5TVEFOQ0UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGluamVjdGFibGUgdHlwZSAnICsgaW5qZWN0YWJsZVR5cGUgKyAnIGR1cmluZyBpbmplY3RhYmxlIHJlZ2lzdHJhdGlvbi4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYWRkKGluamVjdGFibGVJbmplY3RvcnMsIG5hbWUsIFR5cGUsIGRlcGVuZGVuY2llcywgaW5qZWN0YWJsZVR5cGUsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVnaXN0ZXIuaW5qZWN0YWJsZSA9IGluamVjdGFibGU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udGFpbnMgY29uc3RhbnRzIGZvciBpbmplY3RhYmxlIHR5cGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGluamVjdGFibGU7XHJcbiAgICAgICAgKGZ1bmN0aW9uIChpbmplY3RhYmxlKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTdGF0aWMgaW5qZWN0YWJsZXMgd2lsbCBiZSBpbmplY3RlZCBiZWZvcmUgdGhlIGFwcGxpY2F0aW9uIGxvYWRzLiBUaGlzIHByb3ZpZGVzIGEgd2F5IHRvIGNyZWF0ZVxyXG4gICAgICAgICAgICAgKiBhIHN0YXRpYyBjb25zdHJ1Y3RvciBhbmQgbG9hZCBkZXBlbmRlbmNpZXMgaW50byBzdGF0aWMgY2xhc3MgcHJvcGVydGllcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGluamVjdGFibGUuU1RBVElDID0gX19TVEFUSUM7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTaW5nbGV0b24gaW5qZWN0YWJsZXMgd2lsbCBjb250YWluIGEgY29uc3RydWN0b3IuIEEgU2luZ2xldG9uIGluamVjdGFibGUgd2lsbCBiZSBpbnN0YW50aWF0ZWQgb25jZSBhbmRcclxuICAgICAgICAgICAgICogdXNlZCB0aHJvdWdob3V0IHRoZSBhcHBsaWNhdGlvbiBsaWZldGltZS4gSXQgd2lsbCBiZSBpbnN0YW50aWF0ZWQgd2hlbiBhbm90aGVyIGNvbXBvbmVudCBpcyBpbmplY3RlZFxyXG4gICAgICAgICAgICAgKiBhbmQgbGlzdHMgaXQgYXMgYSBkZXBlbmRlbmN5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaW5qZWN0YWJsZS5TSU5HTEVUT04gPSBfX1NJTkdMRVRPTjtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluc3RhbmNlIGluamVjdGFibGVzIHdpbGwgY29udGFpbiBhIGNvbnN0cnVjdG9yLiBBbiBJbnN0YW5jZSBpbmplY3RhYmxlIHdpbGwgYmUgaW5zdGFudGlhdGVkIG11bHRpcGxlIHRpbWVzXHJcbiAgICAgICAgICAgICAqIHRocm91Z2hvdXQgdGhlIGFwcGxpY2F0aW9uIGxpZmV0aW1lLiBJdCB3aWxsIGJlIGluc3RhbnRpYXRlZCB3aGVuZXZlciBhbm90aGVyIGNvbXBvbmVudCBpcyBpbmplY3RlZFxyXG4gICAgICAgICAgICAgKiBhbmQgbGlzdHMgaXQgYXMgYSBkZXBlbmRlbmN5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaW5qZWN0YWJsZS5JTlNUQU5DRSA9IF9fSU5TVEFOQ0U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGYWN0b3J5IGluamVjdGFibGVzIHdpbGwgbm90IGNvbnRhaW4gYSBjb25zdHJ1Y3RvciBidXQgd2lsbCBpbnN0ZWFkIGNvbnRhaW4gYSBtZXRob2QgZm9yIG9idGFpbmluZyBhblxyXG4gICAgICAgICAgICAgKiBpbnN0YW5jZSwgc3VjaCBhcyBnZXRJbnN0YW5jZSgpIG9yIGNyZWF0ZSgpLiBJdCB3aWxsIGJlIGluamVjdGVkIGJlZm9yZSB0aGUgYXBwbGljYXRpb24gbG9hZHMsIHNpbWlsYXIgdG8gYSBTdGF0aWNcclxuICAgICAgICAgICAgICogaW5qZWN0YWJsZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGluamVjdGFibGUuRkFDVE9SWSA9IF9fRkFDVE9SWTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENsYXNzIGluamVjdGFibGVzIGFyZSBlc3NlbnRpYWxseSBhIGRpcmVjdCByZWZlcmVuY2UgdG8gYSBjbGFzcydzIGNvbnN0cnVjdG9yLiBJdCBtYXkgY29udGFpbiBib3RoXHJcbiAgICAgICAgICAgICAqIHN0YXRpYyBhbmQgaW5zdGFuY2UgbWV0aG9kcyBhcyB3ZWxsIGFzIGEgY29uc3RydWN0b3IgZm9yIGNyZWF0aW5nIGEgbmV3IGluc3RhbmNlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaW5qZWN0YWJsZS5DTEFTUyA9IF9fQ0xBU1M7XHJcbiAgICAgICAgfSkoaW5qZWN0YWJsZSA9IHJlZ2lzdGVyLmluamVjdGFibGUgfHwgKHJlZ2lzdGVyLmluamVjdGFibGUgPSB7fSkpO1xyXG4gICAgICAgIGZ1bmN0aW9uIGFuaW1hdGlvbihuYW1lLCBUeXBlLCBkZXBlbmRlbmNpZXMsIGFuaW1hdGlvblR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGFuaW1hdGlvblR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb25UeXBlID0gYW5pbWF0aW9uVHlwZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoYW5pbWF0aW9uVHlwZSA9PT0gX19DU1MgfHwgYW5pbWF0aW9uVHlwZSA9PT0gX19KUykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYW5pbWF0aW9uVHlwZSBcIicgKyBhbmltYXRpb25UeXBlICsgJ1wiIGR1cmluZyBhbmltYXRpb24gcmVnaXN0cmF0aW9uLicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhZGQoKGFuaW1hdGlvblR5cGUgPT09IF9fSlMgPyBqc0FuaW1hdGlvbkluamVjdG9ycyA6IGFuaW1hdGlvbkluamVjdG9ycyksIG5hbWUsIFR5cGUsIGRlcGVuZGVuY2llcywgcmVnaXN0ZXIuaW5qZWN0YWJsZS5JTlNUQU5DRSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlZ2lzdGVyLmFuaW1hdGlvbiA9IGFuaW1hdGlvbjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb250YWlucyBjb25zdGFudHMgZm9yIGFuaW1hdGlvbiB0eXBlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBhbmltYXRpb247XHJcbiAgICAgICAgKGZ1bmN0aW9uIChhbmltYXRpb24pIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgQ1NTIGFuaW1hdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbi5DU1MgPSBfX0NTUztcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgSmF2YVNjcmlwdCBhbmltYXRpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBhbmltYXRpb24uSlMgPSBfX0pTO1xyXG4gICAgICAgIH0pKGFuaW1hdGlvbiA9IHJlZ2lzdGVyLmFuaW1hdGlvbiB8fCAocmVnaXN0ZXIuYW5pbWF0aW9uID0ge30pKTtcclxuICAgIH0pKHJlZ2lzdGVyID0gcGxhdF8xLnJlZ2lzdGVyIHx8IChwbGF0XzEucmVnaXN0ZXIgPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIb2xkcyBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIHJlbGF0ZWQgdG8gZGVwZW5kZW5jeSBpbmplY3Rpb24gY29tcG9uZW50cyBpbiBwbGF0eXB1cy5cclxuICAgICAqL1xyXG4gICAgdmFyIGRlcGVuZGVuY3k7XHJcbiAgICAoZnVuY3Rpb24gKGRlcGVuZGVuY3lfMSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBJbmplY3RvciBjbGFzcyBpcyB1c2VkIGZvciBkZXBlbmRlbmN5IGluamVjdGlvbi4gWW91IGNhbiBjcmVhdGUgYW4gaW5qZWN0b3Igb2JqZWN0LFxyXG4gICAgICAgICAqIHNwZWNpZnkgZGVwZW5kZW5jaWVzIGFuZCBhIGNvbnN0cnVjdG9yIGZvciB5b3VyIGNvbXBvbmVudC4gV2hlbiB0aGUgaW5qZWN0b3Igb2JqZWN0IGlzXHJcbiAgICAgICAgICogJ2luamVjdGVkJyBpdCB3aWxsIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB5b3VyIGNvbXBvbmVudCBhbmQgcGFzcyBpbiB0aGUgZGVwZW5kZW5jaWVzXHJcbiAgICAgICAgICogdG8gdGhlIGNvbnN0cnVjdG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBJbmplY3RvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY29uc3RydWN0b3IgZm9yIGFuIGluamVjdG9yLiBDb252ZXJ0cyBhbnkgbm9uLXN0cmluZyBkZXBlbmRlbmNpZXMgdG8gc3RyaW5ncyB0byBzdXBwb3J0IG1vY2tpbmcgSW5qZWN0b3JzIGR1cmluZyBydW50aW1lLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaW5qZWN0ZWQgdHlwZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtuZXcgKCkgPT4gVH0gQ29uc3RydWN0b3IgVGhlIGNvbnN0cnVjdG9yIG1ldGhvZCBmb3IgdGhlIGNvbXBvbmVudCByZXF1aXJpbmcgdGhlIGRlcGVuZGVuY3lcclxuICAgICAgICAgICAgICogaW5qZWN0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGRlcGVuZGVuY2llcyBBbiBhcnJheSBvZiBzdHJpbmdzIHNwZWNpZnlpbmcgdGhlIGluamVjdGFibGUgZGVwZW5kZW5jaWVzIGZvciB0aGVcclxuICAgICAgICAgICAgICogYXNzb2NpYXRlZCBjb25zdHJ1Y3Rvci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIHR5cGUgb2YgaW5qZWN0b3IsIHVzZWQgZm9yIGluamVjdGFibGVzIHNwZWNpZnlpbmcgYSBpbmplY3RhYmxlVHlwZSBvZlxyXG4gICAgICAgICAgICAgKiBTVEFUSUMsIFNJTkdMRVRPTiwgRkFDVE9SWSwgSU5TVEFOQ0UsIG9yIENMQVNTLiBUaGUgZGVmYXVsdCBpcyBTSU5HTEVUT04uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBJbmplY3RvcihuYW1lLCBDb25zdHJ1Y3RvciwgZGVwZW5kZW5jaWVzLCB0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5Db25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICAgICAgICAgIHZhciBkZXBzID0gdGhpcy5kZXBlbmRlbmNpZXMgPSBJbmplY3Rvci5jb252ZXJ0RGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcyksIGluZGV4ID0gZGVwcy5pbmRleE9mKF9fTk9PUF9JTkpFQ1RPUiksIGNpcmN1bGFyUmVmZXJlbmNlO1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCAnX19pbmplY3Rvck5hbWUnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgJ19faW5qZWN0b3JEZXBlbmRlbmNpZXMnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGRlcHMuc2xpY2UoMCksXHJcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlcGVuZGVuY3lfMiA9IGRlcGVuZGVuY2llc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChkZXBlbmRlbmN5XzIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBkZXBlbmRlbmN5IGZvciAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgKyAnIGF0IGluZGV4ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggKyAnIGlzIHVuZGVmaW5lZCwgZGlkIHlvdSBmb3JnZXQgdG8gaW5jbHVkZSBhIGZpbGU/Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvdWxkIG5vdCByZXNvbHZlIGRlcGVuZGVuY3kgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY3lfMi5zbGljZSg5LCBkZXBlbmRlbmN5XzIuaW5kZXhPZignKCcpKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICcgZm9yICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJy4gQXJlIHlvdSB1c2luZyBhIHN0YXRpYyBpbmplY3RhYmxlIFR5cGU/Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjaXJjdWxhclJlZmVyZW5jZSA9IEluamVjdG9yLl9fZmluZENpcmN1bGFyUmVmZXJlbmNlcyh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhjaXJjdWxhclJlZmVyZW5jZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NpcmN1bGFyIGRlcGVuZGVuY3kgZGV0ZWN0ZWQgZnJvbSAnICsgdGhpcy5uYW1lICsgJyB0byAnICsgY2lyY3VsYXJSZWZlcmVuY2UgKyAnLicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IF9fQXBwU3RhdGljKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIEFwcF8xID0gdGhpcy5pbmplY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlcGVuZGVuY2llcyA9IGRlcHM7XHJcbiAgICAgICAgICAgICAgICAgICAgQXBwXzEuc3RhcnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgYWxsIHN0YXRpYyBpbmplY3RvcnMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBJbmplY3Rvci5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluamVjdG9ycyA9IHN0YXRpY0luamVjdG9ycywga2V5cyA9IE9iamVjdC5rZXlzKGluamVjdG9ycyksIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluamVjdG9yc1trZXlzW2ldXS5pbmplY3QoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN0YXRpY0luamVjdG9ycyA9IHt9O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2F0aGVycyBhbmQgcmV0dXJucyB0aGUgYXJyYXkgb2YgbGlzdGVkIGRlcGVuZGVuY2llcy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBkZXBlbmRlbmNpZXMgVGhlIGFycmF5IG9mIGRlcGVuZGVuY2llcyBzcGVjaWZpZWRcclxuICAgICAgICAgICAgICogYnkgZWl0aGVyIHRoZWlyIENvbnN0cnVjdG9yIG9yIHRoZWlyIHJlZ2lzdGVyZWQgbmFtZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEluamVjdG9yLmdldERlcGVuZGVuY2llcyA9IGZ1bmN0aW9uIChkZXBlbmRlbmNpZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoZGVwZW5kZW5jaWVzKSB8fCBpc0VtcHR5KGRlcGVuZGVuY2llcykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVwcyA9IFtdLCBsZW5ndGggPSBkZXBlbmRlbmNpZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlcHMucHVzaChJbmplY3Rvci5nZXREZXBlbmRlbmN5KGRlcGVuZGVuY2llc1tpXSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlcHM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGaW5kcyBhbmQgcmV0dXJucyB0aGUgZGVwZW5kZW5jeS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IGRlcGVuZGVuY3kgYW4gb2JqZWN0L3N0cmluZyB1c2VkIHRvIGZpbmQgdGhlIGRlcGVuZGVuY3kuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBJbmplY3Rvci5nZXREZXBlbmRlbmN5ID0gZnVuY3Rpb24gKGRlcGVuZGVuY3kpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoZGVwZW5kZW5jeSkgfHwgZGVwZW5kZW5jeSA9PT0gX19OT09QX0lOSkVDVE9SKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEluamVjdG9yLl9fbm9vcCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoSW5qZWN0b3IuaXNJbmplY3RvcihkZXBlbmRlbmN5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXBlbmRlbmN5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEluamVjdG9yLl9fbG9jYXRlSW5qZWN0b3IoZGVwZW5kZW5jeSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDb252ZXJ0cyBkZXBlbmRlbmNpZXMgc3BlY2lmaWVkIGJ5IHRoZWlyIENvbnN0cnVjdG9ycyBpbnRvXHJcbiAgICAgICAgICAgICAqIGVxdWl2YWxlbnQgZGVwZW5kZW5jaWVzIHNwZWNpZmllZCBieSB0aGVpciByZWdpc3RlcmVkIHN0cmluZ1xyXG4gICAgICAgICAgICAgKiBuYW1lLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGRlcGVuZGVuY2llcyBUaGUgYXJyYXkgb2YgZGVwZW5kZW5jaWVzIHNwZWNpZmllZFxyXG4gICAgICAgICAgICAgKiBieSBlaXRoZXIgdGhlaXIgQ29uc3RydWN0b3Igb3IgdGhlaXIgcmVnaXN0ZXJlZCBuYW1lLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgSW5qZWN0b3IuY29udmVydERlcGVuZGVuY2llcyA9IGZ1bmN0aW9uIChkZXBlbmRlbmNpZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNBcnJheShkZXBlbmRlbmNpZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnZlcnQgPSBJbmplY3Rvci5jb252ZXJ0RGVwZW5kZW5jeSwgZGVwcyA9IFtdLCBsZW5ndGggPSBkZXBlbmRlbmNpZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlcHMucHVzaChjb252ZXJ0KGRlcGVuZGVuY2llc1tpXSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlcHM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDb252ZXJ0cyBhIGRlcGVuZGVuY3kgc3BlY2lmaWVkIGJ5IGl0cyBDb25zdHJ1Y3RvcnMgaW50byBhblxyXG4gICAgICAgICAgICAgKiBlcXVpdmFsZW50IGRlcGVuZGVuY3kgc3BlY2lmaWVkIGJ5IGl0cyByZWdpc3RlcmVkIHN0cmluZ1xyXG4gICAgICAgICAgICAgKiBuYW1lLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gZGVwZW5kZW5jeSBUaGUgZGVwZW5kZW5jeSBzcGVjaWZpZWRcclxuICAgICAgICAgICAgICogYnkgZWl0aGVyIGEgQ29uc3RydWN0b3Igb3IgYSByZWdpc3RlcmVkIG5hbWUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBJbmplY3Rvci5jb252ZXJ0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChkZXBlbmRlbmN5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGRlcGVuZGVuY3kpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fTk9PUF9JTkpFQ1RPUjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBJbmplY3Rvci5fX2dldEluamVjdG9yTmFtZShkZXBlbmRlbmN5KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENoZWNrcyBpZiB0aGUgb2JqZWN0IGJlaW5nIHBhc3NlZCBpbiBmdWxmaWxscyB0aGUgcmVxdWlyZW1lbnRzIGZvciBiZWluZyBhbiBJbmplY3Rvci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LmRlcGVuZGVuY3kuSW5qZWN0b3I8YW55Pn0gZGVwZW5kZW5jeSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgSW5qZWN0b3IuaXNJbmplY3RvciA9IGZ1bmN0aW9uIChkZXBlbmRlbmN5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihkZXBlbmRlbmN5LmluamVjdCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAhaXNVbmRlZmluZWQoZGVwZW5kZW5jeS50eXBlKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICFpc1VuZGVmaW5lZChkZXBlbmRlbmN5Lm5hbWUpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIWlzVW5kZWZpbmVkKGRlcGVuZGVuY3kuQ29uc3RydWN0b3IpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgc3RyaW5nIG5hbWUgcmVsYXRlZCB0byBhbiBpbmplY3Rvci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IGRlcGVuZGVuY3kgVGhlIG9iamVjdCB0byBzZWFyY2ggZm9yLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgSW5qZWN0b3IuX19nZXRJbmplY3Rvck5hbWUgPSBmdW5jdGlvbiAoZGVwZW5kZW5jeSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChkZXBlbmRlbmN5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX05PT1BfSU5KRUNUT1I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1N0cmluZyhkZXBlbmRlbmN5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXBlbmRlbmN5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIENvbnN0cnVjdG9yID0gZGVwZW5kZW5jeSwgX2luamVjdCA9IGlzT2JqZWN0KENvbnN0cnVjdG9yLl9pbmplY3QpID8gQ29uc3RydWN0b3IuX2luamVjdCA6IHt9O1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKENvbnN0cnVjdG9yLl9faW5qZWN0b3JOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY3kgPSBDb25zdHJ1Y3Rvci5fX2luamVjdG9yTmFtZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghaXNTdHJpbmcoZGVwZW5kZW5jeSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEluamVjdG9yKGRlcGVuZGVuY3ksIENvbnN0cnVjdG9yLCBfaW5qZWN0LmRlcGVuZGVuY2llcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZmluZCA9IEluamVjdG9yLl9fZmluZEluamVjdG9yLmJpbmQoSW5qZWN0b3IsIGRlcGVuZGVuY3kpLCBpbmplY3RvciA9IGZpbmQoaW5qZWN0YWJsZUluamVjdG9ycykgfHxcclxuICAgICAgICAgICAgICAgICAgICBmaW5kKHVucmVnaXN0ZXJlZEluamVjdG9ycykgfHxcclxuICAgICAgICAgICAgICAgICAgICBmaW5kKHN0YXRpY0luamVjdG9ycykgfHxcclxuICAgICAgICAgICAgICAgICAgICBmaW5kKHZpZXdDb250cm9sSW5qZWN0b3JzKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbmQoY29udHJvbEluamVjdG9ycykgfHxcclxuICAgICAgICAgICAgICAgICAgICBmaW5kKGFuaW1hdGlvbkluamVjdG9ycykgfHxcclxuICAgICAgICAgICAgICAgICAgICBmaW5kKGpzQW5pbWF0aW9uSW5qZWN0b3JzKTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNPYmplY3QoaW5qZWN0b3IpICYmIGlzU3RyaW5nKGRlcGVuZGVuY3kpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0b3IgPSB1bnJlZ2lzdGVyZWRJbmplY3RvcnNbZGVwZW5kZW5jeV0gPSBuZXcgSW5qZWN0b3IoZGVwZW5kZW5jeSwgQ29uc3RydWN0b3IsIENvbnN0cnVjdG9yLl9pbmplY3QuZGVwZW5kZW5jaWVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChpbmplY3RvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5qZWN0b3IubmFtZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBfX05PT1BfSU5KRUNUT1I7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDYWxscyB0aGUgaW5qZWN0b3IncyBjb25zdHJ1Y3RvciB3aXRoIHRoZSBhc3NvY2lhdGVkIGRlcGVuZGVuY2llcy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IENvbnN0cnVjdG9yIFRoZSBDb25zdHJ1Y3RvciB0byBjYWxsLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBjb25zdHJ1Y3Rvci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEluamVjdG9yLl9fY29uc3RydWN0ID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBhcmdzLCB0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKENvbnN0cnVjdG9yKSB8fCBpc051bGwoQ29uc3RydWN0b3IucHJvdG90eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKENvbnN0cnVjdG9yLnByb3RvdHlwZSksIGlzSW5zdGFuY2UgPSB0eXBlID09PSBfX0lOU1RBTkNFLCB0b0luamVjdDtcclxuICAgICAgICAgICAgICAgIGlmIChpc0luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9JbmplY3QgPSBpbnN0YW5jZUluamVjdG9yRGVwZW5kZW5jaWVzW0NvbnN0cnVjdG9yLl9faW5qZWN0b3JOYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghaXNPYmplY3QodG9JbmplY3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9JbmplY3QgPSBJbmplY3Rvci5fX3dhbGsob2JqLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSwge30pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSW5qZWN0b3JEZXBlbmRlbmNpZXNbQ29uc3RydWN0b3IuX19pbmplY3Rvck5hbWVdID0gdG9JbmplY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGRlcGVuZGVuY2llcyA9IGFjcXVpcmUobWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH0sIHRvSW5qZWN0KSksIGtleXMgPSBPYmplY3Qua2V5cyh0b0luamVjdCksIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXlzW2ldXSA9IGRlcGVuZGVuY2llc1tpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciByZXQgPSBvYmouY29uc3RydWN0b3IuYXBwbHkob2JqLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQocmV0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2Fsa3MgdXAgYW4gb2JqZWN0J3MgcHJvdG90eXBlLCBpbmplY3RpbmcgZGVwZW5kZW5jaWVzIGlmIHRoZXkgYXJlXHJcbiAgICAgICAgICAgICAqIHJlZ2lzdGVyZWQgb24gc3RhdGljICdfaW5qZWN0JyBvYmplY3RzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2JqIFRoZSBvYmplY3QgdG8gd2Fsay5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IHByb3RvIHRoZSBwcm90b3R5cGUgb2YgdGhlIG9iamVjdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEluamVjdG9yLl9fd2FsayA9IGZ1bmN0aW9uIChvYmosIHByb3RvLCBleHRlbmRXaXRoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSBwcm90by5jb25zdHJ1Y3RvciwgcGFyZW50SW5qZWN0ID0ge307XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QoQ29uc3RydWN0b3IuX2luamVjdCkgJiYgQ29uc3RydWN0b3IgIT09IE9iamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEluamVjdCA9IEluamVjdG9yLl9fd2FsayhvYmosIE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byksIGV4dGVuZFdpdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHRvSW5qZWN0ID0gX2Nsb25lKENvbnN0cnVjdG9yLl9pbmplY3QsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9leHRlbmQoZmFsc2UsIGZhbHNlLCB7fSwgZXh0ZW5kV2l0aCwgcGFyZW50SW5qZWN0LCB0b0luamVjdCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGaW5kcyBhbiBpbmplY3RvciBvYmplY3Qgd2l0aCB0aGUgYXNzb2NpYXRlZCBjb25zdHJ1Y3Rvci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IENvbnN0cnVjdG9yIFRoZSBDb25zdHJ1Y3RvciB0byBsb2NhdGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBJbmplY3Rvci5fX2xvY2F0ZUluamVjdG9yID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKENvbnN0cnVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBkZXBlbmRlbmN5ID0gQ29uc3RydWN0b3I7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcoQ29uc3RydWN0b3IuX19pbmplY3Rvck5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jeSA9IENvbnN0cnVjdG9yLl9faW5qZWN0b3JOYW1lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGZpbmQgPSBJbmplY3Rvci5fX2ZpbmRJbmplY3Rvci5iaW5kKEluamVjdG9yLCBkZXBlbmRlbmN5KSwgaW5qZWN0b3IgPSBmaW5kKGluamVjdGFibGVJbmplY3RvcnMpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZmluZCh1bnJlZ2lzdGVyZWRJbmplY3RvcnMpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZmluZChzdGF0aWNJbmplY3RvcnMpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZmluZChjb250cm9sSW5qZWN0b3JzKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbmQodmlld0NvbnRyb2xJbmplY3RvcnMpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZmluZChhbmltYXRpb25JbmplY3RvcnMpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZmluZChqc0FuaW1hdGlvbkluamVjdG9ycyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzT2JqZWN0KGluamVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKENvbnN0cnVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzU3RyaW5nKGRlcGVuZGVuY3kpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmN5ID0gdW5pcXVlSWQoX19QbGF0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmplY3RvciA9IG5ldyBJbmplY3RvcihkZXBlbmRlbmN5LCBDb25zdHJ1Y3RvciwgaXNPYmplY3QoQ29uc3RydWN0b3IuX2luamVjdCkgPyBDb25zdHJ1Y3Rvci5faW5qZWN0b3JEZXBlbmRlbmNpZXMgOiBbXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVucmVnaXN0ZXJlZEluamVjdG9yc1tkZXBlbmRlbmN5XSA9IGluamVjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5qZWN0b3IgPSBJbmplY3Rvci5fX3dyYXAoQ29uc3RydWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBpbmplY3RvcjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEZpbmRzIGFuIGluamVjdG9yIG9iamVjdCB3aXRoIHRoZSBhc3NvY2lhdGVkIGNvbnN0cnVjdG9yIGluIHRoZSBnaXZlbiBJbmplY3Rvck9iamVjdC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gQ29uc3RydWN0b3IgVGhlIEZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBJbmplY3Rvci5fX2ZpbmRJbmplY3RvciA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgaW5qZWN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKENvbnN0cnVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKENvbnN0cnVjdG9yID09PSBJbmplY3RvciB8fCBDb25zdHJ1Y3RvciA9PT0gX19JbmplY3RvclN0YXRpYykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBJbmplY3Rvci5fX3dyYXAoSW5qZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldC5uYW1lID0gX19JbmplY3RvclN0YXRpYztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNTdHJpbmcoQ29uc3RydWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluamVjdG9yc1tDb25zdHJ1Y3Rvcl0gfHwgaW5qZWN0b3JzW0NvbnN0cnVjdG9yLnRvTG93ZXJDYXNlKCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogT25jZSBhbiBpbmplY3RvciBpcyBpbmplY3RlZCwgaXQgaXMgd3JhcHBlZCB0byBwcmV2ZW50IGZ1cnRoZXIgaW5qZWN0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIGluamVjdGVkIHZhbHVlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgSW5qZWN0b3IuX193cmFwID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGluamVjdDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWU7IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogX19XUkFQUEVEX0lOSkVDVE9SLFxyXG4gICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgQ29uc3RydWN0b3I6IHZhbHVlXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyBhbiBlbXB0eSBpbmplY3RvciBvYmplY3QuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBJbmplY3Rvci5fX25vb3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGluamVjdDogbm9vcCxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBfX05PT1BfSU5KRUNUT1IsXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogX19OT09QX0lOSkVDVE9SLFxyXG4gICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgQ29uc3RydWN0b3I6IG5vb3BcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZXJlIGlzIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSBpbiBhIGRlcGVuZGVuY3kgdHJlZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LmRlcGVuZGVuY3kuSW5qZWN0b3I8YW55Pn0gaW5qZWN0b3IgVGhlIHN0YXJ0aW5nIHBvaW50IGZvciB0aGUgZGVwZW5kZW5jeSB0cmVlIHNlYXJjaC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEluamVjdG9yLl9fZmluZENpcmN1bGFyUmVmZXJlbmNlcyA9IGZ1bmN0aW9uIChpbmplY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoaXNPYmplY3QoaW5qZWN0b3IpICYmIGlzQXJyYXkoaW5qZWN0b3IuZGVwZW5kZW5jaWVzKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gaW5qZWN0b3IubmFtZSwgZGVwZW5kZW5jaWVzID0gaW5qZWN0b3IuZGVwZW5kZW5jaWVzLCBub2RlLCBzdGFjayA9IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHNvdXJjZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzOiBkZXBlbmRlbmNpZXMuc2xpY2UoMClcclxuICAgICAgICAgICAgICAgICAgICB9XSwgZGVwZW5kZW5jeSwgbG9jYXRlID0gSW5qZWN0b3IuX19sb2NhdGVJbmplY3RvciwgbGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gc3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzID0gbm9kZS5kZXBlbmRlbmNpZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gZGVwZW5kZW5jaWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXBlbmRlbmN5ID09PSBzb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLm5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5qZWN0b3IgPSBsb2NhdGUoZGVwZW5kZW5jeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGlzT2JqZWN0KGluamVjdG9yKSAmJiBpc0FycmF5KGluamVjdG9yLmRlcGVuZGVuY2llcykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGluamVjdG9yLm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXM6IGluamVjdG9yLmRlcGVuZGVuY2llcy5zbGljZSgwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHYXRoZXJzIHRoZSBkZXBlbmRlbmNpZXMgZm9yIHRoZSBJbmplY3RvciBvYmplY3QgYW5kIGNyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlXHJcbiAgICAgICAgICAgICAqIENvbnN0cnVjdG9yLCBwYXNzaW5nIGluIHRoZSBkZXBlbmRlbmNpZXMgaW4gdGhlIG9yZGVyIHRoZXkgd2VyZSBzcGVjaWZpZWQuIElmIHRoZVxyXG4gICAgICAgICAgICAgKiBJbmplY3RvciBjb250YWlucyBhIENvbnN0cnVjdG9yIGZvciBhbiBpbmplY3RhYmxlIGFuZCB0aGUgQ29uc3RydWN0b3IgaXMgcmVnaXN0ZXJlZFxyXG4gICAgICAgICAgICAgKiBhcyBhIFNJTkdMRSB0eXBlIGl0IHdpbGwgb25seSBpbmplY3QgdGhhdCBpbmplY3RhYmxlIG9uY2UuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBJbmplY3Rvci5wcm90b3R5cGUuaW5qZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRvSW5qZWN0ID0gW10sIHR5cGUgPSB0aGlzLnR5cGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVwZW5kZW5jaWVzID0gdGhpcy5kZXBlbmRlbmNpZXMsIGxlbmd0aCA9IGRlcGVuZGVuY2llcy5sZW5ndGgsIGRlcGVuZGVuY3ksIGluamVjdGFibGU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jeSA9IEluamVjdG9yLmdldERlcGVuZGVuY3koZGVwZW5kZW5jaWVzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB0b0luamVjdC5wdXNoKGRlcGVuZGVuY3kuaW5qZWN0KCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5qZWN0YWJsZSA9IEluamVjdG9yLl9fY29uc3RydWN0KHRoaXMuQ29uc3RydWN0b3IsIHRvSW5qZWN0LCB0eXBlKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyh0eXBlKSAmJiB0eXBlICE9PSBfX0lOU1RBTkNFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd3JhcEluamVjdG9yKGluamVjdGFibGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5qZWN0YWJsZS5fX2luamVjdGFibGVfX3R5cGUgPSB0eXBlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluamVjdGFibGU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXcmFwcyB0aGUgaW5qZWN0b3Igd2l0aCB0aGUgaW5zdGFudGlhdGVkIHZhbHVlIGluIHRoZSBjYXNlIG9mIGFcclxuICAgICAgICAgICAgICogU0lOR0xFIG9yIFNUQVRJQyB0eXBlIHNvIHRoYXQgaXQgZG9lcyBub3QgcmUtaW5zdGFudGlhdGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgSW5qZWN0b3IucHJvdG90eXBlLl93cmFwSW5qZWN0b3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5qZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIEluamVjdG9yO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgZGVwZW5kZW5jeV8xLkluamVjdG9yID0gSW5qZWN0b3I7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHVibGljYWxseSBleHBvc2VzIGFsbCB0aGUgZGVwZW5kZW5jeSBpbmplY3RvciBvYmplY3RzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBpbmplY3RvcnM7XHJcbiAgICAgICAgKGZ1bmN0aW9uIChpbmplY3RvcnMpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFuIEluamVjdG9yT2JqZWN0IG9mIENvbnRyb2xzLlxyXG4gICAgICAgICAgICAgKiBDb250YWlucyBhbGwgdGhlIHJlZ2lzdGVyZWQgY29udHJvbHMgZm9yIGFuIGFwcGxpY2F0aW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaW5qZWN0b3JzLmNvbnRyb2wgPSBjb250cm9sSW5qZWN0b3JzO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQW4gSW5qZWN0b3JPYmplY3Qgb2YgSUJhc2VWaWV3Q29udHJvbHMuXHJcbiAgICAgICAgICAgICAqIENvbnRhaW5zIGFsbCB0aGUgcmVnaXN0ZXJlZCB2aWV3IGNvbnRyb2xzIGZvciBhbiBhcHBsaWNhdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGluamVjdG9ycy52aWV3Q29udHJvbCA9IHZpZXdDb250cm9sSW5qZWN0b3JzO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQW4gSW5qZWN0b3JPYmplY3Qgb2Ygb2JqZWN0cy4gQ29udGFpbnMgYWxsIHRoZSByZWdpc3RlcmVkXHJcbiAgICAgICAgICAgICAqIGluamVjdGFibGVzIGZvciBhbiBhcHBsaWNhdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGluamVjdG9ycy5pbmplY3RhYmxlID0gaW5qZWN0YWJsZUluamVjdG9ycztcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFuIEluamVjdG9yT2JqZWN0IG9mIHN0YXRpYyBvYmplY3RzLiBDb250YWlucyBhbGwgdGhlIHJlZ2lzdGVyZWRcclxuICAgICAgICAgICAgICogc3RhdGljIGluamVjdGFibGVzIGZvciBhbiBhcHBsaWNhdGlvbi4gT25jZSB0aGUgaW5qZWN0YWJsZXMgaGF2ZSBiZWVuIGluamVjdGVkLCB0aGV5IGFyZSByZW1vdmVkIGZyb20gdGhpcyBvYmplY3QuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpbmplY3RvcnMuc3RhdGljSW5qZWN0YWJsZSA9IHN0YXRpY0luamVjdG9ycztcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFuIEluamVjdG9yT2JqZWN0IG9mIGFuaW1hdGlvbnMuIENhbiBiZSBlaXRoZXIgQ1NTIG9yIEpTIGltcGxlbWVudGF0aW9ucy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGluamVjdG9ycy5hbmltYXRpb24gPSBhbmltYXRpb25JbmplY3RvcnM7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBbiBJbmplY3Rvck9iamVjdCAgb2YgYW5pbWF0aW9ucy4gU2hvdWxkIG9ubHkgY29udGFpbiBKUyBpbXBsZW1lbnRhdGlvbnMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpbmplY3RvcnMuanNBbmltYXRpb24gPSBqc0FuaW1hdGlvbkluamVjdG9ycztcclxuICAgICAgICB9KShpbmplY3RvcnMgPSBkZXBlbmRlbmN5XzEuaW5qZWN0b3JzIHx8IChkZXBlbmRlbmN5XzEuaW5qZWN0b3JzID0ge30pKTtcclxuICAgIH0pKGRlcGVuZGVuY3kgPSBwbGF0XzEuZGVwZW5kZW5jeSB8fCAocGxhdF8xLmRlcGVuZGVuY3kgPSB7fSkpO1xyXG4gICAgaWYgKCFpc1VuZGVmaW5lZCh3aW5kb3cpKSB7XHJcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHdpbmRvdy5wbGF0KSkge1xyXG4gICAgICAgICAgICB3aW5kb3cucGxhdCA9IHBsYXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh3aW5kb3cubW9kdWxlKSkge1xyXG4gICAgICAgICAgICB3aW5kb3cubW9kdWxlID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYWNxdWlyZShkZXBlbmRlbmNpZXMpIHtcclxuICAgICAgICB2YXIgZGVwcywgYXJyYXkgPSBpc0FycmF5KGRlcGVuZGVuY2llcyk7XHJcbiAgICAgICAgaWYgKGFycmF5KSB7XHJcbiAgICAgICAgICAgIGRlcHMgPSBkZXBlbmRlbmN5LkluamVjdG9yLmdldERlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZGVwcyA9IGRlcGVuZGVuY3kuSW5qZWN0b3IuZ2V0RGVwZW5kZW5jaWVzKFtkZXBlbmRlbmNpZXNdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IGRlcHMubGVuZ3RoLCBvdXRwdXQgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGRlcHNbaV0uaW5qZWN0KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFycmF5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9XHJcbiAgICBwbGF0XzEuYWNxdWlyZSA9IGFjcXVpcmU7XHJcbiAgICAvKipcclxuICAgICAqIEhvbGRzIGFsbCBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIHJlbGF0ZWQgdG8gZGVidWdnaW5nIGNvbXBvbmVudHMgaW4gcGxhdHlwdXMuXHJcbiAgICAgKi9cclxuICAgIHZhciBkZWJ1ZztcclxuICAgIChmdW5jdGlvbiAoZGVidWcpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIYW5kbGVzIGFsbCBsb2dnaW5nL2RlYnVnZ2luZyBmb3IgdGhlIGZyYW1ld29yay4gQWxsIGxvZ3Mgd2lsbCBiZSBidWJibGVkIHVwIHRvIHRoZVxyXG4gICAgICAgICAqIEFwcC5lcnJvciBldmVudCB0byBhbGxvdyBmb3IgZWFzeSBkZWJ1Z2dpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIExvZyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIExvZygpIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIEVSUk9SIGxvZyBsZXZlbFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLkVSUk9SID0gNTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIFdBUk4gbG9nIGxldmVsXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuV0FSTiA9IDQ7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBJTkZPIGxvZyBsZXZlbFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLklORk8gPSAzO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgREVCVUcgbG9nIGxldmVsXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuREVCVUcgPSAyO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgVFJBQ0UgbG9nIGxldmVsXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuVFJBQ0UgPSAxO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIGNvbmZpZ3VyYWJsZSBsb2cgbGV2ZWwgKGRlZmF1bHRzIHRvIElORk8pLiBBbnkgbG9ncyBzZW50IGJlbG93IHRoaXNcclxuICAgICAgICAgICAgICAgICAqIHdpbGwgYmUgc2lsZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sZXZlbCA9IHRoaXMuSU5GTztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTG9ncyBmYXRhbCBlcnJvcnMuIFRoaXMgd2lsbCB0aHJvdyB0aGUgZXJyb3IgYWZ0ZXIgaXQgaXMgbG9nZ2VkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBUaGUgZXJyb3IgdG8gbG9nLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTG9nLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nKGVycm9yLCB0aGlzLkVSUk9SKTtcclxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBMb2cucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nKG1lc3NhZ2UsIHRoaXMuV0FSTik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIExvZy5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cobWVzc2FnZSwgdGhpcy5JTkZPKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgTG9nLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cobWVzc2FnZSwgdGhpcy5ERUJVRyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIExvZy5wcm90b3R5cGUudHJhY2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nKG1lc3NhZ2UsIHRoaXMuVFJBQ0UpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBMb2cucHJvdG90eXBlLnNldExvZ0xldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcobGV2ZWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwgPSB0aGlzW2xldmVsLnRvVXBwZXJDYXNlKCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChsZXZlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5FUlJPUjpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuV0FSTjpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuSU5GTzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuREVCVUc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLlRSQUNFOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZXZlbCA9IGxldmVsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZXZlbCA9IHRoaXMuSU5GTztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgTG9nLnByb3RvdHlwZS5fbG9nID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGxldmVsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3Nob3VsZExvZyhsZXZlbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcobWVzc2FnZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIF9FcnJvckV2ZW50ID0gdGhpcy5fRXJyb3JFdmVudDtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoX0Vycm9yRXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX0Vycm9yRXZlbnQgPSB0aGlzLl9FcnJvckV2ZW50ID0gYWNxdWlyZShfX0Vycm9yRXZlbnRTdGF0aWMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX0Vycm9yRXZlbnQuZGlzcGF0Y2goX19lcnJvciwgTG9nLCBtZXNzYWdlLCBsZXZlbCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEZXRlbWluZXMgd2hldGhlciBvciBub3QgYSBsb2cgbGV2ZWwgaXMgYXQgb3IgYWJvdmUgdGhlIGN1cnJlbnQgbWluaW11bSBsb2cgbGV2ZWwuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbCBUaGUgbG9nIGxldmVsIHRvIGNoZWNrIGFnYWluc3QgdGhlIGN1cnJlbnQgbWluaW11bSBsb2cgbGV2ZWwuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBMb2cucHJvdG90eXBlLl9zaG91bGRMb2cgPSBmdW5jdGlvbiAobGV2ZWwpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOdW1iZXIobGV2ZWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwgPSB0aGlzLklORk87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGV2ZWwgPCBsZXZlbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIExvZztcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGRlYnVnLkxvZyA9IExvZztcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fTG9nLCBMb2cpO1xyXG4gICAgfSkoZGVidWcgPSBwbGF0XzEuZGVidWcgfHwgKHBsYXRfMS5kZWJ1ZyA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIEEgY2xhc3MgY29udGFpbmluZyBib29sZWFuIHZhbHVlcyBzaWduaWZ5aW5nIGJyb3dzZXJcclxuICAgICAqIGFuZC9vciBwbGF0Zm9ybSBjb21wYXRpYmlsaXRpZXMuXHJcbiAgICAgKi9cclxuICAgIHZhciBDb21wYXQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlZmluZSBldmVyeXRoaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIENvbXBhdCgpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFuIG9iamVjdCBjb250YWluaW5nIGFsbCBldmVudCBsb29rdXBzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fX2V2ZW50cyA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLl9fZGVmaW5lQm9vbGVhbnMoKTtcclxuICAgICAgICAgICAgdGhpcy5fX2RlZmluZU1hcHBlZEV2ZW50cygpO1xyXG4gICAgICAgICAgICB0aGlzLl9fZGVmaW5lVmVuZG9yRGVwZW5kZW5jaWVzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX19kZXRlcm1pbmVDc3MoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2sgd2hldGhlciBvciBub3QgYW4gZXZlbnQgZXhpc3RzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCBUaGUgZXZlbnQgdG8gY2hlY2sgdGhlIGV4aXN0ZW5jZSBvZi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb21wYXQucHJvdG90eXBlLmhhc0V2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBldmVudHMgPSB0aGlzLl9fZXZlbnRzLCBldmVudEV4aXN0cyA9IGV2ZW50c1tldmVudF07XHJcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChldmVudEV4aXN0cykpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQgPT09ICdpbnB1dCcgJiYgdGhpcy5JRSA9PT0gOSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RXhpc3RzID0gZXZlbnRzW2V2ZW50XSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRFeGlzdHMgPSBldmVudHNbZXZlbnRdID0gIWlzVW5kZWZpbmVkKGVsZW1lbnRbKCdvbicgKyBldmVudCldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnRFeGlzdHM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWZpbmUgYm9vbGVhbnMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29tcGF0LnByb3RvdHlwZS5fX2RlZmluZUJvb2xlYW5zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3dpbmRvdyA9IHRoaXMuX3dpbmRvdywgbmF2aWdhdG9yID0gX3dpbmRvdy5uYXZpZ2F0b3IgfHwge30sIHVzZXJBZ2VudCA9IChuYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnKS50b0xvd2VyQ2FzZSgpLCBoaXN0b3J5ID0gdGhpcy5faGlzdG9yeSwgZGVmID0gX3dpbmRvdy5kZWZpbmUsIG1zQSA9IF93aW5kb3cuTVNBcHAsIHdpbkpzID0gX3dpbmRvdy5XaW5KUywgYW5kcm9pZCA9ICgvYW5kcm9pZCAoKD86XFxkfFxcLikrKS8uZXhlYyh1c2VyQWdlbnQpIHx8IFtdKVsxXTtcclxuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGFuZHJvaWQpICYmICEvaWVtb2JpbGUvaS50ZXN0KHVzZXJBZ2VudCkpIHtcclxuICAgICAgICAgICAgICAgIGFuZHJvaWQgPSBwYXJzZUludChhbmRyb2lkLnJlcGxhY2UoL1xcLi9nLCAnJyksIDEwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmlzQ29tcGF0aWJsZSA9IGlzRnVuY3Rpb24oT2JqZWN0LmRlZmluZVByb3BlcnR5KSAmJiBpc0Z1bmN0aW9uKHRoaXMuX2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3IpO1xyXG4gICAgICAgICAgICB0aGlzLmNvcmRvdmEgPSAhaXNOdWxsKF93aW5kb3cuY29yZG92YSk7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaFN0YXRlID0gIShpc051bGwoaGlzdG9yeSkgfHwgaXNOdWxsKGhpc3RvcnkucHVzaFN0YXRlKSk7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsZVN1cHBvcnRlZCA9ICEoaXNVbmRlZmluZWQoX3dpbmRvdy5GaWxlKSB8fCBpc1VuZGVmaW5lZChfd2luZG93LkZvcm1EYXRhKSk7XHJcbiAgICAgICAgICAgIHRoaXMuYW1kID0gaXNGdW5jdGlvbihkZWYpICYmICFpc051bGwoZGVmLmFtZCk7XHJcbiAgICAgICAgICAgIHRoaXMubXNBcHAgPSBpc09iamVjdChtc0EpICYmIGlzRnVuY3Rpb24obXNBLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy53aW5KcyA9IGlzT2JqZWN0KHdpbkpzKSAmJiBpc09iamVjdCh3aW5Kcy5BcHBsaWNhdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuaW5kZXhlZERiID0gIWlzTnVsbChfd2luZG93LmluZGV4ZWREQik7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdG8gPSBpc09iamVjdCh7fS5fX3Byb3RvX18pO1xyXG4gICAgICAgICAgICB0aGlzLmdldFByb3RvID0gaXNGdW5jdGlvbihPYmplY3QuZ2V0UHJvdG90eXBlT2YpO1xyXG4gICAgICAgICAgICB0aGlzLnNldFByb3RvID0gaXNGdW5jdGlvbihPYmplY3Quc2V0UHJvdG90eXBlT2YpO1xyXG4gICAgICAgICAgICB0aGlzLmhhc1RvdWNoRXZlbnRzID0gIWlzVW5kZWZpbmVkKF93aW5kb3cub250b3VjaHN0YXJ0KTtcclxuICAgICAgICAgICAgdGhpcy5oYXNQb2ludGVyRXZlbnRzID0gISFuYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuaGFzTXNQb2ludGVyRXZlbnRzID0gISFuYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZDtcclxuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGFuZHJvaWQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLkFORFJPSUQgPSBhbmRyb2lkO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpZSA9IHBhcnNlSW50KCgvbXNpZSAoXFxkKykvLmV4ZWModXNlckFnZW50KSB8fCBbXSlbMV0sIDEwKSB8fFxyXG4gICAgICAgICAgICAgICAgcGFyc2VJbnQoKC90cmlkZW50XFwvLio7IHJ2OihcXGQrKS8uZXhlYyh1c2VyQWdlbnQpIHx8IFtdKVsxXSwgMTApO1xyXG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoaWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLklFID0gaWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlZmluZSBtYXBwZWQgZXZlbnRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29tcGF0LnByb3RvdHlwZS5fX2RlZmluZU1hcHBlZEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzUG9pbnRlckV2ZW50cykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXBwZWRFdmVudHMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJHRvdWNoc3RhcnQ6ICdwb2ludGVyZG93bicsXHJcbiAgICAgICAgICAgICAgICAgICAgJHRvdWNoZW5kOiAncG9pbnRlcnVwJyxcclxuICAgICAgICAgICAgICAgICAgICAkdG91Y2htb3ZlOiAncG9pbnRlcm1vdmUnLFxyXG4gICAgICAgICAgICAgICAgICAgICR0b3VjaGNhbmNlbDogJ3BvaW50ZXJjYW5jZWwnXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaGFzTXNQb2ludGVyRXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcHBlZEV2ZW50cyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAkdG91Y2hzdGFydDogJ01TUG9pbnRlckRvd24nLFxyXG4gICAgICAgICAgICAgICAgICAgICR0b3VjaGVuZDogJ01TUG9pbnRlclVwJyxcclxuICAgICAgICAgICAgICAgICAgICAkdG91Y2htb3ZlOiAnTVNQb2ludGVyTW92ZScsXHJcbiAgICAgICAgICAgICAgICAgICAgJHRvdWNoY2FuY2VsOiAnTVNQb2ludGVyQ2FuY2VsJ1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmhhc1RvdWNoRXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcHBlZEV2ZW50cyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAkdG91Y2hzdGFydDogJ3RvdWNoc3RhcnQnLFxyXG4gICAgICAgICAgICAgICAgICAgICR0b3VjaGVuZDogJ3RvdWNoZW5kJyxcclxuICAgICAgICAgICAgICAgICAgICAkdG91Y2htb3ZlOiAndG91Y2htb3ZlJyxcclxuICAgICAgICAgICAgICAgICAgICAkdG91Y2hjYW5jZWw6ICd0b3VjaGNhbmNlbCdcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcHBlZEV2ZW50cyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAkdG91Y2hzdGFydDogJ21vdXNlZG93bicsXHJcbiAgICAgICAgICAgICAgICAgICAgJHRvdWNoZW5kOiAnbW91c2V1cCcsXHJcbiAgICAgICAgICAgICAgICAgICAgJHRvdWNobW92ZTogJ21vdXNlbW92ZScsXHJcbiAgICAgICAgICAgICAgICAgICAgJHRvdWNoY2FuY2VsOiBudWxsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWZpbmUgYW5pbWF0aW9uIGV2ZW50cyBhbmQgb3RoZXIgdmVuZG9yIHByZWZpeFxyXG4gICAgICAgICAqIGRlcGVuZGVuY2llcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb21wYXQucHJvdG90eXBlLl9fZGVmaW5lVmVuZG9yRGVwZW5kZW5jaWVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3dpbmRvdyA9IHRoaXMuX3dpbmRvdywgZG9jdW1lbnRFbGVtZW50ID0gdGhpcy5fZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBzdHlsZXMgPSBfd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnRFbGVtZW50LCAnJyksIG1hdGNoZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChzdHlsZXMpLmpvaW4oJycpLm1hdGNoKC8tKG1venx3ZWJraXR8bXMpLS8pLCBwcmVmaXgsIGRvbSwgY3NzLCBqc1N5bnRheDtcclxuICAgICAgICAgICAgaWYgKChpc0FycmF5KG1hdGNoZXMpICYmIG1hdGNoZXMubGVuZ3RoID4gMSkpIHtcclxuICAgICAgICAgICAgICAgIHByZWZpeCA9IChpc0FycmF5KG1hdGNoZXMpICYmIG1hdGNoZXMubGVuZ3RoID4gMSkgPyBtYXRjaGVzWzFdIDogJyc7XHJcbiAgICAgICAgICAgICAgICBqc1N5bnRheCA9IHByZWZpeFswXS50b1VwcGVyQ2FzZSgpICsgcHJlZml4LnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgZG9tID0gKCdXZWJLaXR8TW96fE1TJykubWF0Y2gobmV3IFJlZ0V4cCgnKCcgKyBwcmVmaXggKyAnKScsICdpJykpWzFdO1xyXG4gICAgICAgICAgICAgICAgY3NzID0gJy0nICsgcHJlZml4ICsgJy0nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc1VuZGVmaW5lZChzdHlsZXMuT0xpbmspKSB7XHJcbiAgICAgICAgICAgICAgICBwcmVmaXggPSAnbyc7XHJcbiAgICAgICAgICAgICAgICBqc1N5bnRheCA9IGRvbSA9ICdPJztcclxuICAgICAgICAgICAgICAgIGNzcyA9ICctby0nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcHJlZml4ID0ganNTeW50YXggPSBkb20gPSBjc3MgPSAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnZlbmRvclByZWZpeCA9IHtcclxuICAgICAgICAgICAgICAgIGRvbTogZG9tLFxyXG4gICAgICAgICAgICAgICAgbG93ZXJDYXNlOiBwcmVmaXgsXHJcbiAgICAgICAgICAgICAgICBjc3M6IGNzcyxcclxuICAgICAgICAgICAgICAgIHVwcGVyQ2FzZToganNTeW50YXhcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBfd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBfd2luZG93W3ByZWZpeCArICdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcclxuICAgICAgICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IF93aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgICAgICAgICAgIF93aW5kb3dbcHJlZml4ICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddIHx8XHJcbiAgICAgICAgICAgICAgICBfd2luZG93W3ByZWZpeCArICdDYW5jZWxBbmltYXRpb25GcmFtZSddO1xyXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcbiAgICAgICAgICAgIC8vIGhhbmRsZSBBbmRyb2lkIGlzc3VlIHdoZXJlIHN0eWxlLnRyYW5zaXRpb24gZXhpc3RzIGJ1dCB0cmFuc2l0aW9uIGV2ZW50cyBzdGlsbCBuZWVkIHZlbmRvciBwcmVmaXggXHJcbiAgICAgICAgICAgIC8vIHNob3VsZCBvbmx5IGFmZmVjdCB2ZXJzaW9uIDQuMSBidXQgd2Ugd2lsbCBoYW5kbGUgZm9yIDwgNC40LiBcclxuICAgICAgICAgICAgaWYgKChpc1VuZGVmaW5lZCh0aGlzLkFORFJPSUQpIHx8IE1hdGguZmxvb3IodGhpcy5BTkRST0lEIC8gMTApID49IDQ0KSAmJlxyXG4gICAgICAgICAgICAgICAgIShpc1VuZGVmaW5lZChzdHlsZS5hbmltYXRpb24pIHx8IGlzVW5kZWZpbmVkKHN0eWxlLnRyYW5zaXRpb24pKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25TdXBwb3J0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25FdmVudHMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJGFuaW1hdGlvbjogJ2FuaW1hdGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgJGFuaW1hdGlvblN0YXJ0OiAnYW5pbWF0aW9uc3RhcnQnLFxyXG4gICAgICAgICAgICAgICAgICAgICRhbmltYXRpb25FbmQ6ICdhbmltYXRpb25lbmQnLFxyXG4gICAgICAgICAgICAgICAgICAgICRhbmltYXRpb25JdGVyYXRpb246ICdhbmltYXRpb25pdGVyYXRpb24nLFxyXG4gICAgICAgICAgICAgICAgICAgICR0cmFuc2l0aW9uOiAndHJhbnNpdGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgJHRyYW5zaXRpb25TdGFydDogJ3RyYW5zaXRpb25zdGFydCcsXHJcbiAgICAgICAgICAgICAgICAgICAgJHRyYW5zaXRpb25FbmQ6ICd0cmFuc2l0aW9uZW5kJ1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghKGlzVW5kZWZpbmVkKHN0eWxlW2pzU3ludGF4ICsgJ0FuaW1hdGlvbiddKSB8fCBpc1VuZGVmaW5lZChzdHlsZVtqc1N5bnRheCArICdUcmFuc2l0aW9uJ10pKSB8fFxyXG4gICAgICAgICAgICAgICAgIShpc1VuZGVmaW5lZChzdHlsZVtwcmVmaXggKyAnQW5pbWF0aW9uJ10pIHx8IGlzVW5kZWZpbmVkKHN0eWxlW3ByZWZpeCArICdUcmFuc2l0aW9uJ10pKSB8fFxyXG4gICAgICAgICAgICAgICAgIShpc1VuZGVmaW5lZChzdHlsZVtkb20gKyAnQW5pbWF0aW9uJ10pIHx8IGlzVW5kZWZpbmVkKHN0eWxlW2RvbSArICdUcmFuc2l0aW9uJ10pKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25TdXBwb3J0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25FdmVudHMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJGFuaW1hdGlvbjogcHJlZml4ICsgJ0FuaW1hdGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgJGFuaW1hdGlvblN0YXJ0OiBwcmVmaXggKyAnQW5pbWF0aW9uU3RhcnQnLFxyXG4gICAgICAgICAgICAgICAgICAgICRhbmltYXRpb25FbmQ6IHByZWZpeCArICdBbmltYXRpb25FbmQnLFxyXG4gICAgICAgICAgICAgICAgICAgICRhbmltYXRpb25JdGVyYXRpb246IHByZWZpeCArICdBbmltYXRpb25JdGVyYXRpb24nLFxyXG4gICAgICAgICAgICAgICAgICAgICR0cmFuc2l0aW9uOiBwcmVmaXggKyAnVHJhbnNpdGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgJHRyYW5zaXRpb25TdGFydDogcHJlZml4ICsgJ1RyYW5zaXRpb25TdGFydCcsXHJcbiAgICAgICAgICAgICAgICAgICAgJHRyYW5zaXRpb25FbmQ6IHByZWZpeCArICdUcmFuc2l0aW9uRW5kJ1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCBwbGF0eXB1cyBjc3Mgc3R5bGVzIGV4aXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbXBhdC5wcm90b3R5cGUuX19kZXRlcm1pbmVDc3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfZG9jdW1lbnQgPSB0aGlzLl9kb2N1bWVudCwgaGVhZCA9IF9kb2N1bWVudC5oZWFkLCBlbGVtZW50ID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShfX0hpZGUsICcnKTtcclxuICAgICAgICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoZWxlbWVudCwgbnVsbCk7XHJcbiAgICAgICAgICAgIHZhciBjb21wdXRlZFN0eWxlID0gdGhpcy5fd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCksIGRpc3BsYXkgPSBjb21wdXRlZFN0eWxlLmRpc3BsYXksIHZpc2liaWxpdHkgPSBjb21wdXRlZFN0eWxlLnZpc2liaWxpdHk7XHJcbiAgICAgICAgICAgIHRoaXMucGxhdENzcyA9IGRpc3BsYXkgPT09ICdub25lJyB8fCB2aXNpYmlsaXR5ID09PSAnaGlkZGVuJztcclxuICAgICAgICAgICAgaGVhZC5yZW1vdmVDaGlsZChlbGVtZW50KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIENvbXBhdC5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICBfd2luZG93OiBfX1dpbmRvdyxcclxuICAgICAgICAgICAgX2hpc3Rvcnk6IF9fSGlzdG9yeSxcclxuICAgICAgICAgICAgX2RvY3VtZW50OiBfX0RvY3VtZW50XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQ29tcGF0O1xyXG4gICAgfSgpKTtcclxuICAgIHBsYXRfMS5Db21wYXQgPSBDb21wYXQ7XHJcbiAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fQ29tcGF0LCBDb21wYXQpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBleHRlbnNpYmxlIGNsYXNzIGRlZmluaW5nIGNvbW1vbiB1dGlsaXRpZXMgYW5kIGhlbHBlciBmdW5jdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIHZhciBVdGlscyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gVXRpbHMoKSB7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuIGVtcHR5IG1ldGhvZCBmb3IgcXVpY2tseSBjcmVhdGluZyBkdW1teSBvYmplY3RzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFV0aWxzLnByb3RvdHlwZS5ub29wID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFsbG93cyB5b3UgdG8gZXh0ZW5kIHRoZSBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCB3aXRoIGFueSBudW1iZXJcclxuICAgICAgICAgKiBvZiBvdGhlciBvYmplY3RzLiBJZiBvYmplY3RzIHNoYXJlIHByb3BlcnRpZXMsIHRoZSBsYXN0IG9iamVjdCBpbiB0aGVcclxuICAgICAgICAgKiBhcmd1bWVudHMgd2lsbCB0YWtlIHByZWNlZGVuY2UuIFRoaXMgbWV0aG9kIGlzIG9ubHkgYSBzaGFsbG93IGNvcHkgb2ZcclxuICAgICAgICAgKiBhbGwgdGhlIHNvdXJjZSBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IGRlc3RpbmF0aW9uIFRoZSBkZXN0aW5hdGlvbiBvYmplY3QgdG8gZXh0ZW5kLlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gLi4uc291cmNlcyBBbnkgbnVtYmVyIG9mIG9iamVjdHMgd2l0aCB3aGljaCB0byBleHRlbmQgdGhlXHJcbiAgICAgICAgICogZGVzdGluYXRpb24gb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFV0aWxzLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiAoZGVzdGluYXRpb24pIHtcclxuICAgICAgICAgICAgdmFyIHNvdXJjZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF9leHRlbmQuYXBwbHkobnVsbCwgW2ZhbHNlLCBmYWxzZSwgZGVzdGluYXRpb25dLmNvbmNhdChzb3VyY2VzKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbGxvd3MgeW91IHRvIGV4dGVuZCB0aGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3Qgd2l0aCBhbnkgbnVtYmVyXHJcbiAgICAgICAgICogb2Ygb3RoZXIgb2JqZWN0cy4gSWYgb2JqZWN0cyBzaGFyZSBwcm9wZXJ0aWVzLCB0aGUgbGFzdCBvYmplY3QgaW4gdGhlXHJcbiAgICAgICAgICogYXJndW1lbnRzIHdpbGwgdGFrZSBwcmVjZWRlbmNlLiBUaGlzIG1ldGhvZCBpcyBhIGRlZXAgY29weSBvZlxyXG4gICAgICAgICAqIGFsbCB0aGUgc291cmNlIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gZGVzdGluYXRpb24gVGhlIGRlc3RpbmF0aW9uIG9iamVjdCB0byBleHRlbmQuXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSAuLi5zb3VyY2VzIEFueSBudW1iZXIgb2Ygb2JqZWN0cyB3aXRoIHdoaWNoIHRvIGV4dGVuZCB0aGVcclxuICAgICAgICAgKiBkZXN0aW5hdGlvbiBvYmplY3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLmRlZXBFeHRlbmQgPSBmdW5jdGlvbiAoZGVzdGluYXRpb24pIHtcclxuICAgICAgICAgICAgdmFyIHNvdXJjZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF9leHRlbmQuYXBwbHkobnVsbCwgW3RydWUsIGZhbHNlLCBkZXN0aW5hdGlvbl0uY29uY2F0KHNvdXJjZXMpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoZSBwYXNzZWQtaW4gb2JqZWN0LiBJZiBkZWVwIGlzIHRydWUgaXQgd2lsbFxyXG4gICAgICAgICAqIGJlIGEgZGVlcCBjb3B5IChkdXBsaWNhdGUpLCBlbHNlIG5lc3RlZCBvYmplY3RzL2FycmF5cyB3aWxsIGJlIGNvcGllZCBieSByZWZlcmVuY2VcclxuICAgICAgICAgKiBhbmQgbm90IGR1cGxpY2F0ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtUfSBvYmogVGhlIG9iamVjdCB0byBjbG9uZS5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRlZXA/IFdoZXRoZXIgb3Igbm90IGl0IGlzIGEgZGVlcCBjbG9uZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBVdGlscy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAob2JqLCBkZWVwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfY2xvbmUob2JqLCBkZWVwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRha2VzIGluIGFueXRoaW5nIGFuZCBkZXRlcm1pbmVzIGlmIGl0IGlzIGEgdHlwZSBvZiBPYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IG9iaiBBbnl0aGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBVdGlscy5wcm90b3R5cGUuaXNPYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc09iamVjdChvYmopO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFrZXMgaW4gYW55dGhpbmcgYW5kIGRldGVybWluZXMgaWYgaXQgaXMgYSB3aW5kb3cgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBvYmogQW55dGhpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLmlzV2luZG93ID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNXaW5kb3cob2JqKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRha2VzIGluIGFueXRoaW5nIGFuZCBkZXRlcm1pbmVzIGlmIGl0IGlzIGEgZG9jdW1lbnQgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBvYmogQW55dGhpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLmlzRG9jdW1lbnQgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0RvY3VtZW50KG9iaik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUYWtlcyBpbiBhbnl0aGluZyBhbmQgZGV0ZXJtaW5lcyBpZiBpdCBpcyBhIE5vZGUuXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IG9iaiBBbnl0aGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBVdGlscy5wcm90b3R5cGUuaXNOb2RlID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNOb2RlKG9iaik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUYWtlcyBpbiBhbnl0aGluZyBhbmQgZGV0ZXJtaW5lcyBpZiBpdCBpcyBhIERvY3VtZW50RnJhZ21lbnQuXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IG9iaiBBbnl0aGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBVdGlscy5wcm90b3R5cGUuaXNEb2N1bWVudEZyYWdtZW50ID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNEb2N1bWVudEZyYWdtZW50KG9iaik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUYWtlcyBpbiBhbnl0aGluZyBhbmQgZGV0ZXJtaW5lcyBpZiBpdCBpcyBhIHN0cmluZy5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2JqIEFueXRoaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFV0aWxzLnByb3RvdHlwZS5pc1N0cmluZyA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzU3RyaW5nKG9iaik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUYWtlcyBpbiBhbnl0aGluZyBhbmQgZGV0ZXJtaW5lcyBpZiBpdCBpcyBhIFJlZ0V4cCBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IG9iaiBBbnl0aGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBVdGlscy5wcm90b3R5cGUuaXNSZWdFeHAgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc1JlZ0V4cChvYmopO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFrZXMgaW4gYW55dGhpbmcgYW5kIGRldGVybWluZXMgaWYgaXQgaXMgYSBQcm9taXNlIG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2JqIEFueXRoaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFV0aWxzLnByb3RvdHlwZS5pc1Byb21pc2UgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc1Byb21pc2Uob2JqKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRha2VzIGluIGFueXRoaW5nIGFuZCBkZXRlcm1pbmVzIGlmIGl0IGlzIGVtcHR5LiBVc2VmdWwgZm9yXHJcbiAgICAgICAgICogY2hlY2tpbmcgZm9yIGVtcHR5IHN0cmluZ3MsIGFycmF5cywgb3Igb2JqZWN0cyB3aXRob3V0IGtleXMuXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IG9iaiBBbnl0aGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBVdGlscy5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzRW1wdHkob2JqKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRha2VzIGluIGFueXRoaW5nIGFuZCBkZXRlcm1pbmVzIGlmIGl0IGlzIGEgYm9vbGVhbi5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2JqIEFueXRoaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFV0aWxzLnByb3RvdHlwZS5pc0Jvb2xlYW4gPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0Jvb2xlYW4ob2JqKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRha2VzIGluIGFueXRoaW5nIGFuZCBkZXRlcm1pbmVzIGlmIGl0IGlzIGEgbnVtYmVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBvYmogQW55dGhpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLmlzTnVtYmVyID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNOdW1iZXIob2JqKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRha2VzIGluIGFueXRoaW5nIGFuZCBkZXRlcm1pbmVzIGlmIGl0IGlzIGEgRmlsZS5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2JqIEFueXRoaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFV0aWxzLnByb3RvdHlwZS5pc0ZpbGUgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0ZpbGUob2JqKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRha2VzIGluIGFueXRoaW5nIGFuZCBkZXRlcm1pbmVzIGlmIGl0IGlzIGEgZnVuY3Rpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IG9iaiBBbnl0aGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBVdGlscy5wcm90b3R5cGUuaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob2JqKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRha2VzIGluIGFueXRoaW5nIGFuZCBkZXRlcm1pbmVzIGlmIGl0IGlzIG51bGwgb3IgdW5kZWZpbmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBvYmogQW55dGhpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLmlzTnVsbCA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzTnVsbChvYmopO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFrZXMgaW4gYW55dGhpbmcgYW5kIGRldGVybWluZXMgaWYgaXQgaXMgdW5kZWZpbmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBvYmogQW55dGhpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLmlzVW5kZWZpbmVkID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNVbmRlZmluZWQob2JqKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRha2VzIGluIGFueXRoaW5nIGFuZCBkZXRlcm1pbmVzIGlmIGl0IGlzIGFuIEFycmF5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBvYmogQW55dGhpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLmlzQXJyYXkgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KG9iaik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUYWtlcyBpbiBhbnl0aGluZyBhbmQgZGV0ZXJtaW5lcyBpZiBpdCBoYXMgYXJyYXktbGlrZSBxdWFsaXRpZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IG9iaiBBbnl0aGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBVdGlscy5wcm90b3R5cGUuaXNBcnJheUxpa2UgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5TGlrZShvYmopO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFrZXMgaW4gYW55dGhpbmcgYW5kIGRldGVybWluZXMgaWYgaXQgaXMgYSBEYXRlIG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2JqIEFueXRoaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFV0aWxzLnByb3RvdHlwZS5pc0RhdGUgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0RhdGUob2JqKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFV0aWxzLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIG9iaiwgY29udGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyKGl0ZXJhdG9yLCBvYmosIGNvbnRleHQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFrZXMgaW4gYSBsaXN0IGFuZCBvYmplY3QgY29udGFpbmluZyBrZXkvdmFsdWUgcGFpcnMgdG8gc2VhcmNoIGZvciBpbiB0aGUgbGlzdC5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBBbiBvYmplY3QgY29udGFpbmluZyBrZXkvdmFsdWUgcGFpcnMgdG8gbWF0Y2ggd2l0aCBvYmoncyB2YWx1ZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxUPn0gYXJyYXkgVGhlIGxpc3QgdXNlZCBmb3Igc2VhcmNoaW5nIGZvciBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFV0aWxzLnByb3RvdHlwZS53aGVyZSA9IGZ1bmN0aW9uIChwcm9wZXJ0aWVzLCBhcnJheSkge1xyXG4gICAgICAgICAgICByZXR1cm4gd2hlcmUocHJvcGVydGllcywgYXJyYXkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoaXRlcmF0b3IsIG9iaiwgY29udGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZm9yRWFjaChpdGVyYXRvciwgb2JqLCBjb250ZXh0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFV0aWxzLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIG9iaiwgY29udGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWFwKGl0ZXJhdG9yLCBvYmosIGNvbnRleHQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLm1hcEFzeW5jID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBvYmosIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1hcEFzeW5jKGl0ZXJhdG9yLCBvYmosIGNvbnRleHQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFrZXMgaW4gYW4gYXJyYXkgYW5kIGFuIGl0ZXJhdG9yIGZ1bmN0aW9uLiBDYWxscyB0aGUgaXRlcmF0b3Igd2l0aCBhbGwgdGhlIHZhbHVlcyBpbiB0aGUgYXJyYXkuIFRoZVxyXG4gICAgICAgICAqIGl0ZXJhdG9yIGNhbiByZXR1cm4gYSBwcm9taXNlIHRoZSB3aWxsIHJlc29sdmUgd2l0aCB0aGUgbWFwcGVkIHZhbHVlLiBUaGUgbmV4dCB2YWx1ZSBpbiB0aGUgYXJyYXkgd2lsbCBub3QgYmUgcGFzc2VkIHRvXHJcbiAgICAgICAgICogdGhlIGl0ZXJhdG9yIHVudGlsIHRoZSBwcmV2aW91cyBwcm9taXNlIGZ1bGZpbGxzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC5JTGlzdEl0ZXJhdG9yPFQsIHBsYXQuYXN5bmMuSVRoZW5hYmxlPFI+Pn0gaXRlcmF0b3IgVGhlIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8VD59IGFycmF5IEFuIEFycmF5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBjb250ZXh0PyBBbiBvcHRpb25hbCBjb250ZXh0IHRvIGJpbmQgdG8gdGhlIGl0ZXJhdG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFV0aWxzLnByb3RvdHlwZS5tYXBBc3luY0luT3JkZXIgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGFycmF5LCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXBBc3luY0luT3JkZXIoaXRlcmF0b3IsIGFycmF5LCBjb250ZXh0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRha2VzIGluIGFuIGFycmF5IGFuZCBhbiBpdGVyYXRvciBmdW5jdGlvbi4gQ2FsbHMgdGhlIGl0ZXJhdG9yIHdpdGggYWxsIHRoZSB2YWx1ZXMgaW4gdGhlIGFycmF5IGluIGRlc2NlbmRpbmcgb3JkZXIuIFRoZVxyXG4gICAgICAgICAqIGl0ZXJhdG9yIGNhbiByZXR1cm4gYSBwcm9taXNlIHRoZSB3aWxsIHJlc29sdmUgd2l0aCB0aGUgbWFwcGVkIHZhbHVlLiBUaGUgbmV4dCB2YWx1ZSBpbiB0aGUgYXJyYXkgd2lsbCBub3QgYmUgcGFzc2VkIHRvXHJcbiAgICAgICAgICogdGhlIGl0ZXJhdG9yIHVudGlsIHRoZSBwcmV2aW91cyBwcm9taXNlIGZ1bGZpbGxzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC5JTGlzdEl0ZXJhdG9yPFQsIHBsYXQuYXN5bmMuSVRoZW5hYmxlPFI+Pn0gaXRlcmF0b3IgVGhlIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8VD59IGFycmF5IEFuIEFycmF5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBjb250ZXh0PyBBbiBvcHRpb25hbCBjb250ZXh0IHRvIGJpbmQgdG8gdGhlIGl0ZXJhdG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFV0aWxzLnByb3RvdHlwZS5tYXBBc3luY0luRGVzY2VuZGluZ09yZGVyID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBhcnJheSwgY29udGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWFwQXN5bmNJbkRlc2NlbmRpbmdPcmRlcihpdGVyYXRvciwgYXJyYXksIGNvbnRleHQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFrZXMgaW4gYW4gb2JqZWN0IGFuZCBhIHByb3BlcnR5IHRvIGV4dHJhY3QgZnJvbSBhbGwgb2YgdGhlIG9iamVjdCdzIHZhbHVlcy4gUmV0dXJucyBhbiBhcnJheSBvZlxyXG4gICAgICAgICAqIHRoZSAncGx1Y2tlZCcgdmFsdWVzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHByb3BlcnR5IHRvICdwbHVjaycgZnJvbSBlYWNoIHZhbHVlIGluIHRoZSBhcnJheS5cclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PFQ+fSBhcnJheSBUaGUgYXJyYXkgdG8gcGx1Y2sgdGhlIGtleSBmcm9tXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLnBsdWNrID0gZnVuY3Rpb24gKGtleSwgYXJyYXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBsdWNrKGtleSwgYXJyYXkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLnNvbWUgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIG9iaiwgY29udGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc29tZShpdGVyYXRvciwgb2JqLCBjb250ZXh0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRha2VzIGluIGEgbWV0aG9kIGFuZCBhcnJheSBvZiBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGF0IG1ldGhvZC4gRGVsYXlzIGNhbGxpbmcgdGhlIG1ldGhvZCB1bnRpbFxyXG4gICAgICAgICAqIGFmdGVyIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaXMgY2xlYXIuIEVxdWl2YWxlbnQgdG8gYSBzZXRUaW1lb3V0IHdpdGggYSB0aW1lb3V0IG9mIDAuXHJcbiAgICAgICAgICogQHBhcmFtIHsoLi4uYXJnczogQXJyYXk8YW55PikgPT4gdm9pZH0gbWV0aG9kIFRoZSBtZXRob2QgdG8gY2FsbC5cclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGFyZ3M/IFRoZSBhcmd1bWVudHMgdG8gYXBwbHkgdG8gdGhlIG1ldGhvZC5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gY29udGV4dD8gQW4gb3B0aW9uYWwgY29udGV4dCB0byBiaW5kIHRvIHRoZSBtZXRob2QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLnBvc3Rwb25lID0gZnVuY3Rpb24gKG1ldGhvZCwgYXJncywgY29udGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGVmZXIobWV0aG9kLCAwLCBhcmdzLCBjb250ZXh0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRha2VzIGluIGEgbWV0aG9kIGFuZCBhcnJheSBvZiBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGF0IG1ldGhvZC4gRGVsYXlzIGNhbGxpbmcgdGhlIG1ldGhvZCB1bnRpbFxyXG4gICAgICAgICAqIGFmdGVyIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaXMgY2xlYXIuIEVxdWl2YWxlbnQgdG8gYSBzZXRUaW1lb3V0IHdpdGggdGhlIHNwZWNpZmllZCB0aW1lb3V0IHZhbHVlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7KC4uLmFyZ3M6IEFycmF5PGFueT4pID0+IHZvaWR9IG1ldGhvZCBUaGUgbWV0aG9kIHRvIGNhbGwuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgVGhlIHRpbWUgKGluIG1pbGxpc2Vjb25kcykgdG8gZGVsYXkgYmVmb3JlIGNhbGxpbmcgdGhlIHByb3ZpZGVkIG1ldGhvZC5cclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGFyZ3M/IFRoZSBhcmd1bWVudHMgdG8gYXBwbHkgdG8gdGhlIG1ldGhvZC5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gY29udGV4dD8gQW4gb3B0aW9uYWwgY29udGV4dCB0byBiaW5kIHRvIHRoZSBtZXRob2QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLmRlZmVyID0gZnVuY3Rpb24gKG1ldGhvZCwgdGltZW91dCwgYXJncywgY29udGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGVmZXIobWV0aG9kLCB0aW1lb3V0LCBhcmdzLCBjb250ZXh0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRha2VzIGluIGEgbWV0aG9kIGFuZCBhcnJheSBvZiBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGF0IG1ldGhvZC4gQWRkcyB0aGUgbWV0aG9kIHRvIHRoZSBjYWxsIHN0YWNrIGV2ZXJ5XHJcbiAgICAgICAgICogaW50ZXJ2YWwgYW1vdW50IG9mIHRpbWUuIEVxdWl2YWxlbnQgdG8gYSBzZXRJbnRlcnZhbCB3aXRoIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWwgdmFsdWUuXHJcbiAgICAgICAgICogQHBhcmFtIHsoLi4uYXJnczogQXJyYXk8YW55PikgPT4gdm9pZH0gbWV0aG9kIFRoZSBtZXRob2QgdG8gY2FsbC5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW50ZXJ2YWwgVGhlIHRpbWUgKGluIG1pbGxpc2Vjb25kcykgYmV0d2VlbiBlYWNoIGNvbnNlY3V0aXZlIGNhbGwgb2YgdGhlIHByb3ZpZGVkIG1ldGhvZC5cclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGFyZ3M/IFRoZSBhcmd1bWVudHMgdG8gYXBwbHkgdG8gdGhlIG1ldGhvZC5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gY29udGV4dD8gQW4gb3B0aW9uYWwgY29udGV4dCB0byBiaW5kIHRvIHRoZSBtZXRob2QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLnNldEludGVydmFsID0gZnVuY3Rpb24gKG1ldGhvZCwgaW50ZXJ2YWwsIGFyZ3MsIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNldEludGVydmFsR2xvYmFsKG1ldGhvZCwgaW50ZXJ2YWwsIGFyZ3MsIGNvbnRleHQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXNlcyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgaWYgaXQgaXMgYXZhaWxhYmxlLCBlbHNlIGl0IGRvZXMgYSBzZXRUaW1lb3V0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnJhbWVSZXF1ZXN0Q2FsbGJhY2t9IG1ldGhvZCBUaGUgbWV0aG9kIHRvIGNhbGwgd2hlbiB0aGUgcmVxdWVzdCBpcyBmdWxmaWxsZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IGNvbnRleHQ/IEFuIG9wdGlvbmFsIGNvbnRleHQgdG8gYmluZCB0byB0aGUgbWV0aG9kLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFV0aWxzLnByb3RvdHlwZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWVHbG9iYWwobWV0aG9kLCBjb250ZXh0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRha2VzIGluIGEgcHJlZml4IGFuZCByZXR1cm5zIGEgdW5pcXVlIGlkZW50aWZpZXIgc3RyaW5nIHdpdGggdGhlIHByZWZpeCBwcmVwcmVuZGVkLiBJZiBubyBwcmVmaXhcclxuICAgICAgICAgKiBpcyBzcGVjaWZpZWQsIG5vbmUgd2lsbCBiZSBwcmVwZW5kZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeD8gQSBzdHJpbmcgcHJlZml4IHRvIHByZXBlbmQgdG90aGUgdW5pcXVlIElELlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFV0aWxzLnByb3RvdHlwZS51bmlxdWVJZCA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuaXF1ZUlkKHByZWZpeCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUYWtlcyBpbiBhIHNwaW5hbC1jYXNlLCBkb3QuY2FzZSwgb3Igc25ha2VfY2FzZSBzdHJpbmcgYW5kIHJldHVybnNcclxuICAgICAgICAgKiBhIGNhbWVsQ2FzZSBzdHJpbmcuIEFsc28gY2FuIHR1cm4gYSBzdHJpbmcgaW50byBjYW1lbENhc2Ugd2l0aCBzcGFjZVxyXG4gICAgICAgICAqIGFzIGEgZGVsaW1ldGVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHNwaW5hbC1jYXNlLCBkb3QuY2FzZSwgb3Igc25ha2VfY2FzZSBzdHJpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLmNhbWVsQ2FzZSA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbWVsQ2FzZShzdHIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFrZXMgYSBjYW1lbENhc2Ugc3RyaW5nIGFuZCBkZWxpbWl0cyBpdCB1c2luZyB0aGUgc3BlY2lmaWVkIGRlbGltaXRlci5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBjYW1lbENhc2VkIHN0cmluZy5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGVsaW1pdGVyIFRoZSBkZWxpbWl0ZXIgdG8gYWRkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFV0aWxzLnByb3RvdHlwZS5kZWxpbWl0ID0gZnVuY3Rpb24gKHN0ciwgZGVsaW1pdGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkZWxpbWl0KHN0ciwgZGVsaW1pdGVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBVdGlscztcclxuICAgIH0oKSk7XHJcbiAgICBwbGF0XzEuVXRpbHMgPSBVdGlscztcclxuICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19VdGlscywgVXRpbHMpO1xyXG4gICAgLyoqXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFdpbmRvdygpIHtcclxuICAgICAgICByZXR1cm4gd2luZG93O1xyXG4gICAgfVxyXG4gICAgcGxhdF8xLldpbmRvdyA9IFdpbmRvdztcclxuICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19XaW5kb3csIFdpbmRvdyk7XHJcbiAgICAvKipcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gRG9jdW1lbnQoX3dpbmRvdykge1xyXG4gICAgICAgIHJldHVybiBfd2luZG93LmRvY3VtZW50O1xyXG4gICAgfVxyXG4gICAgcGxhdF8xLkRvY3VtZW50ID0gRG9jdW1lbnQ7XHJcbiAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fRG9jdW1lbnQsIERvY3VtZW50LCBbX19XaW5kb3ddKTtcclxuICAgIC8qKlxyXG4gICAgICogSG9sZHMgY2xhc3NlcyBhbmQgaW50ZXJmYWNlcyByZWxhdGVkIHRvIGV4cHJlc3Npb24gaGFuZGxpbmcgaW4gcGxhdHlwdXMuXHJcbiAgICAgKi9cclxuICAgIHZhciBleHByZXNzaW9ucztcclxuICAgIChmdW5jdGlvbiAoZXhwcmVzc2lvbnMpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGNsYXNzIGZvciBrZWVwaW5nIHRyYWNrIG9mIGNvbW1vbmx5IHVzZWQgcmVndWxhciBleHByZXNzaW9ucy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgUmVnZXggPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBSZWdleCgpIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIGZpbmRpbmcgbWFya3VwIGluIGEgc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmt1cFJlZ2V4ID0gbmV3IFJlZ0V4cChfX3N0YXJ0U3ltYm9sICsgJ1tcXFxcU1xcXFxzXSonICsgX19lbmRTeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBGaW5kcyB0aGUgYXJndW1lbnRzIGluIGEgbWV0aG9kIGV4cHJlc3Npb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuYXJndW1lbnRSZWdleCA9IC9cXCgoLiopXFwpLztcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRmluZHMgJy8qLmh0bWwnIG9yICcvKi5odG0nIGluIGEgdXJsLiBVc2VmdWwgZm9yIHJlbW92aW5nXHJcbiAgICAgICAgICAgICAgICAgKiB0aGUgaHRtbCBmaWxlIG91dCBvZiB0aGUgdXJsLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxVcmxSZWdleCA9IC9cXC9bXlxcL10qXFwuKD86aHRtbHxodG0pLztcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRmluZHMgYSBwcm90b2NvbCBkZWxpbWV0ZXIgaW4gYSBzdHJpbmcgKGUuZy4gOi8vKS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm90b2NvbFJlZ2V4ID0gLzpcXC9cXC8vO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBMb29rcyBmb3IgYW55IGludmFsaWQgdmFyaWFibGUgc3ludGF4LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmludmFsaWRWYXJpYWJsZVJlZ2V4ID0gL1teYS16QS1aMC05QF8kXS87XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdyYWJzIHRoZSBmaWxlIG5hbWUgZnJvbSBhIGZpbGUgcGF0aC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maWxlTmFtZVJlZ2V4ID0gLy4qKD86XFwvfFxcXFwpLztcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRGV0ZXJtaW5lcyBpZiBhIGNoYXJhY3RlciBpcyBjb3JyZWxhdGVkIHdpdGggYSBzaGlmdGVkIGtleSBjb2RlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNoaWZ0ZWRLZXlSZWdleCA9IC9bQS1aIUAjJCVeJiooKV8rfXtcIjo/Pjx8fl0vO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEZXRlcm1pbmVzIGlmIGEgdXJsIGlzIHJlbGF0aXZlIG9yIGFic29sdXRlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZ1bGxVcmxSZWdleCA9IC9eKD86W2EtejAtOVxcLV0rOikoPzpcXC9cXC8pP3woPzpcXC9cXC8pL2k7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIERldGVybWluZXMgaWYgYW4gZW1haWwgYWRkcmVzcyBpcyB2YWxpZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUVtYWlsID0gbmV3IFJlZ0V4cCgnXigoW148PigpW1xcXFxdXFxcXFxcLiw7OlxcXFxzQFxcXFxcIl0rKFxcXFwuW148PigpW1xcXFxdXFxcXFxcLiw7OlxcXFxzQFxcXFxcIl0rKSopfCcgK1xyXG4gICAgICAgICAgICAgICAgICAgICcoXFxcXFwiLitcXFxcXCIpKUAoKFxcXFxbWzAtOV17MSwzfVxcXFwuWzAtOV17MSwzfVxcXFwuWzAtOV17MSwzfVxcXFwuWzAtOV17MSwzfVxcXFxdKXwnICtcclxuICAgICAgICAgICAgICAgICAgICAnKChbYS16QS1aXFxcXC0wLTldK1xcXFwuKStbYS16QS1aXXsyLH0pKSQnKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRGV0ZXJtaW5lcyBpZiBhIHRlbGVwaG9uZSBudW1iZXIgaXMgdmFsaWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVUZWxlcGhvbmUgPSAvXlxcKz9bMC05XFwuXFwoXFwpXFxzLV0qJC87XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgcmVndWxhciBleHByZXNzaW9uIGZvciBtYXRjaGluZyBkeW5hbWljIHNlZ21lbnRzIGluIGEgcm91dGUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuZHluYW1pY1NlZ21lbnRzUmVnZXggPSAvXjooW15cXC9dKykkLztcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIG1hdGNoaW5nIHNwbGF0IHNlZ21lbnRzIGluIGEgcm91dGUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuc3BsYXRTZWdtZW50UmVnZXggPSAvXlxcKihbXlxcL10rKSQvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWdleC5wcm90b3R5cGUsIFwibmV3TGluZVJlZ2V4XCIsIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIG1hdGNoaW5nIG9yIHJlbW92aW5nIGFsbCBuZXdsaW5lIGNoYXJhY3RlcnMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAvXFxyfFxcbi9nO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWdleC5wcm90b3R5cGUsIFwib3B0aW9uYWxSb3V0ZVJlZ2V4XCIsIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRmluZHMgb3B0aW9uYWwgcGFyYW1ldGVycyBpbiBhIHJvdXRlIHN0cmluZy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC9cXCgoLio/KVxcKS9nO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWdleC5wcm90b3R5cGUsIFwibmFtZWRQYXJhbWV0ZXJSb3V0ZVJlZ2V4XCIsIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRmluZHMgbmFtZWQgcGFyYW1ldGVycyBpbiBhIHJvdXRlIHN0cmluZy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC8oXFwoXFw/KT86XFx3Ky9nO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWdleC5wcm90b3R5cGUsIFwid2lsZGNhcmRSb3V0ZVJlZ2V4XCIsIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRmluZHMgYW4gYWxwaGFudW1lcmljIHdpbGRjYXJkIG1hdGNoIGluIGEgcm91dGUgc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICogZXhlYygnL2Zvby8qYmFyL2JheicpO1xyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gL1xcKlxcdyovZztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVnZXgucHJvdG90eXBlLCBcImVzY2FwZVJvdXRlUmVnZXhcIiwge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBGaW5kcyBpbnZhbGlkIGNoYXJhY3RlcnMgaW4gYSByb3V0ZSBzdHJpbmcuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAvW1xcLXt9XFxbXFxdKz8uLFxcXFxcXF4kfCNcXHNdL2c7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZ2V4LnByb3RvdHlwZSwgXCJjYW1lbENhc2VSZWdleFwiLCB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEZpbmRzIGRlbGltZXRlcnMgZm9yIHNwaW5hbC1jYXNlLCBzbmFrZV9jYXNlLCBhbmQgZG90LmNhc2UuXHJcbiAgICAgICAgICAgICAgICAgKiB1c2VmdWwgZm9yIGNvbnZlcnRpbmcgdG8gY2FtZWxDYXNlLiBBbHNvIGNhbiB0dXJuIGEgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgKiBpbnRvIGNhbWVsQ2FzZSB3aXRoIHNwYWNlIGFzIGEgZGVsaW1ldGVyLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLyhbXFwtX1xcLlxcc10pKFxcdys/KS9nO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWdleC5wcm90b3R5cGUsIFwiY2FwaXRhbENhc2VSZWdleFwiLCB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEZpbmRzIGFsbCBjYXBpdGFsIGxldHRlcnMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAvW0EtWl0vZztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVnZXgucHJvdG90eXBlLCBcIndoaXRlU3BhY2VSZWdleFwiLCB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEZpbmRzIGFsbCB3aGl0ZXNwYWNlIGFuZCBuZXdsaW5lIGNoYXJhY3RlcnNcclxuICAgICAgICAgICAgICAgICAqIG5vdCBpbiBzdHJpbmcgbGl0ZXJhbHMuIE5lZWRzIHRvIGJlIGNvbWJpbmVkXHJcbiAgICAgICAgICAgICAgICAgKiB3aXRoIHN0cmluZyByZXBsYWNlIGZ1bmN0aW9uIHVzaW5nICQxIGFyZ3VtZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLyhcIlteXCJdKj9cInwnW14nXSo/Jyl8W1xcc1xcclxcblxcdFxcdl0vZztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVnZXgucHJvdG90eXBlLCBcInF1b3RhdGlvblJlZ2V4XCIsIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRmluZHMgYWxsIHNpbmdsZSBhbmQgZG91YmxlIHF1b3Rlcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC8nfFwiL2c7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIFJlZ2V4O1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgZXhwcmVzc2lvbnMuUmVnZXggPSBSZWdleDtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fUmVnZXgsIFJlZ2V4KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGNsYXNzIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIHRha2luZyBpbiBhIEphdmFTY3JpcHQgZXhwcmVzc2lvbiBzdHJpbmcgYW5kXHJcbiAgICAgICAgICogZmluZGluZyBhbGwgb2YgaXRzIHRva2VucyAoaS5lLiBkZWxpbWl0ZXJzLCBvcGVyYXRvcnMsIGV0YykuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFRva2VuaXplciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFRva2VuaXplcigpIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIHByZXZpb3VzIGNoYXJhY3RlciBkdXJpbmcgdG9rZW5pemF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fcHJldmlvdXNDaGFyID0gJyc7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgcmVndWxhciBleHByZXNzaW9uIGZvciBkZXRlcm1pbmluZyBpZiBhIHBvdGVudGlhbCB2YXJpYWJsZSBpcyB2YWxpZCBzeW50YXguXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX192YXJpYWJsZVJlZ2V4ID0gYWNxdWlyZShfX1JlZ2V4KS5pbnZhbGlkVmFyaWFibGVSZWdleDtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBxdWV1ZSB1c2VkIGZvciBkZXRlcm1pbmluZyB0aGUgb3V0cHV0IG9mIHRoZSB0b2tlbml6YXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX19vdXRwdXRRdWV1ZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIHN0YWNrIHVzZWQgZm9yIGRldGVybWluaW5nIG9wZXJhdG9yIHByZWNlZGVuY2UgYW5kIGFpZGluZyB3aXRoIHRoZSBldmFsdWF0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBvcGVyYW5kcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX29wZXJhdG9yU3RhY2sgPSBbXTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBjb2xsZWN0aW9uIHVzZWQgZm9yIGRldGVybWluaW5nIGFyZ3VtZW50IGNvdW50IGZvciBjZXJ0YWluIG9wZXJhdGlvbnMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX19hcmdDb3VudCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIGNvbGxlY3Rpb24gdXNlZCBmb3IgZGV0ZXJtaW5pbmcgYXJndW1lbnQgY291bnQgZm9yIGNlcnRhaW4gb2JqZWN0IGxpdGVyYWwgb3BlcmF0aW9ucy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX29iakFyZ0NvdW50ID0gW107XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBsYXN0IGNoYXJhY3RlciBlbmNvdW50ZXJlZCB3aGlsZSBpbiBhbiBvcGVyYXRpb24gZGVhbGluZyB3aXRoIHRoZSBjb2xvbiBvcGVyYXRvci5cclxuICAgICAgICAgICAgICAgICAqIE5lZWRzIHRvIGJlIGFuIGFycmF5IGR1ZSB0byB0aGUgcG9zc2liaWxpdHkgb2YgbmVzdGVkIGNvbG9uIG9wZXJhdGlvbnMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX19sYXN0Q29sb25DaGFyID0gW107XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBsYXN0IGNoYXJhY3RlciBlbmNvdW50ZXJlZCB3aGlsZSBpbiBhbiBvcGVyYXRpb24gZGVhbGluZyB3aXRoIGNvbW1hcy5cclxuICAgICAgICAgICAgICAgICAqIE5lZWRzIHRvIGJlIGFuIGFycmF5IGR1ZSB0byB0aGUgcG9zc2liaWxpdHkgb2YgbmVzdGVkIGNvbW1hIG9wZXJhdGlvbnMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX19sYXN0Q29tbWFDaGFyID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRha2VzIGluIGFuIGV4cHJlc3Npb24gc3RyaW5nIGFuZCBvdXRwdXRzIGEgdG9rZW5pemVkIGNvbGxlY3Rpb24gb2ZcclxuICAgICAgICAgICAgICogSVRva2Vucy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IFRoZSBKYXZhU2NyaXB0IGV4cHJlc3Npb24gc3RyaW5nIHRvIHRva2VuaXplLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5jcmVhdGVUb2tlbnMgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcclxuICAgICAgICAgICAgICAgIHZhciBjaGFyLCBsZW5ndGggPSBpbnB1dC5sZW5ndGgsIHRlcm5hcnkgPSAwLCB0ZXJuYXJ5Rm91bmQgPSBmYWxzZSwgaXNTcGFjZSA9IHRoaXMuX2lzU3BhY2UsIGlzQWxwaGFOdW1lcmljID0gdGhpcy5faXNBbHBoYU51bWVyaWM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhciA9IGlucHV0W2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzcGFjZSBcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTcGFjZShjaGFyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNBbHBoYU51bWVyaWMoY2hhcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLl9faGFuZGxlQXBsaGFOdW1lcmljKGluZGV4LCBjaGFyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNEZWxpbWl0ZXIoY2hhcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcuJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuX19oYW5kbGVQZXJpb2QoaW5kZXgsIGNoYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAneyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2hhbmRsZUxlZnRCcmFjZShjaGFyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ30nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19oYW5kbGVSaWdodEJyYWNlKGNoYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnWyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2hhbmRsZUxlZnRCcmFja2V0KGNoYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnXSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2hhbmRsZVJpZ2h0QnJhY2tldChjaGFyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJygnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19oYW5kbGVMZWZ0UGFyZW50aGVzaXMoY2hhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcpJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9faGFuZGxlUmlnaHRQYXJlbnRoZXNpcyhjaGFyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJywnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19oYW5kbGVDb21tYShjaGFyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1xcJyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdcIic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLl9faGFuZGxlU3RyaW5nTGl0ZXJhbChpbmRleCwgY2hhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNPcGVyYXRvcihjaGFyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJz8nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlcm5hcnlGb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVybmFyeSsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19oYW5kbGVRdWVzdGlvbihjaGFyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzonOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlcm5hcnkgPSB0aGlzLl9faGFuZGxlQ29sb24oY2hhciwgdGVybmFyeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5fX2hhbmRsZU90aGVyT3BlcmF0b3IoaW5kZXgsIGNoYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09ICc7Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKCdVbmV4cGVjdGVkIHNlbWljb2xvbicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19wcmV2aW91c0NoYXIgPSBjaGFyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRlcm5hcnlGb3VuZCAmJiAodGVybmFyeSA+IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcignSW1wcm9wZXIgdGVybmFyeSBleHByZXNzaW9uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fX29iakFyZ0NvdW50Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKCdJbXByb3BlciBvYmplY3QgbGl0ZXJhbCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX19wb3BSZW1haW5pbmdPcGVyYXRvcnMoKTtcclxuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9fb3V0cHV0UXVldWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNldFRva2VuaXplcigpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERldGVybWluZXMgY2hhcmFjdGVyIHR5cGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyIFRoZSBjaGFyYWN0ZXIgdG8gY2hlY2suXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNOdW1iZXJMaWtlIFdoZXRoZXIgb3Igbm90IHRoZSBjaGFyYWN0ZXIgcmVzZW1ibGVzIGEgbnVtYmVyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5fY2hlY2tUeXBlID0gZnVuY3Rpb24gKGNoYXIsIGlzTnVtYmVyTGlrZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyTGlrZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc051bWVyaWMoY2hhcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faXNBbHBoYU51bWVyaWMoY2hhcik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBMb29rcyBhaGVhZCBpbiB0aGUgZXhwcmVzc2lvbiB0byBncm91cCBzaW1pbGFyIGNoYXJhY3RlciB0eXBlcy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXIgVGhlIGN1cnJlbnQgY2hhcmFjdGVyIGluIHRoZSBleHByZXNzaW9uIHN0cmluZy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBjdXJyZW50IGluZGV4IGluIHRoZSBleHByZXNzaW9uIHN0cmluZy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBpc051bWJlckxpa2UgV2hldGhlciBvciBub3QgdGhlIGNoYXJhY3RlciByZXNlbWJsZXMgYSBudW1iZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLl9sb29rQWhlYWQgPSBmdW5jdGlvbiAoY2hhciwgaW5kZXgsIGlzTnVtYmVyTGlrZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoLCBpbnB1dCA9IHRoaXMuX2lucHV0LCBtYXhMZW5ndGggPSBpbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IG1heExlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoID0gaW5wdXRbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jaGVja1R5cGUoY2gsIGlzTnVtYmVyTGlrZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhciArPSBjaDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFyO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTG9va3MgYWhlYWQgaW4gdGhlIGV4cHJlc3Npb24gdG8gdHJ5IGFuZCBjb21wbGV0ZSB0aGVcclxuICAgICAgICAgICAgICogY3VycmVudCBvcGVyYXRvci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXIgVGhlIG9wZXJhdG9yIHRvIGZpbmQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgY3VycmVudCBpbmRleCBpbiB0aGUgZXhwcmVzc2lvbiBzdHJpbmcuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLl9sb29rQWhlYWRGb3JPcGVyYXRvckZuID0gZnVuY3Rpb24gKGNoYXIsIGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2gsIGZuID0gY2hhciwgaW5wdXQgPSB0aGlzLl9pbnB1dCwgbWF4TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBtYXhMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaCA9IGlucHV0W2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICBmbiArPSBjaDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNPcGVyYXRvcihmbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhciA9IGZuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYXI7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBMb29rcyBhaGVhZCBpbiB0aGUgZXhwcmVzc2lvbiB1bnRpbCBpdCBjb21lcyB0byB0aGUgZW5kaW5nXHJcbiAgICAgICAgICAgICAqIGNoYXJhY3RlciB0byB0cnkgYW5kIGNvbXBsZXRlIGEgcGFydGljdWxhciBzZXF1ZW5jZVxyXG4gICAgICAgICAgICAgKiAoZS5nLiAtIGEgc3RyaW5nIGxpdGVyYWwpLiBBbHNvIHN0cmlwcyB0aGUgZmlyc3QgYW5kIGxhc3RcclxuICAgICAgICAgICAgICogY2hhcmFjdGVycyBvZiB0aGUgcmVzdWx0IChpLmUuIHJlbW92ZXMgdGhlIGRlbGltaXRlcnMpLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW5kQ2hhciBUaGUgZW5kaW5nIGNoYXJhY3Rlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBjdXJyZW50IGluZGV4IGluIHRoZSBleHByZXNzaW9uIHN0cmluZy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRva2VuaXplci5wcm90b3R5cGUuX2xvb2tBaGVhZEZvckRlbGltaXRlciA9IGZ1bmN0aW9uIChlbmRDaGFyLCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoYXIgPSAnJywgY2gsIGlucHV0ID0gdGhpcy5faW5wdXQsIG1heExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHdoaWxlICgoKytpbmRleCA8IG1heExlbmd0aCkgJiYgKGNoID0gaW5wdXRbaW5kZXhdKSAhPT0gZW5kQ2hhcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXIgKz0gY2g7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhcjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBvcHMgdGhlIG9wZXJhdG9yIHN0YWNrIG9udG8gdGhlIG91dHB1dCBxdWV1ZSB1bnRpbCBhIHBhcnRpY3VsYXJcclxuICAgICAgICAgICAgICogb3BlcmF0b3IgdmFsdWUgaXMgcmVhY2hlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LmV4cHJlc3Npb25zLklUb2tlbn0gdG9wT3BlcmF0b3IgVGhlIHRvcCBvZiB0aGUgb3BlcmF0b3Igc3RhY2suXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyIFRoZSBvcGVyYXRvciB2YWx1ZSBiZWluZyBzZWFyY2hlZCBmb3IuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlcnJvciBUaGUgZXJyb3IgdG8gdGhyb3cgaW4gdGhlIGNhc2UgdGhhdCB0aGUgZXhwcmVzc2lvblxyXG4gICAgICAgICAgICAgKiBpcyBpbnZhbGlkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5fcG9wU3RhY2tGb3JWYWwgPSBmdW5jdGlvbiAodG9wT3BlcmF0b3IsIGNoYXIsIGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0UXVldWUgPSB0aGlzLl9fb3V0cHV0UXVldWUsIG9wZXJhdG9yU3RhY2sgPSB0aGlzLl9fb3BlcmF0b3JTdGFjaztcclxuICAgICAgICAgICAgICAgIHdoaWxlICh0b3BPcGVyYXRvci52YWwgIT09IGNoYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRRdWV1ZS5wdXNoKG9wZXJhdG9yU3RhY2suc2hpZnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9wT3BlcmF0b3IgPSBvcGVyYXRvclN0YWNrWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRvclN0YWNrLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhyb3dFcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2hlY2sgaWYgdGhlIFwidmFsXCIgcHJvcGVydHkgb24gYW4gSVRva2VuXHJcbiAgICAgICAgICAgICAqIGlzIHByZXNlbnQgaW4gYSBwYXJ0aWN1bGFyIGNoYXJhY3RlciBzdHJpbmcuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5leHByZXNzaW9ucy5JVG9rZW59IG9iaiBUaGUgSVRva2VuXHJcbiAgICAgICAgICAgICAqIHdpdGggdGhlIFwidmFsXCIgcHJvcGVydHkgdG8gY29tcGFyZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXIgVGhlIGNoYXIgdG8gY29tcGFyZSB3aXRoLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5faXNWYWxFcXVhbCA9IGZ1bmN0aW9uIChvYmosIGNoYXIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwob2JqKSB8fCBpc051bGwob2JqLnZhbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNOdWxsKGNoYXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2JqLnZhbCA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhciA9PT0gJyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhci5pbmRleE9mKG9iai52YWwpICE9PSAtMTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENoZWNrIGlmIHRoZSBcInZhbFwiIHByb3BlcnR5IG9uIGFuIElUb2tlblxyXG4gICAgICAgICAgICAgKiBpcyBub3QgcHJlc2VudCBpbiBhIHBhcnRpY3VsYXIgY2hhcmFjdGVyIHN0cmluZy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LmV4cHJlc3Npb25zLklUb2tlbn0gb2JqIFRoZSBJVG9rZW5cclxuICAgICAgICAgICAgICogd2l0aCB0aGUgXCJ2YWxcIiBwcm9wZXJ0eSB0byBjb21wYXJlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhciBUaGUgY2hhciB0byBjb21wYXJlIHdpdGguXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLl9pc1ZhbFVuZXF1YWwgPSBmdW5jdGlvbiAob2JqLCBjaGFyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKG9iaikgfHwgaXNOdWxsKG9iai52YWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFpc051bGwoY2hhcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvYmoudmFsID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFyICE9PSAnJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFyLmluZGV4T2Yob2JqLnZhbCkgPT09IC0xO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVzZXRzIGFsbCB0aGUgdG9rZW5pemVyJ3MgcHJvcGVydGllcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRva2VuaXplci5wcm90b3R5cGUuX3Jlc2V0VG9rZW5pemVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5wdXQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3ByZXZpb3VzQ2hhciA9ICcnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX291dHB1dFF1ZXVlID0gW107XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fb3BlcmF0b3JTdGFjayA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2FyZ0NvdW50ID0gW107XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fb2JqQXJnQ291bnQgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19sYXN0Q29sb25DaGFyID0gW107XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fbGFzdENvbW1hQ2hhciA9IFtdO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhyb3dzIGEgZmF0YWwgZXhjZXB0aW9uIGluIHRoZSBjYXNlIG9mIGFuIGVycm9yLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXJyb3IgVGhlIGVycm9yIG1lc3NhZ2UgdG8gdGhyb3cuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLl90aHJvd0Vycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZXJyb3IobmV3IEVycm9yKGVycm9yICsgJyBpbiAnICsgdGhpcy5faW5wdXQpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENoZWNrcyBpZiBhIHNpbmdsZSBjaGFyYWN0ZXIgaXMgbnVtZXJpYy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXIgVGhlIGNoYXJhY3RlciB0byBjaGVjay5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRva2VuaXplci5wcm90b3R5cGUuX2lzTnVtZXJpYyA9IGZ1bmN0aW9uIChjaGFyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCcwJyA8PSBjaGFyICYmIGNoYXIgPD0gJzknKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENoZWNrcyBpZiBhIHNpbmdsZSBjaGFyYWN0ZXIgaXMgYSBzcGFjZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXIgVGhlIGNoYXJhY3RlciB0byBjaGVjay5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRva2VuaXplci5wcm90b3R5cGUuX2lzU3BhY2UgPSBmdW5jdGlvbiAoY2hhcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChjaGFyID09PSAnICcgfHxcclxuICAgICAgICAgICAgICAgICAgICBjaGFyID09PSAnXFxyJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGNoYXIgPT09ICdcXG4nIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhciA9PT0gJ1xcdCcgfHxcclxuICAgICAgICAgICAgICAgICAgICBjaGFyID09PSAnXFx2JyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGNoYXIgPT09ICdcXHUwMEEwJyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDaGVja3MgaWYgYSBzaW5nbGUgY2hhcmFjdGVyIGlzIGFscGhhbnVtZXJpYy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXIgVGhlIGNoYXJhY3RlciB0byBjaGVjay5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRva2VuaXplci5wcm90b3R5cGUuX2lzQWxwaGFOdW1lcmljID0gZnVuY3Rpb24gKGNoYXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoJ2EnIDw9IGNoYXIgJiYgY2hhciA8PSAneicgfHxcclxuICAgICAgICAgICAgICAgICAgICAnQScgPD0gY2hhciAmJiBjaGFyIDw9ICdaJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICcwJyA8PSBjaGFyICYmIGNoYXIgPD0gJzknIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgJ0AnID09PSBjaGFyIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgJ18nID09PSBjaGFyIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgJyQnID09PSBjaGFyKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENoZWNrcyBpZiBhIHN0cmluZyBoYXMgcHJvcGVyIEphdmFTY3JpcHQgdmFyaWFibGUgc3ludGF4LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyB0byBjaGVjay5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRva2VuaXplci5wcm90b3R5cGUuX2lzU3RyaW5nVmFsaWRWYXJpYWJsZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLl9fdmFyaWFibGVSZWdleC50ZXN0KGlucHV0KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEhhbmRsZXMgdG9rZW5pemluZyBhbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGN1cnJlbnQgaW5kZXggaW4gdGhlIHN0cmluZyBiZWluZyB0b2tlbml6ZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyIFRoZSBjdXJyZW50IGNoYXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLl9faGFuZGxlQXBsaGFOdW1lcmljID0gZnVuY3Rpb24gKGluZGV4LCBjaGFyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNOdW1iZXJMaWtlID0gdGhpcy5faXNOdW1lcmljKGNoYXIpLCBsb29rQWhlYWQgPSB0aGlzLl9sb29rQWhlYWQoY2hhciwgaW5kZXgsIGlzTnVtYmVyTGlrZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fb3V0cHV0UXVldWUucHVzaChpc051bWJlckxpa2UgPyAoeyB2YWw6IE51bWJlcihsb29rQWhlYWQpLCBhcmdzOiAwIH0pIDpcclxuICAgICAgICAgICAgICAgICAgICAoeyB2YWw6IGxvb2tBaGVhZCwgYXJnczogLTEgfSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ICsgbG9va0FoZWFkLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBIYW5kbGVzIHRva2VuaXppbmcgYSBcIi5cIiBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgY3VycmVudCBpbmRleCBpbiB0aGUgc3RyaW5nIGJlaW5nIHRva2VuaXplZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXIgVGhlIGN1cnJlbnQgY2hhci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRva2VuaXplci5wcm90b3R5cGUuX19oYW5kbGVQZXJpb2QgPSBmdW5jdGlvbiAoaW5kZXgsIGNoYXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvdXRwdXRRdWV1ZSA9IHRoaXMuX19vdXRwdXRRdWV1ZSwgb3BlcmF0b3JTdGFjayA9IHRoaXMuX19vcGVyYXRvclN0YWNrLCB0b3BPdXRwdXRMZW5ndGggPSBvdXRwdXRRdWV1ZS5sZW5ndGggLSAxLCBwcmV2aW91c0NoYXIgPSB0aGlzLl9fcHJldmlvdXNDaGFyLCBsb29rQWhlYWQ7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBvdXRwdXQgcXVldWUgaXMgbnVsbCBPUiBzcGFjZSBvciBvcGVyYXRvciBvciAoIG9yICwgYmVmb3JlIC4gXHJcbiAgICAgICAgICAgICAgICBpZiAodG9wT3V0cHV0TGVuZ3RoIDwgMCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzU3BhY2UocHJldmlvdXNDaGFyKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICFpc051bGwoT1BFUkFUT1JTW3ByZXZpb3VzQ2hhcl0pIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNDaGFyID09PSAnKCcgfHxcclxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0NoYXIgPT09ICcsJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvb2tBaGVhZCA9IHRoaXMuX2xvb2tBaGVhZChjaGFyLCBpbmRleCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gbG9va0FoZWFkLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0UXVldWUucHVzaCh7IHZhbDogcGFyc2VGbG9hdChsb29rQWhlYWQpLCBhcmdzOiAwIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5faXNWYWxFcXVhbChvcGVyYXRvclN0YWNrWzBdLCBjaGFyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFF1ZXVlLnB1c2goeyB2YWw6IGNoYXIsIGFyZ3M6IDAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghKGlzTnVsbChvdXRwdXRRdWV1ZVt0b3BPdXRwdXRMZW5ndGhdKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICFpc051bWJlcihOdW1iZXIob3V0cHV0UXVldWVbdG9wT3V0cHV0TGVuZ3RoXS52YWwpKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzVmFsRXF1YWwob3V0cHV0UXVldWVbdG9wT3V0cHV0TGVuZ3RoIC0gMV0sIGNoYXIpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvb2tBaGVhZCA9IHRoaXMuX2xvb2tBaGVhZChjaGFyLCBpbmRleCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gbG9va0FoZWFkLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0UXVldWVbdG9wT3V0cHV0TGVuZ3RoXS52YWwgKz0gcGFyc2VGbG9hdChsb29rQWhlYWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3JTdGFjay51bnNoaWZ0KHsgdmFsOiBjaGFyLCBhcmdzOiAwIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSGFuZGxlcyB0b2tlbml6aW5nIGEgXCJ7XCIgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhciBUaGUgY3VycmVudCBjaGFyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5fX2hhbmRsZUxlZnRCcmFjZSA9IGZ1bmN0aW9uIChjaGFyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fb3BlcmF0b3JTdGFjay51bnNoaWZ0KHsgdmFsOiBjaGFyLCBhcmdzOiAwIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX29iakFyZ0NvdW50LnB1c2goMCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fbGFzdENvbG9uQ2hhci5wdXNoKGNoYXIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2xhc3RDb21tYUNoYXIucHVzaChjaGFyKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEhhbmRsZXMgdG9rZW5pemluZyBhIFwifVwiIGNoYXJhY3Rlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXIgVGhlIGN1cnJlbnQgY2hhci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRva2VuaXplci5wcm90b3R5cGUuX19oYW5kbGVSaWdodEJyYWNlID0gZnVuY3Rpb24gKGNoYXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvcGVyYXRvclN0YWNrID0gdGhpcy5fX29wZXJhdG9yU3RhY2ssIHRvcE9wZXJhdG9yID0gb3BlcmF0b3JTdGFja1swXSwgbGFzdEFyZ0NvdW50ID0gdGhpcy5fX29iakFyZ0NvdW50LnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbCh0b3BPcGVyYXRvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhyb3dFcnJvcignSW1wcm9wZXIgb2JqZWN0IGxpdGVyYWwnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3BvcFN0YWNrRm9yVmFsKHRvcE9wZXJhdG9yLCAneycsICdJbXByb3BlciBvYmplY3QgbGl0ZXJhbCcpO1xyXG4gICAgICAgICAgICAgICAgLy8gcG9wIGxlZnQgYnJhY2Ugb2ZmIHN0YWNrIFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0b3JTdGFjay5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2xhc3RDb2xvbkNoYXIucG9wKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fbGFzdENvbW1hQ2hhci5wb3AoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19vdXRwdXRRdWV1ZS5wdXNoKHsgdmFsOiAne30nLCBhcmdzOiBsYXN0QXJnQ291bnQgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBIYW5kbGVzIHRva2VuaXppbmcgYSBcIltcIiBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyIFRoZSBjdXJyZW50IGNoYXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLl9faGFuZGxlTGVmdEJyYWNrZXQgPSBmdW5jdGlvbiAoY2hhcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzQ2hhciA9IHRoaXMuX19wcmV2aW91c0NoYXIsIG9wZXJhdG9yU3RhY2sgPSB0aGlzLl9fb3BlcmF0b3JTdGFjaztcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1ZhbEVxdWFsKG9wZXJhdG9yU3RhY2tbMF0sICcuJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fb3V0cHV0UXVldWUucHVzaChvcGVyYXRvclN0YWNrLnNoaWZ0KCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3BlcmF0b3JTdGFjay51bnNoaWZ0KHsgdmFsOiBjaGFyLCBhcmdzOiAwIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2FyZ0NvdW50LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIG51bTogMCxcclxuICAgICAgICAgICAgICAgICAgICBpc0FycmF5OiAhKHByZXZpb3VzQ2hhciA9PT0gJ10nIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzQ2hhciA9PT0gJyknIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzQWxwaGFOdW1lcmljKHByZXZpb3VzQ2hhcikpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19sYXN0Q29tbWFDaGFyLnB1c2goY2hhcik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBIYW5kbGVzIHRva2VuaXppbmcgYSBcIl1cIiBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyIFRoZSBjdXJyZW50IGNoYXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLl9faGFuZGxlUmlnaHRCcmFja2V0ID0gZnVuY3Rpb24gKGNoYXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvcGVyYXRvclN0YWNrID0gdGhpcy5fX29wZXJhdG9yU3RhY2ssIHRvcE9wZXJhdG9yID0gb3BlcmF0b3JTdGFja1swXSwgbGFzdEFyZ0NvdW50T2JqID0gdGhpcy5fX2FyZ0NvdW50LnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbCh0b3BPcGVyYXRvcikgfHwgaXNOdWxsKGxhc3RBcmdDb3VudE9iaikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhyb3dFcnJvcignQnJhY2tldHMgbWlzbWF0Y2gnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghbGFzdEFyZ0NvdW50T2JqLmlzQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0QXJnQ291bnRPYmoubnVtLS07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3BTdGFja0ZvclZhbCh0b3BPcGVyYXRvciwgJ1snLCAnQnJhY2tldHMgbWlzbWF0Y2gnKTtcclxuICAgICAgICAgICAgICAgIC8vIHBvcCBsZWZ0IGJyYWNrZXQgb2ZmIHN0YWNrIFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0b3JTdGFjay5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2xhc3RDb21tYUNoYXIucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBmdW5jdGlvbiBvbiB0b3Agb2Ygc3RhY2sgXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fb3V0cHV0UXVldWUucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsOiAnW10nLFxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6ICh0aGlzLl9fcHJldmlvdXNDaGFyID09PSAnWycpID8gLTEgOiBsYXN0QXJnQ291bnRPYmoubnVtICsgMVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBIYW5kbGVzIHRva2VuaXppbmcgYSBcIihcIiBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyIFRoZSBjdXJyZW50IGNoYXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLl9faGFuZGxlTGVmdFBhcmVudGhlc2lzID0gZnVuY3Rpb24gKGNoYXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0NoYXIgPSB0aGlzLl9fcHJldmlvdXNDaGFyLCBvcGVyYXRvclN0YWNrID0gdGhpcy5fX29wZXJhdG9yU3RhY2ssIGFyZ3M7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNBbHBoYU51bWVyaWMocHJldmlvdXNDaGFyKSB8fCBwcmV2aW91c0NoYXIgPT09ICddJyB8fCBwcmV2aW91c0NoYXIgPT09ICcpJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXRRdWV1ZSA9IHRoaXMuX19vdXRwdXRRdWV1ZSwgdG9wT3V0cHV0ID0gb3V0cHV0UXVldWVbb3V0cHV0UXVldWUubGVuZ3RoIC0gMV0sIHZhbCA9IGlzTnVsbCh0b3BPdXRwdXQpID8gdW5kZWZpbmVkIDogdG9wT3V0cHV0LnZhbDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsID09PSAnW10nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yU3RhY2sudW5zaGlmdChvdXRwdXRRdWV1ZS5wb3AoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yU3RhY2sudW5zaGlmdChvdXRwdXRRdWV1ZS5wb3AoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCEodmFsID09PSAnKCknIHx8IHRoaXMuX2lzTnVtZXJpYyh2YWwpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvclN0YWNrLnVuc2hpZnQob3V0cHV0UXVldWUucG9wKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhcmdzID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX19hcmdDb3VudC5wdXNoKHsgbnVtOiBhcmdzIH0pO1xyXG4gICAgICAgICAgICAgICAgb3BlcmF0b3JTdGFjay51bnNoaWZ0KHsgdmFsOiBjaGFyLCBhcmdzOiBhcmdzIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2xhc3RDb21tYUNoYXIucHVzaChjaGFyKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEhhbmRsZXMgdG9rZW5pemluZyBhIFwiKVwiIGNoYXJhY3Rlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXIgVGhlIGN1cnJlbnQgY2hhci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRva2VuaXplci5wcm90b3R5cGUuX19oYW5kbGVSaWdodFBhcmVudGhlc2lzID0gZnVuY3Rpb24gKGNoYXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvcGVyYXRvclN0YWNrID0gdGhpcy5fX29wZXJhdG9yU3RhY2ssIHRvcE9wZXJhdG9yID0gb3BlcmF0b3JTdGFja1swXSwgbG9jYWxBcmdDb3VudE9iaiA9IHRoaXMuX19hcmdDb3VudC5wb3AoKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwodG9wT3BlcmF0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Rocm93RXJyb3IoJ1BhcmVudGhlc2VzIG1pc21hdGNoJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3BTdGFja0ZvclZhbCh0b3BPcGVyYXRvciwgJygnLCAnUGFyZW50aGVzZXMgbWlzbWF0Y2gnKTtcclxuICAgICAgICAgICAgICAgIC8vIHBvcCBsZWZ0IHBhcmVudGhlc2lzIG9mZiBzdGFjayBcclxuICAgICAgICAgICAgICAgIG9wZXJhdG9yU3RhY2suc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19sYXN0Q29tbWFDaGFyLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgZnVuY3Rpb24gb24gdG9wIG9mIHN0YWNrIFxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGwobG9jYWxBcmdDb3VudE9iaikgJiYgbG9jYWxBcmdDb3VudE9iai5udW0gPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2NhbEFyZ051bSA9IGxvY2FsQXJnQ291bnRPYmoubnVtO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fcHJldmlvdXNDaGFyID09PSAnKCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX19yZW1vdmVGbkZyb21TdGFjayhsb2NhbEFyZ051bSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19vdXRwdXRRdWV1ZS5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWw6ICcoKScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fX3JlbW92ZUZuRnJvbVN0YWNrKGxvY2FsQXJnTnVtICsgMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX291dHB1dFF1ZXVlLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsOiAnKCknLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogKGxvY2FsQXJnTnVtICsgMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSGFuZGxlcyB0b2tlbml6aW5nIGEgXCIsXCIgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhciBUaGUgY3VycmVudCBjaGFyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5fX2hhbmRsZUNvbW1hID0gZnVuY3Rpb24gKGNoYXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsYXN0Q29tbWFBcnJheSA9IHRoaXMuX19sYXN0Q29tbWFDaGFyLCBsYXN0Q29tbWFBcmcgPSBsYXN0Q29tbWFBcnJheVtsYXN0Q29tbWFBcnJheS5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIGlmIChsYXN0Q29tbWFBcmcgPT09ICcoJyB8fCBsYXN0Q29tbWFBcmcgPT09ICdbJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdDb3VudEFycmF5ID0gdGhpcy5fX2FyZ0NvdW50LCBsZW5ndGhfMiA9IGFyZ0NvdW50QXJyYXkubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGhfMiA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IGRlZXBlc3QgZm4gY291bnQgKGRvbid0IG5lZWQgdG8gaW5jcmVtZW50IG9iaiBjb3VudCBiZWNhdXNlIHdlIGluY3JlbWVudCB3aXRoIGNvbG9uKSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnQ291bnRBcnJheVtsZW5ndGhfMiAtIDFdLm51bSsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Rocm93RXJyb3IoJ01pc21hdGNoIHdpdGggJyArIGxhc3RDb21tYUFyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHRvcE9wZXJhdG9yID0gdGhpcy5fX29wZXJhdG9yU3RhY2tbMF07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHRvcE9wZXJhdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90aHJvd0Vycm9yKCdVbmV4cGVjdGVkIGNvbW1hJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3BTdGFja0ZvclZhbCh0b3BPcGVyYXRvciwgbGFzdENvbW1hQXJnLCAnVW5leHBlY3RlZCBjb21tYScpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSGFuZGxlcyB0b2tlbml6aW5nIGEgc3RyaW5nIGxpdGVyYWwuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgY3VycmVudCBpbmRleCBpbiB0aGUgc3RyaW5nIGJlaW5nIHRva2VuaXplZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXIgVGhlIGN1cnJlbnQgY2hhci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRva2VuaXplci5wcm90b3R5cGUuX19oYW5kbGVTdHJpbmdMaXRlcmFsID0gZnVuY3Rpb24gKGluZGV4LCBjaGFyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbG9va0FoZWFkID0gdGhpcy5fbG9va0FoZWFkRm9yRGVsaW1pdGVyKGNoYXIsIGluZGV4KSwgb3BlcmF0b3JTdGFjayA9IHRoaXMuX19vcGVyYXRvclN0YWNrLCB0b3BPcGVyYXRvciA9IG9wZXJhdG9yU3RhY2tbMF07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbCh0b3BPcGVyYXRvcikgJiYgKHRvcE9wZXJhdG9yLnZhbCA9PT0gJ1snIHx8ICh0b3BPcGVyYXRvci52YWwgPT09ICcoJyAmJiB0b3BPcGVyYXRvci5hcmdzID49IDApKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yU3RhY2sudW5zaGlmdCh7IHZhbDogbG9va0FoZWFkLCBhcmdzOiAwIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX291dHB1dFF1ZXVlLnB1c2goeyB2YWw6IGxvb2tBaGVhZCwgYXJnczogMCB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCArIGxvb2tBaGVhZC5sZW5ndGggKyAxO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSGFuZGxlcyB0b2tlbml6aW5nIGEgXCI/XCIgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhciBUaGUgY3VycmVudCBjaGFyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5fX2hhbmRsZVF1ZXN0aW9uID0gZnVuY3Rpb24gKGNoYXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19sYXN0Q29sb25DaGFyLnB1c2goY2hhcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZGV0ZXJtaW5lUHJlY2VkZW5jZShjaGFyKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEhhbmRsZXMgdG9rZW5pemluZyBhIFwiOlwiIGNoYXJhY3Rlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXIgVGhlIGN1cnJlbnQgY2hhci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHRlcm5hcnkgVGhlIGN1cnJlbnQgdGVybmFyeSBjb3VudGVyLiBJbmNyZW1lbnRzIHdoZW4gYSB0ZXJuYXJ5IGlzIGZvdW5kLFxyXG4gICAgICAgICAgICAgKiBkZWNyZW1lbnRzIHdoZW4gYSB0ZXJuYXJ5IGlzIGNvbXBsZXRlZC4gSXQgY2FuIGJlIHZlcnkgdXNlZnVsIHdoZW4gdGhlcmUgaXMgbmVzdGVkIHRlcm5hcmllcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRva2VuaXplci5wcm90b3R5cGUuX19oYW5kbGVDb2xvbiA9IGZ1bmN0aW9uIChjaGFyLCB0ZXJuYXJ5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGFzdENvbG9uQ2hhckFycmF5ID0gdGhpcy5fX2xhc3RDb2xvbkNoYXIsIGxhc3RDb2xvbkNoYXJhY3RlciA9IGxhc3RDb2xvbkNoYXJBcnJheVtsYXN0Q29sb25DaGFyQXJyYXkubGVuZ3RoIC0gMV0sIG91dHB1dFF1ZXVlID0gdGhpcy5fX291dHB1dFF1ZXVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RDb2xvbkNoYXJhY3RlciA9PT0gJz8nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yU3RhY2sgPSB0aGlzLl9fb3BlcmF0b3JTdGFjaywgdG9wT3BlcmF0b3IgPSBvcGVyYXRvclN0YWNrWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwodG9wT3BlcmF0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoJ1Rlcm5hcnkgbWlzbWF0Y2gnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0ZXJuYXJ5LS07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9wIGxhdGVzdCBjb2xvbiBjaGFyIG9mZiBxdWV1ZSBcclxuICAgICAgICAgICAgICAgICAgICBsYXN0Q29sb25DaGFyQXJyYXkucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9wU3RhY2tGb3JWYWwodG9wT3BlcmF0b3IsICc/JywgJ1Rlcm5hcnkgbWlzbWF0Y2gnKTtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRRdWV1ZS5wdXNoKG9wZXJhdG9yU3RhY2suc2hpZnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3JTdGFjay51bnNoaWZ0KHsgdmFsOiBjaGFyLCBhcmdzOiAtMiB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxhc3RDb2xvbkNoYXJhY3RlciA9PT0gJ3snKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iakFyZ0NvdW50ID0gdGhpcy5fX29iakFyZ0NvdW50LCBvdXRwdXRMYXN0ID0gb3V0cHV0UXVldWUubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICBvYmpBcmdDb3VudFtvYmpBcmdDb3VudC5sZW5ndGggLSAxXSsrO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXRMYXN0IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKCdVbmV4cGVjdGVkIGNvbG9uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0UXVldWVbb3V0cHV0TGFzdF0uYXJncyA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKCdVbmV4cGVjdGVkIGNvbG9uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlcm5hcnk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBIYW5kbGVzIHRva2VuaXppbmcgYWxsIG90aGVyIG9wZXJhdG9ycy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBjdXJyZW50IGluZGV4IGluIHRoZSBzdHJpbmcgYmVpbmcgdG9rZW5pemVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhciBUaGUgY3VycmVudCBjaGFyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5fX2hhbmRsZU90aGVyT3BlcmF0b3IgPSBmdW5jdGlvbiAoaW5kZXgsIGNoYXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsb29rQWhlYWQgPSB0aGlzLl9sb29rQWhlYWRGb3JPcGVyYXRvckZuKGNoYXIsIGluZGV4KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19kZXRlcm1pbmVQcmVjZWRlbmNlKGxvb2tBaGVhZCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggKyBsb29rQWhlYWQubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBvcHMgb3BlcmF0b3JzIGxlZnQgb24gdGhlIG9wZXJhdG9yIHN0YWNrIG9udG8gdGhlIG91dHB1dCBxdWV1ZVxyXG4gICAgICAgICAgICAgKiBjaGVja2luZyBmb3IgbWlzbWF0Y2hlcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRva2VuaXplci5wcm90b3R5cGUuX19wb3BSZW1haW5pbmdPcGVyYXRvcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0UXVldWUgPSB0aGlzLl9fb3V0cHV0UXVldWUsIG9wZXJhdG9yU3RhY2sgPSB0aGlzLl9fb3BlcmF0b3JTdGFjaywgdG9wT3BlcmF0b3IsIHRvcE9wZXJhdG9yVmFsO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKG9wZXJhdG9yU3RhY2subGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcE9wZXJhdG9yID0gb3BlcmF0b3JTdGFjay5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcE9wZXJhdG9yVmFsID0gdG9wT3BlcmF0b3IudmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3BPcGVyYXRvclZhbCA9PT0gJygnIHx8IHRvcE9wZXJhdG9yVmFsID09PSAnKScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Rocm93RXJyb3IoJ1BhcmVudGhlc2VzIG1pc21hdGNoJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFF1ZXVlLnB1c2godG9wT3BlcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR3JhYnMgZXNzZW50aWFsIHRva2VuIGRldGFpbHMgZm9yIGEgZ2l2ZW4gb3BlcmF0b3IuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciBUaGUgb3BlcmF0b3Igd2hvc2UgZGV0YWlscyBhcmUgYmVpbmcgcmVxdWVzdGVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5fX2RldGVybWluZU9wZXJhdG9yID0gZnVuY3Rpb24gKG9wZXJhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnKyc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnLSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fb3V0cHV0UXVldWUubGVuZ3RoID09PSAwIHx8IGlzT3BlcmF0b3IodGhpcy5fX3ByZXZpb3VzQ2hhcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBPUEVSQVRPUlNbJ3UnICsgb3BlcmF0b3JdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9QRVJBVE9SU1tvcGVyYXRvcl07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEZXRlcm1pbmVzIHRoZSBwcmVjZWRlbmNlIG9mIGEgZ2l2ZW4gb3BlcmF0b3IgaW4gcmVsYXRpb24gdG8gb3RoZXIgb3BlcmF0b3JzXHJcbiAgICAgICAgICAgICAqIGluIHRoZSBvcGVyYXRvciBzdGFjayBhbmQgcGxhY2VzIGl0IGluIHRoZSBvcGVyYXRvciBzdGFjay5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIFRoZSBvcGVyYXRvciB3aG9zZSBwcmVjZWRlbmNlIGlzIGJlaW5nIGRldGVybWluZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLl9fZGV0ZXJtaW5lUHJlY2VkZW5jZSA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yRm4gPSB0aGlzLl9fZGV0ZXJtaW5lT3BlcmF0b3Iob3BlcmF0b3IpLCBvcGVyYXRvclByZWNlZGVuY2UgPSBvcGVyYXRvckZuLnByZWNlZGVuY2UsIGlzTHRSID0gb3BlcmF0b3JGbi5hc3NvY2lhdGl2aXR5ID09PSAnbHRyJywgb3BlcmF0b3JTdGFjayA9IHRoaXMuX19vcGVyYXRvclN0YWNrLCBvdXRwdXRRdWV1ZSA9IHRoaXMuX19vdXRwdXRRdWV1ZSwgZmlyc3RBcnJheU9wZXJhdG9yLCBmaXJzdEFycmF5VmFsO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yU3RhY2subGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3JTdGFjay51bnNoaWZ0KHsgdmFsOiBvcGVyYXRvciwgYXJnczogb3BlcmF0b3JGbi5mbi5sZW5ndGggLSAyIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICBmaXJzdEFycmF5VmFsID0gb3BlcmF0b3JTdGFja1swXS52YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0QXJyYXlWYWwgPT09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRRdWV1ZS5wdXNoKG9wZXJhdG9yU3RhY2suc2hpZnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmaXJzdEFycmF5T3BlcmF0b3IgPSBPUEVSQVRPUlNbZmlyc3RBcnJheVZhbF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoaXNOdWxsKGZpcnN0QXJyYXlPcGVyYXRvcikgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIShmaXJzdEFycmF5T3BlcmF0b3IucHJlY2VkZW5jZSA8IG9wZXJhdG9yUHJlY2VkZW5jZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlzTHRSICYmIGZpcnN0QXJyYXlPcGVyYXRvci5wcmVjZWRlbmNlID09PSBvcGVyYXRvclByZWNlZGVuY2UpKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0UXVldWUucHVzaChvcGVyYXRvclN0YWNrLnNoaWZ0KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3JTdGFjay51bnNoaWZ0KHsgdmFsOiBvcGVyYXRvciwgYXJnczogb3BlcmF0b3JGbi5mbi5sZW5ndGggLSAyIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAob3BlcmF0b3JTdGFjay5sZW5ndGggPiAwKTtcclxuICAgICAgICAgICAgICAgIG9wZXJhdG9yU3RhY2sudW5zaGlmdCh7IHZhbDogb3BlcmF0b3IsIGFyZ3M6IG9wZXJhdG9yRm4uZm4ubGVuZ3RoIC0gMiB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlbW92ZXMgYSByZWZlcmVuY2UgdG8gYSBmdW5jdGlvbiB0aGF0IGlzIHByZXNlbnQgaW4gdGhlIG9wZXJhdG9yIHN0YWNrIGFuZCBwbGFjZXNcclxuICAgICAgICAgICAgICogaXQgaW4gdGhlIG91dHB1dCBxdWV1ZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGFyZ0NvdW50IFRoZSBjdXJyZW50IGxvY2FsIGFyZ3VtZW50IGNvdW50IHVzZWQgd2l0aCBmdW5jdGlvbnMsXHJcbiAgICAgICAgICAgICAqIGFycmF5cywgYW5kIG9iamVjdCBsaXRlcmFscy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRva2VuaXplci5wcm90b3R5cGUuX19yZW1vdmVGbkZyb21TdGFjayA9IGZ1bmN0aW9uIChhcmdDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dFF1ZXVlID0gdGhpcy5fX291dHB1dFF1ZXVlLCBvcGVyYXRvclN0YWNrID0gdGhpcy5fX29wZXJhdG9yU3RhY2ssIHRvcE9wZXJhdG9yID0gb3BlcmF0b3JTdGFja1swXSwgaXNWYWxFcXVhbCA9IHRoaXMuX2lzVmFsRXF1YWwsIGlzVmFsVW5lcXVhbCA9IHRoaXMuX2lzVmFsVW5lcXVhbCwgZm5Ub2tlbiwgYXRMZWFzdE9uZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKCFpc051bGwodG9wT3BlcmF0b3IpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxVbmVxdWFsKHRvcE9wZXJhdG9yLCAnKFsnKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLl9pc1N0cmluZ1ZhbGlkVmFyaWFibGUodG9wT3BlcmF0b3IudmFsKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbEVxdWFsKHRvcE9wZXJhdG9yLnZhbCwgJy5bXScpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQWNjZXNzb3IodG9wT3BlcmF0b3IudmFsKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmblRva2VuID0gb3BlcmF0b3JTdGFjay5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGZuVG9rZW4uYXJncyAhPT0gLTEgfHwgaXNWYWxFcXVhbChmblRva2VuLCAnLltdJykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuVG9rZW4uYXJncyA9IC0yO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRRdWV1ZS5wdXNoKGZuVG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcE9wZXJhdG9yID0gb3BlcmF0b3JTdGFja1swXTtcclxuICAgICAgICAgICAgICAgICAgICBhdExlYXN0T25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghKGF0TGVhc3RPbmUgfHwgaXNWYWxVbmVxdWFsKG91dHB1dFF1ZXVlW291dHB1dFF1ZXVlLmxlbmd0aCAtIGFyZ0NvdW50IC0gMV0sICcoKScpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGF0TGVhc3RPbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0TGVhc3RPbmU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFRva2VuaXplci5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICAgICAgX2xvZzogX19Mb2dcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFRva2VuaXplcjtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGV4cHJlc3Npb25zLlRva2VuaXplciA9IFRva2VuaXplcjtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fVG9rZW5pemVyLCBUb2tlbml6ZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgY2xhc3MgZm9yIHBhcnNpbmcgSmF2YVNjcmlwdCBleHByZXNzaW9uIHN0cmluZ3MgYW5kIGNyZWF0aW5nXHJcbiAgICAgICAgICogSVBhcnNlZEV4cHJlc3Npb25zLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBQYXJzZXIoKSB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgc2luZ2xlIGV4cHJlc3Npb24ncyB0b2tlbiByZXByZXNlbnRhdGlvbiBjcmVhdGVkIGJ5IGEgVG9rZW5pemVyLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b2tlbnMgPSBbXTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQW4gZXhwcmVzc2lvbiBjYWNoZS4gVXNlZCBzbyB0aGF0IGEgSmF2YVNjcmlwdCBleHByZXNzaW9uIGlzIG9ubHkgZXZlciBwYXJzZWQgb25jZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2NhY2hlID0ge307XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgZHluYW1pY2FsbHkgYnVpbHQgc3RyaW5nIGFycmF5IHRoYXQgcmVwcmVzZW50cyB0aGUgZXZhbHVhdGlvbiBmdW5jdGlvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2NvZGVBcnJheSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIGxpc3Qgb2YgYWxsIHRoZSBpZGVudGlmaWVycyBkaXNjb3ZlcmVkIGluIHRoZSBKYXZhU2NyaXB0IGV4cHJlc3Npb24gc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9faWRlbnRpZmllcnMgPSBbXTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSB0ZW1wb3JhcnkgbGlzdCBvZiBpZGVudGlmaWVycyBmb3VuZCB1c2VkIHRvIGJ1aWxkIGFuZCBldmFsdWF0ZSBlYWNoIGFjdHVhbCBpZGVudGlmaWVyLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fdGVtcElkZW50aWZpZXJzID0gW107XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFuIG9iamVjdCB3aG9zZSBrZXlzIHJlcHJlc2VudCBhIGxpc3Qgb2YgYWxsIHVuaXF1ZSBhbGlhc2VzIGZvdW5kIGluIHRoZSBKYXZhU2NyaXB0IGV4cHJlc3Npb24gc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fYWxpYXNlcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgY29uc3RhbnQgdGhhdCBuZWVkcyB0byBiZSBwcmVwZW5kZWQgdG8gZXZlcnkgZHlhbm1pYyBldmFsIGZ1bmN0aW9uLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZm5FdmFsQ29uc3RhbnQgPSAndmFyIGluaXRpYWxDb250ZXh0O3JldHVybiAnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJzZXMgYSBKYXZhU2NyaXB0IGV4cHJlc3Npb24gc3RyaW5nLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBUaGUgSmF2YVNjcmlwdCBleHByZXNzaW9uIHN0cmluZyB0byBwYXJzZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlZE9iamVjdCA9IHRoaXMuX19jYWNoZVtleHByZXNzaW9uXTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKHBhcnNlZE9iamVjdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBwYXJzZWRPYmplY3QuZXhwcmVzc2lvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcnM6IHBhcnNlZE9iamVjdC5pZGVudGlmaWVycy5zbGljZSgwKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpYXNlczogcGFyc2VkT2JqZWN0LmFsaWFzZXMuc2xpY2UoMCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2YWx1YXRlOiBwYXJzZWRPYmplY3QuZXZhbHVhdGVcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9rZW5zID0gdGhpcy5fdG9rZW5pemVyLmNyZWF0ZVRva2VucyhleHByZXNzaW9uKTtcclxuICAgICAgICAgICAgICAgIHBhcnNlZE9iamVjdCA9IHRoaXMuX2V2YWx1YXRlKGV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkZW50aWZpZXJzID0gcGFyc2VkT2JqZWN0LmlkZW50aWZpZXJzO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlkZW50aWZpZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub01vZGVsXzEgPSBwYXJzZWRPYmplY3QuZXZhbHVhdGUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkT2JqZWN0LmV2YWx1YXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbm9Nb2RlbF8xOyB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2NhY2hlW2V4cHJlc3Npb25dID0gcGFyc2VkT2JqZWN0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZE9iamVjdDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIElmIGEga2V5IGlzIHBhc3NlZCBpbiwgaXQgY2xlYXJzIHRoYXQgc2luZ2xlIHZhbHVlIGluIHRoZSBleHByZXNzaW9uIGNhY2hlLiBJZiBub1xyXG4gICAgICAgICAgICAgKiBrZXkgaXMgcHJlc2VudCwgdGhlIGVudGlyZSBleHByZXNzaW9uIGNhY2hlIHdpbGwgYmUgY2xlYXJlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleT8gQW4gb3B0aW9uYWwga2V5IHRoYXQgd2lsbCBjbGVhciBpdHMgc3RvcmVkIHZhbHVlIGluIHRoZSBleHByZXNzaW9uXHJcbiAgICAgICAgICAgICAqIGNhY2hlIGlmIHBhc3NlZCBpbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkodGhpcy5fX2NhY2hlLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX19jYWNoZSA9IHt9O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRXZhbHVhdGUgdGhlIGN1cnJlbnQgSVRva2VuIGFycmF5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBUaGUgSmF2YVNjcmlwdCBleHByZXNzaW9uIHRvIGV2YWx1YXRlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fZXZhbHVhdGUgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VucyA9IHRoaXMuX3Rva2VucywgbGVuZ3RoID0gdG9rZW5zLmxlbmd0aCwgdGVtcElkZW50aWZpZXJzID0gdGhpcy5fX3RlbXBJZGVudGlmaWVycywgY29kZUFycmF5ID0gdGhpcy5fX2NvZGVBcnJheSwgdXNlTG9jYWxDb250ZXh0ID0gZmFsc2UsIHRva2VuT2JqLCB0b2tlbiwgYXJncztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbk9iaiA9IHRva2Vuc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlbk9iai52YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IHRva2VuT2JqLmFyZ3M7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgaXRzIGFuIGFjY2Vzc29yIFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FjY2Vzc29yKHRva2VuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcoKSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlTG9jYWxDb250ZXh0ID0gdGhpcy5fX2hhbmRsZUZ1bmN0aW9uKGluZGV4LCBhcmdzLCB1c2VMb2NhbENvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAne30nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVBcnJheS5wdXNoKHRoaXMuX19jb252ZXJ0T2JqZWN0KGFyZ3MpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wSWRlbnRpZmllcnMucHVzaCgnLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgZW1wdHkgYXJyYXkgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVBcnJheS5wdXNoKCdbXScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wSWRlbnRpZmllcnMucHVzaCgnLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhcmdzID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlQXJyYXkucHVzaCh0aGlzLl9fY29udmVydEFycmF5TGl0ZXJhbChhcmdzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBJZGVudGlmaWVycy5wdXNoKCcuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VMb2NhbENvbnRleHQgPSB0aGlzLl9faW5kZXhJbnRvT2JqZWN0KGluZGV4LCB0b2tlbiwgdXNlTG9jYWxDb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNPcGVyYXRvcih0b2tlbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgc3RyaW5nIGxpdGVyYWwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlQXJyYXkucHVzaCh0aGlzLl9fY29udmVydFByaW1pdGl2ZShpbmRleCwgdG9rZW4sIGFyZ3MpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc/JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2hhbmRsZVF1ZXN0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzonOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9faGFuZGxlQ29sb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnKyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnLSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9ICd1JyArIHRva2VuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2hhbmRsZU9wZXJhdG9yKHRva2VuLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBvdGVudGlhbCBmdW5jdGlvbiBvciBvYmplY3QgdG8gaW5kZXggaW50byBcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlQXJyYXkucHVzaCh0aGlzLl9fY29udmVydEZ1bmN0aW9uKGluZGV4LCB0b2tlbiwgdXNlTG9jYWxDb250ZXh0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlQXJyYXkucHVzaCh0aGlzLl9fY29udmVydFByaW1pdGl2ZShpbmRleCwgdG9rZW4sIGFyZ3MpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG1vdmUgdGhlIHJlc3Qgb2YgdGhlIHRlbXBJZGVudGlmaWVycyB0byB0aGUgaWRlbnRpZmllcnMgXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3BSZW1haW5pbmdJZGVudGlmaWVycygpO1xyXG4gICAgICAgICAgICAgICAgLy8gbWFrZSB0aGUgaWRlbnRpZmllcnMgYXJyYXkgdW5xaXVlIGVudHJpZXMgb25seSBcclxuICAgICAgICAgICAgICAgIHRoaXMuX21ha2VJZGVudGlmaWVyc1VuaXF1ZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlZEV4cHJlc3Npb24gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZhbHVhdGU6IG5ldyBGdW5jdGlvbihfX0NPTlRFWFQsIF9fQUxJQVNFUywgdGhpcy5fX2ZuRXZhbENvbnN0YW50ICsgKGNvZGVBcnJheS5sZW5ndGggPT09IDAgPyAoJ1wiJyArIGV4cHJlc3Npb24gKyAnXCInKSA6IGNvZGVBcnJheS5qb2luKCcnKSkgKyAnOycpLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcnM6IHRoaXMuX19pZGVudGlmaWVycy5zbGljZSgwKSxcclxuICAgICAgICAgICAgICAgICAgICBhbGlhc2VzOiBPYmplY3Qua2V5cyh0aGlzLl9fYWxpYXNlcylcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvLyByZXNldCBwYXJzZXIncyBwcm9wZXJ0aWVzIFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzZXRQYXJzZXIoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWRFeHByZXNzaW9uO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGVlayBhdCB0aGUgbmV4dCBJVG9rZW4uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggYmVmb3JlIHRoZSBkZXNpcmVkIElUb2tlblxyXG4gICAgICAgICAgICAgKiBpbiB0aGUgYXJyYXkuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9wZWVrID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW5zW2luZGV4ICsgMV07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBMb29rIGJhY2sgYXQgdGhlIHByZXZpb3VzIElUb2tlbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBhZnRlciB0aGUgZGVzaXJlZCBJVG9rZW5cclxuICAgICAgICAgICAgICogaW4gdGhlIGFycmF5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fbG9va0JhY2sgPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90b2tlbnNbaW5kZXggLSAxXTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEV2YWx1YXRlIGFuZCByZW1vdmUgdGhlIGxlZnRvdmVyIGlkZW50aWZpZXJzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fcG9wUmVtYWluaW5nSWRlbnRpZmllcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaWRlbnRpZmllcnMgPSB0aGlzLl9faWRlbnRpZmllcnMsIHRlbXBJZGVudGlmaWVycyA9IHRoaXMuX190ZW1wSWRlbnRpZmllcnMsIGxhc3Q7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAodGVtcElkZW50aWZpZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gdGVtcElkZW50aWZpZXJzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0ICE9PSAnLicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcnMucHVzaChsYXN0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZW1vdmUgZHVwbGljYXRlIGlkZW50aWZpZXJzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fbWFrZUlkZW50aWZpZXJzVW5pcXVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkZW50aWZpZXJzID0gdGhpcy5fX2lkZW50aWZpZXJzLCB1bmlxdWVJZGVudGlmaWVycyA9IFtdLCB1bmlxdWVJZGVudGlmaWVyT2JqZWN0ID0ge30sIGlkZW50aWZpZXI7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaWRlbnRpZmllcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSBpZGVudGlmaWVycy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXVuaXF1ZUlkZW50aWZpZXJPYmplY3RbaWRlbnRpZmllcl0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlSWRlbnRpZmllck9iamVjdFtpZGVudGlmaWVyXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2lkZW50aWZpZXJzID0gdW5pcXVlSWRlbnRpZmllcnM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDaGVjayBpZiB0aGUgXCJ2YWxcIiBwcm9wZXJ0eSBvbiBhbiBJVG9rZW5cclxuICAgICAgICAgICAgICogaXMgcHJlc2VudCBpbiBhIHBhcnRpY3VsYXIgY2hhcmFjdGVyIHN0cmluZy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LmV4cHJlc3Npb25zLklUb2tlbn0gb2JqIFRoZSBJVG9rZW5cclxuICAgICAgICAgICAgICogd2l0aCB0aGUgXCJ2YWxcIiBwcm9wZXJ0eSB0byBjb21wYXJlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhciBUaGUgY2hhciB0byBjb21wYXJlIHdpdGguXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9pc1ZhbEVxdWFsID0gZnVuY3Rpb24gKG9iaiwgY2hhcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChvYmopIHx8IGlzTnVsbChvYmoudmFsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc051bGwoY2hhcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvYmoudmFsID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFyID09PSAnJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFyLmluZGV4T2Yob2JqLnZhbCkgIT09IC0xO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2hlY2sgaWYgdGhlIFwidmFsXCIgcHJvcGVydHkgb24gYW4gSVRva2VuXHJcbiAgICAgICAgICAgICAqIGlzIG5vdCBwcmVzZW50IGluIGEgcGFydGljdWxhciBjaGFyYWN0ZXIgc3RyaW5nLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuZXhwcmVzc2lvbnMuSVRva2VufSBvYmogVGhlIElUb2tlblxyXG4gICAgICAgICAgICAgKiB3aXRoIHRoZSBcInZhbFwiIHByb3BlcnR5IHRvIGNvbXBhcmUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyIFRoZSBjaGFyIHRvIGNvbXBhcmUgd2l0aC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUuX2lzVmFsVW5lcXVhbCA9IGZ1bmN0aW9uIChvYmosIGNoYXIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwob2JqKSB8fCBpc051bGwob2JqLnZhbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWlzTnVsbChjaGFyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9iai52YWwgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYXIgIT09ICcnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYXIuaW5kZXhPZihvYmoudmFsKSA9PT0gLTE7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXNldHMgYWxsIHRoZSBwYXJzZXIncyBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fcmVzZXRQYXJzZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b2tlbnMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19jb2RlQXJyYXkgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19pZGVudGlmaWVycyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3RlbXBJZGVudGlmaWVycyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2FsaWFzZXMgPSB7fTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRocm93cyBhIGZhdGFsIGV4Y2VwdGlvbiBpbiB0aGUgY2FzZSBvZiBhbiBlcnJvci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGVycm9yIFRoZSBlcnJvciBtZXNzYWdlIHRvIHRocm93LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fdGhyb3dFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nLmVycm9yKG5ldyBFcnJvcihlcnJvcikpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSGFuZGxlcyBhIHRva2VuIHRoYXQgaXMgYSBwcmltaXRpdmUgdmFsdWUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgY3VycmVudCBpbmRleCBpbiB0aGUgSVRva2VuIGFycmF5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gVGhlIGN1cnJlbnQgSVRva2VuIHZhbHVlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJncyBUaGUgY3VycmVudCBJVG9rZW4gYXJncy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUuX19jb252ZXJ0UHJpbWl0aXZlID0gZnVuY3Rpb24gKGluZGV4LCB0b2tlbiwgYXJncykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RlbXBJZGVudGlmaWVycy5wdXNoKCcuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGNhc3RUb2tlbklzTnVtYmVyTGlrZSA9IGlzTnVtYmVyKE51bWJlcih0b2tlbikpLCBwZWVrID0gdGhpcy5fcGVlayhpbmRleCksIGlzUGVla0luZGV4ZXIgPSAhKGlzTnVsbChwZWVrKSB8fCBwZWVrLmFyZ3MgPj0gMSksIGlzVmFsRXF1YWwgPSB0aGlzLl9pc1ZhbEVxdWFsO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzS2V5d29yZCh0b2tlbikgfHxcclxuICAgICAgICAgICAgICAgICAgICAoaXNTdHJpbmcodG9rZW4pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChjYXN0VG9rZW5Jc051bWJlckxpa2UgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzVmFsVW5lcXVhbChwZWVrLCAnW10oKScpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaXNWYWxFcXVhbChwZWVrLCAnW10nKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFpc1BlZWtJbmRleGVyKSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RlbXBJZGVudGlmaWVycy5wdXNoKCcuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdcIicgKyB0b2tlbiArICdcIic7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhc3RUb2tlbklzTnVtYmVyTGlrZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoaXNWYWxFcXVhbChwZWVrLCAnLltdJykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUGVla0luZGV4ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX190ZW1wSWRlbnRpZmllcnMucHVzaCh0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdGVtcElkZW50aWZpZXJzLnB1c2goJy4nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSGFuZGxlcyBhIHBvdGVudGlhbCBmdW5jdGlvbiBvciBvYmplY3QgdGhhdCBuZWVkcyB0byBiZSBpbmRleGVkIGludG8uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgY3VycmVudCBpbmRleCBpbiB0aGUgSVRva2VuIGFycmF5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gVGhlIGN1cnJlbnQgSVRva2VuIHZhbHVlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVzZUxvY2FsQ29udGV4dCBXaGV0aGVyIG9yIG5vdCB3ZSBuZWVkIHRvIHVzZSBhbiBhbHJlYWR5IHBhcnNlZCBvYmplY3QgYXMgdGhlIGN1cnJlbnQgY29udGV4dC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUuX19jb252ZXJ0RnVuY3Rpb24gPSBmdW5jdGlvbiAoaW5kZXgsIHRva2VuLCB1c2VMb2NhbENvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlblswXSA9PT0gJ0AnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2FsaWFzZXNbdG9rZW4uc2xpY2UoMSldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzS2V5d29yZCh0b2tlbikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdGVtcElkZW50aWZpZXJzLnB1c2goJy4nKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFRva2VuID0gdGhpcy5fcGVlayhpbmRleCksIGlzVmFsRXF1YWwgPSB0aGlzLl9pc1ZhbEVxdWFsO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsRXF1YWwodGhpcy5fdG9rZW5zW2luZGV4IC0gMV0sICcoKScpICYmIGlzVmFsRXF1YWwobmV4dFRva2VuLCAnLltdJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdGVtcElkZW50aWZpZXJzLnB1c2goJy4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190ZW1wSWRlbnRpZmllcnMucHVzaCh0b2tlbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChuZXh0VG9rZW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChuZXh0VG9rZW4udmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJy4nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcoKSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVzZUxvY2FsQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnKGluaXRpYWxDb250ZXh0ID0gKCcgKyB0aGlzLl9fZmluZEluaXRpYWxDb250ZXh0LnRvU3RyaW5nKCkgKyAnKShjb250ZXh0LGFsaWFzZXMsXCInICsgdG9rZW4gKyAnXCIpKSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyhpbml0aWFsQ29udGV4dCA9ICgnICsgdGhpcy5fX2ZpbmRJbml0aWFsQ29udGV4dC50b1N0cmluZygpICsgJykoY29udGV4dCxhbGlhc2VzLFwiJyArIHRva2VuICsgJ1wiKSknO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSGFuZGxlcyBhbiBvYmplY3QgbGl0ZXJhbC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGFyZ3MgVGhlIGN1cnJlbnQgSVRva2VuIGFyZ3MuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9fY29udmVydE9iamVjdCA9IGZ1bmN0aW9uIChhcmdzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaWRlbnRpZmllcnMgPSB0aGlzLl9faWRlbnRpZmllcnMsIHRlbXBJZGVudGlmaWVycyA9IHRoaXMuX190ZW1wSWRlbnRpZmllcnMsIGNvZGVBcnJheSA9IHRoaXMuX19jb2RlQXJyYXksIGogPSAwLCBrZXksIGNvZGVTdHIgPSAneycsIHRlbXBJZGVudGlmaWVyLCB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGorKyA8IGFyZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wID0gY29kZUFycmF5LnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGNvZGVBcnJheS5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb2RlU3RyICs9ICcsXCInICsga2V5ICsgJ1wiOicgKyB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wSWRlbnRpZmllcnMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wSWRlbnRpZmllciA9IHRlbXBJZGVudGlmaWVycy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcG9wIHRoZSBrZXkncyB0ZW1wSWRlbnRpZmllciBcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcElkZW50aWZpZXJzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVtcElkZW50aWZpZXIgIT09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcnMucHVzaCh0ZW1wSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZVN0ci5yZXBsYWNlKCcsJywgJycpICsgJ30nO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSGFuZGxlcyBhbiBBcnJheSBsaXRlcmFsLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJncyBUaGUgY3VycmVudCBJVG9rZW4gYXJncy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUuX19jb252ZXJ0QXJyYXlMaXRlcmFsID0gZnVuY3Rpb24gKGFyZ3MpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpZGVudGlmaWVycyA9IHRoaXMuX19pZGVudGlmaWVycywgdGVtcElkZW50aWZpZXJzID0gdGhpcy5fX3RlbXBJZGVudGlmaWVycywgY29kZUFycmF5ID0gdGhpcy5fX2NvZGVBcnJheSwgaiA9IDAsIHRlbXBTdHIgPSAnJywgdGVtcElkZW50aWZpZXI7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaisrIDwgYXJncykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBTdHIgPSBjb2RlQXJyYXkucG9wKCkgKyAnLCcgKyB0ZW1wU3RyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wSWRlbnRpZmllcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wSWRlbnRpZmllciA9IHRlbXBJZGVudGlmaWVycy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBJZGVudGlmaWVyICE9PSAnLicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXJzLnB1c2godGVtcElkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdbJyArIHRlbXBTdHIuc2xpY2UoMCwgLTEpICsgJ10nO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSGFuZGxlcyBhbiBhY2Nlc3NvciB0eXBlIGZ1bmN0aW9uIHRva2VuIFwiKClcIi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBjdXJyZW50IGluZGV4IGluIHRoZSBJVG9rZW4gYXJyYXkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcmdzIFRoZSBjdXJyZW50IElUb2tlbiBhcmdzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVzZUxvY2FsQ29udGV4dCBXaGV0aGVyIG9yIG5vdCB3ZSBuZWVkIHRvIHVzZSBhbiBhbHJlYWR5IHBhcnNlZCBvYmplY3QgYXMgdGhlIGN1cnJlbnQgY29udGV4dC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUuX19oYW5kbGVGdW5jdGlvbiA9IGZ1bmN0aW9uIChpbmRleCwgYXJncywgdXNlTG9jYWxDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaWRlbnRpZmllcnMgPSB0aGlzLl9faWRlbnRpZmllcnMsIHRlbXBJZGVudGlmaWVycyA9IHRoaXMuX190ZW1wSWRlbnRpZmllcnMsIGNvZGVBcnJheSA9IHRoaXMuX19jb2RlQXJyYXksIGogPSAwLCBwcmV2aW91c1Rva2VuID0gdGhpcy5fbG9va0JhY2soaW5kZXgpLCBncmFiRm5OYW1lID0gIWlzTnVsbChwcmV2aW91c1Rva2VuKSAmJiAocHJldmlvdXNUb2tlbi5hcmdzID09PSAtMiB8fCB0aGlzLl9pc1ZhbEVxdWFsKHByZXZpb3VzVG9rZW4sICcuW10nKSksIHRlbXBTdHIgPSAnJywgdGVtcElkZW50aWZpZXIsIGZuTmFtZSA9ICcnLCBpZGVudGlmaWVyRm5OYW1lID0gJycsIGNvZGVTdHIsIHB1c2hlZElkZW50aWZpZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChncmFiRm5OYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm5OYW1lID0gY29kZUFycmF5LnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXJGbk5hbWUgPSB0ZW1wSWRlbnRpZmllcnMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaisrIDwgYXJncykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBTdHIgPSBjb2RlQXJyYXkucG9wKCkgKyAnLCcgKyB0ZW1wU3RyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wSWRlbnRpZmllcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wSWRlbnRpZmllciA9IHRlbXBJZGVudGlmaWVycy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBJZGVudGlmaWVyICE9PSAnLicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXJzLnB1c2godGVtcElkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaGVkSWRlbnRpZmllciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJncyA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2RlU3RyID0gJy5jYWxsKGluaXRpYWxDb250ZXh0IHx8IGNvbnRleHQsJyArIHRlbXBTdHIuc2xpY2UoMCwgdGVtcFN0ci5sZW5ndGggLSAxKSArICcpJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZGVTdHIgPSAnLmNhbGwoaW5pdGlhbENvbnRleHQgfHwgY29udGV4dCknO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHVzZUxvY2FsQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVzZUxvY2FsQ29udGV4dCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlQXJyYXkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IGNvZGVBcnJheS5wb3AoKSwgbGFzdEluZGV4ID0gdGVtcElkZW50aWZpZXJzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGxhc3RJbmRleCA8IDAgfHwgdGVtcElkZW50aWZpZXJzW2xhc3RJbmRleF0gPT09ICcuJyB8fCBpZGVudGlmaWVyRm5OYW1lID09PSAnJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBJZGVudGlmaWVyc1tsYXN0SW5kZXhdICs9ICcuJyArIGlkZW50aWZpZXJGbk5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVycy5wdXNoKHRlbXBJZGVudGlmaWVycy5wb3AoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIShpZGVudGlmaWVyRm5OYW1lID09PSAnJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIXB1c2hlZElkZW50aWZpZXIgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRbMF0gPT09ICdbJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dFtjb250ZXh0Lmxlbmd0aCAtIDFdID09PSAnXScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyc1tpZGVudGlmaWVycy5sZW5ndGggLSAxXSArPSAnLicgKyBpZGVudGlmaWVyRm5OYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KGZuTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVTdHIgPSBjb250ZXh0ICsgY29kZVN0cjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVTdHIgPSAnKCgnICsgdGhpcy5fX2luZGV4SW50b0NvbnRleHQudG9TdHJpbmcoKSArICcpKCcgKyBjb250ZXh0ICsgJyxcIicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuTmFtZSArICdcIikgfHwgKGZ1bmN0aW9uICgpIHt9KSknICsgY29kZVN0cjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcignSW1wcm9wZXIgZXhwcmVzc2lvbiBvciBjb250ZXh0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyYWJGbk5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZVN0ciA9ICcoaW5pdGlhbENvbnRleHQgPSAoKCcgKyB0aGlzLl9fZmluZEluaXRpYWxDb250ZXh0LnRvU3RyaW5nKCkgKyAnKShjb250ZXh0LGFsaWFzZXMsXCInICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuTmFtZSArICdcIikgfHwgKGZ1bmN0aW9uICgpIHt9KSknICsgY29kZVN0ciArICcpJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcnMucHVzaChmbk5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZVN0ciA9IGNvZGVBcnJheS5wb3AoKSArIGNvZGVTdHI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29kZUFycmF5LnB1c2goY29kZVN0cik7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gdGVtcElkZW50aWZpZXJzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1ZhbEVxdWFsKHRoaXMuX3BlZWsoaW5kZXgpLCAnW10nKSAmJiBsZW5ndGggPiAwICYmIHRlbXBJZGVudGlmaWVyc1tsZW5ndGggLSAxXSAhPT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcnMucHVzaCh0ZW1wSWRlbnRpZmllcnMucG9wKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZUxvY2FsQ29udGV4dDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEhhbmRsZXMgYW4gYWNjZXNzb3IgdHlwZSB0b2tlbiB0aGF0IGlzIGZvciBpbmRleGluZyAoaS5lLiBcIi5cIiBvciBcIltdXCIpLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGN1cnJlbnQgaW5kZXggaW4gdGhlIElUb2tlbiBhcnJheS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIFRoZSBjdXJyZW50IElUb2tlbiB2YWx1ZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSB1c2VMb2NhbENvbnRleHQgV2hldGhlciBvciBub3Qgd2UgbmVlZCB0byB1c2UgYW4gYWxyZWFkeSBwYXJzZWQgb2JqZWN0IGFzIHRoZSBjdXJyZW50IGNvbnRleHQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9faW5kZXhJbnRvT2JqZWN0ID0gZnVuY3Rpb24gKGluZGV4LCB0b2tlbiwgdXNlTG9jYWxDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNWYWxFcXVhbCA9IHRoaXMuX2lzVmFsRXF1YWw7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWxFcXVhbCh0aGlzLl9wZWVrKGluZGV4KSwgJygpJykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBjb2RlQXJyYXkgPSB0aGlzLl9fY29kZUFycmF5LCBjb2RlU3RyID0gY29kZUFycmF5LnBvcCgpLCBpZGVudGlmaWVycyA9IHRoaXMuX19pZGVudGlmaWVycywgdGVtcElkZW50aWZpZXJzID0gdGhpcy5fX3RlbXBJZGVudGlmaWVycywgcHJldmlvdXNUb2tlbiA9IHRoaXMuX2xvb2tCYWNrKGluZGV4KSwgaWRlbnRpZmllckluZGV4ZXIgPSB0ZW1wSWRlbnRpZmllcnMucG9wKCksIGhhc0lkZW50aWZpZXJJbmRleGVyID0gIWlzTnVsbChpZGVudGlmaWVySW5kZXhlciksIGxhc3RJbmRleDtcclxuICAgICAgICAgICAgICAgIGlmIChoYXNJZGVudGlmaWVySW5kZXhlciAmJiBpZGVudGlmaWVySW5kZXhlclswXSA9PT0gJ0AnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZVN0ciA9ICcoJyArIHRoaXMuX19pbmRleEludG9Db250ZXh0LnRvU3RyaW5nKCkgKyAnKSgnICsgY29kZUFycmF5LnBvcCgpICsgJywnICsgY29kZVN0ciArICcpJztcclxuICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXJJbmRleGVyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGVtcElkZW50aWZpZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcnMucHVzaCh0ZW1wSWRlbnRpZmllcnMucG9wKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzVmFsRXF1YWwocHJldmlvdXNUb2tlbiwgJysrLS0oKVtdKi8lPzo+PTw9JiZ8fCE9PT0nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZGVTdHIgPSAnKCcgKyB0aGlzLl9faW5kZXhJbnRvQ29udGV4dC50b1N0cmluZygpICsgJykoJyArIGNvZGVBcnJheS5wb3AoKSArICcsJyArIGNvZGVTdHIgKyAnKSc7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcElkZW50aWZpZXJzLnB1c2goJy4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSAnW10nICYmICEoaXNOdWxsKHByZXZpb3VzVG9rZW4pIHx8IHByZXZpb3VzVG9rZW4uYXJncyA+PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZGVTdHIgPSAnKCcgKyB0aGlzLl9faW5kZXhJbnRvQ29udGV4dC50b1N0cmluZygpICsgJykoJyArIGNvZGVBcnJheS5wb3AoKSArICcsJyArIGNvZGVTdHIgKyAnKSc7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdEluZGV4ID0gdGVtcElkZW50aWZpZXJzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RJbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wSWRlbnRpZmllcnNbbGFzdEluZGV4XSAhPT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVycy5wdXNoKHRlbXBJZGVudGlmaWVycy5wb3AoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVySW5kZXhlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2RlU3RyID0gJygnICsgdGhpcy5fX2luZGV4SW50b0NvbnRleHQudG9TdHJpbmcoKSArICcpKCcgKyBjb2RlQXJyYXkucG9wKCkgKyAnLFwiJyArIGNvZGVTdHIgKyAnXCIpJztcclxuICAgICAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSB0ZW1wSWRlbnRpZmllcnMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdEluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBJZGVudGlmaWVyc1tsYXN0SW5kZXhdICE9PSAnLicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBJZGVudGlmaWVyc1tsYXN0SW5kZXhdICs9ICcuJyArIGlkZW50aWZpZXJJbmRleGVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhhc0lkZW50aWZpZXJJbmRleGVyICYmIGlkZW50aWZpZXJJbmRleGVyICE9PSAnLicgJiYgdG9rZW4gIT09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXJJbmRleGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb2RlQXJyYXkucHVzaChjb2RlU3RyKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VMb2NhbENvbnRleHQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBIYW5kbGVzIHRoZSBcIj9cIiBvcGVyYXRvci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUuX19oYW5kbGVRdWVzdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpZGVudGlmaWVycyA9IHRoaXMuX19pZGVudGlmaWVycywgdGVtcElkZW50aWZpZXJzID0gdGhpcy5fX3RlbXBJZGVudGlmaWVycywgY29kZUFycmF5ID0gdGhpcy5fX2NvZGVBcnJheSwgdGVtcCA9IGNvZGVBcnJheS5wb3AoKSwgdGVtcElkZW50aWZpZXI7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wSWRlbnRpZmllcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wSWRlbnRpZmllciA9IHRlbXBJZGVudGlmaWVycy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBJZGVudGlmaWVyICE9PSAnLicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXJzLnB1c2godGVtcElkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb2RlQXJyYXkucHVzaChjb2RlQXJyYXkucG9wKCkgKyAnPycgKyB0ZW1wKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEhhbmRsZXMgdGhlIFwiOlwiIG9wZXJhdG9yLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fX2hhbmRsZUNvbG9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkZW50aWZpZXJzID0gdGhpcy5fX2lkZW50aWZpZXJzLCB0ZW1wSWRlbnRpZmllcnMgPSB0aGlzLl9fdGVtcElkZW50aWZpZXJzLCBjb2RlQXJyYXkgPSB0aGlzLl9fY29kZUFycmF5LCB0ZW1wID0gY29kZUFycmF5LnBvcCgpLCB0ZW1wSWRlbnRpZmllcjtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBJZGVudGlmaWVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBJZGVudGlmaWVyID0gdGVtcElkZW50aWZpZXJzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVtcElkZW50aWZpZXIgIT09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcnMucHVzaCh0ZW1wSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvZGVBcnJheS5wdXNoKGNvZGVBcnJheS5wb3AoKSArICc6JyArIHRlbXApO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSGFuZGxlcyBhbGwgb3RoZXIgb3BlcmF0b3JzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gVGhlIGN1cnJlbnQgSVRva2VuIHZhbHVlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJncyBUaGUgY3VycmVudCBJVG9rZW4gYXJncy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUuX19oYW5kbGVPcGVyYXRvciA9IGZ1bmN0aW9uICh0b2tlbiwgYXJncykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkZW50aWZpZXJzID0gdGhpcy5fX2lkZW50aWZpZXJzLCB0ZW1wSWRlbnRpZmllcnMgPSB0aGlzLl9fdGVtcElkZW50aWZpZXJzLCBjb2RlQXJyYXkgPSB0aGlzLl9fY29kZUFycmF5LCBqID0gMCwgdGVtcFN0ciA9ICcnLCB0ZW1wSWRlbnRpZmllcjtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChqKysgPCBhcmdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcFN0ciA9ICdmdW5jdGlvbiAoY29udGV4dCwgYWxpYXNlcykgeyByZXR1cm4gJyArIGNvZGVBcnJheS5wb3AoKSArICc7IH0nICsgJywnICsgdGVtcFN0cjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGVtcElkZW50aWZpZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcElkZW50aWZpZXIgPSB0ZW1wSWRlbnRpZmllcnMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wSWRlbnRpZmllciAhPT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVycy5wdXNoKHRlbXBJZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHB1c2ggaWRlbnRpZmllciBmb3IgbmV3IHJlc3VsdCBvZiBvcGVyYXRvciBcclxuICAgICAgICAgICAgICAgIHRlbXBJZGVudGlmaWVycy5wdXNoKCcuJyk7XHJcbiAgICAgICAgICAgICAgICBjb2RlQXJyYXkucHVzaCgnKCcgKyBPUEVSQVRPUlNbdG9rZW5dLmZuLnRvU3RyaW5nKCkgKyAnKShjb250ZXh0LCBhbGlhc2VzLCcgKyB0ZW1wU3RyLnNsaWNlKDAsIHRlbXBTdHIubGVuZ3RoIC0gMSkgKyAnKScpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2FmZWx5IGZpbmRzIGFuIGluaXRpYWwgY29udGV4dC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IGNvbnRleHQgVGhlIGNvbnRleHQgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gYWxpYXNlcyBBbnkgYWxpYXNlcyB0aGF0IG1heSBleGlzdC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIFRoZSBwcm9wZXJ0eSB1c2VkIHRvIGZpbmQgdGhlIGluaXRpYWwgY29udGV4dC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUuX19maW5kSW5pdGlhbENvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCwgYWxpYXNlcywgdG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlblswXSA9PT0gJ0AnICYmIGFsaWFzZXMgIT09IG51bGwgJiYgdHlwZW9mIGFsaWFzZXMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFsaWFzZXNbdG9rZW4uc2xpY2UoMSldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGV4dCAhPT0gbnVsbCAmJiB0eXBlb2YgY29udGV4dCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dFt0b2tlbl07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTYWZlbHkgZHJpbGxzIGRvd24gaW50byBhIHNwZWNpZmllZCBjb250ZXh0IHdpdGggYSBnaXZlbiB0b2tlbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IGNvbnRleHQgVGhlIGNvbnRleHQgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gVGhlIHByb3BlcnR5IHVzZWQgdG8gZHJpbGwgaW50byB0aGUgY29udGV4dC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUuX19pbmRleEludG9Db250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQsIHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dCAhPT0gbnVsbCAmJiB0eXBlb2YgY29udGV4dCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dFt0b2tlbl07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFBhcnNlci5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICAgICAgX3Rva2VuaXplcjogX19Ub2tlbml6ZXIsXHJcbiAgICAgICAgICAgICAgICBfbG9nOiBfX0xvZ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gUGFyc2VyO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgZXhwcmVzc2lvbnMuUGFyc2VyID0gUGFyc2VyO1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19QYXJzZXIsIFBhcnNlcik7XHJcbiAgICB9KShleHByZXNzaW9ucyA9IHBsYXRfMS5leHByZXNzaW9ucyB8fCAocGxhdF8xLmV4cHJlc3Npb25zID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogSG9sZHMgY2xhc3NlcyBhbmQgaW50ZXJmYWNlcyByZWxhdGVkIHRvIHdlYiBjb21wb25lbnRzIGluIHBsYXR5cHVzLlxyXG4gICAgICovXHJcbiAgICB2YXIgd2ViO1xyXG4gICAgKGZ1bmN0aW9uICh3ZWIpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBMb2NhdGlvbihfd2luZG93KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfd2luZG93LmxvY2F0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3ZWIuTG9jYXRpb24gPSBMb2NhdGlvbjtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fTG9jYXRpb24sIExvY2F0aW9uLCBbX19XaW5kb3ddKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY2xhc3MgdGhhdCBoYW5kbGVzIGFsbCBpbnRlcmFjdGlvbiB3aXRoIHRoZSBicm93c2VyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBCcm93c2VyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBjb25zdHJ1Y3RvciBmb3IgYSBCcm93c2VyLiBBc3NpZ25zIGEgdWlkIGFuZCBzdWJzY3JpYmVzIHRvIHRoZSAnYmVmb3JlTG9hZCcgZXZlbnQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBCcm93c2VyKCkge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIHVuaXF1ZSBzdHJpbmcgaWRlbnRpZmllci5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy51aWQgPSB1bmlxdWVJZChfX1BsYXQpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgYnJvd3NlcidzIGxhc3QgVVJMLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fbGFzdFVybCA9IHRoaXMuX2xvY2F0aW9uLmhyZWY7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBicm93c2VyIGlzIGluIGFuIGluaXRpYWxpemF0aW9uIHN0YXRlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9faW5pdGlhbGl6aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9FdmVudE1hbmFnZXIub24odGhpcy51aWQsIF9fYmVmb3JlTG9hZCwgdGhpcy5pbml0aWFsaXplLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jb21wYXQubXNBcHApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFjayA9IFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbml0aWFsaXplcyB0aGUgQnJvd3NlciBpbnN0YW5jZSwgdHJpbXMgdGhlIHVybCwgYW5kXHJcbiAgICAgICAgICAgICAqIGFkZHMgZXZlbnRzIGZvciBwb3BzdGF0ZSBhbmQgaGFzaGNoYW5nZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJyb3dzZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NvbXBhdCA9IHRoaXMuX2NvbXBhdDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX0V2ZW50TWFuYWdlci5kaXNwb3NlKHRoaXMudWlkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19pbml0aWFsaXppbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYWNxdWlyZShfX1VybFV0aWxzSW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHVybCA9IHRoaXMudXJsKCksIHRyaW1tZWRVcmwgPSB1cmwsIGNoYW5nZWQgPSB0aGlzLl91cmxDaGFuZ2VkLmJpbmQodGhpcyksIF9kb20gPSB0aGlzLl9kb20sIF93aW5kb3cgPSB0aGlzLl93aW5kb3c7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJpbW1lZFVybCAhPT0gdXJsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cmwodHJpbW1lZFVybCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoX2NvbXBhdC5wdXNoU3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBfZG9tLmFkZEV2ZW50TGlzdGVuZXIoX3dpbmRvdywgX19QT1BTVEFURSwgY2hhbmdlZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX2RvbS5hZGRFdmVudExpc3RlbmVyKF93aW5kb3csIF9fSEFTSENIQU5HRSwgY2hhbmdlZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2luaXRpYWxpemluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyBvciBnZXRzIHRoZSBjdXJyZW50IF93aW5kb3cubG9jYXRpb25cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVybD8gVGhlIFVSTCB0byBzZXQgdGhlIGxvY2F0aW9uIHRvLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcGxhY2U/IFdoZXRoZXIgb3Igbm90IHRvIHJlcGxhY2UgdGhlIGN1cnJlbnQgVVJMIGluXHJcbiAgICAgICAgICAgICAqIHRoZSBoaXN0b3J5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQnJvd3Nlci5wcm90b3R5cGUudXJsID0gZnVuY3Rpb24gKHVybCwgcmVwbGFjZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gdGhpcy5fbG9jYXRpb247XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcodXJsKSAmJiAhdGhpcy5faXNMYXN0VXJsKHVybCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcGxhY2UgJiYgaXNBcnJheSh0aGlzLl9zdGFjaykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2sucHVzaChsb2NhdGlvbi5ocmVmKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0VXJsKHVybCwgcmVwbGFjZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX2N1cnJlbnRVcmwgfHwgbG9jYXRpb24uaHJlZjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE5hdmlnYXRlcyBiYWNrIGluIHRoZSBicm93c2VyIGhpc3RvcnlcclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aD0xIFRoZSBsZW5ndGggdG8gZ28gYmFja1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQnJvd3Nlci5wcm90b3R5cGUuYmFjayA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOdW1iZXIobGVuZ3RoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0YWNrID0gdGhpcy5fc3RhY2s7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShfc3RhY2spICYmIF9zdGFjay5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2sgPSBfc3RhY2sgPSBfc3RhY2suc2xpY2UoMCwgX3N0YWNrLmxlbmd0aCAtIChsZW5ndGggLSAxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cmwoX3N0YWNrLnBvcCgpKTtcclxuICAgICAgICAgICAgICAgICAgICBfc3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5faGlzdG9yeS5nbygtbGVuZ3RoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE5hdmlnYXRlcyBmb3J3YXJkIGluIHRoZSBicm93c2VyIGhpc3RvcnlcclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aD0xIFRoZSBsZW5ndGggdG8gZ28gZm9yd2FyZFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQnJvd3Nlci5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOdW1iZXIobGVuZ3RoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oaXN0b3J5LmdvKGxlbmd0aCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFVybFV0aWxzIG9iamVjdC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHVybD8gVGhlIFVSTCB0byBhc3NvY2lhdGUgd2l0aCB0aGUgbmV3IFVybFV0aWxzXHJcbiAgICAgICAgICAgICAqIGluc3RhbmNlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQnJvd3Nlci5wcm90b3R5cGUudXJsVXRpbHMgPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgICAgICAgICB1cmwgPSB1cmwgfHwgdGhpcy51cmwoKTtcclxuICAgICAgICAgICAgICAgIHZhciBfdXJsVXRpbHMgPSBhY3F1aXJlKF9fVXJsVXRpbHNJbnN0YW5jZSksIF9jb25maWcgPSBCcm93c2VyLmNvbmZpZztcclxuICAgICAgICAgICAgICAgIGlmIChfY29uZmlnLnJvdXRpbmdUeXBlID09PSBfY29uZmlnLkhBU0gpIHtcclxuICAgICAgICAgICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShuZXcgUmVnRXhwKCcjJyArIChfY29uZmlnLmhhc2hQcmVmaXggfHwgJycpICsgJy8/JyksICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF91cmxVdGlscy5pbml0aWFsaXplKHVybCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3VybFV0aWxzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgcmVxdWVzdGVkIFVSTCBpcyBjcm9zcyBkb21haW4uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB1cmwgVGhlIFVSTCB0byB2ZXJpZnkgd2hldGhlciBvciBub3QgaXQncyBjcm9zcyBkb21haW4uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCcm93c2VyLnByb3RvdHlwZS5pc0Nyb3NzRG9tYWluID0gZnVuY3Rpb24gKHVybCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1N0cmluZyh1cmwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHVybFV0aWxzID0gdGhpcy51cmxVdGlscyh1cmwpLCBsb2NhdGlvblV0aWxzID0gdGhpcy51cmxVdGlscygpO1xyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHByb3RvY29sOmhvc3Q6cG9ydCBtaXNtYXRjaCBcclxuICAgICAgICAgICAgICAgIHJldHVybiB1cmxVdGlscy5wcm90b2NvbCAhPT0gbG9jYXRpb25VdGlscy5wcm90b2NvbCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHVybFV0aWxzLmhvc3RuYW1lICE9PSBsb2NhdGlvblV0aWxzLmhvc3RuYW1lIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsVXRpbHMucG9ydCAhPT0gbG9jYXRpb25VdGlscy5wb3J0O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRm9ybWF0cyB0aGUgVVJMIGluIHRoZSBjYXNlIG9mIEhBU0ggcm91dGluZy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHVybCBUaGUgVVJMIHRvIGZvcm1hdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJyb3dzZXIucHJvdG90eXBlLmZvcm1hdFVybCA9IGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb25maWcgPSBCcm93c2VyLmNvbmZpZywgYmFzZVVybCA9IGNvbmZpZy5iYXNlVXJsLCBpc0xvY2FsID0gIXRoaXMuX3JlZ2V4LmZ1bGxVcmxSZWdleC50ZXN0KHVybCkgfHwgdXJsLmluZGV4T2YoYmFzZVVybCkgPiAtMTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNTdHJpbmcodXJsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh1cmwgPT09IGJhc2VVcmwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHVybFswXSA9PT0gJy8nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gdXJsLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTG9jYWwgJiYgY29uZmlnLnJvdXRpbmdUeXBlID09PSBjb25maWcuSEFTSCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYXNQcm90b2NvbCA9IHVybC5pbmRleE9mKHRoaXMudXJsVXRpbHMoKS5wcm90b2NvbCkgIT09IC0xLCBwcmVmaXggPSBjb25maWcuaGFzaFByZWZpeCB8fCAnJywgYXBwZW5kID0gJyMnICsgcHJlZml4LCBoYXNoUmVnZXggPSBuZXcgUmVnRXhwKGFwcGVuZCArICd8Iy8nKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodXJsW3VybC5sZW5ndGggLSAxXSAhPT0gJy8nICYmIHVybC5pbmRleE9mKCc/JykgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSAnLyc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNQcm90b2NvbCAmJiAhaGFzaFJlZ2V4LnRlc3QodXJsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSB1cmwgKyBhcHBlbmQgKyAnLyc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFoYXNoUmVnZXgudGVzdCh1cmwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IGFwcGVuZCArICgodXJsWzBdICE9PSAnLycpID8gJy8nIDogJycpICsgdXJsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0xvY2FsICYmIHVybC5pbmRleE9mKGJhc2VVcmwpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVybCA9IGJhc2VVcmwgKyB1cmw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGV2ZW50IHRvIGZpcmUgaW4gdGhlIGNhc2Ugb2YgYSBVUkwgY2hhbmdlLiBJdCBraWNrc1xyXG4gICAgICAgICAgICAgKiBvZmYgYSAndXJsQ2hhbmdlZCcgZGlyZWN0IGV2ZW50IG5vdGlmaWNhdGlvbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHVybCBUaGUgVVJMIHRvIHZlcmlmeSB3aGV0aGVyIG9yIG5vdCBpdCdzIGNyb3NzIGRvbWFpbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJyb3dzZXIucHJvdG90eXBlLl91cmxDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9faW5pdGlhbGl6aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2N1cnJlbnRVcmwgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdmFyIHV0aWxzID0gdGhpcy51cmxVdGlscygpLCAkY29uZmlnID0gQnJvd3Nlci5jb25maWcsIHVybCA9IHRoaXMuX3RyaW1TbGFzaGVzKHV0aWxzLmhyZWYpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19sYXN0VXJsID09PSB1cmwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fbGFzdFVybCA9IHVybDtcclxuICAgICAgICAgICAgICAgIHZhciAkbWFuYWdlciA9IHRoaXMuX0V2ZW50TWFuYWdlcjtcclxuICAgICAgICAgICAgICAgIHBvc3Rwb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAkbWFuYWdlci5kaXNwYXRjaChfX3VybENoYW5nZWQsIF90aGlzLCAkbWFuYWdlci5ESVJFQ1QsIFt1dGlsc10pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDaGVja3MgZm9yIHRoZSBleGlzdGVuY2Ugb2YgcHVzaFN0YXRlIGFuZFxyXG4gICAgICAgICAgICAgKiBzZXRzIHRoZSBicm93c2VyIFVSTCBhY2NvcmRpbmdseS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIHNldC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSByZXBsYWNlPyBXaGV0aGVyIG9yIG5vdCB0byByZXBsYWNlIHRoZVxyXG4gICAgICAgICAgICAgKiBjdXJyZW50IFVSTCBpbiB0aGUgaGlzdG9yeS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJyb3dzZXIucHJvdG90eXBlLl9zZXRVcmwgPSBmdW5jdGlvbiAodXJsLCByZXBsYWNlKSB7XHJcbiAgICAgICAgICAgICAgICB1cmwgPSB0aGlzLmZvcm1hdFVybCh1cmwpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHV0aWxzID0gdGhpcy51cmxVdGlscyh1cmwpLCBiYXNlVXJsID0gQnJvd3Nlci5jb25maWcuYmFzZVVybCwgX2hpc3RvcnkgPSB0aGlzLl9oaXN0b3J5LCBfbG9jYXRpb24gPSB0aGlzLl9sb2NhdGlvbjtcclxuICAgICAgICAgICAgICAgIGlmICh1dGlscy5ocmVmLmluZGV4T2YoYmFzZVVybCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2xvY2F0aW9uLmhyZWYgPSB1cmw7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIFVSTCBpcyBhYnNvbHV0ZSBcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcmVnZXguZnVsbFVybFJlZ2V4LnRlc3QodXJsKSAmJiB1cmxbMF0gIT09ICcvJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHVybCA9IGJhc2VVcmwgKyB1cmw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29tcGF0LnB1c2hTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IF9oaXN0b3J5LnN0YXRlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzT2JqZWN0KHN0YXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaGlzdG9yeS5yZXBsYWNlU3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNMb2NhdGlvbjogc3RhdGUucHJldmlvdXNMb2NhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAnJywgdXJsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9oaXN0b3J5LnB1c2hTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0xvY2F0aW9uOiB0aGlzLnVybFV0aWxzKCkucGF0aG5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgJycsIHVybCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fX2luaXRpYWxpemluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91cmxDaGFuZ2VkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2N1cnJlbnRVcmwgPSB1cmw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGxhY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xvY2F0aW9uLnJlcGxhY2UodXJsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sb2NhdGlvbi5ocmVmID0gdXJsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERldGVybWluZXMgaWYgdGhlIHVybCBpcyBlcXVhbCB0byB0aGUgbGFzdCB1cmxcclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIG1hdGNoXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCcm93c2VyLnByb3RvdHlwZS5faXNMYXN0VXJsID0gZnVuY3Rpb24gKHVybCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxhc3QgPSB0aGlzLl9fbGFzdFVybDtcclxuICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyh1cmwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkodXJsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSAnLyc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHVybCA9IHRoaXMuX3RyaW1TbGFzaGVzKHRoaXMudXJsVXRpbHModXJsKS5ocmVmKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB1cmwgPT09IGxhc3Q7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUcmltcyB0cmFpbGluZyBzbGFzaGVzIGZyb20gYSB1cmwuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0cmltXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCcm93c2VyLnByb3RvdHlwZS5fdHJpbVNsYXNoZXMgPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzU3RyaW5nKHVybCkgfHwgdXJsW3VybC5sZW5ndGggLSAxXSAhPT0gJy8nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVybDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB1cmwuc2xpY2UoMCwgLTEpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBCcm93c2VyLl9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgICAgICBfRXZlbnRNYW5hZ2VyOiBfX0V2ZW50TWFuYWdlclN0YXRpYyxcclxuICAgICAgICAgICAgICAgIF9jb21wYXQ6IF9fQ29tcGF0LFxyXG4gICAgICAgICAgICAgICAgX3JlZ2V4OiBfX1JlZ2V4LFxyXG4gICAgICAgICAgICAgICAgX3dpbmRvdzogX19XaW5kb3csXHJcbiAgICAgICAgICAgICAgICBfbG9jYXRpb246IF9fTG9jYXRpb24sXHJcbiAgICAgICAgICAgICAgICBfaGlzdG9yeTogX19IaXN0b3J5LFxyXG4gICAgICAgICAgICAgICAgX2RvbTogX19Eb21cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBJQnJvd3NlckNvbmZpZyBpbmplY3RhYmxlIG9iamVjdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJyb3dzZXIuY29uZmlnID0ge1xyXG4gICAgICAgICAgICAgICAgSEFTSDogJ2hhc2gnLFxyXG4gICAgICAgICAgICAgICAgU1RBVEU6ICdzdGF0ZScsXHJcbiAgICAgICAgICAgICAgICByb3V0aW5nVHlwZTogJ2hhc2gnLFxyXG4gICAgICAgICAgICAgICAgaGFzaFByZWZpeDogJyEnLFxyXG4gICAgICAgICAgICAgICAgYmFzZVVybDogJydcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIEJyb3dzZXI7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICB3ZWIuQnJvd3NlciA9IEJyb3dzZXI7XHJcbiAgICAgICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX0Jyb3dzZXIsIEJyb3dzZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIElCcm93c2VyQ29uZmlnKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gQnJvd3Nlci5jb25maWc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdlYi5JQnJvd3NlckNvbmZpZyA9IElCcm93c2VyQ29uZmlnO1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19Ccm93c2VyQ29uZmlnLCBJQnJvd3NlckNvbmZpZyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVhbHMgd2l0aCBvYnRhaW5pbmcgZGV0YWlsZWQgaW5mb3JtYXRpb24gYWJvdXQgYW5cclxuICAgICAgICAgKiBhc3NvY2lhdGVkIFVSTC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgVXJsVXRpbHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGNvbnN0cnVjdG9yIGZvciBhIFVybFV0aWxzIGluc3RhbmNlLlxyXG4gICAgICAgICAgICAgKiBIYW5kbGVzIHBhcnNpbmcgdGhlIGluaXRpYWwgVVJMIGFuZCBvYnRhaW4gdGhlIGJhc2UgVVJMIGlmIG5lY2Vzc2FyeS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFVybFV0aWxzKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuX2Jyb3dzZXJDb25maWcsIGJhc2VVcmwgPSBjb25maWcuYmFzZVVybDtcclxuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KGJhc2VVcmwpIHx8ICF0aGlzLl9yZWdleC5mdWxsVXJsUmVnZXgudGVzdChiYXNlVXJsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSB0aGlzLl93aW5kb3cubG9jYXRpb24uaHJlZiwgdHJpbW1lZFVybCA9IHVybC5yZXBsYWNlKHRoaXMuX3JlZ2V4LmluaXRpYWxVcmxSZWdleCwgJy8nKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcoYmFzZVVybCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2VVcmwuaW5kZXhPZignLycpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlVXJsID0gYmFzZVVybC5zbGljZSgxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVVybCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBiYXNlVXJsID0gVXJsVXRpbHMuX19nZXRCYXNlVXJsKHRyaW1tZWRVcmwpICsgYmFzZVVybDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYmFzZVVybFtiYXNlVXJsLmxlbmd0aCAtIDFdID09PSAnLycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVVybCA9IGJhc2VVcmwuc2xpY2UoMCwgLTEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25maWcuYmFzZVVybCA9IGJhc2VVcmwgKyAnLyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENyZWF0ZXMgYSBxdWVyeSBvYmplY3Qgb3V0IG9mIHRoZSBVUkwncyBxdWVyeSBzZWFyY2ggc3RyaW5nLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VhcmNoIFRoZSBVUkwncyBxdWVyeSBzZWFyY2ggc3RyaW5nLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVXJsVXRpbHMuX19nZXRRdWVyeSA9IGZ1bmN0aW9uIChzZWFyY2gpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZVF1ZXJ5KHNlYXJjaCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBPYnRhaW5zIHRoZSBiYXNlIFVSTCBmb3IgdGhlIGFwcC9zaXRlIGZvciBkb2luZyBTVEFURSB0eXBlIHJvdXRpbmcuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGluaXRpYWwgVVJMIHBhc3NlZCBpbnRvIHRoZSBCcm93c2VyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVXJsVXRpbHMuX19nZXRCYXNlVXJsID0gZnVuY3Rpb24gKHVybCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9yZWdleCA9IGFjcXVpcmUoX19SZWdleCksIF9sb2NhdGlvbiA9IGFjcXVpcmUoX19Mb2NhdGlvbiksIG9yaWdpbiA9IF9sb2NhdGlvbi5vcmlnaW4sIHByb3RvY29sID0gX2xvY2F0aW9uLnByb3RvY29sLCBob3N0ID0gX2xvY2F0aW9uLmhvc3Q7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvdG9jb2wgPT09ICdmaWxlOicgfHwgcHJvdG9jb2wuaW5kZXhPZignd21hcHAnKSA+IC0xIHx8IHByb3RvY29sLmluZGV4T2YoJ21zLWFwcHgnKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luID0gX2xvY2F0aW9uLmhyZWY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1VuZGVmaW5lZChvcmlnaW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luID0gX2xvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIF9sb2NhdGlvbi5ob3N0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3JpZ2luID0gb3JpZ2luLnJlcGxhY2UoX3JlZ2V4LmluaXRpYWxVcmxSZWdleCwgJycpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbi5zcGxpdCgnPycpWzBdLnNwbGl0KCcjJylbMF0gKyAnLyc7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbml0aWFsaXplcyBhbmQgZGVmaW5lcyBwcm9wZXJ0aWVzIHVzaW5nXHJcbiAgICAgICAgICAgICAqIHRoZSBpbnB1dCB1cmwuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGlucHV0IHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgVXJsVXRpbHMgaW5zdGFuY2UuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBVcmxVdGlscy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgICAgICAgICAgIHVybCA9IHVybCB8fCAnJztcclxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gVXJsVXRpbHMuX191cmxVdGlsc0VsZW1lbnQgfHxcclxuICAgICAgICAgICAgICAgICAgICAoVXJsVXRpbHMuX191cmxVdGlsc0VsZW1lbnQgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJykpLCBfYnJvd3NlckNvbmZpZyA9IHRoaXMuX2Jyb3dzZXJDb25maWc7XHJcbiAgICAgICAgICAgICAgICAvLyBhbHdheXMgbWFrZSBsb2NhbCB1cmxzIHJlbGF0aXZlIHRvIHN0YXJ0IHBhZ2UuIFxyXG4gICAgICAgICAgICAgICAgaWYgKHVybFswXSA9PT0gJy8nICYmIHVybC5pbmRleE9mKCcvLycpICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gdXJsLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gQWx3YXlzIGFwcGVuZCB0aGUgYmFzZVVybCBpZiB0aGlzIGlzIG5vdCBhIGZ1bGwtdXJsIFxyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9yZWdleC5mdWxsVXJsUmVnZXgudGVzdCh1cmwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gX2Jyb3dzZXJDb25maWcuYmFzZVVybCArIHVybDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdocmVmJywgdXJsKTtcclxuICAgICAgICAgICAgICAgIHVybCA9IGVsZW1lbnQuaHJlZjtcclxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyB0d2ljZSBmb3IgY2VyYWluIGJyb3dzZXJzIChlLmcuIHdpbjgpIFxyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCB1cmwpO1xyXG4gICAgICAgICAgICAgICAgdXJsID0gZWxlbWVudC5ocmVmO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ocmVmID0gdXJsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm90b2NvbCA9IGVsZW1lbnQucHJvdG9jb2wgPyBlbGVtZW50LnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpIDogJyc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhvc3QgPSBlbGVtZW50Lmhvc3Q7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaCA9IGVsZW1lbnQuc2VhcmNoID8gZWxlbWVudC5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYXNoID0gZWxlbWVudC5oYXNoID8gZWxlbWVudC5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJyc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gZWxlbWVudC5ob3N0bmFtZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9ydCA9IGVsZW1lbnQucG9ydDtcclxuICAgICAgICAgICAgICAgIHZhciBwYXRoO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0VtcHR5KF9icm93c2VyQ29uZmlnLmJhc2VVcmwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHVybC5yZXBsYWNlKF9icm93c2VyQ29uZmlnLmJhc2VVcmwsICcvJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoID0gKGVsZW1lbnQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZWxlbWVudC5wYXRobmFtZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICcvJyArIGVsZW1lbnQucGF0aG5hbWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKHRoaXMuX3JlZ2V4LmluaXRpYWxVcmxSZWdleCwgJy8nKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGF0aG5hbWUgPSBwYXRoLnNwbGl0KCc/JylbMF0uc3BsaXQoJyMnKVswXTtcclxuICAgICAgICAgICAgICAgIHRoaXMucXVlcnkgPSBVcmxVdGlscy5fX2dldFF1ZXJ5KHRoaXMuc2VhcmNoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgdG9TdHJpbmcgZnVuY3Rpb24gaW1wbGVtZW50YXRpb24gZm9yIHRoZSBVcmxVdGlscyBjbGFzcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFVybFV0aWxzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhyZWY7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFVybFV0aWxzLl9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgICAgICBfRXZlbnRNYW5hZ2VyOiBfX0V2ZW50TWFuYWdlclN0YXRpYyxcclxuICAgICAgICAgICAgICAgIF9kb2N1bWVudDogX19Eb2N1bWVudCxcclxuICAgICAgICAgICAgICAgIF93aW5kb3c6IF9fV2luZG93LFxyXG4gICAgICAgICAgICAgICAgX2NvbXBhdDogX19Db21wYXQsXHJcbiAgICAgICAgICAgICAgICBfcmVnZXg6IF9fUmVnZXgsXHJcbiAgICAgICAgICAgICAgICBfYnJvd3NlckNvbmZpZzogX19Ccm93c2VyQ29uZmlnXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBVcmxVdGlscztcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIHdlYi5VcmxVdGlscyA9IFVybFV0aWxzO1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19VcmxVdGlsc0luc3RhbmNlLCBVcmxVdGlscywgbnVsbCwgX19JTlNUQU5DRSk7XHJcbiAgICB9KSh3ZWIgPSBwbGF0XzEud2ViIHx8IChwbGF0XzEud2ViID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogSG9sZHMgYWxsIGNsYXNzZXMgYW5kIGludGVyZmFjZXMgcmVsYXRlZCB0byBhc3luYyBjb21wb25lbnRzIGluIHBsYXR5cHVzLlxyXG4gICAgICovXHJcbiAgICB2YXIgYXN5bmM7XHJcbiAgICAoZnVuY3Rpb24gKGFzeW5jKSB7XHJcbiAgICAgICAgdmFyIF9fcHJvbWlzZVF1ZXVlID0gW10sIGJyb3dzZXJHbG9iYWwgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpID8gd2luZG93IDoge30sIEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gYnJvd3Nlckdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGJyb3dzZXJHbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlciwgc2NoZWR1bGVGbHVzaDtcclxuICAgICAgICB2YXIgcHJvY2VzcyA9IHByb2Nlc3M7XHJcbiAgICAgICAgLy8gZGVjaWRlIHdoYXQgYXN5bmMgbWV0aG9kIHRvIHVzZSB0byB0cmlnZ2VyaW5nIHByb2Nlc3Npbmcgb2YgcXVldWVkIGNhbGxiYWNrczogXHJcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB7fS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScpIHtcclxuICAgICAgICAgICAgc2NoZWR1bGVGbHVzaCA9IHVzZU5leHRUaWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgIHNjaGVkdWxlRmx1c2ggPSB1c2VNdXRhdGlvbk9ic2VydmVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzY2hlZHVsZUZsdXNoID0gdXNlU2V0VGltZW91dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUYWtlcyBpbiBhIGdlbmVyaWMgdHlwZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBmdWxsZmlsbGVkIHN1Y2Nlc3MgdHlwZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgUHJvbWlzZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBbiBFUzYgaW1wbGVtZW50YXRpb24gb2YgdGhlIFByb21pc2UgQVBJLiBVc2VmdWwgZm9yIGFzeW5jaHJvbm91cyBwcm9ncmFtbWluZy5cclxuICAgICAgICAgICAgICogVGFrZXMgaW4gMiBnZW5lcmljIHR5cGVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZ1bGxmaWxsZWQgc3VjY2VzcyBhbmQgZXJyb3IgdHlwZXMuXHJcbiAgICAgICAgICAgICAqIFRoZSBlcnJvciB0eXBlIChVKSBzaG91bGQgZXh0ZW5kIEVycm9yIGluIG9yZGVyIHRvIGdldCBwcm9wZXIgc3RhY2sgdHJhY2luZy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LmFzeW5jLklSZXNvbHZlRnVuY3Rpb248Uj59IHJlc29sdmVGdW5jdGlvbiBBIElSZXNvbHZlRnVuY3Rpb24gZm9yIGZ1bGZpbGxpbmcvcmVqZWN0aW5nIHRoZSBQcm9taXNlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gUHJvbWlzZShyZXNvbHZlRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNGdW5jdGlvbihyZXNvbHZlRnVuY3Rpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb21pc2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmFpbGVkIHRvIGNvbnN0cnVjdCBcIlByb21pc2VcIjogJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdQbGVhc2UgdXNlIHRoZSBcIm5ld1wiIG9wZXJhdG9yLCB0aGlzIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fc3Vic2NyaWJlcnMgPSBbXTtcclxuICAgICAgICAgICAgICAgIFByb21pc2UuX19pbnZva2VSZXNvbHZlRnVuY3Rpb24ocmVzb2x2ZUZ1bmN0aW9uLCB0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBQcm9taXNlLmFsbCA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KHByb21pc2VzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbcHJvbWlzZXNdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBbXSwgcmVtYWluaW5nID0gcHJvbWlzZXMubGVuZ3RoLCBwcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW1haW5pbmcgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShbXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlc29sdmVyKGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHJlc29sdmVBbGwoaW5kZXgsIHZhbHVlKTsgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZUFsbChpbmRleCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tcmVtYWluaW5nID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvbWlzZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IHByb21pc2VzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcm9taXNlKHByb21pc2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4ocmVzb2x2ZXIoaSksIHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlQWxsKGksIHByb21pc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFByb21pc2UucmFjZSA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KHByb21pc2VzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW3Byb21pc2VzXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvbWlzZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IHByb21pc2VzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvbWlzZSAmJiB0eXBlb2YgcHJvbWlzZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocHJvbWlzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMgd2l0aCB0aGUgaW5wdXQgdmFsdWUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBlcnJvciBUaGUgdmFsdWUgdG8gcmVqZWN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW52b2tlcyB0aGUgcmVzb2x2ZSBmdW5jdGlvbiBmb3IgYSBwcm9taXNlLiBIYW5kbGVzIGVycm9yIGNhdGNoaW5nLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuYXN5bmMuSVJlc29sdmVGdW5jdGlvbjxSPn0gcmVzb2x2ZUZ1bmN0aW9uIFRoZSByZXNvbHZlIGZ1bmN0aW9uIHRvIGludm9rZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LmFzeW5jLlByb21pc2U8Uj59IHByb21pc2UgVGhlIHByb21pc2Ugb24gd2hpY2ggdG8gaW52b2tlIHRoZSByZXNvbHZlIGZ1bmN0aW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUHJvbWlzZS5fX2ludm9rZVJlc29sdmVGdW5jdGlvbiA9IGZ1bmN0aW9uIChyZXNvbHZlRnVuY3Rpb24sIHByb21pc2UpIHtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5fX3Jlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVqZWN0UHJvbWlzZShyZWFzb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLl9fcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVGdW5jdGlvbihyZXNvbHZlUHJvbWlzZSwgcmVqZWN0UHJvbWlzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdFByb21pc2UoZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbnZva2VzIGEgY2FsbGJhY2sgZm9yIGEgcHJvbWlzZSB3aXRoIHRoZSBzcGVjaWZpZWQgZGV0YWlsLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuYXN5bmMuU3RhdGV9IHNldHRsZWQgVGhlIHN0YXRlIG9mIHRoZSBwcm9taXNlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gcHJvbWlzZSBUaGUgcHJvbWlzZSBvYmplY3QuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7KHJlc3BvbnNlOiBhbnkpID0+IHZvaWR9IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBpbnZva2UuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBkZXRhaWwgVGhlIGRldGFpbHMgdG8gcGFzcyB0byB0aGUgY2FsbGJhY2suXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQcm9taXNlLl9faW52b2tlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoc2V0dGxlZCwgcHJvbWlzZSwgY2FsbGJhY2ssIGRldGFpbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhc0NhbGxiYWNrID0gaXNGdW5jdGlvbihjYWxsYmFjayksIHZhbHVlLCBlcnJvciwgc3VjY2VlZGVkLCBmYWlsZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrKGRldGFpbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGRldGFpbDtcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZWVkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKFByb21pc2UuX19oYW5kbGVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChoYXNDYWxsYmFjayAmJiBzdWNjZWVkZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLl9fcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmYWlsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLl9fcmVqZWN0KHByb21pc2UsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNldHRsZWQgPT09IFN0YXRlLkZVTEZJTExFRCkge1xyXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UuX19yZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNldHRsZWQgPT09IFN0YXRlLlJFSkVDVEVEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5fX3JlamVjdChwcm9taXNlLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQdWJsaXNoZXMgdGhlIHByb21pc2UgZGV0YWlscyB0byBhbGwgdGhlIHN1YnNjcmliZXJzIGZvciBhIHByb21pc2UuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBwcm9taXNlIFRoZSBwcm9taXNlIG9iamVjdC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LmFzeW5jLlN0YXRlfSBzZXR0bGVkIFRoZSBzdGF0ZSBvZiB0aGUgcHJvbWlzZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFByb21pc2UuX19wdWJsaXNoID0gZnVuY3Rpb24gKHByb21pc2UsIHNldHRsZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdWJzY3JpYmVycyA9IHByb21pc2UuX19zdWJzY3JpYmVycywgZGV0YWlsID0gcHJvbWlzZS5fX2RldGFpbCwgY2hpbGQsIGNhbGxiYWNrO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzY3JpYmVycy5sZW5ndGg7IGkgKz0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gc3Vic2NyaWJlcnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBzdWJzY3JpYmVyc1tpICsgc2V0dGxlZF07XHJcbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5fX2ludm9rZUNhbGxiYWNrKHNldHRsZWQsIGNoaWxkLCBjYWxsYmFjaywgZGV0YWlsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHByb21pc2UuX19zdWJzY3JpYmVycyA9IG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQdWJsaXNoZXMgYSBwcm9taXNlcyB0aGF0IGhhcyBiZWVuIGZ1bGZpbGxlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IHByb21pc2UgVGhlIHByb21pc2Ugb2JqZWN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUHJvbWlzZS5fX3B1Ymxpc2hGdWxmaWxsbWVudCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgICBQcm9taXNlLl9fcHVibGlzaChwcm9taXNlLCBwcm9taXNlLl9fc3RhdGUgPSBTdGF0ZS5GVUxGSUxMRUQpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUHVibGlzaGVzIGEgcHJvbWlzZXMgdGhhdCBoYXMgYmVlbiByZWplY3RlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IHByb21pc2UgVGhlIHByb21pc2Ugb2JqZWN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUHJvbWlzZS5fX3B1Ymxpc2hSZWplY3Rpb24gPSBmdW5jdGlvbiAocHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5fX3B1Ymxpc2gocHJvbWlzZSwgcHJvbWlzZS5fX3N0YXRlID0gU3RhdGUuUkVKRUNURUQpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQXN5bmNocm9ub3VzbHkgcmVqZWN0cyBhIHByb21pc2VcclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IHByb21pc2UgVGhlIHByb21pc2Ugb2JqZWN0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gcmVhc29uIFRoZSBkZXRhaWwgb2YgdGhlIHJlamVjdGVkIHByb21pc2UuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQcm9taXNlLl9fcmVqZWN0ID0gZnVuY3Rpb24gKHByb21pc2UsIHJlYXNvbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb21pc2UuX19zdGF0ZSAhPT0gU3RhdGUuUEVORElORykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHByb21pc2UuX19zdGF0ZSA9IFN0YXRlLlNFQUxFRDtcclxuICAgICAgICAgICAgICAgIHByb21pc2UuX19kZXRhaWwgPSByZWFzb247XHJcbiAgICAgICAgICAgICAgICBQcm9taXNlLmNvbmZpZy5hc3luYyhQcm9taXNlLl9fcHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBc3luY2hyb25vdXNseSBmdWxmaWxscyBhIHByb21pc2VcclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LmFzeW5jLlByb21pc2U8Uj59IHByb21pc2UgVGhlIHByb21pc2Ugb2JqZWN0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIGRldGFpbCBvZiB0aGUgZnVsZmlsbGVkIHByb21pc2UuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQcm9taXNlLl9fZnVsZmlsbCA9IGZ1bmN0aW9uIChwcm9taXNlLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb21pc2UuX19zdGF0ZSAhPT0gU3RhdGUuUEVORElORykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHByb21pc2UuX19zdGF0ZSA9IFN0YXRlLlNFQUxFRDtcclxuICAgICAgICAgICAgICAgIHByb21pc2UuX19kZXRhaWwgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIFByb21pc2UuY29uZmlnLmFzeW5jKFByb21pc2UuX19wdWJsaXNoRnVsZmlsbG1lbnQsIHByb21pc2UpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQXN5bmNocm9ub3VzbHkgZnVsZmlsbHMgYSBwcm9taXNlLCBhbGxvd2luZyBmb3IgcHJvbWlzZSBjaGFpbmluZy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LmFzeW5jLlByb21pc2U8Uj59IHByb21pc2UgVGhlIHByb21pc2Ugb2JqZWN0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIGRldGFpbCBvZiB0aGUgZnVsZmlsbGVkIHByb21pc2UuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQcm9taXNlLl9fcmVzb2x2ZSA9IGZ1bmN0aW9uIChwcm9taXNlLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5fX2Z1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIVByb21pc2UuX19oYW5kbGVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLl9fZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBIYW5kbGVzIGNoYWluaW5nIHByb21pc2VzIHRvZ2V0aGVyLCB3aGVuIGEgcHJvbWlzZSBpcyByZXR1cm5lZCBmcm9tIHdpdGhpbiBhIHRoZW4gaGFuZGxlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LmFzeW5jLlByb21pc2U8Uj59IHByb21pc2UgVGhlIHByb21pc2Ugb2JqZWN0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuYXN5bmMuUHJvbWlzZTxSPn0gdmFsdWUgVGhlIG5leHQgcHJvbWlzZSB0byBhd2FpdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFByb21pc2UuX19oYW5kbGVUaGVuYWJsZSA9IGZ1bmN0aW9uIChwcm9taXNlLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc29sdmVkO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5fX3JlamVjdChwcm9taXNlLCBuZXcgVHlwZUVycm9yKCdBIHByb21pc2VzIGNhbGxiYWNrIGNhbm5vdCByZXR1cm4gdGhlIHNhbWUgcHJvbWlzZS4nKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNQcm9taXNlKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnRoZW4uY2FsbCh2YWx1ZSwgZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UuX19yZXNvbHZlKHByb21pc2UsIHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLl9fZnVsZmlsbChwcm9taXNlLCB2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UuX19yZWplY3QocHJvbWlzZSwgdmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLl9fcmVqZWN0KHByb21pc2UsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQWRkcyBhIGNoaWxkIHByb21pc2UgdG8gdGhlIHBhcmVudCdzIHN1YnNjcmliZXJzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuYXN5bmMuUHJvbWlzZTxhbnk+fSBwYXJlbnQgVGhlIHBhcmVudCBwcm9taXNlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuYXN5bmMuUHJvbWlzZTxhbnk+fSB2YWx1ZSBUaGUgY2hpbGQgcHJvbWlzZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHsoc3VjY2VzczogYW55KSA9PiBhbnl9IG9uRnVsbGZpbGxlZCBUaGUgZnVsZmlsbGVkIG1ldGhvZCBmb3IgdGhlIGNoaWxkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geyhlcnJvcjogYW55KSA9PiBhbnl9IG9uUmVqZWN0ZWQgVGhlIHJlamVjdGVkIG1ldGhvZCBmb3IgdGhlIGNoaWxkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUHJvbWlzZS5fX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN1YnNjcmliZXJzID0gcGFyZW50Ll9fc3Vic2NyaWJlcnM7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gc3Vic2NyaWJlcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlcnNbbGVuZ3RoXSA9IGNoaWxkO1xyXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlcnNbbGVuZ3RoICsgU3RhdGUuRlVMRklMTEVEXSA9IG9uRnVsZmlsbGVkO1xyXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlcnNbbGVuZ3RoICsgU3RhdGUuUkVKRUNURURdID0gb25SZWplY3RlZDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRoZW5Qcm9taXNlID0gbmV3IHRoaXMuY29uc3RydWN0b3Iobm9vcCwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3N0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrc18xID0gYXJndW1lbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UuY29uZmlnLmFzeW5jKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5fX2ludm9rZUNhbGxiYWNrKHByb21pc2UuX19zdGF0ZSwgdGhlblByb21pc2UsIGNhbGxiYWNrc18xW3Byb21pc2UuX19zdGF0ZSAtIDFdLCBwcm9taXNlLl9fZGV0YWlsKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UuX19zdWJzY3JpYmUodGhpcywgdGhlblByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGVuUHJvbWlzZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE91dHB1dHMgdGhlIFByb21pc2UgYXMgYSByZWFkYWJsZSBzdHJpbmcuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnW29iamVjdCBQcm9taXNlXSc7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY29uZmlndXJhdGlvbiBmb3IgY3JlYXRpbmcgYXN5bmNocm9ub3VzIHByb21pc2UgZmx1c2hpbmcuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQcm9taXNlLmNvbmZpZyA9IHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBhc3luYzogZnVuY3Rpb24gKGNhbGxiYWNrLCBhcmcpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gX19wcm9taXNlUXVldWUucHVzaChbY2FsbGJhY2ssIGFyZ10pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVGbHVzaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2U7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBhc3luYy5Qcm9taXNlID0gUHJvbWlzZTtcclxuICAgICAgICB2YXIgU3RhdGU7XHJcbiAgICAgICAgKGZ1bmN0aW9uIChTdGF0ZSkge1xyXG4gICAgICAgICAgICBTdGF0ZVtTdGF0ZVtcIlBFTkRJTkdcIl0gPSAodm9pZCAwKV0gPSBcIlBFTkRJTkdcIjtcclxuICAgICAgICAgICAgU3RhdGVbU3RhdGVbXCJTRUFMRURcIl0gPSAwXSA9IFwiU0VBTEVEXCI7XHJcbiAgICAgICAgICAgIFN0YXRlW1N0YXRlW1wiRlVMRklMTEVEXCJdID0gMV0gPSBcIkZVTEZJTExFRFwiO1xyXG4gICAgICAgICAgICBTdGF0ZVtTdGF0ZVtcIlJFSkVDVEVEXCJdID0gMl0gPSBcIlJFSkVDVEVEXCI7XHJcbiAgICAgICAgfSkoU3RhdGUgfHwgKFN0YXRlID0ge30pKTtcclxuICAgICAgICA7XHJcbiAgICAgICAgLy8gbm9kZSBcclxuICAgICAgICBmdW5jdGlvbiB1c2VOZXh0VGljaygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiB1c2VNdXRhdGlvbk9ic2VydmVyKCkge1xyXG4gICAgICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpLCBfZG9jdW1lbnQgPSBhY3F1aXJlKF9fRG9jdW1lbnQpLCBfd2luZG93ID0gYWNxdWlyZShfX1dpbmRvdyksIGVsZW1lbnQgPSBfZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCwgeyBhdHRyaWJ1dGVzOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICBfd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3VubG9hZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICAgICAgICAgIG9ic2VydmVyID0gbnVsbDtcclxuICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RyYWluUXVldWUnLCAnZHJhaW5RdWV1ZScpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiB1c2VTZXRUaW1lb3V0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcG9zdHBvbmUoZmx1c2gpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBmbHVzaCgpIHtcclxuICAgICAgICAgICAgdmFyIHR1cGxlLCBjYWxsYmFjaywgYXJnO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9fcHJvbWlzZVF1ZXVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0dXBsZSA9IF9fcHJvbWlzZVF1ZXVlW2ldO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSB0dXBsZVswXTtcclxuICAgICAgICAgICAgICAgIGFyZyA9IHR1cGxlWzFdO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soYXJnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfX3Byb21pc2VRdWV1ZSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBJUHJvbWlzZShfd2luZG93KSB7XHJcbiAgICAgICAgICAgIGlmICghaXNOdWxsKF93aW5kb3cuUHJvbWlzZSkgJiZcclxuICAgICAgICAgICAgICAgIGlzRnVuY3Rpb24oX3dpbmRvdy5Qcm9taXNlLmFsbCkgJiZcclxuICAgICAgICAgICAgICAgIGlzRnVuY3Rpb24oX3dpbmRvdy5Qcm9taXNlLnJhY2UpICYmXHJcbiAgICAgICAgICAgICAgICBpc0Z1bmN0aW9uKF93aW5kb3cuUHJvbWlzZS5yZXNvbHZlKSAmJlxyXG4gICAgICAgICAgICAgICAgaXNGdW5jdGlvbihfd2luZG93LlByb21pc2UucmVqZWN0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF93aW5kb3cuUHJvbWlzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXN5bmMuSVByb21pc2UgPSBJUHJvbWlzZTtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fUHJvbWlzZSwgSVByb21pc2UsIFtfX1dpbmRvd10sIF9fQ0xBU1MpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEh0dHBSZXF1ZXN0IHByb3ZpZGVzIGEgd3JhcHBlciBmb3IgdGhlIFhNTEh0dHBSZXF1ZXN0IG9iamVjdC4gQWxsb3dzIGZvclxyXG4gICAgICAgICAqIHNlbmRpbmcgQUpBWCByZXF1ZXN0cyB0byBhIHNlcnZlci4gVGhpcyBjbGFzcyBkb2VzIG5vdCBzdXBwb3J0XHJcbiAgICAgICAgICogc3luY2hyb25vdXMgcmVxdWVzdHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEh0dHBSZXF1ZXN0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBjb25zdHJ1Y3RvciBmb3IgYSBIdHRwUmVxdWVzdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEh0dHBSZXF1ZXN0KCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbXBhdCA9IGFjcXVpcmUoX19Db21wYXQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2ZpbGVTdXBwb3J0ZWQgPSBjb21wYXQuZmlsZVN1cHBvcnRlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIEh0dHBSZXF1ZXN0IHdpdGggb3B0aW9ucy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LmFzeW5jLklIdHRwQ29uZmlnfSBvcHRpb25zIFRoZSBJSHR0cENvbmZpZ1N0YXRpYyB1c2VkIHRvIGN1c3RvbWl6ZSB0aGlzIEh0dHBSZXF1ZXN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgSHR0cFJlcXVlc3QucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX29wdGlvbnMgPSBfZXh0ZW5kKGZhbHNlLCBmYWxzZSwge30sIHRoaXMuX2NvbmZpZywgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFeGVjdXRlcyBhbiBYTUxIdHRwUmVxdWVzdCBhbmQgcmVzb2x2ZXMgYW4gSUFqYXhQcm9taXNlIHVwb24gY29tcGxldGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9fb3B0aW9ucywgdXJsID0gb3B0aW9ucy51cmw7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzU3RyaW5nKHVybCkgfHwgaXNFbXB0eSh1cmwudHJpbSgpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnZhbGlkT3B0aW9ucygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy51cmwgPSB0aGlzLl9icm93c2VyLnVybFV0aWxzKHVybCkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIHZhciBpc0Nyb3NzRG9tYWluID0gb3B0aW9ucy5pc0Nyb3NzRG9tYWluIHx8IGZhbHNlLCB4RG9tYWluID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBmb3JjZWQgY3Jvc3MgZG9tYWluIGNhbGwgb3IgY29ycyBpcyBub3Qgc3VwcG9ydGVkIChJRTkpIFxyXG4gICAgICAgICAgICAgICAgaWYgKGlzQ3Jvc3NEb21haW4pIHtcclxuICAgICAgICAgICAgICAgICAgICB4RG9tYWluID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoaXMueGhyLndpdGhDcmVkZW50aWFscykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeERvbWFpbiA9IHRoaXMuX2Jyb3dzZXIuaXNDcm9zc0RvbWFpbih1cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh4RG9tYWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy54aHIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuanNvbnBDYWxsYmFjayA9IG9wdGlvbnMuanNvbnBDYWxsYmFjayB8fCB1bmlxdWVJZChfX0pTT05QX0NBTExCQUNLKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlSnNvbnAoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZW5kWGhyUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRXhlY3V0ZXMgYW4gSlNPTlAgcmVxdWVzdCBhbmQgcmVzb2x2ZXMgYW4gSUFqYXhQcm9taXNlIHVwb24gY29tcGxldGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5leGVjdXRlSnNvbnAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9fb3B0aW9ucywgdXJsID0gb3B0aW9ucy51cmw7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzU3RyaW5nKHVybCkgfHwgaXNFbXB0eSh1cmwudHJpbSgpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnZhbGlkT3B0aW9ucygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy51cmwgPSB0aGlzLl9icm93c2VyLnVybFV0aWxzKHVybCkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwodGhpcy5qc29ucENhbGxiYWNrKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuanNvbnBDYWxsYmFjayA9IG9wdGlvbnMuanNvbnBDYWxsYmFjayB8fCB1bmlxdWVJZChfX0NhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IEFqYXhQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3dpbmRvdyA9IF90aGlzLl93aW5kb3csIF9kb2N1bWVudCA9IF90aGlzLl9kb2N1bWVudCwgc2NyaXB0VGFnID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpLCBqc29ucENhbGxiYWNrID0gX3RoaXMuanNvbnBDYWxsYmFjaywganNvbnBJZGVudGlmaWVyID0gb3B0aW9ucy5qc29ucElkZW50aWZpZXIgfHwgJ2NhbGxiYWNrJztcclxuICAgICAgICAgICAgICAgICAgICBzY3JpcHRUYWcuc3JjID0gdXJsICsgKCh1cmwuaW5kZXhPZignPycpID4gLTEpID8gJyYnIDogJz8nKSArIGpzb25wSWRlbnRpZmllciArICc9JyArIGpzb25wQ2FsbGJhY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gX3dpbmRvd1tqc29ucENhbGxiYWNrXTtcclxuICAgICAgICAgICAgICAgICAgICBfd2luZG93W2pzb25wQ2FsbGJhY2tdID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNsZWFuIHVwIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihfdGhpcy5jbGVhclRpbWVvdXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jbGVhclRpbWVvdXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChzY3JpcHRUYWcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQob2xkVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eShfd2luZG93LCBqc29ucENhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF93aW5kb3dbanNvbnBDYWxsYmFja10gPSBvbGRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIGNhbGxiYWNrIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9rIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAyMDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBfZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHRUYWcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bWJlcih0aW1lb3V0KSAmJiB0aW1lb3V0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBmaXJzdCBwb3N0cG9uZSB0byBhdm9pZCBhbHdheXMgdGltaW5nIG91dCB3aGVuIGRlYnVnZ2luZywgdGhvdWdoIHRoaXMgaXMgbm90IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhIGZvb2xwcm9vZiBtZXRob2QuIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jbGVhclRpbWVvdXQgPSBwb3N0cG9uZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jbGVhclRpbWVvdXQgPSBkZWZlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBBamF4RXJyb3Ioe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogJ1JlcXVlc3QgdGltZWQgb3V0IGluICcgKyB0aW1lb3V0ICsgJ21zIGZvciAnICsgdXJsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXN0IHRpbWVvdXQgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogNDA4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF93aW5kb3dbanNvbnBDYWxsYmFja10gPSBub29wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGltZW91dCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHByb21pc2UuaW5pdGlhbGl6ZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSB3cmFwcGVyIGZvciB0aGUgWE1MSHR0cFJlcXVlc3QncyBvblJlYWR5U3RhdGVDaGFuZ2VkIGNhbGxiYWNrLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgSHR0cFJlcXVlc3QucHJvdG90eXBlLl94aHJPblJlYWR5U3RhdGVDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeGhyID0gdGhpcy54aHI7XHJcbiAgICAgICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdHVzXzEgPSB4aHIuc3RhdHVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXNfMSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSB4aHIucmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwocmVzcG9uc2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0geGhyLnJlc3BvbnNlVGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmaWxlIHByb3RvY29sIGlzc3VlICoqTmVlZHMgdG8gYmUgdGVzdGVkIG1vcmUgdGhvcm91Z2hseSoqIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvayBpZiByZXNwb25zZSBpcyBub3QgZW1wdHksIE5vdCBGb3VuZCBvdGhlcndpc2UgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNFbXB0eShyZXNwb25zZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gMzA0IGlzIG5vdCBtb2RpZmllZCBcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHN0YXR1c18xID49IDIwMCAmJiBzdGF0dXNfMSA8IDMwMCkgfHwgc3RhdHVzXzEgPT09IDMwNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBlbHNlIHt9IFRPRE86IGFkZCBwcm9ncmVzcyBmb3IgeGhyIGlmIHdlIGNob29zZSB0byBhZGQgcHJvZ3Jlc3MgdG8gQWpheFByb21pc2UgXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgZnVuY3Rpb24gdGhhdCBpbml0aWFsaXplcyBhbmQgc2VuZHMgdGhlIFhNTEh0dHBSZXF1ZXN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgSHR0cFJlcXVlc3QucHJvdG90eXBlLl9zZW5kWGhyUmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgeGhyID0gdGhpcy54aHIsIG9wdGlvbnMgPSB0aGlzLl9fb3B0aW9ucywgbWV0aG9kID0gb3B0aW9ucy5tZXRob2QsIHVybCA9IG9wdGlvbnMudXJsLCBwcm9taXNlID0gbmV3IEFqYXhQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3VjY2VzcyA9IF90aGlzLl94aHJPblJlYWR5U3RhdGVDaGFuZ2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChzdWNjZXNzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZSA9IF90aGlzLl9mb3JtYXRSZXNwb25zZShvcHRpb25zLnJlc3BvbnNlVHlwZSwgc3VjY2Vzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgQWpheEVycm9yKHJlc3BvbnNlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMueGhyID0gb3B0aW9ucyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzU3RyaW5nKG1ldGhvZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5pbmZvKCdBamF4T3B0aW9ucyBtZXRob2Qgd2FzIG5vdCBvZiB0eXBlIHN0cmluZy4gRGVmYXVsdGluZyB0byBcIkdFVFwiLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4obWV0aG9kLnRvVXBwZXJDYXNlKCksIHVybCwgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3luY2hyb25vdXMgWEhSIG5vdCBzdXBwb3J0ZWQgXHJcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZSwgb3B0aW9ucy51c2VyLCBvcHRpb25zLnBhc3N3b3JkKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VUeXBlID0gb3B0aW9ucy5yZXNwb25zZVR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoX3RoaXMuX19maWxlU3VwcG9ydGVkIHx8IHJlc3BvbnNlVHlwZSA9PT0gJycgfHwgcmVzcG9uc2VUeXBlID09PSAndGV4dCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlVHlwZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBBbmRyb2lkIDwgNC40IHdpbGwgdGhyb3cgYSBET00gRXhjZXB0aW9uIDEyIGlmIHJlc3BvbnNlVHlwZSBpcyBzZXQgdG8ganNvbi4gXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG9ubHkgd2F5IHRvIGRvIGZlYXR1cmUgZGV0ZWN0aW9uIGlzIHdpdGggdHJ5L2NhdGNoLiBcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VUeXBlID09PSAnanNvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gb3B0aW9ucy53aXRoQ3JlZGVudGlhbHM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pbWVUeXBlID0gb3B0aW9ucy5vdmVycmlkZU1pbWVUeXBlLCBkYXRhID0gb3B0aW9ucy5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhtaW1lVHlwZSkgJiYgIWlzRW1wdHkobWltZVR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vdmVycmlkZU1pbWVUeXBlKG1pbWVUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChkYXRhKSB8fCBkYXRhID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBkYXRhIGV4aXN0cyBzbyBzZXQgaGVhZGVycyBhbmQgc2VuZCByZXF1ZXN0IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fX3NldEhlYWRlcnMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNlbmQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1zID0gb3B0aW9ucy50cmFuc2Zvcm1zIHx8IFtdLCBsZW5ndGhfMyA9IHRyYW5zZm9ybXMubGVuZ3RoLCBjb250ZW50VHlwZSA9IG9wdGlvbnMuY29udGVudFR5cGUsIGNvbnRlbnRUeXBlRXhpc3RzID0gaXNTdHJpbmcoY29udGVudFR5cGUpICYmICFpc0VtcHR5KGNvbnRlbnRUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aF8zID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgZGF0YSB0cmFuc2Zvcm1zIGRlZmluZWQsIGFzc3VtZSB0aGV5J3JlIGdvaW5nIHRvIHRha2UgY2FyZSBvZiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFueSBhbmQgYWxsIHRyYW5zZm9ybWF0aW9ucy4gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aF8zOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gdHJhbnNmb3Jtc1tpXShkYXRhLCB4aHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgY29udGVudFR5cGUgZXhpc3RzLCBhc3N1bWUgdGhleSBkaWQgbm90IHNldCBpdCBpbiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZWlyIGhlYWRlcnMgYXMgd2VsbCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZUV4aXN0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCBjb250ZW50VHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fX3NldEhlYWRlcnMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZW5kKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KGRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBpc09iamVjdCBhbmQgY29udGVudFR5cGUgZXhpc3RzIHdlIHdhbnQgdG8gdHJhbnNmb3JtIHRoZSBkYXRhIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlRXhpc3RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlTG93ZXIgPSBjb250ZW50VHlwZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZUxvd2VyLmluZGV4T2YoJ3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwZXJmb3JtIGFuIGVuY29kZWQgZm9ybSB0cmFuc2Zvcm1hdGlvbiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF90aGlzLl9fc2VyaWFsaXplRm9ybURhdGEoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IENvbnRlbnQtVHlwZSBoZWFkZXIgYmVjYXVzZSB3ZSdyZSBhc3N1bWluZyB0aGV5IGRpZG4ndCBzZXQgaXQgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIHRoZWlyIGhlYWRlcnMgb2JqZWN0IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgY29udGVudFR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fX3NldEhlYWRlcnMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNlbmQoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRlbnRUeXBlTG93ZXIuaW5kZXhPZignbXVsdGlwYXJ0L2Zvcm0tZGF0YScpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIGNoZWNrIGlmIEZpbGUgaXMgYSBzdXBwb3J0ZWQgb2JqZWN0IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX19maWxlU3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2UgRm9ybURhdGEgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX3RoaXMuX19hcHBlbmRGb3JtRGF0YSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IHNldCB0aGUgQ29udGVudC1UeXBlIGhlYWRlciBkdWUgdG8gbW9kZXJuIGJyb3dzZXJzIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0dGluZyBzcGVjaWFsIGhlYWRlcnMgZm9yIG11bHRpcGFydC9mb3JtLWRhdGEgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fX3NldEhlYWRlcnMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZW5kKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlIGlmcmFtZSB0cmljayBmb3Igb2xkZXIgYnJvd3NlcnMgKGRvIG5vdCBzZW5kIGEgcmVxdWVzdCkgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNhc2UgaXMgdGhlIHJlYXNvbiBmb3IgdGhpcyBnaWFudCwgdGVycmlibGUsIG5lc3RlZCBpZi1lbHNlIHN0YXRlbWVudCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fc3VibWl0RnJhbWVkRm9ybURhdGEoKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnhociA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXNzdW1lIHN0cmluZ2lmaWNhdGlvbiBpcyBwb3NzaWJsZSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgQ29udGVudC1UeXBlIGhlYWRlciBiZWNhdXNlIHdlJ3JlIGFzc3VtaW5nIHRoZXkgZGlkbid0IHNldCBpdCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhlaXIgaGVhZGVycyBvYmplY3QgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCBjb250ZW50VHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fc2V0SGVhZGVycygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2VuZChkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb250ZW50VHlwZSBkb2VzIG5vdCBleGlzdCBzbyBzaW1wbHkgc2V0IGRlZmluZWQgaGVhZGVycyBhbmQgc2VuZCByYXcgZGF0YSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fX3NldEhlYWRlcnMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2VuZChkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGNvbnRlbnRUeXBlIGV4aXN0cyBzZXQgQ29udGVudC1UeXBlIGhlYWRlciBiZWNhdXNlIHdlJ3JlIGFzc3VtaW5nIHRoZXkgZGlkbid0IHNldCBpdCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIHRoZWlyIGhlYWRlcnMgb2JqZWN0IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlRXhpc3RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsIGNvbnRlbnRUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fc2V0SGVhZGVycygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNlbmQoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHRpbWVvdXQpICYmIHRpbWVvdXQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGZpcnN0IHBvc3Rwb25lIHRvIGF2b2lkIGFsd2F5cyB0aW1pbmcgb3V0IHdoZW4gZGVidWdnaW5nLCB0aG91Z2ggdGhpcyBpcyBub3QgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgZm9vbHByb29mIG1ldGhvZC4gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNsZWFyVGltZW91dCA9IHBvc3Rwb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNsZWFyVGltZW91dCA9IGRlZmVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEFqYXhFcnJvcih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiAnUmVxdWVzdCB0aW1lZCBvdXQgaW4gJyArIHRpbWVvdXQgKyAnbXMgZm9yICcgKyBvcHRpb25zLnVybCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKTsgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyOiB4aHJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMueGhyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQgLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlLmluaXRpYWxpemUodGhpcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgaXMgaW1tZWRpYXRlbHkgcmVqZWN0ZWQgZHVlIHRvIGFuIGVycm9yLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgSHR0cFJlcXVlc3QucHJvdG90eXBlLl9pbnZhbGlkT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFqYXhQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLndhcm4oJ0F0dGVtcHRpbmcgYSByZXF1ZXN0IHdpdGhvdXQgc3BlY2lmeWluZyBhIHVybCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgQWpheEVycm9yKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6ICdBdHRlbXB0aW5nIGEgcmVxdWVzdCB3aXRob3V0IHNwZWNpZnlpbmcgYSB1cmwnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEFsbFJlc3BvbnNlSGVhZGVyczogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyOiBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgZnVuY3Rpb24gdGhhdCBmb3JtYXRzIHRoZSByZXNwb25zZSBmcm9tIHRoZSBYTUxIdHRwUmVxdWVzdC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHJlc3BvbnNlVHlwZSBUaGUgdXNlciBkZXNpZ25hdGVkIHJlc3BvbnNlVHlwZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN1Y2Nlc3MgU2lnbmlmaWVzIGlmIHRoZSByZXNwb25zZSB3YXMgYSBzdWNjZXNzXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBIdHRwUmVxdWVzdC5wcm90b3R5cGUuX2Zvcm1hdFJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlVHlwZSwgc3VjY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHhociA9IHRoaXMueGhyLCBzdGF0dXMgPSB4aHIuc3RhdHVzLCByZXNwb25zZSA9IHhoci5yZXNwb25zZTtcclxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gdHJ5LCBjYXRjaCBpbnN0ZWFkIG9mIGJvb2xlYW4gc2hvcnQgY2lyY3VpdCBiZWNhdXNlIGNocm9tZSBkb2Vzbid0IGxpa2UgY2hlY2tpbmcgXHJcbiAgICAgICAgICAgICAgICAvLyByZXNwb25zZVRleHQgd2hlbiB0aGUgcmVzcG9uc2VUeXBlIGlzIGFueXRoaW5nIG90aGVyIHRoYW4gZW1wdHkgb3IgJ3RleHQnIFxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChyZXNwb25zZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHhoci5yZXNwb25zZVRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBmaWxlIHByb3RvY29sIGlzc3VlICoqTmVlZHMgdG8gYmUgdGVzdGVkIG1vcmUgdGhvcm91Z2hseSoqIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9rIGlmIHJlc3BvbnNlIGVtcHR5LCBOb3QgRm91bmQgb3RoZXJ3aXNlIFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IHN1Y2Nlc3MgPyAyMDAgOiA0MDQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXMuY2xlYXJUaW1lb3V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VUeXBlID09PSAnanNvbicgJiYgaXNTdHJpbmcocmVzcG9uc2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBKU09OLnBhcnNlKHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeGhyOiB4aHJcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBoZWFkZXJzIGZvciBhbiBYTUxIdHRwUmVxdWVzdFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgSHR0cFJlcXVlc3QucHJvdG90eXBlLl9fc2V0SGVhZGVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBoZWFkZXJzID0gdGhpcy5fX29wdGlvbnMuaGVhZGVycywga2V5cyA9IE9iamVjdC5rZXlzKGhlYWRlcnMgfHwge30pLCB4aHIgPSB0aGlzLnhociwgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgaTtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGtleXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBoZWFkZXJzW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2VyaWFsaXplcyBtdWx0aXBhcnQgZm9ybSBkYXRhIGluIGFuIFhNTEh0dHBSZXF1ZXN0IGFzIGEgc3RyaW5nLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgSHR0cFJlcXVlc3QucHJvdG90eXBlLl9fc2VyaWFsaXplRm9ybURhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX19vcHRpb25zLmRhdGEsIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKSwga2V5LCB2YWwsIGZvcm1CdWZmZXIgPSBbXTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXlzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IGRhdGFba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHZhbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF5IHRocm93IGEgZmF0YWwgZXJyb3IgYnV0IHRoaXMgaXMgYW4gaW52YWxpZCBjYXNlIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cud2FybignSW52YWxpZCBmb3JtIGVudHJ5IHdpdGgga2V5IFwiJyArIGtleSArICdcIiBhbmQgdmFsdWUgXCInICsgdmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gSlNPTi5zdHJpbmdpZnkodmFsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybUJ1ZmZlci5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1CdWZmZXIuam9pbignJicpLnJlcGxhY2UoLyUyMC9nLCAnKycpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ3JlYXRlcyBGb3JtRGF0YSB0byBhZGQgdG8gdGhlIFhNTEh0dHBSZXF1ZXN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgSHR0cFJlcXVlc3QucHJvdG90eXBlLl9fYXBwZW5kRm9ybURhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX19vcHRpb25zLmRhdGEsIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCksIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKSwga2V5LCB2YWw7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoa2V5cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5cy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBkYXRhW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbCh2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChrZXksICcnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGaWxlKHZhbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChrZXksIHZhbCwgdmFsLm5hbWUgfHwgdmFsLmZpbGVOYW1lIHx8ICdibG9iJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXkgdGhyb3cgYSBmYXRhbCBlcnJvciBidXQgdGhpcyBpcyBhbiBpbnZhbGlkIGNhc2UgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cud2FybignSW52YWxpZCBmb3JtIGVudHJ5IHdpdGgga2V5IFwiJyArIGtleSArICdcIiBhbmQgdmFsdWUgXCInICsgdmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChrZXksIEpTT04uc3RyaW5naWZ5KHZhbCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoa2V5LCB2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtRGF0YTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEhhbmRsZXMgc3VibWl0dGluZyBtdWx0aXBhcnQgZm9ybSBkYXRhIHVzaW5nIGFuIGlmcmFtZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fX3N1Ym1pdEZyYW1lZEZvcm1EYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fX29wdGlvbnMsIGRhdGEgPSBvcHRpb25zLmRhdGEsIHVybCA9IG9wdGlvbnMudXJsLCBfZG9jdW1lbnQgPSB0aGlzLl9kb2N1bWVudCwgJGJvZHkgPSBfZG9jdW1lbnQuYm9keSwgUHJvbWlzZSA9IGFjcXVpcmUoX19Qcm9taXNlKSwgZm9ybSA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyksIGlmcmFtZSA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKSwgaWZyYW1lTmFtZSA9IHVuaXF1ZUlkKCdpZnJhbWVfdGFyZ2V0JyksIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKSwga2V5O1xyXG4gICAgICAgICAgICAgICAgaWZyYW1lLm5hbWUgPSBmb3JtLnRhcmdldCA9IGlmcmFtZU5hbWU7XHJcbiAgICAgICAgICAgICAgICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6ZmFsc2U7JztcclxuICAgICAgICAgICAgICAgIGZvcm0uZW5jdHlwZSA9IGZvcm0uZW5jb2RpbmcgPSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSc7XHJcbiAgICAgICAgICAgICAgICBmb3JtLmFjdGlvbiA9IHVybDtcclxuICAgICAgICAgICAgICAgIGZvcm0ubWV0aG9kID0gJ1BPU1QnO1xyXG4gICAgICAgICAgICAgICAgZm9ybS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGtleXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGtleXMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybS5pbnNlcnRCZWZvcmUodGhpcy5fX2NyZWF0ZUlucHV0KGtleSwgZGF0YVtrZXldKSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnhoci5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lLm9ubG9hZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRib2R5LnJlbW92ZUNoaWxkKGZvcm0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkYm9keS5yZW1vdmVDaGlsZChpZnJhbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmcmFtZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gaWZyYW1lLmNvbnRlbnREb2N1bWVudC5ib2R5LmlubmVySFRNTDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJGJvZHkucmVtb3ZlQ2hpbGQoZm9ybSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IGNvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDIwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gJyc7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnhociA9IGlmcmFtZS5vbmxvYWQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgJGJvZHkuaW5zZXJ0QmVmb3JlKGZvcm0sIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICRib2R5Lmluc2VydEJlZm9yZShpZnJhbWUsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcm0uc3VibWl0KCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENyZWF0ZXMgaW5wdXQgZm9yIGZvcm0gZGF0YSBzdWJtaXNzaW9ucy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fX2NyZWF0ZUlucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2RvY3VtZW50ID0gdGhpcy5fZG9jdW1lbnQsIGlucHV0ID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcbiAgICAgICAgICAgICAgICBpbnB1dC50eXBlID0gJ2hpZGRlbic7XHJcbiAgICAgICAgICAgICAgICBpbnB1dC5uYW1lID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbCh2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQudmFsdWUgPSAnJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB2YWwgaXMgYW4gcHNldWRvIEZpbGUgXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsLnNsaWNlKSAmJiAhKGlzVW5kZWZpbmVkKHZhbC5uYW1lKSB8fCBpc1VuZGVmaW5lZCh2YWwucGF0aCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWxlTGlzdCA9IF9kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwiZmlsZVwiXVtuYW1lPVwiJyArIGtleSArICdcIl0nKSwgbGVuZ3RoXzQgPSBmaWxlTGlzdC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vIGlucHV0cyBmb3VuZCwgc3RyaW5naWZ5IHRoZSBkYXRhIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoXzQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5pbmZvKCdDb3VsZCBub3QgZmluZCBpbnB1dFt0eXBlPVwiZmlsZVwiXSB3aXRoIFtuYW1lPVwiJyArIGtleSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1wiXS4gU3RyaW5naWZ5aW5nIGRhdGEgaW5zdGVhZC4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LnZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChsZW5ndGhfNCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSBmaWxlTGlzdFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN3YXAgbm9kZXMgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xvbmUgPSBpbnB1dC5jbG9uZU5vZGUodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjbG9uZSwgaW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmFyZSBjYXNlIGJ1dCBtYXkgaGF2ZSBtdWx0aXBsZSBmb3JtcyB3aXRoIGZpbGUgaW5wdXRzIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCBoYXZlIHRoZSBzYW1lIG5hbWUgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZUlucHV0ID0gdm9pZCAwLCBwYXRoID0gdmFsLnBhdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobGVuZ3RoXzQtLSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlSW5wdXQgPSBmaWxlTGlzdFtsZW5ndGhfNF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVJbnB1dC52YWx1ZSA9PT0gcGF0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dCA9IGZpbGVJbnB1dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3dhcCBub2RlcyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0Q2xvbmUgPSBpbnB1dC5jbG9uZU5vZGUodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGlucHV0Q2xvbmUsIGlucHV0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY291bGQgbm90IGZpbmQgdGhlIHJpZ2h0IGZpbGUgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoXzQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmluZm8oJ0NvdWxkIG5vdCBmaW5kIGlucHV0W3R5cGU9XCJmaWxlXCJdIHdpdGggW25hbWU9XCInICsga2V5ICsgJ1wiXSBhbmQgW3ZhbHVlPVwiJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbC5wYXRoICsgJ1wiXS4gU3RyaW5naWZ5aW5nIGRhdGEgaW5zdGVhZC4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC52YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1heSB0aHJvdyBhIGZhdGFsIGVycm9yIGJ1dCB0aGlzIGlzIGFuIGludmFsaWQgY2FzZSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmluZm8oJ0ludmFsaWQgZm9ybSBlbnRyeSB3aXRoIGtleSBcIicgKyBrZXkgKyAnXCIgYW5kIHZhbHVlIFwiJyArIHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LnZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dC52YWx1ZSA9IHZhbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgSHR0cFJlcXVlc3QuX2luamVjdCA9IHtcclxuICAgICAgICAgICAgICAgIF9icm93c2VyOiBfX0Jyb3dzZXIsXHJcbiAgICAgICAgICAgICAgICBfd2luZG93OiBfX1dpbmRvdyxcclxuICAgICAgICAgICAgICAgIF9kb2N1bWVudDogX19Eb2N1bWVudCxcclxuICAgICAgICAgICAgICAgIF9jb25maWc6IF9fSHR0cENvbmZpZyxcclxuICAgICAgICAgICAgICAgIF9sb2c6IF9fTG9nXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBIdHRwUmVxdWVzdDtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGFzeW5jLkh0dHBSZXF1ZXN0ID0gSHR0cFJlcXVlc3Q7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBjbGFzcyB0aGF0IGZvcm1zIGFuIEVycm9yIG9iamVjdCB3aXRoIGFuIElBamF4UmVzcG9uc2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEFqYXhFcnJvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY29uc3RydWN0b3IgZm9yIGFuIEFqYXhFcnJvci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LmFzeW5jLklBamF4UmVzcG9uc2V9IHJlc3BvbnNlIFRoZSBJQWpheFJlc3BvbnNlIG9iamVjdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEFqYXhFcnJvcihyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgRXJyb3IgKCdBamF4RXJyb3InKVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSAnQWpheEVycm9yJztcclxuICAgICAgICAgICAgICAgIEVycm9yLmFwcGx5KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IHRoaXMubWVzc2FnZSA9IHJlc3BvbnNlLnJlc3BvbnNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSByZXNwb25zZS5zdGF0dXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdldEFsbFJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlLmdldEFsbFJlc3BvbnNlSGVhZGVycztcclxuICAgICAgICAgICAgICAgIHRoaXMueGhyID0gcmVzcG9uc2UueGhyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBPdXRwdXRzIGEgZm9ybWF0dGVkIHN0cmluZyBkZXNjcmliaW5nIHRoZSBBamF4RXJyb3IuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBBamF4RXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gdGhpcy5yZXNwb25zZSwgcmVzcG9uc2VUZXh0ID0gcmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QocmVzcG9uc2UpICYmICFyZXNwb25zZS5oYXNPd25Qcm9wZXJ0eSgndG9TdHJpbmcnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlVGV4dCA9IEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXM6ICcgKyB0aGlzLnN0YXR1cyArICcgYW5kIHJlc3BvbnNlOiAnICsgcmVzcG9uc2VUZXh0O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gQWpheEVycm9yO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgYXN5bmMuQWpheEVycm9yID0gQWpheEVycm9yO1xyXG4gICAgICAgIC8vIGhhdmUgdG8gYnlwYXNzIFRTIGZsYWdzIGluIG9yZGVyIHRvIHByb3Blcmx5IGV4dGVuZCBFcnJvciBcclxuICAgICAgICBBamF4RXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlc2NyaWJlcyBhIHR5cGUgb2YgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggYW4gSUFqYXhSZXNwb25zZVxyXG4gICAgICAgICAqIGFuZCBjYW4gYmUgb3B0aW9uYWxseSBjYW5jZWxsZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEFqYXhQcm9taXNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKEFqYXhQcm9taXNlLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBBamF4UHJvbWlzZShyZXNvbHZlRnVuY3Rpb24sIHByb21pc2UpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHJlc29sdmVGdW5jdGlvbik7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBXaW5kb3cgb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl93aW5kb3cgPSBhY3F1aXJlKF9fV2luZG93KTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKHByb21pc2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2h0dHAgPSBwcm9taXNlLl9faHR0cDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBtZXRob2QgdG8gaW5pdGlhbGl6ZSB0aGlzIEFqYXhQcm9taXNlLCBwYXNzaW5nIGl0IHRoZVxyXG4gICAgICAgICAgICAgKiBhc3NvY2lhdGVkIElIdHRwUmVxdWVzdC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LmFzeW5jLkh0dHBSZXF1ZXN0fSBodHRwIFRoZSBodHRwIHJlcXVlc3QgZm9yIHRoaXMgcHJvbWlzZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEFqYXhQcm9taXNlLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGh0dHApIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChodHRwKSAmJiBpc051bGwodGhpcy5fX2h0dHApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2h0dHAgPSBodHRwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBtZXRob2QgdG8gY2FuY2VsIHRoZSBBSkFYIGNhbGwgYXNzb2NpYXRlZCB3aXRoIHRoaXMgQWpheFByb21pc2UuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBBamF4UHJvbWlzZS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGh0dHAgPSB0aGlzLl9faHR0cCwgeGhyID0gaHR0cC54aHIsIGpzb25wQ2FsbGJhY2sgPSBodHRwLmpzb25wQ2FsbGJhY2s7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihodHRwLmNsZWFyVGltZW91dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBodHRwLmNsZWFyVGltZW91dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGwoeGhyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHhoci5hYm9ydCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGh0dHAueGhyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc051bGwoanNvbnBDYWxsYmFjaykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl93aW5kb3dbanNvbnBDYWxsYmFja10gPSBub29wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3N1YnNjcmliZXJzID0gW107XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFqYXhQcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS50aGVuLmNhbGwodGhpcywgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBamF4UHJvbWlzZS5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuY2F0Y2guY2FsbCh0aGlzLCBvblJlamVjdGVkKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIEFqYXhQcm9taXNlO1xyXG4gICAgICAgIH0oUHJvbWlzZSkpO1xyXG4gICAgICAgIGFzeW5jLkFqYXhQcm9taXNlID0gQWpheFByb21pc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGluc3RhbnRpYXRlZCBjbGFzcyBvZiB0aGUgaW5qZWN0YWJsZSBmb3IgbWFraW5nXHJcbiAgICAgICAgICogQUpBWCByZXF1ZXN0cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgSHR0cCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEh0dHAoKSB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFByb3ZpZGVzIHZhbHVlIG1hcHBpbmdzIGZvciBYTUxIdHRwUmVxdWVzdFJlc3BvbnNlVHlwZXNcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZVR5cGUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgREVGQVVMVDogJycsXHJcbiAgICAgICAgICAgICAgICAgICAgQVJSQVlCVUZGRVI6ICdhcnJheWJ1ZmZlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgQkxPQjogJ2Jsb2InLFxyXG4gICAgICAgICAgICAgICAgICAgIERPQ1VNRU5UOiAnZG9jdW1lbnQnLFxyXG4gICAgICAgICAgICAgICAgICAgIEpTT046ICdqc29uJyxcclxuICAgICAgICAgICAgICAgICAgICBURVhUOiAndGV4dCdcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFByb3ZpZGVzIENvbnRlbnQtVHlwZSBtYXBwaW5ncyBmb3IgSHR0cCBQT1NUIHJlcXVlc3RzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRUeXBlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIEVOQ09ERURfRk9STTogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04JyxcclxuICAgICAgICAgICAgICAgICAgICBKU09OOiAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04JyxcclxuICAgICAgICAgICAgICAgICAgICBNVUxUSVBBUlRfRk9STTogJ211bHRpcGFydC9mb3JtLWRhdGEnLFxyXG4gICAgICAgICAgICAgICAgICAgIE9DVEVUX1NUUkVBTTogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtjaGFyc2V0PXV0Zi04JyxcclxuICAgICAgICAgICAgICAgICAgICBYTUw6ICdhcHBsaWNhdGlvbi94bWw7Y2hhcnNldD11dGYtOCcsXHJcbiAgICAgICAgICAgICAgICAgICAgUExBSU5fVEVYVDogJ3RleHQvcGxhaW4nLFxyXG4gICAgICAgICAgICAgICAgICAgIEhUTUw6ICd0ZXh0L2h0bWwnXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIHdyYXBwZXIgbWV0aG9kIGZvciB0aGUgSHR0cCBjbGFzcyB0aGF0IGNyZWF0ZXMgYW5kIGV4ZWN1dGVzIGEgbmV3IEh0dHAgd2l0aFxyXG4gICAgICAgICAgICAgKiB0aGUgc3BlY2lmaWVkIElIdHRwQ29uZmlnLiBUaGlzIGZ1bmN0aW9uIHdpbGwgY2hlY2sgaWZcclxuICAgICAgICAgICAgICogWE1MSHR0cFJlcXVlc3QgbGV2ZWwgMiBpcyBwcmVzZW50LCBhbmQgd2lsbCBkZWZhdWx0IHRvIEpTT05QIGlmIGl0IGlzbid0IGFuZFxyXG4gICAgICAgICAgICAgKiB0aGUgcmVxdWVzdCBpcyBjcm9zcy1kb21haW4uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5hc3luYy5JSHR0cENvbmZpZ30gb3B0aW9ucyBUaGUgSUh0dHBDb25maWcgZm9yIGVpdGhlciB0aGUgWE1MSHR0cFJlcXVlc3RcclxuICAgICAgICAgICAgICogb3IgdGhlIEpTT05QIGNhbGxiYWNrLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgSHR0cC5wcm90b3R5cGUuYWpheCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IGFjcXVpcmUoX19IdHRwUmVxdWVzdEluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QuaW5pdGlhbGl6ZShvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0LmV4ZWN1dGUoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgZGlyZWN0IG1ldGhvZCB0byBmb3JjZSBhIGNyb3NzLWRvbWFpbiBKU09OUCByZXF1ZXN0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuYXN5bmMuSUpzb25wQ29uZmlnfSBvcHRpb25zIFRoZSBJSnNvbnBDb25maWdcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEh0dHAucHJvdG90eXBlLmpzb25wID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gYWNxdWlyZShfX0h0dHBSZXF1ZXN0SW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5pbml0aWFsaXplKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3QuZXhlY3V0ZUpzb25wKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBNYWtlcyBhbiBhamF4IHJlcXVlc3QsIHNwZWNpZnlpbmcgcmVzcG9uc2VUeXBlOiAnanNvbicuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5hc3luYy5JSHR0cENvbmZpZ30gb3B0aW9ucyBUaGUgSUh0dHBDb25maWdcclxuICAgICAgICAgICAgICogZm9yIGVpdGhlciB0aGUgWE1MSHR0cFJlcXVlc3Qgb3IgdGhlIEpTT05QIGNhbGxiYWNrLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgSHR0cC5wcm90b3R5cGUuanNvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IGFjcXVpcmUoX19IdHRwUmVxdWVzdEluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QuaW5pdGlhbGl6ZShfZXh0ZW5kKGZhbHNlLCBmYWxzZSwge30sIG9wdGlvbnMsIHsgcmVzcG9uc2VUeXBlOiAnanNvbicgfSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3QuZXhlY3V0ZSgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGVmYXVsdCBIdHRwIGNvbmZpZ1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgSHR0cC5jb25maWcgPSB7XHJcbiAgICAgICAgICAgICAgICB1cmw6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnJyxcclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge30sXHJcbiAgICAgICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgdGltZW91dDogbnVsbCxcclxuICAgICAgICAgICAgICAgIGpzb25wSWRlbnRpZmllcjogJ2NhbGxiYWNrJyxcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04J1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gSHR0cDtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGFzeW5jLkh0dHAgPSBIdHRwO1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19IdHRwLCBIdHRwKTtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fSHR0cFJlcXVlc3RJbnN0YW5jZSwgSHR0cFJlcXVlc3QsIG51bGwsIF9fSU5TVEFOQ0UpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIElIdHRwQ29uZmlnKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gSHR0cC5jb25maWc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzeW5jLklIdHRwQ29uZmlnID0gSUh0dHBDb25maWc7XHJcbiAgICAgICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX0h0dHBDb25maWcsIElIdHRwQ29uZmlnKTtcclxuICAgIH0pKGFzeW5jID0gcGxhdF8xLmFzeW5jIHx8IChwbGF0XzEuYXN5bmMgPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIb2xkcyBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIHJlbGF0ZWQgdG8gc3RvcmFnZSBpbiBwbGF0eXB1cy5cclxuICAgICAqL1xyXG4gICAgdmFyIHN0b3JhZ2U7XHJcbiAgICAoZnVuY3Rpb24gKHN0b3JhZ2VfMSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBrZXllZCBjb2xsZWN0aW9uIG9mIGFsbCBjcmVhdGVkIENhY2hlcyBpbiB0aGVcclxuICAgICAgICAgKiBJQ2FjaGVGYWN0b3J5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBjYWNoZXMgPSB7fSwgXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW50ZXJuYWwgc3RvcmFnZSBmb3IgYWxsIHRoZSBpdGVtcyBzdG9yZWQgaW4gZWFjaCBDYWNoZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBpbnRlcm5hbENhY2hlcyA9IHt9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgQ2FjaGUgY2xhc3MsIGZvciB1c2Ugd2l0aCB0aGUgSUNhY2hlRmFjdG9yeSBpbmplY3RhYmxlLlxyXG4gICAgICAgICAqIFVzZWQgZm9yIHN0b3Jpbmcgb2JqZWN0cy4gVGFrZXMgaW4gYSBnZW5lcmljIHR5cGUgY29ycmVzcG9uZGluZyB0byB0aGUgdHlwZSBvZiBvYmplY3RzIGl0IGNvbnRhaW5zLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBDYWNoZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY29uc3RydWN0b3IgZm9yIGEgQ2FjaGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgaWQgdG8gdXNlIHRvIHJldHJpZXZlIHRoZSBjYWNoZSBmcm9tIHRoZSBJQ2FjaGVGYWN0b3J5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuc3RvcmFnZS5JQ2FjaGVPcHRpb25zfSBvcHRpb25zIFRoZSBJQ2FjaGVPcHRpb25zIGZvciBjdXN0b21pemluZyB0aGUgY2FjaGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBDYWNoZSh1aWQsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX191aWQgPSB1aWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fb3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fc2l6ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKG9wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX29wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IDBcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxDYWNoZXNbdWlkXSA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBNZXRob2QgZm9yIGNyZWF0aW5nIGEgbmV3IGNhY2hlIG9iamVjdC4gVGFrZXMgYSBnZW5lcmljIHR5cGUgdG8gZGVub3RlIHRoZVxyXG4gICAgICAgICAgICAgKiB0eXBlIG9mIG9iamVjdHMgc3RvcmVkIGluIHRoZSBuZXcgY2FjaGUuICBJZiBhIGNhY2hlIHdpdGggdGhlIHNhbWUgSUQgYWxyZWFkeSBleGlzdHNcclxuICAgICAgICAgICAgICogaW4gdGhlIElDYWNoZUZhY3RvcnksIGEgbmV3IGNhY2hlIHdpbGwgbm90IGJlIGNyZWF0ZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1aWQgVGhlIElEIG9mIHRoZSBuZXcgQ2FjaGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5zdG9yYWdlLklDYWNoZU9wdGlvbnN9IG9wdGlvbnMgSUNhY2hlT3B0aW9uc1xyXG4gICAgICAgICAgICAgKiBmb3IgY3VzdG9taXppbmcgdGhlIENhY2hlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ2FjaGUuY3JlYXRlID0gZnVuY3Rpb24gKHVpZCwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlID0gY2FjaGVzW3VpZF07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGNhY2hlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlID0gY2FjaGVzW3VpZF0gPSBuZXcgQ2FjaGUodWlkLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgYSBjYWNoZSBvdXQgb2YgdGhlIElDYWNoZUZhY3RvcnkgaWYgaXQgZXhpc3RzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdWlkIFRoZSBpZGVudGlmaWVyIHVzZWQgdG8gc2VhcmNoIGZvciB0aGUgY2FjaGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDYWNoZS5mZXRjaCA9IGZ1bmN0aW9uICh1aWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZXNbdWlkXTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENsZWFycyB0aGUgSUNhY2hlRmFjdG9yeSBhbmQgYWxsIG9mIGl0cyBjYWNoZXMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDYWNoZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY2FjaGVzKSwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVzW2tleXNbaV1dLmNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYWNoZXMgPSB7fTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHJpZXZlcyB0aGUgSUNhY2hlSW5mbyBhYm91dCB0aGlzIGNhY2hlXHJcbiAgICAgICAgICAgICAqIChpLmUuIElELCBzaXplLCBvcHRpb25zKVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ2FjaGUucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHVpZDogdGhpcy5fX3VpZCxcclxuICAgICAgICAgICAgICAgICAgICBzaXplOiB0aGlzLl9fc2l6ZSxcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB0aGlzLl9fb3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE1ldGhvZCBmb3IgaW5zZXJ0aW5nIGFuIG9iamVjdCBpbnRvIGFuIENhY2hlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gdXNlIGZvciBzdG9yYWdlL3JldHJpZXZhbCBvZiB0aGUgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1R9IHZhbHVlIFRoZSB2YWx1ZSB0byBzdG9yZSB3aXRoIHRoZSBhc3NvY2lhdGVkIGtleS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENhY2hlLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IGludGVybmFsQ2FjaGVzW3RoaXMuX191aWRdW2tleV07XHJcbiAgICAgICAgICAgICAgICBpbnRlcm5hbENhY2hlc1t0aGlzLl9fdWlkXVtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19zaXplKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdGltZW91dCA9IHRoaXMuX19vcHRpb25zLnRpbWVvdXQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIodGltZW91dCkgJiYgdGltZW91dCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZlcih0aGlzLnJlbW92ZSwgdGltZW91dCwgW2tleV0sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTWV0aG9kIGZvciByZXRyaWV2aW5nIGFuIG9iamVjdCBmcm9tIGFuIENhY2hlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvciBpbiBhbiBDYWNoZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENhY2hlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFsQ2FjaGVzW3RoaXMuX191aWRdW2tleV07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBNZXRob2QgZm9yIHJlbW92aW5nIGFuIG9iamVjdCBmcm9tIGFuIENhY2hlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gcmVtb3ZlIGZyb20gdGhlIENhY2hlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ2FjaGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KGludGVybmFsQ2FjaGVzW3RoaXMuX191aWRdLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3NpemUtLTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE1ldGhvZCBmb3IgY2xlYXJpbmcgYW4gQ2FjaGUsIHJlbW92aW5nIGFsbCBvZiBpdHMga2V5cy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGludGVybmFsQ2FjaGVzW3RoaXMuX191aWRdID0ge307XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fc2l6ZSA9IDA7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBNZXRob2QgZm9yIHJlbW92aW5nIGFuIElDYWNoZSBmcm9tIHRoZSBJQ2FjaGVGYWN0b3J5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ2FjaGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eShjYWNoZXMsIHRoaXMuX191aWQpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gQ2FjaGU7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBzdG9yYWdlXzEuQ2FjaGUgPSBDYWNoZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBJQ2FjaGVGYWN0b3J5KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gQ2FjaGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0b3JhZ2VfMS5JQ2FjaGVGYWN0b3J5ID0gSUNhY2hlRmFjdG9yeTtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fQ2FjaGVGYWN0b3J5LCBJQ2FjaGVGYWN0b3J5LCBudWxsLCBfX0ZBQ1RPUlkpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0b3JhZ2VfMS5tYW5hZ2VyQ2FjaGUgPSBDYWNoZS5jcmVhdGUoJ19fbWFuYWdlckNhY2hlJyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gSU1hbmFnZXJDYWNoZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2VfMS5tYW5hZ2VyQ2FjaGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0b3JhZ2VfMS5JTWFuYWdlckNhY2hlID0gSU1hbmFnZXJDYWNoZTtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fTWFuYWdlckNhY2hlLCBJTWFuYWdlckNhY2hlKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVc2VkIGZvciBjYWNoaW5nIGNvbXBpbGVkIG5vZGVzLiBUaGlzIGNsYXNzIHdpbGxcclxuICAgICAgICAgKiBjbG9uZSBhIHRlbXBsYXRlIHdoZW4geW91IHB1dCBpdCBpbiB0aGUgY2FjaGUuIEl0IHdpbGxcclxuICAgICAgICAgKiBhbHNvIGNsb25lIHRoZSB0ZW1wbGF0ZSB3aGVuIHlvdSByZXRyaWV2ZSBpdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgVGVtcGxhdGVDYWNoZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhUZW1wbGF0ZUNhY2hlLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGNvbnN0cnVjdG9yIGZvciBhIFRlbXBsYXRlQ2FjaGUuIENyZWF0ZXMgYSBuZXcgQ2FjaGVcclxuICAgICAgICAgICAgICogd2l0aCB0aGUgSUQgXCJfX3RlbXBsYXRlQ2FjaGVcIi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFRlbXBsYXRlQ2FjaGUoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCAnX190ZW1wbGF0ZUNhY2hlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgVGVtcGxhdGVDYWNoZS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBQcm9taXNlID0gdGhpcy5fUHJvbWlzZTtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUucHV0LmNhbGwodGhpcywga2V5LCBQcm9taXNlLnJlc29sdmUodmFsdWUpKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0RvY3VtZW50RnJhZ21lbnQodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5jbG9uZU5vZGUodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc05vZGUodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHZhbHVlLmNsb25lTm9kZSh0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBmcmFnbWVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSB8fCBpc051bGwodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzZXJpYWxpemVIdG1sKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTWV0aG9kIGZvciByZXRyaWV2aW5nIGEgTm9kZSBmcm9tIHRoaXMgY2FjaGUuIFRoZSBEb2N1bWVudEZyYWdtZW50IHRoYXQgcmVzb2x2ZXMgZnJvbSB0aGUgcmV0dXJuZWRcclxuICAgICAgICAgICAgICogUHJvbWlzZSB3aWxsIGJlIGNsb25lZCB0byBhdm9pZCBtYW5pcHVsYXRpbmcgdGhlIGNhY2hlZCB0ZW1wbGF0ZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IgaW4gdGhpcyBjYWNoZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRlbXBsYXRlQ2FjaGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBfc3VwZXIucHJvdG90eXBlLnJlYWQuY2FsbCh0aGlzLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChwcm9taXNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLnJlamVjdChudWxsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucHV0KGtleSwgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLndhcm4oJ0Vycm9yIHJldHJpZXZpbmcgdGVtcGxhdGUsICcgKyBrZXkgKyAnLCBmcm9tIHByb21pc2UuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVGVtcGxhdGVDYWNoZS5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICAgICAgX1Byb21pc2U6IF9fUHJvbWlzZSxcclxuICAgICAgICAgICAgICAgIF9sb2c6IF9fTG9nXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBUZW1wbGF0ZUNhY2hlO1xyXG4gICAgICAgIH0oQ2FjaGUpKTtcclxuICAgICAgICBzdG9yYWdlXzEuVGVtcGxhdGVDYWNoZSA9IFRlbXBsYXRlQ2FjaGU7XHJcbiAgICAgICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX1RlbXBsYXRlQ2FjaGUsIFRlbXBsYXRlQ2FjaGUpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgYmFzZSBjbGFzcyBmb3Igc3RvcmluZyBkYXRhIHdpdGggYSBkZXNpZ25hdGVkIHN0b3JhZ2UgdHlwZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgQmFzZVN0b3JhZ2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGNvbnN0cnVjdG9yIGZvciBhIEJhc2VTdG9yYWdlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gQmFzZVN0b3JhZ2Uoc3RvcmFnZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3JhZ2UgPSBzdG9yYWdlO1xyXG4gICAgICAgICAgICAgICAgZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH0sIHN0b3JhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlU3RvcmFnZS5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGl0ZW1zIGluIHN0b3JhZ2UuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9yYWdlLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2xlYXJzIHN0b3JhZ2UsIGRlbGV0aW5nIGFsbCBvZiBpdHMga2V5cy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJhc2VTdG9yYWdlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3JhZ2UuY2xlYXIoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgYW4gaXRlbSBvdXQgb2Ygc3RvcmFnZSB3aXRoIHRoZSBhc3NpZ25lZCBrZXkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgaXRlbSB0byByZXRyaWV2ZSBmcm9tIHN0b3JhZ2UuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCYXNlU3RvcmFnZS5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9yYWdlLmdldEl0ZW0oa2V5KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFsbG93cyBmb3IgaXRlcmF0aW5nIG92ZXIgc3RvcmFnZSBrZXlzIHdpdGggYW4gaW5kZXguIFdoZW5cclxuICAgICAgICAgICAgICogY2FsbGVkIHdpdGggYW4gaW5kZXgsIGl0IHdpbGwgcmV0dXJuIHRoZSBrZXkgYXQgdGhhdCBpbmRleCBpblxyXG4gICAgICAgICAgICAgKiBzdG9yYWdlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IHVzZWQgdG8gcmV0cmlldmUgdGhlIGFzc29jaWF0ZWQga2V5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmFzZVN0b3JhZ2UucHJvdG90eXBlLmtleSA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2Uua2V5KGluZGV4KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNlYXJjaGVzIGluIHN0b3JhZ2UgZm9yIGFuIGl0ZW0gYW5kIHJlbW92ZXMgaXQgaWYgaXRcclxuICAgICAgICAgICAgICogZXhpc3RzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGl0ZW0gdG8gcmVtb3ZlIGZyb20gc3RvcmFnZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJhc2VTdG9yYWdlLnByb3RvdHlwZS5yZW1vdmVJdGVtID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBZGRzIGRhdGEgdG8gc3RvcmFnZSB3aXRoIHRoZSBkZXNpZ25hdGVkIGtleS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBpdGVtIHRvIHN0b3JlIGluIHN0b3JhZ2UuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIHN0b3JlIGluIHN0b3JhZ2Ugd2l0aCB0aGUga2V5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmFzZVN0b3JhZ2UucHJvdG90eXBlLnNldEl0ZW0gPSBmdW5jdGlvbiAoa2V5LCBkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdG9yYWdlLnNldEl0ZW0oa2V5LCBkYXRhKTtcclxuICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IHRoaXMuZ2V0SXRlbShrZXkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gQmFzZVN0b3JhZ2U7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBzdG9yYWdlXzEuQmFzZVN0b3JhZ2UgPSBCYXNlU3RvcmFnZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGNsYXNzIHVzZWQgdG8gd3JhcCBIVE1MNSBsb2NhbFN0b3JhZ2UgaW50byBhbiBpbmplY3RhYmxlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBMb2NhbFN0b3JhZ2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoTG9jYWxTdG9yYWdlLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBMb2NhbFN0b3JhZ2UoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBhY3F1aXJlKF9fV2luZG93KS5sb2NhbFN0b3JhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBMb2NhbFN0b3JhZ2U7XHJcbiAgICAgICAgfShCYXNlU3RvcmFnZSkpO1xyXG4gICAgICAgIHN0b3JhZ2VfMS5Mb2NhbFN0b3JhZ2UgPSBMb2NhbFN0b3JhZ2U7XHJcbiAgICAgICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX0xvY2FsU3RvcmFnZSwgTG9jYWxTdG9yYWdlKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGNsYXNzIGZvciB3cmFwcGluZyBTZXNzaW9uU3RvcmFnZSBhcyBhbiBpbmplY3RhYmxlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBTZXNzaW9uU3RvcmFnZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhTZXNzaW9uU3RvcmFnZSwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gU2Vzc2lvblN0b3JhZ2UoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBhY3F1aXJlKF9fV2luZG93KS5zZXNzaW9uU3RvcmFnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFNlc3Npb25TdG9yYWdlO1xyXG4gICAgICAgIH0oQmFzZVN0b3JhZ2UpKTtcclxuICAgICAgICBzdG9yYWdlXzEuU2Vzc2lvblN0b3JhZ2UgPSBTZXNzaW9uU3RvcmFnZTtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fU2Vzc2lvblN0b3JhZ2UsIFNlc3Npb25TdG9yYWdlKTtcclxuICAgIH0pKHN0b3JhZ2UgPSBwbGF0XzEuc3RvcmFnZSB8fCAocGxhdF8xLnN0b3JhZ2UgPSB7fSkpO1xyXG4gICAgLyogdHNsaW50OmRpc2FibGU6bm8tdW51c2VkLXZhcmlhYmxlICovXHJcbiAgICAvKipcclxuICAgICAqIEFuIG9iamVjdCB1c2VkIHRvIGNyZWF0ZSBJVG9rZW5EZXRhaWxzIGZvciBldmVyeSBvcGVyYXRvci5cclxuICAgICAqL1xyXG4gICAgdmFyIE9QRVJBVE9SUyA9IHtcclxuICAgICAgICAndSsnOiB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDQsIGFzc29jaWF0aXZpdHk6ICdydGwnLFxyXG4gICAgICAgICAgICBmbjogZnVuY3Rpb24gKGNvbnRleHQsIGFsaWFzZXMsIGEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiArYShjb250ZXh0LCBhbGlhc2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJysnOiB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDYsIGFzc29jaWF0aXZpdHk6ICdsdHInLFxyXG4gICAgICAgICAgICBmbjogZnVuY3Rpb24gKGNvbnRleHQsIGFsaWFzZXMsIGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhKGNvbnRleHQsIGFsaWFzZXMpICsgYihjb250ZXh0LCBhbGlhc2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ3UtJzoge1xyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiA0LCBhc3NvY2lhdGl2aXR5OiAncnRsJyxcclxuICAgICAgICAgICAgZm46IGZ1bmN0aW9uIChjb250ZXh0LCBhbGlhc2VzLCBhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLWEoY29udGV4dCwgYWxpYXNlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICctJzoge1xyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiA2LCBhc3NvY2lhdGl2aXR5OiAnbHRyJyxcclxuICAgICAgICAgICAgZm46IGZ1bmN0aW9uIChjb250ZXh0LCBhbGlhc2VzLCBhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYShjb250ZXh0LCBhbGlhc2VzKSAtIGIoY29udGV4dCwgYWxpYXNlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICcqJzoge1xyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiA1LCBhc3NvY2lhdGl2aXR5OiAnbHRyJyxcclxuICAgICAgICAgICAgZm46IGZ1bmN0aW9uIChjb250ZXh0LCBhbGlhc2VzLCBhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYShjb250ZXh0LCBhbGlhc2VzKSAqIGIoY29udGV4dCwgYWxpYXNlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICcvJzoge1xyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiA1LCBhc3NvY2lhdGl2aXR5OiAnbHRyJyxcclxuICAgICAgICAgICAgZm46IGZ1bmN0aW9uIChjb250ZXh0LCBhbGlhc2VzLCBhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYShjb250ZXh0LCBhbGlhc2VzKSAvIGIoY29udGV4dCwgYWxpYXNlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICclJzoge1xyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiA1LCBhc3NvY2lhdGl2aXR5OiAnbHRyJyxcclxuICAgICAgICAgICAgZm46IGZ1bmN0aW9uIChjb250ZXh0LCBhbGlhc2VzLCBhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYShjb250ZXh0LCBhbGlhc2VzKSAlIGIoY29udGV4dCwgYWxpYXNlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICc/Jzoge1xyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiAxNSwgYXNzb2NpYXRpdml0eTogJ3J0bCcsXHJcbiAgICAgICAgICAgIGZuOiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICc6Jzoge1xyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiAxNSwgYXNzb2NpYXRpdml0eTogJ3J0bCcsXHJcbiAgICAgICAgICAgIGZuOiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICc+Jzoge1xyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiA4LCBhc3NvY2lhdGl2aXR5OiAnbHRyJyxcclxuICAgICAgICAgICAgZm46IGZ1bmN0aW9uIChjb250ZXh0LCBhbGlhc2VzLCBhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYShjb250ZXh0LCBhbGlhc2VzKSA+IGIoY29udGV4dCwgYWxpYXNlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICc8Jzoge1xyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiA4LCBhc3NvY2lhdGl2aXR5OiAnbHRyJyxcclxuICAgICAgICAgICAgZm46IGZ1bmN0aW9uIChjb250ZXh0LCBhbGlhc2VzLCBhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYShjb250ZXh0LCBhbGlhc2VzKSA8IGIoY29udGV4dCwgYWxpYXNlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICchJzoge1xyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiA0LCBhc3NvY2lhdGl2aXR5OiAncnRsJyxcclxuICAgICAgICAgICAgZm46IGZ1bmN0aW9uIChjb250ZXh0LCBhbGlhc2VzLCBhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gIWEoY29udGV4dCwgYWxpYXNlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICd+Jzoge1xyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiA0LCBhc3NvY2lhdGl2aXR5OiAncnRsJyxcclxuICAgICAgICAgICAgZm46IGZ1bmN0aW9uIChjb250ZXh0LCBhbGlhc2VzLCBhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gfmEoY29udGV4dCwgYWxpYXNlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICcmJzoge1xyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiAxMCwgYXNzb2NpYXRpdml0eTogJ2x0cicsXHJcbiAgICAgICAgICAgIGZuOiBmdW5jdGlvbiAoY29udGV4dCwgYWxpYXNlcywgYSwgYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEoY29udGV4dCwgYWxpYXNlcykgJiBiKGNvbnRleHQsIGFsaWFzZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnfCc6IHtcclxuICAgICAgICAgICAgcHJlY2VkZW5jZTogMTIsIGFzc29jaWF0aXZpdHk6ICdsdHInLFxyXG4gICAgICAgICAgICBmbjogZnVuY3Rpb24gKGNvbnRleHQsIGFsaWFzZXMsIGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhKGNvbnRleHQsIGFsaWFzZXMpIHwgYihjb250ZXh0LCBhbGlhc2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJz4+Jzoge1xyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiA3LCBhc3NvY2lhdGl2aXR5OiAnbHRyJyxcclxuICAgICAgICAgICAgZm46IGZ1bmN0aW9uIChjb250ZXh0LCBhbGlhc2VzLCBhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYShjb250ZXh0LCBhbGlhc2VzKSA+PiBiKGNvbnRleHQsIGFsaWFzZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnPDwnOiB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDcsIGFzc29jaWF0aXZpdHk6ICdsdHInLFxyXG4gICAgICAgICAgICBmbjogZnVuY3Rpb24gKGNvbnRleHQsIGFsaWFzZXMsIGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhKGNvbnRleHQsIGFsaWFzZXMpIDw8IGIoY29udGV4dCwgYWxpYXNlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICc+Pj4nOiB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDcsIGFzc29jaWF0aXZpdHk6ICdsdHInLFxyXG4gICAgICAgICAgICBmbjogZnVuY3Rpb24gKGNvbnRleHQsIGFsaWFzZXMsIGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhKGNvbnRleHQsIGFsaWFzZXMpID4+PiBiKGNvbnRleHQsIGFsaWFzZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnJiYnOiB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDEzLCBhc3NvY2lhdGl2aXR5OiAnbHRyJyxcclxuICAgICAgICAgICAgZm46IGZ1bmN0aW9uIChjb250ZXh0LCBhbGlhc2VzLCBhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYShjb250ZXh0LCBhbGlhc2VzKSAmJiBiKGNvbnRleHQsIGFsaWFzZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnfHwnOiB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDE0LCBhc3NvY2lhdGl2aXR5OiAnbHRyJyxcclxuICAgICAgICAgICAgZm46IGZ1bmN0aW9uIChjb250ZXh0LCBhbGlhc2VzLCBhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYShjb250ZXh0LCBhbGlhc2VzKSB8fCBiKGNvbnRleHQsIGFsaWFzZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnPT0nOiB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDksIGFzc29jaWF0aXZpdHk6ICdsdHInLFxyXG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTp0cmlwbGUtZXF1YWxzICovXHJcbiAgICAgICAgICAgIGZuOiBmdW5jdGlvbiAoY29udGV4dCwgYWxpYXNlcywgYSwgYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEoY29udGV4dCwgYWxpYXNlcykgPT0gYihjb250ZXh0LCBhbGlhc2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJz09PSc6IHtcclxuICAgICAgICAgICAgcHJlY2VkZW5jZTogOSwgYXNzb2NpYXRpdml0eTogJ2x0cicsXHJcbiAgICAgICAgICAgIGZuOiBmdW5jdGlvbiAoY29udGV4dCwgYWxpYXNlcywgYSwgYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEoY29udGV4dCwgYWxpYXNlcykgPT09IGIoY29udGV4dCwgYWxpYXNlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICchPSc6IHtcclxuICAgICAgICAgICAgcHJlY2VkZW5jZTogOSwgYXNzb2NpYXRpdml0eTogJ2x0cicsXHJcbiAgICAgICAgICAgIC8qIHRzbGludDpkaXNhYmxlOnRyaXBsZS1lcXVhbHMgKi9cclxuICAgICAgICAgICAgZm46IGZ1bmN0aW9uIChjb250ZXh0LCBhbGlhc2VzLCBhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYShjb250ZXh0LCBhbGlhc2VzKSAhPSBiKGNvbnRleHQsIGFsaWFzZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnIT09Jzoge1xyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiA5LCBhc3NvY2lhdGl2aXR5OiAnbHRyJyxcclxuICAgICAgICAgICAgZm46IGZ1bmN0aW9uIChjb250ZXh0LCBhbGlhc2VzLCBhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYShjb250ZXh0LCBhbGlhc2VzKSAhPT0gYihjb250ZXh0LCBhbGlhc2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJz49Jzoge1xyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiA4LCBhc3NvY2lhdGl2aXR5OiAnbHRyJyxcclxuICAgICAgICAgICAgZm46IGZ1bmN0aW9uIChjb250ZXh0LCBhbGlhc2VzLCBhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYShjb250ZXh0LCBhbGlhc2VzKSA+PSBiKGNvbnRleHQsIGFsaWFzZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnPD0nOiB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDgsIGFzc29jaWF0aXZpdHk6ICdsdHInLFxyXG4gICAgICAgICAgICBmbjogZnVuY3Rpb24gKGNvbnRleHQsIGFsaWFzZXMsIGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhKGNvbnRleHQsIGFsaWFzZXMpIDw9IGIoY29udGV4dCwgYWxpYXNlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICc9Jzoge1xyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiAxNywgYXNzb2NpYXRpdml0eTogJ3J0bCcsXHJcbiAgICAgICAgICAgIGZuOiBmdW5jdGlvbiAoY29udGV4dCwgYWxpYXNlcywgYSwgYikge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9sb2cgPSBwbGF0LmFjcXVpcmUoX19Mb2cpO1xyXG4gICAgICAgICAgICAgICAgX2xvZy5lcnJvcihuZXcgRXJyb3IoJ0Fzc2lnbm1lbnQgb3BlcmF0b3JzIGFyZSBub3Qgc3VwcG9ydGVkJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnKysnOiB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDMsIGFzc29jaWF0aXZpdHk6ICcnLFxyXG4gICAgICAgICAgICBmbjogZnVuY3Rpb24gKGNvbnRleHQsIGFsaWFzZXMsIGEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfbG9nID0gcGxhdC5hY3F1aXJlKF9fTG9nKTtcclxuICAgICAgICAgICAgICAgIF9sb2cuZXJyb3IobmV3IEVycm9yKCdBc3NpZ25tZW50IG9wZXJhdG9ycyBhcmUgbm90IHN1cHBvcnRlZCcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJy0tJzoge1xyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiAzLCBhc3NvY2lhdGl2aXR5OiAnJyxcclxuICAgICAgICAgICAgZm46IGZ1bmN0aW9uIChjb250ZXh0LCBhbGlhc2VzLCBhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2xvZyA9IHBsYXQuYWNxdWlyZShfX0xvZyk7XHJcbiAgICAgICAgICAgICAgICBfbG9nLmVycm9yKG5ldyBFcnJvcignQXNzaWdubWVudCBvcGVyYXRvcnMgYXJlIG5vdCBzdXBwb3J0ZWQnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICcrPSc6IHtcclxuICAgICAgICAgICAgcHJlY2VkZW5jZTogMTcsIGFzc29jaWF0aXZpdHk6ICdydGwnLFxyXG4gICAgICAgICAgICBmbjogZnVuY3Rpb24gKGNvbnRleHQsIGFsaWFzZXMsIGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfbG9nID0gcGxhdC5hY3F1aXJlKF9fTG9nKTtcclxuICAgICAgICAgICAgICAgIF9sb2cuZXJyb3IobmV3IEVycm9yKCdBc3NpZ25tZW50IG9wZXJhdG9ycyBhcmUgbm90IHN1cHBvcnRlZCcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJy09Jzoge1xyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiAxNywgYXNzb2NpYXRpdml0eTogJ3J0bCcsXHJcbiAgICAgICAgICAgIGZuOiBmdW5jdGlvbiAoY29udGV4dCwgYWxpYXNlcywgYSwgYikge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9sb2cgPSBwbGF0LmFjcXVpcmUoX19Mb2cpO1xyXG4gICAgICAgICAgICAgICAgX2xvZy5lcnJvcihuZXcgRXJyb3IoJ0Fzc2lnbm1lbnQgb3BlcmF0b3JzIGFyZSBub3Qgc3VwcG9ydGVkJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnKj0nOiB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDE3LCBhc3NvY2lhdGl2aXR5OiAncnRsJyxcclxuICAgICAgICAgICAgZm46IGZ1bmN0aW9uIChjb250ZXh0LCBhbGlhc2VzLCBhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2xvZyA9IHBsYXQuYWNxdWlyZShfX0xvZyk7XHJcbiAgICAgICAgICAgICAgICBfbG9nLmVycm9yKG5ldyBFcnJvcignQXNzaWdubWVudCBvcGVyYXRvcnMgYXJlIG5vdCBzdXBwb3J0ZWQnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICcvPSc6IHtcclxuICAgICAgICAgICAgcHJlY2VkZW5jZTogMTcsIGFzc29jaWF0aXZpdHk6ICdydGwnLFxyXG4gICAgICAgICAgICBmbjogZnVuY3Rpb24gKGNvbnRleHQsIGFsaWFzZXMsIGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfbG9nID0gcGxhdC5hY3F1aXJlKF9fTG9nKTtcclxuICAgICAgICAgICAgICAgIF9sb2cuZXJyb3IobmV3IEVycm9yKCdBc3NpZ25tZW50IG9wZXJhdG9ycyBhcmUgbm90IHN1cHBvcnRlZCcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJyU9Jzoge1xyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiAxNywgYXNzb2NpYXRpdml0eTogJ3J0bCcsXHJcbiAgICAgICAgICAgIGZuOiBmdW5jdGlvbiAoY29udGV4dCwgYWxpYXNlcywgYSwgYikge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9sb2cgPSBwbGF0LmFjcXVpcmUoX19Mb2cpO1xyXG4gICAgICAgICAgICAgICAgX2xvZy5lcnJvcihuZXcgRXJyb3IoJ0Fzc2lnbm1lbnQgb3BlcmF0b3JzIGFyZSBub3Qgc3VwcG9ydGVkJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQW4gb2JqZWN0IHVzZWQgdG8gY3JlYXRlIElUb2tlbkRldGFpbHMgZm9yIGV2ZXJ5IGFjY2Vzc29yLlxyXG4gICAgICovXHJcbiAgICB2YXIgQUNDRVNTT1JTID0ge1xyXG4gICAgICAgICcoKSc6IHsgcHJlY2VkZW5jZTogMiwgYXNzb2NpYXRpdml0eTogbnVsbCwgZm46IG51bGwgfSxcclxuICAgICAgICAnW10nOiB7IHByZWNlZGVuY2U6IDIsIGFzc29jaWF0aXZpdHk6IG51bGwsIGZuOiBudWxsIH0sXHJcbiAgICAgICAgJy4nOiB7IHByZWNlZGVuY2U6IDIsIGFzc29jaWF0aXZpdHk6IG51bGwsIGZuOiBudWxsIH0sXHJcbiAgICAgICAgJ3t9JzogeyBwcmVjZWRlbmNlOiAxLCBhc3NvY2lhdGl2aXR5OiBudWxsLCBmbjogbnVsbCB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBvYmplY3QgdXNlZCB0byBjcmVhdGUgSVRva2VuRGV0YWlscyBmb3IgZXZlcnkgZGVsaW1pdGVyLlxyXG4gICAgICovXHJcbiAgICB2YXIgREVMSU1JVEVSUyA9IHtcclxuICAgICAgICAneyc6IHsgcHJlY2VkZW5jZTogMSwgYXNzb2NpYXRpdml0eTogbnVsbCwgZm46IG51bGwgfSxcclxuICAgICAgICAnfSc6IHsgcHJlY2VkZW5jZTogMSwgYXNzb2NpYXRpdml0eTogbnVsbCwgZm46IG51bGwgfSxcclxuICAgICAgICAnWyc6IHsgcHJlY2VkZW5jZTogMiwgYXNzb2NpYXRpdml0eTogbnVsbCwgZm46IG51bGwgfSxcclxuICAgICAgICAnXSc6IHsgcHJlY2VkZW5jZTogMiwgYXNzb2NpYXRpdml0eTogbnVsbCwgZm46IG51bGwgfSxcclxuICAgICAgICAnKCc6IHsgcHJlY2VkZW5jZTogMiwgYXNzb2NpYXRpdml0eTogbnVsbCwgZm46IG51bGwgfSxcclxuICAgICAgICAnKSc6IHsgcHJlY2VkZW5jZTogMiwgYXNzb2NpYXRpdml0eTogbnVsbCwgZm46IG51bGwgfSxcclxuICAgICAgICAnLic6IHsgcHJlY2VkZW5jZTogMiwgYXNzb2NpYXRpdml0eTogbnVsbCwgZm46IG51bGwgfSxcclxuICAgICAgICAnLCc6IHsgcHJlY2VkZW5jZTogMTgsIGFzc29jaWF0aXZpdHk6IG51bGwsIGZuOiBudWxsIH0sXHJcbiAgICAgICAgJ1xcJyc6IHsgcHJlY2VkZW5jZTogMCwgYXNzb2NpYXRpdml0eTogbnVsbCwgZm46IG51bGwgfSxcclxuICAgICAgICAnXCInOiB7IHByZWNlZGVuY2U6IDAsIGFzc29jaWF0aXZpdHk6IG51bGwsIGZuOiBudWxsIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFuIG9iamVjdCB1c2VkIHRvIGdldCBsaXRlcmFsIHZhbHVlcyBmcm9tIHN0cmluZyB2YWx1ZXMgb2YgZmFsc2UsIHRydWUsIGFuZCB1bmRlZmluZWRcclxuICAgICAqL1xyXG4gICAgdmFyIEtFWVdPUkRTID0ge1xyXG4gICAgICAgIGZhbHNlOiBmYWxzZSxcclxuICAgICAgICB0cnVlOiB0cnVlLFxyXG4gICAgICAgIG51bGw6IG51bGwsXHJcbiAgICAgICAgdW5kZWZpbmVkOiAndW5kZWZpbmVkJ1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGEgc3RyaW5nIGlzIGluIHRoZSBERUxJTUlURVJTIGFycmF5LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgc3RyaW5nIHRvIGluZGV4IGludG8gdGhlIERFTElNSVRFUlMgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzRGVsaW1pdGVyKGtleSkge1xyXG4gICAgICAgIHJldHVybiAhaXNOdWxsKERFTElNSVRFUlNba2V5XSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBhIHN0cmluZyBpcyBpbiB0aGUgQUNDRVNTT1JTIGFycmF5LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgc3RyaW5nIHRvIGluZGV4IGludG8gdGhlIEFDQ0VTU09SUyBhcnJheS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNBY2Nlc3NvcihrZXkpIHtcclxuICAgICAgICByZXR1cm4gIWlzTnVsbChBQ0NFU1NPUlNba2V5XSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBhIHN0cmluZyBpcyBpbiB0aGUgT1BFUkFUT1JTIGFycmF5LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgc3RyaW5nIHRvIGluZGV4IGludG8gdGhlIE9QRVJBVE9SUyBhcnJheS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNPcGVyYXRvcihrZXkpIHtcclxuICAgICAgICByZXR1cm4gIWlzTnVsbChPUEVSQVRPUlNba2V5XSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBhIHN0cmluZyBpcyBpbiB0aGUgS0VZV09SRFMgYXJyYXkuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBzdHJpbmcgdG8gaW5kZXggaW50byB0aGUgS0VZV09SRFMgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzS2V5d29yZChrZXkpIHtcclxuICAgICAgICByZXR1cm4gIWlzVW5kZWZpbmVkKEtFWVdPUkRTW2tleV0pO1xyXG4gICAgfVxyXG4gICAgLyogdHNsaW50OmVuYWJsZTpuby11bnVzZWQtdmFyaWFibGUgKi9cclxuICAgIC8qKlxyXG4gICAgICogSG9sZHMgYWxsIGNsYXNzZXMgYW5kIGludGVyZmFjZXMgcmVsYXRlZCB0byBvYnNlcnZhYmxlIGNvbXBvbmVudHMgaW4gcGxhdHlwdXMuXHJcbiAgICAgKi9cclxuICAgIHZhciBvYnNlcnZhYmxlO1xyXG4gICAgKGZ1bmN0aW9uIChvYnNlcnZhYmxlKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGFycmF5IG1ldGhvZHMgdG8gYmUgb3ZlcndyaXR0ZW4gaWYgaXQgaXMgdG8gYmUgb2JzZXJ2ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGFycmF5TWV0aG9kcyA9IFsncHVzaCcsICdwb3AnLCAncmV2ZXJzZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBjbGFzcyBmb3IgbWFuYWdpbmcgYm90aCBjb250ZXh0IGluaGVyaXRhbmNlIGFuZCBvYnNlcnZhYmxlIHByb3BlcnRpZXMgb24gY29udHJvbHMgYW5kXHJcbiAgICAgICAgICogZmFjaWxpdGF0aW5nIGluIGRhdGEtYmluZGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgQ29udGV4dE1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBDb250ZXh0TWFuYWdlcigpIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSBDb21wYXQgaW5qZWN0YWJsZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29tcGF0ID0gYWNxdWlyZShfX0NvbXBhdCk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFuIG9iamVjdCBmb3IgcXVpY2tseSBhY2Nlc3NpbmcgY2FsbGJhY2tzIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIGlkZW50aWZpZXIuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX19pZGVudGlmaWVycyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBbiBvYmplY3QgZm9yIHF1aWNrbHkgYWNjZXNzaW5nIGNoaWxkIGNvbnRleHQgYXNzb2NpYXRpb25zIChoZWxwcyB3aXRoXHJcbiAgICAgICAgICAgICAgICAgKiBub3RpZnlpbmcgY2hpbGQgcHJvcGVydGllcykuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX19pZGVudGlmaWVySGFzaCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBbiBvYmplY3QgZm9yIHN0b3JpbmcgbGlzdGVuZXJzIGZvciBBcnJheSBsZW5ndGggY2hhbmdlcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2xlbmd0aExpc3RlbmVycyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBbiBvYmplY3QgZm9yIHF1aWNrbHkgYWNjZXNzaW5nIHByZXZpb3VzbHkgYWNjZXNzZWQgb3Igb2JzZXJ2ZWQgb2JqZWN0cyBhbmQgcHJvcGVydGllcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2NvbnRleHRPYmplY3RzID0ge307XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBwcm9wZXJ0eSBjdXJyZW50bHkgYmVpbmcgbW9kaWZpZWQgaXMgZHVlIHRvIGFuIG9ic2VydmVkIGFycmF5IGZ1bmN0aW9uLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9faXNBcnJheUZ1bmN0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIENvbnRleHRNYW5hZ2VyIGFzc29jaWF0ZWQgdG8gdGhlIGdpdmVuIGNvbnRyb2wuIElmIG5vXHJcbiAgICAgICAgICAgICAqIENvbnRleHRNYW5hZ2VyIGV4aXN0cywgb25lIGlzIGNyZWF0ZWQgZm9yIHRoYXQgY29udHJvbC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LkNvbnRyb2x9IGNvbnRyb2wgVGhlIGNvbnRyb2wgb24gd2hpY2ggdG8gbG9jYXRlIHRoZSBDb250ZXh0TWFuYWdlci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLmdldE1hbmFnZXIgPSBmdW5jdGlvbiAoY29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHRNYW5hZ2VyLCBtYW5hZ2VycyA9IENvbnRleHRNYW5hZ2VyLl9fbWFuYWdlcnMsIHVpZCA9IGNvbnRyb2wudWlkLCBtYW5hZ2VyID0gbWFuYWdlcnNbdWlkXTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKG1hbmFnZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dE1hbmFnZXIgPSBtYW5hZ2VyO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0TWFuYWdlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRleHRNYW5hZ2VyID0gbWFuYWdlcnNbdWlkXSA9IG5ldyBDb250ZXh0TWFuYWdlcigpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dE1hbmFnZXIuY29udGV4dCA9IGNvbnRyb2w7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dE1hbmFnZXI7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLmRpc3Bvc2UgPSBmdW5jdGlvbiAoY29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChjb250cm9sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB1aWQgPSBjb250cm9sLnVpZCwgY29udHJvbHMgPSBDb250ZXh0TWFuYWdlci5fX2NvbnRyb2xzLCBpZGVudGlmaWVycyA9IGNvbnRyb2xzW3VpZF0gfHwge30sIG1hbmFnZXJzID0gQ29udGV4dE1hbmFnZXIuX19tYW5hZ2VycywgbWFuYWdlciA9IG1hbmFnZXJzW3VpZF07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChtYW5hZ2VyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hbmFnZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KG1hbmFnZXJzLCB1aWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhpZGVudGlmaWVycyksIGxpc3RlbmVycztcclxuICAgICAgICAgICAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSBpZGVudGlmaWVyc1trZXlzLnNoaWZ0KCldO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc2hpZnQoKSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KGNvbnRyb2xzLCB1aWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGwoY29udHJvbC5jb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLnVuT2JzZXJ2ZShjb250cm9sLmNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLmRlZmluZVByb3BlcnR5KGNvbnRyb2wsIF9fQ09OVEVYVCwgY29udHJvbC5jb250ZXh0LCB0cnVlLCB0cnVlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycyBmb3IgYW4gQXJyYXkgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gdWlkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWJzb2x1dGVJZGVudGlmaWVyIFRoZSBpZGVudGlmaWVyIHVzZWQgdG8gbG9jYXRlIHRoZSBhcnJheS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVpZCBUaGUgdWlkIHVzZWQgdG8gc2VhcmNoIGZvciBsaXN0ZW5lcnMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDb250ZXh0TWFuYWdlci5yZW1vdmVBcnJheUxpc3RlbmVycyA9IGZ1bmN0aW9uIChhYnNvbHV0ZUlkZW50aWZpZXIsIHVpZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IENvbnRleHRNYW5hZ2VyLmFycmF5Q2hhbmdlTGlzdGVuZXJzW2Fic29sdXRlSWRlbnRpZmllcl07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChsaXN0ZW5lcnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkobGlzdGVuZXJzLCB1aWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2FmZWx5IHJldHJpZXZlcyB0aGUgbG9jYWwgY29udGV4dCBnaXZlbiBhIHJvb3QgY29udGV4dCBhbmQgYW4gQXJyYXkgb2ZcclxuICAgICAgICAgICAgICogcHJvcGVydHkgc3RyaW5ncy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IHJvb3RDb250ZXh0IFRoZSByb290IG9iamVjdCBpbiB3aGljaCB0byBmaW5kIGEgbG9jYWwgY29udGV4dC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBzcGxpdCBUaGUgc3RyaW5nIGFycmF5IGNvbnRhaW5pbmcgcHJvcGVydGllcyB1c2VkIHRvIGluZGV4IGludG9cclxuICAgICAgICAgICAgICogdGhlIHJvb3RDb250ZXh0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uIChyb290Q29udGV4dCwgc3BsaXQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwocm9vdENvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvb3RDb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3BsaXQgPSBzcGxpdC5zbGljZSgwKTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChzcGxpdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdENvbnRleHQgPSByb290Q29udGV4dFtzcGxpdC5zaGlmdCgpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHJvb3RDb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm9vdENvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvb3RDb250ZXh0O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGVmaW5lcyBhbiBvYmplY3QgcHJvcGVydHkgd2l0aCB0aGUgYXNzb2NpYXRlZCB2YWx1ZS4gVXNlZnVsIGZvciB1bm9ic2VydmluZyBvYmplY3RzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2JqIFRoZSBvYmplY3Qgb24gd2hpY2ggdG8gZGVmaW5lIHRoZSBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcHJvcGVydHkga2V5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIHZhbHVlIHVzZWQgdG8gZGVmaW5lIHRoZSBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBlbnVtZXJhYmxlPyBXaGV0aGVyIG9yIG5vdCB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIGVudW1lcmFibGUgKGFibGUgdG8gYmUgaXRlcmF0ZWRcclxuICAgICAgICAgICAgICogb3ZlciBpbiBhIGxvb3ApXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29uZmlndXJhYmxlPyBXaGV0aGVyIG9yIG5vdCB0aGUgcHJvcGVydHkgaXMgYWJsZSB0byBiZSByZWNvbmZpZ3VyZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gd3JpdGFibGU/IFdoZXRoZXIgb3Igbm90IGFzc2lnbm1lbnQgb3BlcmF0b3JzIHdvcmsgb24gdGhlIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIuZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlLCBlbnVtZXJhYmxlLCBjb25maWd1cmFibGUsIHdyaXRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlLCBlbnVtZXJhYmxlLCBjb25maWd1cmFibGUsIHdyaXRhYmxlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERlZmluZXMgYW4gb2JqZWN0IHByb3BlcnR5IHdpdGggdGhlIGFzc29jaWF0ZWQgdmFsdWUuIFVzZWZ1bCBmb3IgdW5vYnNlcnZpbmcgb2JqZWN0cy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IG9iaiBUaGUgb2JqZWN0IG9uIHdoaWNoIHRvIGRlZmluZSB0aGUgcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHByb3BlcnR5IGtleS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSB2YWx1ZSB1c2VkIHRvIGRlZmluZSB0aGUgcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW51bWVyYWJsZT8gV2hldGhlciBvciBub3QgdGhlIHByb3BlcnR5IHNob3VsZCBiZSBlbnVtZXJhYmxlIChhYmxlIHRvIGJlIGl0ZXJhdGVkXHJcbiAgICAgICAgICAgICAqIG92ZXIgaW4gYSBsb29wKVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbmZpZ3VyYWJsZT8gV2hldGhlciBvciBub3QgdGhlIHByb3BlcnR5IGlzIGFibGUgdG8gYmUgcmVjb25maWd1cmVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIuZGVmaW5lR2V0dGVyID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSwgZW51bWVyYWJsZSwgY29uZmlndXJhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBfZGVmaW5lR2V0dGVyKG9iaiwga2V5LCB2YWx1ZSwgZW51bWVyYWJsZSwgY29uZmlndXJhYmxlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFB1c2hlcyB0aGUgZnVuY3Rpb24gZm9yIHJlbW92aW5nIGFuIG9ic2VydmVkIHByb3BlcnR5IHVwb24gYWRkaW5nIHRoZSBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aWZlciBUaGUgaWRlbnRpZmllciBmb3Igd2hpY2ggdGhlIHJlbW92ZSBsaXN0ZW5lciBpcyBiZWluZyBwdXNoZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1aWQgVGhlIHVuaXF1ZSBJRCBvZiB0aGUgY29udHJvbCBvYnNlcnZpbmcgdGhlIGlkZW50aWZpZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5JUmVtb3ZlTGlzdGVuZXJ9IGxpc3RlbmVyIFRoZSBmdW5jdGlvbiBmb3IgcmVtb3ZpbmcgdGhlIG9ic2VydmVkIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIucHVzaFJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGlkZW50aWZpZXIsIHVpZCwgbGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb250cm9scyA9IENvbnRleHRNYW5hZ2VyLl9fY29udHJvbHMsIGNvbnRyb2wgPSBjb250cm9sc1t1aWRdLCBsaXN0ZW5lcnM7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGNvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbCA9IGNvbnRyb2xzW3VpZF0gPSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IGNvbnRyb2xbaWRlbnRpZmllcl07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGxpc3RlbmVycykpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSBjb250cm9sW2lkZW50aWZpZXJdID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTcGxpY2VzIGEgZ2l2ZW4gZnVuY3Rpb24gZm9yIHJlbW92aW5nIGFuIG9ic2VydmVkIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmVyIFRoZSBpZGVudGlmaWVyIGZvciB3aGljaCB0aGUgcmVtb3ZlIGxpc3RlbmVyIGlzIGJlaW5nIHNwbGljZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1aWQgVGhlIHVuaXF1ZSBJRCBvZiB0aGUgY29udHJvbCBvYnNlcnZpbmcgdGhlIGlkZW50aWZpZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5JUmVtb3ZlTGlzdGVuZXJ9IGxpc3RlbmVyIFRoZSBmdW5jdGlvbiBmb3IgcmVtb3ZpbmcgdGhlIG9ic2VydmVkIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIuc3BsaWNlUmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoaWRlbnRpZmllciwgdWlkLCBsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xzID0gQ29udGV4dE1hbmFnZXIuX19jb250cm9scywgY29udHJvbCA9IGNvbnRyb2xzW3VpZF0sIGxpc3RlbmVycztcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoY29udHJvbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSBjb250cm9sW2lkZW50aWZpZXJdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChsaXN0ZW5lcnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eShjb250cm9sLCBpZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlbW92ZXMgYSBzcGVjaWZpZWQgaWRlbnRpZmllciBmcm9tIGJlaW5nIG9ic2VydmVkIGZvciBhIGdpdmVuIHNldCBvZiBjb250cm9sIElEcy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB1aWRzIFRoZSBzZXQgb2YgdW5pcXVlIElkcyBmb3Igd2hpY2ggdG8gcmVtb3ZlIHRoZSBzcGVjaWZpZWQgaWRlbnRpZmllci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aWZpZXIgVGhlIGlkZW50aWZpZXIgdG8gc3RvcCBvYnNlcnZpbmcuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDb250ZXh0TWFuYWdlci5yZW1vdmVJZGVudGlmaWVyID0gZnVuY3Rpb24gKHVpZHMsIGlkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSB1aWRzLmxlbmd0aCwgY29udHJvbHMgPSBDb250ZXh0TWFuYWdlci5fX2NvbnRyb2xzLCBpZGVudGlmaWVycztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVycyA9IGNvbnRyb2xzW3VpZHNbaV1dO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwoaWRlbnRpZmllcnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eShpZGVudGlmaWVycywgaWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFbnN1cmVzIHRoYXQgYW4gaWRlbnRpZmllciBwYXRoIHdpbGwgZXhpc3Qgb24gYSBnaXZlbiBjb250cm9sLiBXaWxsIGNyZWF0ZVxyXG4gICAgICAgICAgICAgKiBvYmplY3RzL2FycmF5cyBpZiBuZWNlc3NhcnkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5UZW1wbGF0ZUNvbnRyb2x9IGNvbnRyb2wgVGhlIFRlbXBsYXRlQ29udHJvbFxyXG4gICAgICAgICAgICAgKiBvbiB3aGljaCB0byBjcmVhdGUgdGhlIGNvbnRleHQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGlmaWVyIFRoZSBwZXJpb2QtZGVsaW1pdGVkIGlkZW50aWZpZXIgc3RyaW5nIHVzZWQgdG8gY3JlYXRlXHJcbiAgICAgICAgICAgICAqIHRoZSBjb250ZXh0IHBhdGguXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDb250ZXh0TWFuYWdlci5jcmVhdGVDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRyb2wsIGlkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY29udHJvbC5jb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc09iamVjdChjb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwoY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRyb2wuY29udGV4dCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIuX2xvZy53YXJuKCdBIGNoaWxkIGNvbnRyb2wgaXMgdHJ5aW5nIHRvIGNyZWF0ZSBhIGNoaWxkIGNvbnRleHQgdGhhdCBoYXMgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYSBwYXJlbnQgY29udHJvbCB3aXRoIGEgcHJpbWl0aXZlIHR5cGUgY29udGV4dCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHNwbGl0ID0gaWRlbnRpZmllci5zcGxpdCgnLicpLCBwcm9wZXJ0eSwgdGVtcDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChzcGxpdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgPSBzcGxpdC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXAgPSBjb250ZXh0W3Byb3BlcnR5XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHRlbXApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc051bWJlcihOdW1iZXIoc3BsaXRbMF0pKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcCA9IGNvbnRleHRbcHJvcGVydHldID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gY29udGV4dFtwcm9wZXJ0eV0gPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gdGVtcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSXRlcmF0ZXMgdGhyb3VnaCBhbGwgdGhlIG5lc3RlZCBwcm9wZXJ0aWVzIGluIGFuIG9iamVjdCBhbmQgcmVkZWZpbmVzIHRoZSBwcm9wZXJ0aWVzIHRvIG5vdCB1c2UgZ2V0dGVycy9zZXR0ZXJzXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBvYmogVGhlIG9iamVjdCB0byBzdG9wIG9ic2VydmluZy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLnVuT2JzZXJ2ZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgICAgIF9leHRlbmQodHJ1ZSwgdHJ1ZSwgb2JqKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNhZmVseSByZXRyaWV2ZXMgdGhlIGxvY2FsIGNvbnRleHQgZm9yIHRoaXMgbWFuYWdlciBnaXZlbiBhbiBBcnJheSBvZlxyXG4gICAgICAgICAgICAgKiBwcm9wZXJ0eSBzdHJpbmdzIGFuZCBvYnNlcnZlcyBpdCBpZiBub3QgZm91bmQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gc3BsaXQgVGhlIHN0cmluZyBhcnJheSBjb250YWluaW5nIHByb3BlcnRpZXMgdXNlZCB0byBpbmRleCBpbnRvXHJcbiAgICAgICAgICAgICAqIHRoZSBjb250ZXh0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9ic2VydmU/IFdoZXRoZXIgb3Igbm90IHRvIG9ic2VydmUgdGhlIGlkZW50aWZpZXIgaW5kaWNhdGVkIGJ5IHRoZVxyXG4gICAgICAgICAgICAgKiBzcGxpdCBBcnJheS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLnByb3RvdHlwZS5nZXRDb250ZXh0ID0gZnVuY3Rpb24gKHNwbGl0LCBvYnNlcnZlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q29udGV4dChzcGxpdC5qb2luKCcuJyksIHNwbGl0LCBvYnNlcnZlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdpdmVuIGEgcGVyaW9kLWRlbGltaXRlZCBpZGVudGlmaWVyLCBvYnNlcnZlcyBhbiBvYmplY3QgYW5kIGNhbGxzIHRoZSBnaXZlbiBsaXN0ZW5lciB3aGVuIHRoZVxyXG4gICAgICAgICAgICAgKiBvYmplY3QgY2hhbmdlcy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFic29sdXRlSWRlbnRpZmllciBUaGUgcGVyaW9kLWRlbGltaXRlZCBpZGVudGlmaWVyIG5vdGluZyB0aGUgcHJvcGVydHkgdG8gYmUgb2JzZXJ2ZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5vYnNlcnZhYmxlLklMaXN0ZW5lcn0gb2JzZXJ2YWJsZUxpc3RlbmVyIEFuIG9iamVjdCBpbXBsbWVudGluZyBJT2JzZXJ2YWJsZUxpc3RlbmVyLiBUaGUgbGlzdGVuZXIgd2lsbCBiZVxyXG4gICAgICAgICAgICAgKiBub3RpZmllZCBvZiBvYmplY3QgY2hhbmdlcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24gKGFic29sdXRlSWRlbnRpZmllciwgb2JzZXJ2YWJsZUxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkoYWJzb2x1dGVJZGVudGlmaWVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub29wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHNwbGl0ID0gYWJzb2x1dGVJZGVudGlmaWVyLnNwbGl0KCcuJyksIGtleSA9IHNwbGl0LnBvcCgpLCBpc0xlbmd0aCA9IGtleSA9PT0gJ2xlbmd0aCcsIGhhc0lkZW50aWZpZXIgPSB0aGlzLl9oYXNJZGVudGlmaWVyKGFic29sdXRlSWRlbnRpZmllciksIGhhc09ic2VydmFibGVMaXN0ZW5lciA9ICFpc051bGwob2JzZXJ2YWJsZUxpc3RlbmVyKSwgam9pbiwgY29udGV4dDtcclxuICAgICAgICAgICAgICAgIGlmIChzcGxpdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgam9pbiA9IHNwbGl0LmpvaW4oJy4nKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gdGhpcy5fZ2V0Q29udGV4dChqb2luLCBzcGxpdCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBqb2luID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzT2JqZWN0KGNvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc09ic2VydmFibGVMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19sZW5ndGhMaXN0ZW5lcnNbYWJzb2x1dGVJZGVudGlmaWVyXSA9IG9ic2VydmFibGVMaXN0ZW5lcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLnB1c2hSZW1vdmVMaXN0ZW5lcihhYnNvbHV0ZUlkZW50aWZpZXIsIG9ic2VydmFibGVMaXN0ZW5lci51aWQsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eShfdGhpcy5fX2xlbmd0aExpc3RlbmVycywgYWJzb2x1dGVJZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRPYnNlcnZhYmxlTGlzdGVuZXIoYWJzb2x1dGVJZGVudGlmaWVyLCBvYnNlcnZhYmxlTGlzdGVuZXIsIGlzTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vb3A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBzZXQgb2JzZXJ2ZWRJZGVudGlmaWVyIHRvIG51bGwgXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fb2JzZXJ2ZWRJZGVudGlmaWVyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19jb250ZXh0T2JqZWN0c1thYnNvbHV0ZUlkZW50aWZpZXJdID0gY29udGV4dFtrZXldO1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgb2JzZXJ2ZWRJZGVudGlmaWVyIGlzIG5vdCBudWxsLCB0aGUgcHJpbWl0aXZlIGlzIGFscmVhZHkgYmVpbmcgd2F0Y2hlZCBcclxuICAgICAgICAgICAgICAgIHZhciBvYnNlcnZlZElkZW50aWZpZXIgPSB0aGlzLl9fb2JzZXJ2ZWRJZGVudGlmaWVyLCBpc09ic2VydmVkID0gIWlzTnVsbChvYnNlcnZlZElkZW50aWZpZXIpLCByZW1vdmVDYWxsYmFjayA9IG5vb3A7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNPYnNlcnZlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc0lkZW50aWZpZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGhhc09ic2VydmFibGVMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZW1vdmVPYnNlcnZlZENhbGxiYWNrXzEgPSBub29wLCByZW1vdmVBYnNvbHV0ZUNhbGxiYWNrXzEgPSB0aGlzLl9hZGRPYnNlcnZhYmxlTGlzdGVuZXIoYWJzb2x1dGVJZGVudGlmaWVyLCBvYnNlcnZhYmxlTGlzdGVuZXIsIGlzTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNPYnNlcnZlZCAmJiBhYnNvbHV0ZUlkZW50aWZpZXIgIT09IG9ic2VydmVkSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVPYnNlcnZlZENhbGxiYWNrXzEgPSB0aGlzLl9hZGRPYnNlcnZhYmxlTGlzdGVuZXIob2JzZXJ2ZWRJZGVudGlmaWVyLCBvYnNlcnZhYmxlTGlzdGVuZXIsIGlzTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUFic29sdXRlQ2FsbGJhY2tfMSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVPYnNlcnZlZENhbGxiYWNrXzEoKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudElzQXJyYXkgPSBpc0FycmF5KGNvbnRleHQpLCByZW1vdmVPYnNlcnZhYmxlTGlzdGVuZXIgPSByZW1vdmVDYWxsYmFjaywgcmVtb3ZlTGlzdGVuZXIgPSBub29wLCByZW1vdmVBcnJheU9ic2VydmUgPSBub29wLCBudW1LZXkgPSBOdW1iZXIoa2V5KTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRJc0FycmF5ICYmIG51bUtleSA+PSBjb250ZXh0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyID0gdGhpcy5vYnNlcnZlKGpvaW4gKyAnLmxlbmd0aCcsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdWlkOiBvYnNlcnZhYmxlTGlzdGVuZXIudWlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcjogZnVuY3Rpb24gKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bUtleSA+PSBuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZGVmaW5lKGFic29sdXRlSWRlbnRpZmllciwgY29udGV4dCwga2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVPYnNlcnZhYmxlTGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWhhc0lkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB2YWx1ZSBpcyBkZWZpbmVkIGFuZCBjb250ZXh0IG1hbmFnZXIgaGFzbid0IHNlZW4gdGhpcyBpZGVudGlmaWVyIFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRJc0FycmF5ICYmIGlzTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHNwbGl0LnBvcCgpLCBwYXJlbnRDb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KHNwbGl0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19vYnNlcnZlZElkZW50aWZpZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3MocGFyZW50Q29udGV4dCwgcHJvcGVydHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcodGhpcy5fX29ic2VydmVkSWRlbnRpZmllcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpvaW4gPSB0aGlzLl9fb2JzZXJ2ZWRJZGVudGlmaWVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNPYnNlcnZhYmxlTGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1aWRfMSA9IG9ic2VydmFibGVMaXN0ZW5lci51aWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lciA9IHRoaXMub2JzZXJ2ZUFycmF5TXV0YXRpb24odWlkXzEsIG5vb3AsIGpvaW4sIGNvbnRleHQsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQXJyYXlPYnNlcnZlID0gdGhpcy5vYnNlcnZlKGpvaW4sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aWQ6IHVpZF8xLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyOiBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyID0gX3RoaXMub2JzZXJ2ZUFycmF5TXV0YXRpb24odWlkXzEsIG5vb3AsIGpvaW4sIG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVPYnNlcnZhYmxlTGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUFycmF5T2JzZXJ2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlZmluZShhYnNvbHV0ZUlkZW50aWZpZXIsIGNvbnRleHQsIGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUNhbGxiYWNrO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogT2JzZXJ2ZXMgYW4gYXJyYXkgYW5kIGNhbGxzIHRoZSBsaXN0ZW5lciB3aGVuIGNlcnRhaW4gZnVuY3Rpb25zIGFyZSBjYWxsZWQgb25cclxuICAgICAgICAgICAgICogdGhhdCBhcnJheS4gVGhlIHdhdGNoZWQgZnVuY3Rpb25zIGFyZSBwdXNoLCBwb3AsIHNoaWZ0LCBzcGxpY2UsIHVuc2hpZnQsIHNvcnQsXHJcbiAgICAgICAgICAgICAqIGFuZCByZXZlcnNlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdWlkIFRoZSB1bmlxdWUgSUQgb2YgdGhlIG9iamVjdCBvYnNlcnZpbmcgdGhlIGFycmF5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geyhjaGFuZ2VzOiBBcnJheTxwbGF0Lm9ic2VydmFibGUuSUFycmF5Q2hhbmdlczxhbnk+PikgPT4gdm9pZH0gbGlzdGVuZXIgVGhlIGNhbGxiYWNrIGZvciBhZnRlclxyXG4gICAgICAgICAgICAgKiB3aGVuIGFuIG9ic2VydmVkIEFycmF5IGZ1bmN0aW9uIGhhcyBiZWVuIGNhbGxlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFic29sdXRlSWRlbnRpZmllciBUaGUgaWRlbnRpZmllciBmcm9tIHRoZSByb290IGNvbnRleHQgdXNlZCB0byBmaW5kIHRoZSBhcnJheS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcnJheSBUaGUgYXJyYXkgdG8gYmUgb2JzZXJ2ZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gb2xkQXJyYXkgVGhlIG9sZCBhcnJheSB0byBzdG9wIG9ic2VydmluZy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXlNdXRhdGlvbiA9IGZ1bmN0aW9uICh1aWQsIGxpc3RlbmVyLCBhYnNvbHV0ZUlkZW50aWZpZXIsIGFycmF5LCBvbGRBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkob2xkQXJyYXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzdG9yZUFycmF5KG9sZEFycmF5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoYXJyYXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vb3A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgc3BsaXQgPSBhYnNvbHV0ZUlkZW50aWZpZXIuc3BsaXQoJy4nKSwgcHJvcGVydHkgPSBzcGxpdC5wb3AoKSwgY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dChzcGxpdCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX29ic2VydmVkSWRlbnRpZmllciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3MoY29udGV4dCwgcHJvcGVydHkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKHRoaXMuX19vYnNlcnZlZElkZW50aWZpZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVJZGVudGlmaWVyID0gdGhpcy5fX29ic2VydmVkSWRlbnRpZmllcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciByZW1vdmVMaXN0ZW5lcnMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVycy5wdXNoKHRoaXMuX3B1c2hBcnJheUxpc3RlbmVyKHVpZCwgYWJzb2x1dGVJZGVudGlmaWVyLCBsaXN0ZW5lcikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fb3ZlcndyaXRlQXJyYXkoYWJzb2x1dGVJZGVudGlmaWVyLCBhcnJheSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZW1vdmVMaXN0ZW5lcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcnMucG9wKCkoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGlzcG9zZXMgdGhlIG1lbW9yeSBmb3IgYW4gQ29udGV4dE1hbmFnZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDb250ZXh0TWFuYWdlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9faWRlbnRpZmllcnMgPSB7fTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19pZGVudGlmaWVySGFzaCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2NvbnRleHRPYmplY3RzID0ge307XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQdXNoZXMgQXJyYXkgbXV0YXRpb24gbGlzdGVuZXJzIGFuZCByZW1vdmVycy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVpZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgdG8gc3RvcmUgdGhlIGNhbGxiYWNrLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWJzb2x1dGVJZGVudGlmaWVyIFRoZSBpZGVudGlmaWVyIG9mIHRoZSBBcnJheSBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHsoY2hhbmdlczogQXJyYXk8cGxhdC5vYnNlcnZhYmxlLklBcnJheUNoYW5nZXM8YW55Pj4pID0+IHZvaWR9IGxpc3RlbmVyIFRoZSBBcnJheSBtdXRhdGlvbiBsaXN0ZW5lci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLnByb3RvdHlwZS5fcHVzaEFycmF5TGlzdGVuZXIgPSBmdW5jdGlvbiAodWlkLCBhYnNvbHV0ZUlkZW50aWZpZXIsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJyYXlMaXN0ZW5lcnMgPSBDb250ZXh0TWFuYWdlci5hcnJheUNoYW5nZUxpc3RlbmVycywgYXJyYXlDYWxsYmFja3MgPSBhcnJheUxpc3RlbmVyc1thYnNvbHV0ZUlkZW50aWZpZXJdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChhcnJheUNhbGxiYWNrcykpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcnJheUNhbGxiYWNrcyA9IGFycmF5TGlzdGVuZXJzW2Fic29sdXRlSWRlbnRpZmllcl0gPSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBjYWxsYmFja3MgPSBhcnJheUNhbGxiYWNrc1t1aWRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChjYWxsYmFja3MpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzID0gYXJyYXlDYWxsYmFja3NbdWlkXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyUmVtb3ZlZCA9IGZhbHNlLCByZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJSZW1vdmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJSZW1vdmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBDb250ZXh0TWFuYWdlci5zcGxpY2VSZW1vdmVMaXN0ZW5lcihhYnNvbHV0ZUlkZW50aWZpZXIsIHVpZCwgcmVtb3ZlTGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGNhbGxiYWNrcy5pbmRleE9mKGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkoYXJyYXlDYWxsYmFja3MsIHVpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KGFycmF5Q2FsbGJhY2tzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkoYXJyYXlMaXN0ZW5lcnMsIGFic29sdXRlSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2gobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIucHVzaFJlbW92ZUxpc3RlbmVyKGFic29sdXRlSWRlbnRpZmllciwgdWlkLCByZW1vdmVMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlTGlzdGVuZXI7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXN0b3JlcyBhbiBhcnJheSB0byB1c2UgQXJyYXkucHJvdG90eXBlIGluc3RlYWQgb2YgbGlzdGVuZXIgZnVuY3Rpb25zLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGFycmF5IFRoZSBhcnJheSB0byByZXN0b3JlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIucHJvdG90eXBlLl9yZXN0b3JlQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfY29tcGF0ID0gdGhpcy5fY29tcGF0O1xyXG4gICAgICAgICAgICAgICAgaWYgKF9jb21wYXQuc2V0UHJvdG8pIHtcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJyYXksIE9iamVjdC5jcmVhdGUoQXJyYXkucHJvdG90eXBlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfY29tcGF0LnByb3RvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXkuX19wcm90b19fID0gT2JqZWN0LmNyZWF0ZShBcnJheS5wcm90b3R5cGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aF81ID0gYXJyYXlNZXRob2RzLmxlbmd0aCwgbWV0aG9kID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoXzU7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSBhcnJheU1ldGhvZHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W21ldGhvZF0gPSBBcnJheS5wcm90b3R5cGVbbWV0aG9kXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBPdmVyd3JpdGVzIGFuIEFycmF5J3MgcHJvdG90eXBlIHRvIG9ic2VydmUgbXV0YXRpb24gZnVuY3Rpb25zLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWJzb2x1dGVJZGVudGlmaWVyIFRoZSBpZGVudGlmaWVyIGZvciB0aGUgQXJyYXkgb2ZmIGNvbnRleHQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJyYXkgVGhlIGFycmF5IHRvIG92ZXJ3cml0ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLnByb3RvdHlwZS5fb3ZlcndyaXRlQXJyYXkgPSBmdW5jdGlvbiAoYWJzb2x1dGVJZGVudGlmaWVyLCBhcnJheSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jb21wYXQgPSB0aGlzLl9jb21wYXQsIGxlbmd0aCA9IGFycmF5TWV0aG9kcy5sZW5ndGgsIG1ldGhvZCwgaTtcclxuICAgICAgICAgICAgICAgIGlmIChfY29tcGF0LnByb3RvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUoQXJyYXkucHJvdG90eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gYXJyYXlNZXRob2RzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpbbWV0aG9kXSA9IHRoaXMuX292ZXJ3cml0ZUFycmF5RnVuY3Rpb24oYWJzb2x1dGVJZGVudGlmaWVyLCBtZXRob2QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2NvbXBhdC5zZXRQcm90bykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJyYXksIG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheS5fX3Byb3RvX18gPSBvYmo7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9IGFycmF5TWV0aG9kc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBDb250ZXh0TWFuYWdlci5kZWZpbmVQcm9wZXJ0eShhcnJheSwgbWV0aG9kLCB0aGlzLl9vdmVyd3JpdGVBcnJheUZ1bmN0aW9uKGFic29sdXRlSWRlbnRpZmllciwgbWV0aG9kKSwgZmFsc2UsIHRydWUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgY29udGV4dCBvYmplY3Qgb2YgYW4gaWRlbnRpZmllci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aWZpZXIgVGhlIGlkZW50aWZpZXIgZm9yIHdoaWNoIHdlJ3JlIGdldHRpbmcgdGhlIGNvbnRleHQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gc3BsaXQgVGhlIHN0cmluZyBhcnJheSBjb250YWluaW5nIHByb3BlcnRpZXMgdXNlZCB0byBpbmRleCBpbnRvXHJcbiAgICAgICAgICAgICAqIHRoZSBjb250ZXh0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9ic2VydmU/IFdoZXRoZXIgb3Igbm90IHRvIG9ic2VydmUgdGhlIGlkZW50aWZpZXIgaW5kaWNhdGVkIGJ5IHRoZVxyXG4gICAgICAgICAgICAgKiBzcGxpdCBBcnJheS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLnByb3RvdHlwZS5fZ2V0Q29udGV4dCA9IGZ1bmN0aW9uIChpZGVudGlmaWVyLCBzcGxpdCwgb2JzZXJ2ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLl9fY29udGV4dE9iamVjdHNbaWRlbnRpZmllcl07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGNvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9ic2VydmUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IHRoaXMuX19jb250ZXh0T2JqZWN0c1tpZGVudGlmaWVyXSA9IHRoaXMuX29ic2VydmVJbW1lZGlhdGVDb250ZXh0KHNwbGl0LCBpZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzLl9nZXRJbW1lZGlhdGVDb250ZXh0KHNwbGl0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGltbWVkaWF0ZSBjb250ZXh0IG9mIGlkZW50aWZpZXIgYnkgc3BsaXR0aW5nIG9uIFwiLlwiLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHNwbGl0IFRoZSBzdHJpbmcgYXJyYXkgY29udGFpbmluZyBwcm9wZXJ0aWVzIHVzZWQgdG8gaW5kZXggaW50b1xyXG4gICAgICAgICAgICAgKiB0aGUgY29udGV4dC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLnByb3RvdHlwZS5fZ2V0SW1tZWRpYXRlQ29udGV4dCA9IGZ1bmN0aW9uIChzcGxpdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3BsaXQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0W3NwbGl0LnNoaWZ0KCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwoY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBpbW1lZGlhdGUgY29udGV4dCBvZiBpZGVudGlmaWVyIGJ5IHNwbGl0dGluZyBvbiBcIi5cIlxyXG4gICAgICAgICAgICAgKiBhbmQgb2JzZXJ2ZXMgdGhlIG9iamVjdHMgYWxvbmcgdGhlIHdheS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBzcGxpdCBUaGUgaWRlbnRpZmllcidzIHNwbGl0IHN0cmluZyBhcnJheSBjb250YWluaW5nIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgICogdXNlZCB0byBpbmRleCBpbnRvIHRoZSBjb250ZXh0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmllciBUaGUgaWRlbnRpZmllciBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLnByb3RvdHlwZS5fb2JzZXJ2ZUltbWVkaWF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoc3BsaXQsIGlkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwodGhpcy5fX2lkZW50aWZpZXJzW2lkZW50aWZpZXJdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2ZShpZGVudGlmaWVyLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRJbW1lZGlhdGVDb250ZXh0KHNwbGl0KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE9idGFpbnMgdGhlIG9sZCB2YWx1ZSBhbmQgbmV3IHZhbHVlIG9mIGEgZ2l2ZW4gY29udGV4dFxyXG4gICAgICAgICAgICAgKiBwcm9wZXJ0eSBvbiBhIHByb3BlcnR5IGNoYW5nZWQgZXZlbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gc3BsaXQgVGhlIHNwbGl0IGlkZW50aWZpZXIgb2YgdGhlIHByb3BlcnR5IHRoYXQgY2hhbmdlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IG5ld1Jvb3RDb250ZXh0IFRoZSBuZXcgY29udGV4dC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IG9sZFJvb3RDb250ZXh0IFRoZSBvbGQgY29udGV4dC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLnByb3RvdHlwZS5fZ2V0VmFsdWVzID0gZnVuY3Rpb24gKHNwbGl0LCBuZXdSb290Q29udGV4dCwgb2xkUm9vdENvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSwgZG9OZXcgPSBpc09iamVjdChuZXdSb290Q29udGV4dCksIGRvT2xkID0gaXNPYmplY3Qob2xkUm9vdENvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHNwbGl0Lmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHNwbGl0LnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvTmV3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Jvb3RDb250ZXh0ID0gbmV3Um9vdENvbnRleHRbcHJvcGVydHldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKG5ld1Jvb3RDb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9OZXcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9PbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkUm9vdENvbnRleHQgPSBvbGRSb290Q29udGV4dFtwcm9wZXJ0eV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwob2xkUm9vdENvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb09sZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGRvTmV3IHx8IGRvT2xkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHNwbGl0WzBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlLCBvbGRWYWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKG5ld1Jvb3RDb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gbmV3Um9vdENvbnRleHRbcHJvcGVydHldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGwob2xkUm9vdENvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWUgPSBvbGRSb290Q29udGV4dFtwcm9wZXJ0eV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZTogb2xkVmFsdWVcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBOb3RpZmllcyBhbGwgY2hpbGQgcHJvcGVydGllcyBiZWluZyBvYnNlcnZlZCB0aGF0IGEgcGFyZW50IHByb3BlcnR5XHJcbiAgICAgICAgICAgICAqIGhhcyBjaGFuZ2VkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmllciBUaGUgaWRlbnRpZmllciBmb3IgdGhlIHByb3BlcnR5IHRoYXQgY2hhbmdlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IG5ld1ZhbHVlIFRoZSBuZXcgdmFsdWUgb2YgdGhlIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gbWFwcGluZ3M/IEFuIGFycmF5IG9mIG1hcHBlZCBjaGlsZCBpZGVudGlmaWVyIGtleXMgdG8gbm90aWZ5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIucHJvdG90eXBlLl9ub3RpZnlDaGlsZFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoaWRlbnRpZmllciwgbmV3VmFsdWUsIG9sZFZhbHVlLCBtYXBwaW5ncykge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIG1hcHBpbmdzID0gbWFwcGluZ3MgfHwgT2JqZWN0LmtleXModGhpcy5fX2lkZW50aWZpZXJIYXNoW2lkZW50aWZpZXJdIHx8IHt9KTtcclxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBtYXBwaW5ncy5sZW5ndGgsIGJpbmRpbmcsIHByb3BlcnR5LCBwYXJlbnRQcm9wZXJ0eSwgc3BsaXQsIHZhbHVlcyA9IHt9LCB2YWx1ZSwgcGVyaW9kID0gJy4nLCBsZW5ndGhTdHIgPSAnbGVuZ3RoJywga2V5LCBrZXlJc0xlbmd0aCwgc3RhcnQgPSBpZGVudGlmaWVyLmxlbmd0aCArIDEsIG5ld1BhcmVudCwgb2xkUGFyZW50LCBuZXdDaGlsZCwgb2xkQ2hpbGQ7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZyA9IG1hcHBpbmdzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gYmluZGluZy5zbGljZShzdGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3BsaXQgPSBwcm9wZXJ0eS5zcGxpdChwZXJpb2QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHNwbGl0LnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGtleUlzTGVuZ3RoID0gKGtleSA9PT0gbGVuZ3RoU3RyKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRQcm9wZXJ0eSA9IHNwbGl0LmpvaW4ocGVyaW9kKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShwYXJlbnRQcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGFyZW50ID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZFBhcmVudCA9IG9sZFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZCA9IGlzTnVsbChuZXdQYXJlbnQpID8gdW5kZWZpbmVkIDogbmV3UGFyZW50W2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZENoaWxkID0gaXNOdWxsKG9sZFBhcmVudCkgPyB1bmRlZmluZWQgOiBvbGRQYXJlbnRba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleUlzTGVuZ3RoICYmICFpc0FycmF5KG9sZFBhcmVudCkgJiYgaXNBcnJheShuZXdQYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoTGlzdGVuZXIgPSB0aGlzLl9fbGVuZ3RoTGlzdGVuZXJzW2JpbmRpbmddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc051bGwobGVuZ3RoTGlzdGVuZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVpZCA9IGxlbmd0aExpc3RlbmVyLnVpZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXlTcGxpdCA9IGlkZW50aWZpZXIuc3BsaXQocGVyaW9kKSwgYXJyYXlLZXkgPSBhcnJheVNwbGl0LnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBqb2luID0gYXJyYXlTcGxpdC5qb2luKHBlcmlvZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFycmF5UGFyZW50ID0gdGhpcy5fZ2V0Q29udGV4dChqb2luLCBhcnJheVNwbGl0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX29ic2VydmVkSWRlbnRpZmllciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzKGFycmF5UGFyZW50LCBhcnJheUtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKHRoaXMuX19vYnNlcnZlZElkZW50aWZpZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpvaW4gPSB0aGlzLl9fb2JzZXJ2ZWRJZGVudGlmaWVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlTGlzdGVuZXIgPSB0aGlzLm9ic2VydmVBcnJheU11dGF0aW9uKHVpZCwgbm9vcCwgam9pbiwgbmV3UGFyZW50LCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmUoam9pbiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aWQ6IHVpZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXI6IGZ1bmN0aW9uIChuVmFsdWUsIG9WYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyID0gX3RoaXMub2JzZXJ2ZUFycmF5TXV0YXRpb24odWlkLCBub29wLCBqb2luLCBuVmFsdWUsIG9WYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eSh0aGlzLl9fbGVuZ3RoTGlzdGVuZXJzLCBiaW5kaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbcGFyZW50UHJvcGVydHldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbcGFyZW50UHJvcGVydHldID0gdGhpcy5fZ2V0VmFsdWVzKHNwbGl0LCBuZXdWYWx1ZSwgb2xkVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BhcmVudCA9IHZhbHVlLm5ld1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRQYXJlbnQgPSB2YWx1ZS5vbGRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQgPSBpc051bGwobmV3UGFyZW50KSA/IG5ld1BhcmVudCA6IG5ld1BhcmVudFtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRDaGlsZCA9IGlzTnVsbChvbGRQYXJlbnQpID8gb2xkUGFyZW50IDogb2xkUGFyZW50W2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1twcm9wZXJ0eV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdDaGlsZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWU6IG9sZENoaWxkXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QobmV3UGFyZW50KSAmJiAoIWlzQXJyYXkobmV3UGFyZW50KSB8fCBuZXdQYXJlbnQubGVuZ3RoID4ga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWZpbmUoYmluZGluZywgbmV3UGFyZW50LCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9leGVjdXRlKGJpbmRpbmcsIG5ld0NoaWxkLCBvbGRDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQWRkcyBhIGxpc3RlbmVyIHRvIGJlIGZpcmVkIGZvciBhIHBhcnRpY3VsYXIgaWRlbnRpZmllci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFic29sdXRlSWRlbnRpZmllciBUaGUgaWRlbnRpZmllciBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0Lm9ic2VydmFibGUuSUxpc3RlbmVyfSBvYnNlcnZhYmxlTGlzdGVuZXIgVGhlIGZ1bmN0aW9uIGFuZCBhc3NvY2lhdGVkIHVuaXF1ZSBJRCB0byBiZSBmaXJlZFxyXG4gICAgICAgICAgICAgKiBmb3IgdGhpcyBpZGVudGlmaWVyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTGVuZ3RoPyBJbmRpY2F0ZXMgdGhlIHByb3BlcnR5IGJlaW5nIG9ic2VydmVkIGlzIGFuIEFycmF5J3MgbGVuZ3RoLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIucHJvdG90eXBlLl9hZGRPYnNlcnZhYmxlTGlzdGVuZXIgPSBmdW5jdGlvbiAoYWJzb2x1dGVJZGVudGlmaWVyLCBvYnNlcnZhYmxlTGlzdGVuZXIsIGlzTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTGVuZ3RoID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwbGl0ID0gYWJzb2x1dGVJZGVudGlmaWVyLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9wIGxlbmd0aCBrZXkgXHJcbiAgICAgICAgICAgICAgICAgICAgc3BsaXQucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gc3BsaXQucG9wKCksIGNvbnRleHQgPSB0aGlzLmdldENvbnRleHQoc3BsaXQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QoY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX29ic2VydmVkSWRlbnRpZmllciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY2Vzcyhjb250ZXh0LCBwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyh0aGlzLl9fb2JzZXJ2ZWRJZGVudGlmaWVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVJZGVudGlmaWVyID0gdGhpcy5fX29ic2VydmVkSWRlbnRpZmllciArIChpc0xlbmd0aCA9PT0gdHJ1ZSA/ICcubGVuZ3RoJyA6ICcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX19hZGQoYWJzb2x1dGVJZGVudGlmaWVyLCBvYnNlcnZhYmxlTGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHVpZCA9IG9ic2VydmFibGVMaXN0ZW5lci51aWQsIHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBDb250ZXh0TWFuYWdlci5zcGxpY2VSZW1vdmVMaXN0ZW5lcihhYnNvbHV0ZUlkZW50aWZpZXIsIHVpZCwgcmVtb3ZlKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVtb3ZlQ2FsbGJhY2soYWJzb2x1dGVJZGVudGlmaWVyLCBvYnNlcnZhYmxlTGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLnB1c2hSZW1vdmVMaXN0ZW5lcihhYnNvbHV0ZUlkZW50aWZpZXIsIHVpZCwgcmVtb3ZlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBPYnNlcnZlcyBhIHByb3BlcnR5IG9uIGEgZ2l2ZW4gY29udGV4dCBzcGVjaWZpZWQgYnkgYW4gaWRlbnRpZmllci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aWZpZXIgVGhlIGZ1bGwgaWRlbnRpZmllciBwYXRoIGZvciB0aGUgcHJvcGVydHkgYmVpbmcgb2JzZXJ2ZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBpbW1lZGlhdGVDb250ZXh0IFRoZSBvYmplY3Qgd2hvc2UgcHJvcGVydHkgd2lsbCBiZSBvYnNlcnZlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdmFsdWUgb24gdGhlIGltbWVkaWF0ZUNvbnRleHQgdGhhdCdzXHJcbiAgICAgICAgICAgICAqIGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIucHJvdG90eXBlLl9kZWZpbmUgPSBmdW5jdGlvbiAoaWRlbnRpZmllciwgaW1tZWRpYXRlQ29udGV4dCwga2V5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QoaW1tZWRpYXRlQ29udGV4dFtrZXldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19kZWZpbmVPYmplY3QoaWRlbnRpZmllciwgaW1tZWRpYXRlQ29udGV4dCwga2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19kZWZpbmVQcmltaXRpdmUoaWRlbnRpZmllciwgaW1tZWRpYXRlQ29udGV4dCwga2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEludGVyY2VwdHMgYW4gYXJyYXkgZnVuY3Rpb24gZm9yIG9ic2VydmF0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWJzb2x1dGVJZGVudGlmaWVyIFRoZSBmdWxsIGlkZW50aWZpZXIgcGF0aCBmb3IgdGhlIG9ic2VydmVkIGFycmF5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kIFRoZSBhcnJheSBtZXRob2QgYmVpbmcgY2FsbGVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIucHJvdG90eXBlLl9vdmVyd3JpdGVBcnJheUZ1bmN0aW9uID0gZnVuY3Rpb24gKGFic29sdXRlSWRlbnRpZmllciwgbWV0aG9kKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tPYmplY3RzID0gQ29udGV4dE1hbmFnZXIuYXJyYXlDaGFuZ2VMaXN0ZW5lcnNbYWJzb2x1dGVJZGVudGlmaWVyXSB8fCB7fSwgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgLy8gd2UgY2FuJ3QgdXNlIGEgZmF0LWFycm93IGZ1bmN0aW9uIGhlcmUgYmVjYXVzZSB3ZSBuZWVkIHRoZSBhcnJheSBjb250ZXh0LiBcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBvYnNlcnZlZEFycmF5Rm4oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgb2xkTGVuZ3RoID0gdGhpcy5sZW5ndGgsIG9yaWdpbmFsQXJyYXkgPSB0aGlzLnNsaWNlKDApLCByZXR1cm5WYWx1ZSwgaXNVbnNoaWZ0ID0gbWV0aG9kID09PSAndW5zaGlmdCcsIGlzU2hpZnQgPSBtZXRob2QgPT09ICdzaGlmdCcsIGlzU3BsaWNlID0gbWV0aG9kID09PSAnc3BsaWNlJywgc2VsZk5vdGlmeSA9IGlzU2hpZnQgfHwgaXNVbnNoaWZ0IHx8IGlzU3BsaWNlLCBpc1VwZGF0ZSA9IG1ldGhvZCA9PT0gJ3NvcnQnIHx8IG1ldGhvZCA9PT0gJ3JldmVyc2UnLCBvbGRBcnJheSwgYWRkZWRDb3VudCwgaW5kZXgsIG5ld0xlbmd0aCwgcmVtb3ZlZDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZk5vdGlmeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fX2lzQXJyYXlGdW5jdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gQXJyYXkucHJvdG90eXBlW21ldGhvZF0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9faXNBcnJheUZ1bmN0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xlbmd0aCA9IHRoaXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1NoaWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRlZENvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgPSBvbGRMZW5ndGggPiAwID8gW3JldHVyblZhbHVlXSA6IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzVW5zaGlmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkZWRDb3VudCA9IGFyZ3MubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkZWRDb3VudCA9IGFyZ3MubGVuZ3RoIC0gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gYXJnc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgPSByZXR1cm5WYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBBcnJheS5wcm90b3R5cGVbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGVuZ3RoID0gdGhpcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1VwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkQXJyYXkgPSBvcmlnaW5hbEFycmF5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1ldGhvZCA9PT0gJ3B1c2gnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRlZENvdW50ID0gYXJncy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IG9sZExlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtZXRob2QgPT09ICdwb3AnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRlZENvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gbmV3TGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZCA9IG9sZExlbmd0aCA+IDAgPyBbcmV0dXJuVmFsdWVdIDogW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2hpZnQgfHwgaXNTcGxpY2UgfHwgbWV0aG9kID09PSAncG9wJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDb250ZXh0TWFuYWdlci51bk9ic2VydmUocmV0dXJuVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNhbGxiYWNrT2JqZWN0cyksIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBjYWxsYmFja3MsIGpMZW5ndGgsIGksIGo7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrT2JqZWN0c1trZXlzW2ldXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgakxlbmd0aCA9IGNhbGxiYWNrcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuZ3RoOyArK2opIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc1tqXShbe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG1ldGhvZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkOiByZW1vdmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRlZENvdW50OiBhZGRlZENvdW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRBcnJheTogb2xkQXJyYXlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGZOb3RpZnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX25vdGlmeUNoaWxkUHJvcGVydGllcyhhYnNvbHV0ZUlkZW50aWZpZXIsIHRoaXMsIG9yaWdpbmFsQXJyYXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2V4ZWN1dGUoYWJzb2x1dGVJZGVudGlmaWVyICsgJy5sZW5ndGgnLCBuZXdMZW5ndGgsIG9sZExlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZW1vdmVzIGEgc2luZ2xlIGxpc3RlbmVyIGNhbGxiYWNrXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGlmaWVyIFRoZSBpZGVudGlmaWVyIGF0dGFjaGVkIHRvIHRoZSBjYWxsYmFja3MuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5vYnNlcnZhYmxlLklMaXN0ZW5lcn0gbGlzdGVuZXIgVGhlIG9ic2VydmFibGUgbGlzdGVuZXIgdG8gcmVtb3ZlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIucHJvdG90eXBlLl9yZW1vdmVDYWxsYmFjayA9IGZ1bmN0aW9uIChpZGVudGlmaWVyLCBsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX19pZGVudGlmaWVyc1tpZGVudGlmaWVyXTtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoY2FsbGJhY2tzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSB0aGUgb2JzZXJ2ZWQgbGlzdGVuZXIgXHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KHRoaXMuX19jb250ZXh0T2JqZWN0cywgaWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDaGVja3MgaWYgdGhlIHNwZWNpZmllZCBpZGVudGlmaWVyIGlzIGFscmVhZHkgYmVpbmdcclxuICAgICAgICAgICAgICogb2JzZXJ2ZWQgaW4gdGhpcyBjb250ZXh0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmllciBUaGUgaWRlbnRpZmllciBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLnByb3RvdHlwZS5faGFzSWRlbnRpZmllciA9IGZ1bmN0aW9uIChpZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gIWlzRW1wdHkodGhpcy5fX2lkZW50aWZpZXJzW2lkZW50aWZpZXJdKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEV4ZWN1dGVzIHRoZSBsaXN0ZW5lcnMgZm9yIHRoZSBzcGVjaWZpZWQgaWRlbnRpZmllciBvblxyXG4gICAgICAgICAgICAgKiB0aGlzIGNvbnRleHQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGlmaWVyIFRoZSBpZGVudGlmaWVyIGF0dGFjaGVkIHRvIHRoZSBjYWxsYmFja3MuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgbmV3IHZhbHVlIG9uIHRoaXMgY29udGV4dCBzcGVjaWZpZWQgYnlcclxuICAgICAgICAgICAgICogdGhlIGlkZW50aWZpZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBvbGRWYWx1ZSBUaGUgb2xkIHZhbHVlIG9uIHRoaXMgY29udGV4dCBzcGVjaWZpZWQgYnlcclxuICAgICAgICAgICAgICogdGhlIGlkZW50aWZpZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDb250ZXh0TWFuYWdlci5wcm90b3R5cGUuX2V4ZWN1dGUgPSBmdW5jdGlvbiAoaWRlbnRpZmllciwgdmFsdWUsIG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2JzZXJ2YWJsZUxpc3RlbmVycyA9IHRoaXMuX19pZGVudGlmaWVyc1tpZGVudGlmaWVyXTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eSh0aGlzLl9fY29udGV4dE9iamVjdHMsIGlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2NvbnRleHRPYmplY3RzW2lkZW50aWZpZXJdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG9sZFZhbHVlIHx8IGlzTnVsbChvYnNlcnZhYmxlTGlzdGVuZXJzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSBvYnNlcnZhYmxlTGlzdGVuZXJzLnNsaWNlKDApLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5saXN0ZW5lcih2YWx1ZSwgb2xkVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGVmaW5lcyBhIGdldHRlciBhbmQgc2V0dGVyIGZvciBhbiBvYmplY3QgdXNpbmcgT2JqZWN0LmRlZmluZVByb3BlcnR5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmllciBUaGUgaWRlbnRpZmllciBvZiB0aGUgb2JqZWN0IGJlaW5nIGRlZmluZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBpbW1lZGlhdGVDb250ZXh0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIHRoZSBvYmplY3QgYmVpbmcgZGVmaW5lZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcHJvcGVydHkga2V5IG9mIHRoZSBvYmplY3QgYmVpbmcgZGVmaW5lZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLnByb3RvdHlwZS5fX2RlZmluZU9iamVjdCA9IGZ1bmN0aW9uIChpZGVudGlmaWVyLCBpbW1lZGlhdGVDb250ZXh0LCBrZXkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBpbW1lZGlhdGVDb250ZXh0W2tleV07XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW1tZWRpYXRlQ29udGV4dCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fb2JzZXJ2ZWRJZGVudGlmaWVyID0gaWRlbnRpZmllcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX19pc0FycmF5RnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBDb250ZXh0TWFuYWdlci51bk9ic2VydmUob2xkVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBfdGhpcy5fX2lkZW50aWZpZXJIYXNoW2lkZW50aWZpZXJdLCBjaGlsZFByb3BlcnRpZXNFeGlzdCA9IGZhbHNlLCBtYXBwaW5ncztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHByb3BzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZ3MgPSBPYmplY3Qua2V5cyhwcm9wcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZFByb3BlcnRpZXNFeGlzdCA9IG1hcHBpbmdzLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2V4ZWN1dGUoaWRlbnRpZmllciwgdmFsdWUsIG9sZFZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkUHJvcGVydGllc0V4aXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbm90aWZ5Q2hpbGRQcm9wZXJ0aWVzKGlkZW50aWZpZXIsIHZhbHVlLCBvbGRWYWx1ZSwgbWFwcGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fX2RlZmluZVByaW1pdGl2ZShpZGVudGlmaWVyLCBpbW1lZGlhdGVDb250ZXh0LCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRW1wdHkoX3RoaXMuX19pZGVudGlmaWVyc1tpZGVudGlmaWVyXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLmRlZmluZVByb3BlcnR5KGltbWVkaWF0ZUNvbnRleHQsIGtleSwgdmFsdWUsIHRydWUsIHRydWUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fZGVmaW5lUHJpbWl0aXZlKGlkZW50aWZpZXIsIGltbWVkaWF0ZUNvbnRleHQsIGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERlZmluZXMgYSBnZXR0ZXIgYW5kIHNldHRlciBmb3IgYSBwcmltaXRpdmUgdXNpbmcgT2JqZWN0LmRlZmluZVByb3BlcnR5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmllciBUaGUgaWRlbnRpZmllciBvZiB0aGUgcHJpbWl0aXZlIGJlaW5nIGRlZmluZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBpbW1lZGlhdGVDb250ZXh0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIHRoZSBwcmltaXRpdmUgYmVpbmcgZGVmaW5lZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcHJvcGVydHkga2V5IG9mIHRoZSBwcmltaXRpdmUgYmVpbmcgZGVmaW5lZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLnByb3RvdHlwZS5fX2RlZmluZVByaW1pdGl2ZSA9IGZ1bmN0aW9uIChpZGVudGlmaWVyLCBpbW1lZGlhdGVDb250ZXh0LCBrZXkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBpbW1lZGlhdGVDb250ZXh0W2tleV0sIGlzRGVmaW5lZCA9ICFpc051bGwodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoaW1tZWRpYXRlQ29udGV4dCkgJiYga2V5ID09PSAnbGVuZ3RoJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbW1lZGlhdGVDb250ZXh0LCBrZXksIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19vYnNlcnZlZElkZW50aWZpZXIgPSBpZGVudGlmaWVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fX2lzQXJyYXlGdW5jdGlvbiAmJiBpc0FycmF5KGltbWVkaWF0ZUNvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BzID0gX3RoaXMuX19pZGVudGlmaWVySGFzaFtpZGVudGlmaWVyXSwgY2hpbGRQcm9wZXJ0aWVzRXhpc3QgPSBmYWxzZSwgbWFwcGluZ3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChwcm9wcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmdzID0gT2JqZWN0LmtleXMocHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRQcm9wZXJ0aWVzRXhpc3QgPSBtYXBwaW5ncy5sZW5ndGggPiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9leGVjdXRlKGlkZW50aWZpZXIsIG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGRQcm9wZXJ0aWVzRXhpc3QgJiYgaXNFbXB0eShfdGhpcy5fX2lkZW50aWZpZXJzW2lkZW50aWZpZXJdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIuZGVmaW5lUHJvcGVydHkoaW1tZWRpYXRlQ29udGV4dCwga2V5LCB2YWx1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fX2RlZmluZU9iamVjdChpZGVudGlmaWVyLCBpbW1lZGlhdGVDb250ZXh0LCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkUHJvcGVydGllc0V4aXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX25vdGlmeUNoaWxkUHJvcGVydGllcyhpZGVudGlmaWVyLCBuZXdWYWx1ZSwgb2xkVmFsdWUsIG1hcHBpbmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNEZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fX2RlZmluZVByaW1pdGl2ZShpZGVudGlmaWVyLCBpbW1lZGlhdGVDb250ZXh0LCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNEZWZpbmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQWRkcyBhbmQgYXNzb2NpYXRlcyBhIGxpc3RlbmVyIHdpdGggYSBnaXZlbiBpZGVudGlmaWVyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmllciBUaGUgaWRlbnRpZmllciB0byBhdHRhY2ggdGhlIGxpc3RlbmVyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQub2JzZXJ2YWJsZS5JTGlzdGVuZXJ9IG9ic2VydmFibGVMaXN0ZW5lciBUaGUgbGlzdGVuZXIgYmVpbmcgYWRkZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDb250ZXh0TWFuYWdlci5wcm90b3R5cGUuX19hZGQgPSBmdW5jdGlvbiAoaWRlbnRpZmllciwgb2JzZXJ2YWJsZUxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fX2lkZW50aWZpZXJzW2lkZW50aWZpZXJdLCBwcmlvcml0eSA9IG9ic2VydmFibGVMaXN0ZW5lci5wcmlvcml0eSwgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoY2FsbGJhY2tzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcyA9IHRoaXMuX19pZGVudGlmaWVyc1tpZGVudGlmaWVyXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHByaW9yaXR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGhfNiA9IGNhbGxiYWNrcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGhfNjsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmlvcml0eSA+IGNhbGxiYWNrc1tpXS5wcmlvcml0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAwLCBvYnNlcnZhYmxlTGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZhYmxlTGlzdGVuZXIucHJpb3JpdHkgPSAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghZm91bmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MucHVzaChvYnNlcnZhYmxlTGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2FkZEhhc2hWYWx1ZXMoaWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBZGRzIGEgbWFwcGluZyBmb3IgYW4gaWRlbnRpZmllciB3aGljaCBhbGxvd3MgcXVpY2sgYWNjZXNzIHRvIGl0XHJcbiAgICAgICAgICAgICAqIGlmIGEgcGFyZW50IGNvbnRleHQgaXMgY2hhbmdlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aWZpZXIgVGhlIGlkZW50aWZpZXIgdG8gbWFwLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIucHJvdG90eXBlLl9fYWRkSGFzaFZhbHVlcyA9IGZ1bmN0aW9uIChpZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaWRlbnRpZmllckhhc2ggPSB0aGlzLl9faWRlbnRpZmllckhhc2g7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QoaWRlbnRpZmllckhhc2hbaWRlbnRpZmllcl0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWRlbnRpZmllckhhc2hbaWRlbnRpZmllcl0gPSB7fTtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCwgcGVyaW9kID0gJy4nLCBpZGVudCA9IGlkZW50aWZpZXIsIGhhc2hWYWx1ZTtcclxuICAgICAgICAgICAgICAgIHdoaWxlICgoaW5kZXggPSBpZGVudC5sYXN0SW5kZXhPZihwZXJpb2QpKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZGVudCA9IGlkZW50LnNsaWNlKDAsIGluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNoVmFsdWUgPSBpZGVudGlmaWVySGFzaFtpZGVudF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChoYXNoVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc2hWYWx1ZSA9IGlkZW50aWZpZXJIYXNoW2lkZW50XSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWRlbnQgIT09IGlkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2hWYWx1ZVtpZGVudGlmaWVyXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaWRlbnQgIT09IGlkZW50aWZpZXIgJiYgIWhhc2hWYWx1ZVtpZGVudGlmaWVyXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNoVmFsdWVbaWRlbnRpZmllcl0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgc2V0IG9mIGZ1bmN0aW9ucyB0byBiZSBmaXJlZCB3aGVuIGEgcGFydGljdWxhciBvYnNlcnZlZCBhcnJheSBpcyBtdXRhdGVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIuYXJyYXlDaGFuZ2VMaXN0ZW5lcnMgPSB7fTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFuIG9iamVjdCBmb3IgcXVpY2tseSBhY2Nlc3NpbmcgYSBwcmV2aW91c2x5IGNyZWF0ZWQgQ29udGV4dE1hbmFnZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDb250ZXh0TWFuYWdlci5fX21hbmFnZXJzID0ge307XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBbiBvYmplY3QgZm9yIHN0b3JpbmcgZnVuY3Rpb25zIHRvIHJlbW92ZSBsaXN0ZW5lcnMgZm9yIG9ic2VydmVkIGlkZW50aWZpZXJzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIuX19jb250cm9scyA9IHt9O1xyXG4gICAgICAgICAgICByZXR1cm4gQ29udGV4dE1hbmFnZXI7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBvYnNlcnZhYmxlLkNvbnRleHRNYW5hZ2VyID0gQ29udGV4dE1hbmFnZXI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gSUNvbnRleHRNYW5hZ2VyU3RhdGljKF9sb2cpIHtcclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIuX2xvZyA9IF9sb2c7XHJcbiAgICAgICAgICAgIHJldHVybiBDb250ZXh0TWFuYWdlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JzZXJ2YWJsZS5JQ29udGV4dE1hbmFnZXJTdGF0aWMgPSBJQ29udGV4dE1hbmFnZXJTdGF0aWM7XHJcbiAgICAgICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX0NvbnRleHRNYW5hZ2VyU3RhdGljLCBJQ29udGV4dE1hbmFnZXJTdGF0aWMsIFtcclxuICAgICAgICAgICAgX19Mb2dcclxuICAgICAgICBdLCBfX1NUQVRJQyk7XHJcbiAgICAgICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX0NvbnRleHRNYW5hZ2VySW5zdGFuY2UsIENvbnRleHRNYW5hZ2VyLCBudWxsLCBfX0lOU1RBTkNFKTtcclxuICAgIH0pKG9ic2VydmFibGUgPSBwbGF0XzEub2JzZXJ2YWJsZSB8fCAocGxhdF8xLm9ic2VydmFibGUgPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIb2xkcyBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIHJlbGF0ZWQgdG8gZXZlbnQgbWFuYWdlbWVudCBjb21wb25lbnRzIGluIHBsYXR5cHVzLlxyXG4gICAgICovXHJcbiAgICB2YXIgZXZlbnRzO1xyXG4gICAgKGZ1bmN0aW9uIChldmVudHMpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbiBldmVudCBjbGFzcyB0aGF0IHByb3BhZ2F0ZXMgdGhyb3VnaCBhIGNvbnRyb2wgdHJlZS5cclxuICAgICAgICAgKiBQcm9wYWdhdGlvbiBvZiB0aGUgZXZlbnQgYWx3YXlzIHN0YXJ0cyBhdCB0aGUgc2VuZGVyLCBhbGxvd2luZyBhIGNvbnRyb2wgdG8gYm90aFxyXG4gICAgICAgICAqIGluaXRpYWxpemUgYW5kIGNvbnN1bWUgYW4gZXZlbnQuIElmIGEgY29uc3VtZXIgb2YgYW4gZXZlbnQgdGhyb3dzIGFuIGVycm9yIHdoaWxlXHJcbiAgICAgICAgICogaGFuZGxpbmcgdGhlIGV2ZW50IGl0IHdpbGwgYmUgbG9nZ2VkIHRvIHRoZSBhcHAgdXNpbmcgTG9nLmRlYnVnLiBFcnJvcnMgd2lsbFxyXG4gICAgICAgICAqIG5vdCBzdG9wIHByb3BhZ2F0aW9uIG9mIHRoZSBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgRGlzcGF0Y2hFdmVudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIERpc3BhdGNoRXZlbnQoKSB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHByZXZlbnREZWZhdWx0KCkgd2FzIGNhbGxlZCBvbiB0aGUgZXZlbnQuIFNlbmRlcnMgb2YgdGhlXHJcbiAgICAgICAgICAgICAgICAgKiBldmVudCBjYW4gY2hlY2sgdGhpcyBwcm9wZXJ0eSB0byBrbm93IGlmIHRoZXkgc2hvdWxkIGNhcnJ5IG91dCBhIGRlZmF1bHRcclxuICAgICAgICAgICAgICAgICAqIGFjdGlvbiBhcyBhIHJlc3VsdCBvZiB0aGUgZXZlbnQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgZXZlbnQgcHJvcGFnYXRpb24gd2FzIHN0b3BwZWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIERpc3BhdGNoRXZlbnQucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAobmFtZSwgc2VuZGVyLCBkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbiB8fCB0aGlzLl9FdmVudE1hbmFnZXIuVVA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRlciA9IHNlbmRlcjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENhbmNlbHMgdGhlIGRlZmF1bHQgYWN0aW9uIChpZiB0aGVyZSBpcyBvbmUpIGZvciBhbiBldmVudC4gRG9lcyBub3QgYWZmZWN0IHByb3BhZ2F0aW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRGlzcGF0Y2hFdmVudC5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX0NvbnRleHRNYW5hZ2VyLmRlZmluZUdldHRlcih0aGlzLCAnZGVmYXVsdFByZXZlbnRlZCcsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2FsbCB0aGlzIG1ldGhvZCB0byBoYWx0IHRoZSBwcm9wYWdhdGlvbiBvZiBhbiB1cHdhcmQtbW92aW5nIGV2ZW50LlxyXG4gICAgICAgICAgICAgKiBEb3dud2FyZCBldmVudHMgY2Fubm90IGJlIHN0b3BwZWQgd2l0aCB0aGlzIG1ldGhvZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERpc3BhdGNoRXZlbnQucHJvdG90eXBlLnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gdGhpcy5fRXZlbnRNYW5hZ2VyLlVQKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9FdmVudE1hbmFnZXIucHJvcGFnYXRpbmdFdmVudHNbdGhpcy5uYW1lXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBEaXNwYXRjaEV2ZW50Ll9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgICAgICBfRXZlbnRNYW5hZ2VyOiBfX0V2ZW50TWFuYWdlclN0YXRpYyxcclxuICAgICAgICAgICAgICAgIF9Db250ZXh0TWFuYWdlcjogX19Db250ZXh0TWFuYWdlclN0YXRpY1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gRGlzcGF0Y2hFdmVudDtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGV2ZW50cy5EaXNwYXRjaEV2ZW50ID0gRGlzcGF0Y2hFdmVudDtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fRGlzcGF0Y2hFdmVudEluc3RhbmNlLCBEaXNwYXRjaEV2ZW50LCBudWxsLCBfX0lOU1RBTkNFKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXByZXNlbnRzIGEgTGlmZWN5Y2xlIEV2ZW50LiBMaWZlY3ljbGUgRXZlbnRzIGFyZSBhbHdheXMgZGlyZWN0IGV2ZW50cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgTGlmZWN5Y2xlRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoTGlmZWN5Y2xlRXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIExpZmVjeWNsZUV2ZW50KCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENyZWF0ZXMgYSBuZXcgTGlmZWN5Y2xlRXZlbnQgYW5kIGZpcmVzIGl0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBzZW5kZXIgVGhlIHNlbmRlciBvZiB0aGUgZXZlbnQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBMaWZlY3ljbGVFdmVudC5kaXNwYXRjaCA9IGZ1bmN0aW9uIChuYW1lLCBzZW5kZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudCA9IGFjcXVpcmUoX19MaWZlY3ljbGVFdmVudEluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIGV2ZW50LmluaXRpYWxpemUobmFtZSwgc2VuZGVyKTtcclxuICAgICAgICAgICAgICAgIEV2ZW50TWFuYWdlci5zZW5kRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIGV2ZW50LCBwb3B1bGF0aW5nIGl0cyBwdWJsaWMgcHJvcGVydGllcy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gc2VuZGVyIFRoZSBzZW5kZXIgb2YgdGhlIGV2ZW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTGlmZWN5Y2xlRXZlbnQucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAobmFtZSwgc2VuZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBuYW1lLCBzZW5kZXIsIHRoaXMuX0V2ZW50TWFuYWdlci5ESVJFQ1QpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gTGlmZWN5Y2xlRXZlbnQ7XHJcbiAgICAgICAgfShEaXNwYXRjaEV2ZW50KSk7XHJcbiAgICAgICAgZXZlbnRzLkxpZmVjeWNsZUV2ZW50ID0gTGlmZWN5Y2xlRXZlbnQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gSUxpZmVjeWNsZUV2ZW50U3RhdGljKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTGlmZWN5Y2xlRXZlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV2ZW50cy5JTGlmZWN5Y2xlRXZlbnRTdGF0aWMgPSBJTGlmZWN5Y2xlRXZlbnRTdGF0aWM7XHJcbiAgICAgICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX0xpZmVjeWNsZUV2ZW50U3RhdGljLCBJTGlmZWN5Y2xlRXZlbnRTdGF0aWMsIG51bGwsIF9fU1RBVElDKTtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fTGlmZWN5Y2xlRXZlbnRJbnN0YW5jZSwgTGlmZWN5Y2xlRXZlbnQsIG51bGwsIF9fSU5TVEFOQ0UpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1hbmFnZXMgZGlzcGF0Y2hpbmcgZXZlbnRzLCBoYW5kbGluZyBhbGwgcHJvcGFnYXRpbmcgZXZlbnRzIGFzIHdlbGwgYXMgYW55IGVycm9yIGhhbmRsaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBFdmVudE1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBFdmVudE1hbmFnZXIoKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluaXRpYWxpemVzIHRoZSBFdmVudE1hbmFnZXIsIGNyZWF0aW5nIHRoZSBpbml0aWFsIEFMTSBldmVudCBsaXN0ZW5lcnMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFdmVudE1hbmFnZXIuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChFdmVudE1hbmFnZXIuX19pbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIEV2ZW50TWFuYWdlci5fX2luaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZhciBsaWZlY3ljbGVMaXN0ZW5lcnMgPSBFdmVudE1hbmFnZXIuX19saWZlY3ljbGVFdmVudExpc3RlbmVycywgX2NvbXBhdCA9IEV2ZW50TWFuYWdlci5fY29tcGF0LCBfZG9jdW1lbnQgPSBFdmVudE1hbmFnZXIuX2RvY3VtZW50LCBfd2luZG93ID0gRXZlbnRNYW5hZ2VyLl93aW5kb3csIF9kb20gPSBFdmVudE1hbmFnZXIuX2RvbSwgZGlzcGF0Y2ggPSBMaWZlY3ljbGVFdmVudC5kaXNwYXRjaCwgbGlzdGVuZXI7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobGlmZWN5Y2xlTGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGxpZmVjeWNsZUxpc3RlbmVycy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihsaXN0ZW5lci5uYW1lLCBsaXN0ZW5lci52YWx1ZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKF9jb21wYXQuY29yZG92YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudE5hbWVzID0gW19fcmVzdW1lLCBfX29ubGluZSwgX19vZmZsaW5lXSwgd2luSnNfMSA9IF9jb21wYXQud2luSnMsIGxlbmd0aF83ID0gZXZlbnROYW1lcy5sZW5ndGgsIGV2ZW50XzEsIGRpc3BhdGNoZXIgPSBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goZXYsIEV2ZW50TWFuYWdlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfTsgfSwgZm4gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGhfNzsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50XzEgPSBldmVudE5hbWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbiA9IGRpc3BhdGNoZXIoZXZlbnRfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpZmVjeWNsZUxpc3RlbmVycy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGV2ZW50XzEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kb20uYWRkRXZlbnRMaXN0ZW5lcihfZG9jdW1lbnQsIGV2ZW50XzEsIGZuLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZuID0gZGlzcGF0Y2hlcihfX3N1c3BlbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpZmVjeWNsZUxpc3RlbmVycy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogX19wYXVzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZuXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2RvbS5hZGRFdmVudExpc3RlbmVyKF9kb2N1bWVudCwgX19wYXVzZSwgZm4sIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBmbiA9IGRpc3BhdGNoZXIoX19yZWFkeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlmZWN5Y2xlTGlzdGVuZXJzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBfX2RldmljZVJlYWR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZm5cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBfZG9tLmFkZEV2ZW50TGlzdGVuZXIoX2RvY3VtZW50LCBfX2RldmljZVJlYWR5LCBmbiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdpbkpzXzEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKF9fYmFja0J1dHRvbiwgRXZlbnRNYW5hZ2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGxpZmVjeWNsZUxpc3RlbmVycy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogX19iYWNrQnV0dG9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZm5cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBfZG9tLmFkZEV2ZW50TGlzdGVuZXIoX2RvY3VtZW50LCBfX2JhY2tCdXR0b24sIGZuLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpbkpzXzEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChfX2JhY2tCdXR0b24sIEV2ZW50TWFuYWdlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlmZWN5Y2xlTGlzdGVuZXJzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogX19iYWNrQ2xpY2ssXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF93aW5kb3cuV2luSlMuQXBwbGljYXRpb24uYWRkRXZlbnRMaXN0ZW5lcihfX2JhY2tDbGljaywgZm4sIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfY29tcGF0LmFtZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIF9kb20uYWRkRXZlbnRMaXN0ZW5lcihfd2luZG93LCAnbG9hZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goX19yZWFkeSwgRXZlbnRNYW5hZ2VyKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlbW92ZXMgYWxsIGV2ZW50IGxpc3RlbmVycyBmb3IgYSBnaXZlbiB1aWQuIFVzZWZ1bCBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uIHdoZW5cclxuICAgICAgICAgICAgICogY2VydGFpbiBvYmplY3RzIHRoYXQgbGlzdGVuIHRvIGV2ZW50cyBnbyBvdXQgb2Ygc2NvcGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1aWQgVGhlIHVpZCBmb3Igd2hpY2ggdGhlIGV2ZW50IGxpc3RlbmVycyB3aWxsIGJlIHJlbW92ZWQuJ1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRXZlbnRNYW5hZ2VyLmRpc3Bvc2UgPSBmdW5jdGlvbiAodWlkKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eShFdmVudE1hbmFnZXIuX19ldmVudHNMaXN0ZW5lcnMsIHVpZCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciBmb3IgYSBEaXNwYXRjaEV2ZW50LiBUaGUgbGlzdGVuZXIgd2lsbCBiZSBjYWxsZWQgd2hlbiBhIERpc3BhdGNoRXZlbnQgaXNcclxuICAgICAgICAgICAgICogcHJvcGFnYXRpbmcgb3ZlciB0aGUgZ2l2ZW4gdWlkLiBBbnkgbnVtYmVyIG9mIGxpc3RlbmVycyBjYW4gZXhpc3QgZm9yIGEgc2luZ2xlIGV2ZW50IG5hbWUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1aWQgQSB1bmlxdWUgaWQgdG8gYXNzb2NpYXRlIHdpdGggdGhlIG9iamVjdCByZWdpc3RlcmluZyB0aGUgbGlzdGVuZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiB0by5cclxuICAgICAgICAgICAgICogQHBhcmFtIHsoZXY6IERpc3BhdGNoRXZlbnQsIC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkfSBsaXN0ZW5lciBUaGUgbWV0aG9kIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyBmaXJlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IGNvbnRleHQ/IFRoZSBjb250ZXh0IHdpdGggd2hpY2ggdG8gY2FsbCB0aGUgbGlzdGVuZXIgbWV0aG9kLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRXZlbnRNYW5hZ2VyLm9uID0gZnVuY3Rpb24gKHVpZCwgZXZlbnROYW1lLCBsaXN0ZW5lciwgY29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50c0xpc3RlbmVyID0gRXZlbnRNYW5hZ2VyLl9fZXZlbnRzTGlzdGVuZXJzW3VpZF07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGV2ZW50c0xpc3RlbmVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50c0xpc3RlbmVyID0gRXZlbnRNYW5hZ2VyLl9fZXZlbnRzTGlzdGVuZXJzW3VpZF0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyczoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHRcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50TGlzdGVuZXJzID0gZXZlbnRzTGlzdGVuZXIubGlzdGVuZXJzW2V2ZW50TmFtZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkoZXZlbnRMaXN0ZW5lcnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRMaXN0ZW5lcnMgPSBldmVudHNMaXN0ZW5lci5saXN0ZW5lcnNbZXZlbnROYW1lXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXZlbnRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGV2ZW50TGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBldmVudExpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgRXZlbnRNYW5hZ2VyLmRpc3BhdGNoID0gZnVuY3Rpb24gKG5hbWUsIHNlbmRlciwgZGlyZWN0aW9uLCBhcmdzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2Rpc3BhdGNoRXZlbnQgPSBhY3F1aXJlKF9fRGlzcGF0Y2hFdmVudEluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50LmluaXRpYWxpemUobmFtZSwgc2VuZGVyLCBkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgRXZlbnRNYW5hZ2VyLnNlbmRFdmVudChfZGlzcGF0Y2hFdmVudCwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX2Rpc3BhdGNoRXZlbnQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBzdHJpbmcgaXMgYSByZWdpc3RlcmVkIGRpcmVjdGlvbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGRpcmVjdGlvbiBUaGUgZGlyZWN0aW9uIG9mIHRoZSBldmVudFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRXZlbnRNYW5hZ2VyLmhhc0RpcmVjdGlvbiA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoZGlyZWN0aW9uID09PSBFdmVudE1hbmFnZXIuVVAgfHxcclxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPT09IEV2ZW50TWFuYWdlci5ET1dOIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID09PSBFdmVudE1hbmFnZXIuRElSRUNUKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERldGVybWluZXMgdGhlIGFwcHJvcHJpYXRlIGRpcmVjdGlvbiBhbmQgZGlzcGF0Y2hlcyB0aGUgZXZlbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5ldmVudHMuRGlzcGF0Y2hFdmVudH0gZXZlbnQgVGhlIERpc3BhdGNoRXZlbnQgdG8gc2VuZFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGFyZ3MgVGhlIGFyZ3VtZW50cyBhc3NvY2lhdGVkIHdpdGggdGhlIGV2ZW50XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFdmVudE1hbmFnZXIuc2VuZEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50LCBhcmdzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGV2ZW50Lm5hbWUsIGRpcmVjdGlvbiA9IGV2ZW50LmRpcmVjdGlvbjtcclxuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgRXZlbnRNYW5hZ2VyLnByb3BhZ2F0aW5nRXZlbnRzW25hbWVdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEV2ZW50TWFuYWdlci5VUDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgRXZlbnRNYW5hZ2VyLl9kaXNwYXRjaFVwKGV2ZW50LCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBFdmVudE1hbmFnZXIuRE9XTjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgRXZlbnRNYW5hZ2VyLl9kaXNwYXRjaERvd24oZXZlbnQsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEV2ZW50TWFuYWdlci5ESVJFQ1Q6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEV2ZW50TWFuYWdlci5fZGlzcGF0Y2hEaXJlY3QoZXZlbnQsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KEV2ZW50TWFuYWdlci5wcm9wYWdhdGluZ0V2ZW50cywgbmFtZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEaXNwYXRjaGVzIHRoZSBldmVudCB1cCB0aGUgY29udHJvbCBjaGFpbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LmV2ZW50cy5EaXNwYXRjaEV2ZW50fSBldmVudCBUaGUgZXZlbnQgYmVpbmcgZGlzcGF0Y2hlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcmdzIFRoZSBhcmd1bWVudHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBldmVudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEV2ZW50TWFuYWdlci5fZGlzcGF0Y2hVcCA9IGZ1bmN0aW9uIChldmVudCwgYXJncykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBldmVudC5uYW1lLCBwYXJlbnQgPSBldmVudC5zZW5kZXI7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoIWlzTnVsbChwYXJlbnQpICYmIEV2ZW50TWFuYWdlci5wcm9wYWdhdGluZ0V2ZW50c1tuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwocGFyZW50LnVpZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIEV2ZW50TWFuYWdlci5fX2V4ZWN1dGVFdmVudChwYXJlbnQudWlkLCBldmVudCwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERpc3BhdGNoZXMgdGhlIGV2ZW50IGRvd24gdGhlIGNvbnRyb2wgY2hhaW4uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5ldmVudHMuRGlzcGF0Y2hFdmVudH0gZXZlbnQgVGhlIGV2ZW50IGJlaW5nIGRpc3BhdGNoZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJncyBUaGUgYXJndW1lbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFdmVudE1hbmFnZXIuX2Rpc3BhdGNoRG93biA9IGZ1bmN0aW9uIChldmVudCwgYXJncykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xzID0gW10sIGNvbnRyb2wsIG5hbWUgPSBldmVudC5uYW1lO1xyXG4gICAgICAgICAgICAgICAgY29udHJvbHMucHVzaChldmVudC5zZW5kZXIpO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbnRyb2xzLmxlbmd0aCAmJiBFdmVudE1hbmFnZXIucHJvcGFnYXRpbmdFdmVudHNbbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sID0gY29udHJvbHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChjb250cm9sLnVpZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIEV2ZW50TWFuYWdlci5fX2V4ZWN1dGVFdmVudChjb250cm9sLnVpZCwgZXZlbnQsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwoY29udHJvbC5jb250cm9scykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xzID0gY29udHJvbHMuY29uY2F0KGNvbnRyb2wuY29udHJvbHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGlzcGF0Y2hlcyB0aGUgZXZlbnQgZGlyZWN0bHkgdG8gYWxsIGxpc3RlbmVycy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LmV2ZW50cy5EaXNwYXRjaEV2ZW50fSBldmVudCBUaGUgZXZlbnQgYmVpbmcgZGlzcGF0Y2hlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcmdzIFRoZSBhcmd1bWVudHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBldmVudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEV2ZW50TWFuYWdlci5fZGlzcGF0Y2hEaXJlY3QgPSBmdW5jdGlvbiAoZXZlbnQsIGFyZ3MpIHtcclxuICAgICAgICAgICAgICAgIHZhciB1aWRzID0gT2JqZWN0LmtleXMoRXZlbnRNYW5hZ2VyLl9fZXZlbnRzTGlzdGVuZXJzKSwgbGVuZ3RoID0gdWlkcy5sZW5ndGgsIG5hbWUgPSBldmVudC5uYW1lLCBldmVudHNMaXN0ZW5lcjtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUV2ZW50TWFuYWdlci5wcm9wYWdhdGluZ0V2ZW50c1tuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzTGlzdGVuZXIgPSBFdmVudE1hbmFnZXIuX19ldmVudHNMaXN0ZW5lcnNbdWlkc1tpXV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChldmVudHNMaXN0ZW5lcikgfHwgaXNOdWxsKGV2ZW50c0xpc3RlbmVyLmxpc3RlbmVyc1tuYW1lXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIEV2ZW50TWFuYWdlci5fX2NhbGxMaXN0ZW5lcnMoZXZlbnRzTGlzdGVuZXIuY29udGV4dCwgZXZlbnQsIGV2ZW50c0xpc3RlbmVyLmxpc3RlbmVyc1tuYW1lXSwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEaXNwYXRjaGVzIHRoZSBldmVudCB0byB0aGUgbGlzdGVuZXJzIGZvciB0aGUgZ2l2ZW4gdWlkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdWlkIFRoZSB1aWQgdXNlZCB0byBmaW5kIHRoZSBldmVudCBsaXN0ZW5lcnMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5ldmVudHMuRGlzcGF0Y2hFdmVudH0gVGhlIGV2ZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBzZW5kIHRvIHRoZSBsaXN0ZW5lcnMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFdmVudE1hbmFnZXIuX19leGVjdXRlRXZlbnQgPSBmdW5jdGlvbiAodWlkLCBldiwgYXJncykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50c0xpc3RlbmVyID0gRXZlbnRNYW5hZ2VyLl9fZXZlbnRzTGlzdGVuZXJzW3VpZF07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGV2ZW50c0xpc3RlbmVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gZXZlbnRzTGlzdGVuZXIuY29udGV4dCwgbGlzdGVuZXJzID0gZXZlbnRzTGlzdGVuZXIubGlzdGVuZXJzW2V2Lm5hbWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChsaXN0ZW5lcnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgRXZlbnRNYW5hZ2VyLl9fY2FsbExpc3RlbmVycyhjb250ZXh0LCBldiwgbGlzdGVuZXJzLCBhcmdzKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENhbGxzIGV2ZW50IGxpc3RlbmVycyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0LCBldmVudCwgYW5kIGFyZ3VtZW50cy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IGNvbnRleHQgVGhlIGNvbnRleHQgd2l0aCB3aGljaCB0byBjYWxsIHRoZSBsaXN0ZW5lcnMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5ldmVudHMuRGlzcGF0Y2hFdmVudH0gVGhlIGV2ZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PChldjogRGlzcGF0Y2hFdmVudCwgLi4uYXJnczogYW55W10pID0+IHZvaWQ+fSBUaGUgZXZlbnQgbGlzdGVuZXJzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBzZW5kIHRvIHRoZSBsaXN0ZW5lcnMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFdmVudE1hbmFnZXIuX19jYWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKGNvbnRleHQsIGV2LCBsaXN0ZW5lcnMsIGFyZ3MpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZXYubmFtZSwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aCwgaW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgIGFyZ3MgPSBbZXZdLmNvbmNhdChhcmdzKTtcclxuICAgICAgICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIEV2ZW50TWFuYWdlci5wcm9wYWdhdGluZ0V2ZW50c1tuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpbmRleF0uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEV2ZW50TWFuYWdlci5fbG9nLmRlYnVnKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFuIHVwd2FyZC1tb3ZpbmcgZXZlbnQgd2lsbCBzdGFydCBhdCB0aGUgc2VuZGVyIGFuZCBtb3ZlXHJcbiAgICAgICAgICAgICAqIHVwIHRoZSBwYXJlbnQgY2hhaW4uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFdmVudE1hbmFnZXIuVVAgPSAndXAnO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBkb3dud2FyZC1tb3ZpbmcgZXZlbnQgd2lsbCBzdGFydCBhdCB0aGUgc2VuZGVyIGFuZCBtb3ZlXHJcbiAgICAgICAgICAgICAqIHRvIGl0cyBjaGlsZHJlbiBhbmQgYmV5b25kLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRXZlbnRNYW5hZ2VyLkRPV04gPSAnZG93bic7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHb2VzIHRocm91Z2ggYWxsIGxpc3RlbmVycyBmb3IgYW4gZXZlbnQgbmFtZSwgaWdub3Jpbmcgb3JkZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFdmVudE1hbmFnZXIuRElSRUNUID0gJ2RpcmVjdCc7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBLZWVwcyB0cmFjayBvZiB3aGljaCBldmVudHMgYXJlIGN1cnJlbnRseSBwcm9wYWdhdGluZy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEV2ZW50TWFuYWdlci5wcm9wYWdhdGluZ0V2ZW50cyA9IHt9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSG9sZHMgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMga2V5ZWQgYnkgdWlkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRXZlbnRNYW5hZ2VyLl9fZXZlbnRzTGlzdGVuZXJzID0ge307XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBIb2xkcyBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyBmb3IgdGhlIGFwcGxpY2F0aW9uIGxpZmVmeWNsZSBldmVudHMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFdmVudE1hbmFnZXIuX19saWZlY3ljbGVFdmVudExpc3RlbmVycyA9IFtdO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogd2hldGhlciBvciBub3QgdGhlIGV2ZW50IG1hbmFnZXIgaGFzIGJlZW4gaW5pdGlhbGl6ZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFdmVudE1hbmFnZXIuX19pbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gRXZlbnRNYW5hZ2VyO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgZXZlbnRzLkV2ZW50TWFuYWdlciA9IEV2ZW50TWFuYWdlcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBJRXZlbnRNYW5hZ2VyU3RhdGljKF9sb2csIF9jb21wYXQsIF9kb2N1bWVudCwgX3dpbmRvdywgX2RvbSkge1xyXG4gICAgICAgICAgICBFdmVudE1hbmFnZXIuX2xvZyA9IF9sb2c7XHJcbiAgICAgICAgICAgIEV2ZW50TWFuYWdlci5fY29tcGF0ID0gX2NvbXBhdDtcclxuICAgICAgICAgICAgRXZlbnRNYW5hZ2VyLl9kb2N1bWVudCA9IF9kb2N1bWVudDtcclxuICAgICAgICAgICAgRXZlbnRNYW5hZ2VyLl93aW5kb3cgPSBfd2luZG93O1xyXG4gICAgICAgICAgICBFdmVudE1hbmFnZXIuX2RvbSA9IF9kb207XHJcbiAgICAgICAgICAgIHJldHVybiBFdmVudE1hbmFnZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV2ZW50cy5JRXZlbnRNYW5hZ2VyU3RhdGljID0gSUV2ZW50TWFuYWdlclN0YXRpYztcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fRXZlbnRNYW5hZ2VyU3RhdGljLCBJRXZlbnRNYW5hZ2VyU3RhdGljLCBbXHJcbiAgICAgICAgICAgIF9fTG9nLFxyXG4gICAgICAgICAgICBfX0NvbXBhdCxcclxuICAgICAgICAgICAgX19Eb2N1bWVudCxcclxuICAgICAgICAgICAgX19XaW5kb3csXHJcbiAgICAgICAgICAgIF9fRG9tXHJcbiAgICAgICAgXSwgX19TVEFUSUMpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlcHJlc2VudHMgYW4gaW50ZXJuYWwgRXJyb3IgRXZlbnQuIFRoaXMgaXMgdXNlZCBmb3IgYW55XHJcbiAgICAgICAgICogaW50ZXJuYWwgZXJyb3JzIChib3RoIGZhdGFsIGFuZCB3YXJuaW5ncykuIEFsbCBlcnJvciBldmVudHMgYXJlXHJcbiAgICAgICAgICogZGlyZWN0IGV2ZW50cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgRXJyb3JFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhFcnJvckV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBFcnJvckV2ZW50KCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENyZWF0ZXMgYSBuZXcgRXJyb3JFdmVudCBhbmQgZmlyZXMgaXQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IHNlbmRlciBUaGUgc2VuZGVyIG9mIHRoZSBldmVudC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtFfSBlcnJvciBUaGUgZXJyb3IgdGhhdCBvY2N1cnJlZCwgcmVzdWx0aW5nIGluIHRoZSBldmVudC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGxvZ0xldmVsIFRoZSBzZXZlcml0eSBsZXZlbCBvZiB0aGUgZXJyb3JcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEVycm9yRXZlbnQuZGlzcGF0Y2ggPSBmdW5jdGlvbiAobmFtZSwgc2VuZGVyLCBlcnJvciwgbG9nTGV2ZWwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudCA9IGFjcXVpcmUoRXJyb3JFdmVudCk7XHJcbiAgICAgICAgICAgICAgICBldmVudC5pbml0aWFsaXplKG5hbWUsIHNlbmRlciwgbnVsbCwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgZXZlbnQubG9nTGV2ZWwgPSBsb2dMZXZlbDtcclxuICAgICAgICAgICAgICAgIEVycm9yRXZlbnQuX0V2ZW50TWFuYWdlci5zZW5kRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBFcnJvckV2ZW50LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG5hbWUsIHNlbmRlciwgZGlyZWN0aW9uLCBlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgbmFtZSwgc2VuZGVyLCB0aGlzLl9FdmVudE1hbmFnZXIuRElSRUNUKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIEVycm9yRXZlbnQ7XHJcbiAgICAgICAgfShEaXNwYXRjaEV2ZW50KSk7XHJcbiAgICAgICAgZXZlbnRzLkVycm9yRXZlbnQgPSBFcnJvckV2ZW50O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIElFcnJvckV2ZW50U3RhdGljKF9FdmVudE1hbmFnZXIpIHtcclxuICAgICAgICAgICAgRXJyb3JFdmVudC5fRXZlbnRNYW5hZ2VyID0gX0V2ZW50TWFuYWdlcjtcclxuICAgICAgICAgICAgcmV0dXJuIEVycm9yRXZlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV2ZW50cy5JRXJyb3JFdmVudFN0YXRpYyA9IElFcnJvckV2ZW50U3RhdGljO1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19FcnJvckV2ZW50U3RhdGljLCBJRXJyb3JFdmVudFN0YXRpYywgW19fRXZlbnRNYW5hZ2VyU3RhdGljXSwgX19TVEFUSUMpO1xyXG4gICAgfSkoZXZlbnRzID0gcGxhdF8xLmV2ZW50cyB8fCAocGxhdF8xLmV2ZW50cyA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgZm9yIGZhY2lsaXRhdGluZyBkYXRhIGFuZCBET00gbWFuaXB1bGF0aW9uLiBDb250YWlucyBsaWZlY3ljbGUgZXZlbnRzXHJcbiAgICAgKiBhcyB3ZWxsIGFzIHByb3BlcnRpZXMgZm9yIGNvbW11bmljYXRpbmcgd2l0aCBvdGhlciBjb250cm9scy4gVGhpcyBpcyB0aGUgYmFzZVxyXG4gICAgICogY2xhc3MgZm9yIGFsbCB0eXBlcyBvZiBjb250cm9scy5cclxuICAgICAqL1xyXG4gICAgdmFyIENvbnRyb2wgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjb25zdHJ1Y3RvciBmb3IgYSBjb250cm9sLiBBbnkgaW5qZWN0YWJsZXMgc3BlY2lmaWVkIGR1cmluZyBjb250cm9sIHJlZ2lzdHJhdGlvbiB3aWxsIGJlXHJcbiAgICAgICAgICogcGFzc2VkIGludG8gdGhlIGNvbnN0cnVjdG9yIGFzIGFyZ3VtZW50cyBhcyBsb25nIGFzIHRoZSBjb250cm9sIGlzIGluc3RhbnRpYXRlZCB3aXRoIGl0cyBhc3NvY2lhdGVkXHJcbiAgICAgICAgICogaW5qZWN0b3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gQ29udHJvbCgpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgdW5pcXVlIGlkLCBjcmVhdGVkIGR1cmluZyBpbnN0YW50aWF0aW9uIGFuZCBmb3VuZCBvbiBldmVyeSBDb250cm9sLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy51aWQgPSB1bmlxdWVJZChfX1BsYXQpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU3BlY2lmaWVzIHRoZSBwcmlvcml0eSBvZiB0aGUgY29udHJvbC4gVGhlIHB1cnBvc2Ugb2ZcclxuICAgICAgICAgICAgICogdGhpcyBpcyBzbyB0aGF0IGNvbnRyb2xzIGxpa2UgcGxhdC1iaW5kIGNhbiBoYXZlIGEgaGlnaGVyXHJcbiAgICAgICAgICAgICAqIHByaW9yaXR5IHRoYW4gcGxhdC10YXAuIFRoZSBwbGF0LWJpbmQgd2lsbCBiZSBpbml0aWFsaXplZFxyXG4gICAgICAgICAgICAgKiBhbmQgbG9hZGVkIGJlZm9yZSBwbGF0LXRhcCwgbWVhbmluZyBpdCBoYXMgdGhlIGZpcnN0IGNoYW5jZVxyXG4gICAgICAgICAgICAgKiB0byByZXNwb25kIHRvIGV2ZW50cy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMucHJpb3JpdHkgPSAwO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ29udGFpbnMgRE9NIGhlbHBlciBtZXRob2RzIGZvciBtYW5pcHVsYXRpbmcgdGhpcyBjb250cm9sJ3MgZWxlbWVudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZG9tID0gQ29udHJvbC5fZG9tO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ29udGFpbnMgaGVscGVyIG1ldGhvZHMgZm9yIGRhdGEgbWFuaXB1bGF0aW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy51dGlscyA9IGFjcXVpcmUoX19VdGlscyk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIExvZyBpbmplY3RhYmxlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fbG9nID0gQ29udHJvbC5fbG9nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBDb250cm9sLmdldFJvb3RDb250cm9sID0gZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuICAgICAgICAgICAgaWYgKGlzTnVsbChjb250cm9sKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2w7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzTnVsbChjb250cm9sLnJvb3QpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbC5yb290O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlICghKGlzTnVsbChjb250cm9sLnBhcmVudCkgfHwgY29udHJvbC5oYXNPd25Db250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGwoY29udHJvbC5yb290KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sLnJvb3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250cm9sID0gY29udHJvbC5wYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFjb250cm9sLmhhc093bkNvbnRleHQgJiYgaXNPYmplY3QoY29udHJvbC5jb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgQ29udHJvbC5fbG9nLmRlYnVnKCdSb290IGNvbnRyb2w6ICcgKyBjb250cm9sLnR5cGUgKyAnIGZvdW5kIHRoYXQgc2V0cyBpdHMgY29udGV4dCB0byBhbiBPYmplY3QgYnV0IGRvZXMgbm90IHNldCB0aGUgaGFzT3duQ29udGV4dCAnICtcclxuICAgICAgICAgICAgICAgICAgICAnZmxhZyB0byB0cnVlLiBQbGVhc2Ugc2V0IHRoZSBmbGFnIGlmIHRoZSBjb250cm9sIGludGVuZHMgdG8gdXNlIGl0cyBvd24gY29udGV4dC4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29udHJvbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdpdmVuIGEgY29udHJvbCwgY2FsbHMgdGhlIGxvYWRlZCBtZXRob2QgZm9yIHRoZSBjb250cm9sIGlmIGl0IGV4aXN0cy5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQuQ29udHJvbH0gY29udHJvbCBUaGUgY29udHJvbCB0byBsb2FkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbnRyb2wubG9hZCA9IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcbiAgICAgICAgICAgIHZhciBfUHJvbWlzZSA9IENvbnRyb2wuX1Byb21pc2U7XHJcbiAgICAgICAgICAgIGlmIChpc051bGwoY29udHJvbCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGN0cmwgPSBjb250cm9sO1xyXG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcoY3RybC5hYnNvbHV0ZUNvbnRleHRQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oY3RybC5jb250ZXh0Q2hhbmdlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dE1hbmFnZXIgPSBDb250cm9sLl9Db250ZXh0TWFuYWdlci5nZXRNYW5hZ2VyKGN0cmwucm9vdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dE1hbmFnZXIub2JzZXJ2ZShjdHJsLmFic29sdXRlQ29udGV4dFBhdGgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdWlkOiBjb250cm9sLnVpZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IF9fQ09OVEVYVF9DSEFOR0VEX1BSSU9SSVRZLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcjogZnVuY3Rpb24gKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWkuVGVtcGxhdGVDb250cm9sLmNvbnRleHRDaGFuZ2VkKGNvbnRyb2wsIG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihjdHJsLnpDQ19fcGxhdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC56Q0NfX3BsYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkoY3RybCwgJ3pDQ19fcGxhdCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gY3RybC5lbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTm9kZShlbGVtZW50KSAmJiBpc0Z1bmN0aW9uKGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKF9fSGlkZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oY29udHJvbC5sb2FkZWQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX1Byb21pc2UucmVzb2x2ZShjb250cm9sLmxvYWRlZCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX1Byb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGlzcG9zZXMgYWxsIHRoZSBuZWNlc3NhcnkgbWVtb3J5IGZvciBhIGNvbnRyb2wuIFVzZXMgc3BlY2lmaWMgZGlzcG9zZVxyXG4gICAgICAgICAqIG1ldGhvZHMgcmVsYXRlZCB0byBhIGNvbnRyb2wncyBjb25zdHJ1Y3RvciBpZiBuZWNlc3NhcnkuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LkNvbnRyb2x9IGNvbnRyb2wgVGhlIENvbnRyb2wgdG8gZGlzcG9zZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb250cm9sLmRpc3Bvc2UgPSBmdW5jdGlvbiAoY29udHJvbCkge1xyXG4gICAgICAgICAgICB2YXIgY3RybCA9IGNvbnRyb2w7XHJcbiAgICAgICAgICAgIGlmIChpc051bGwoY3RybCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghaXNVbmRlZmluZWQoY3RybC50ZW1wbGF0ZUNvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICBBdHRyaWJ1dGVDb250cm9sLmRpc3Bvc2UoY3RybCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY3RybC5oYXNPd25Db250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB1aS5WaWV3Q29udHJvbC5kaXNwb3NlKGN0cmwpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGN0cmwuY29udHJvbHMpIHtcclxuICAgICAgICAgICAgICAgIHVpLlRlbXBsYXRlQ29udHJvbC5kaXNwb3NlKGN0cmwpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGNvbnRyb2wuZGlzcG9zZSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2wuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIENvbnRyb2wucmVtb3ZlRXZlbnRMaXN0ZW5lcnMoY29udHJvbCk7XHJcbiAgICAgICAgICAgIENvbnRyb2wuX0NvbnRleHRNYW5hZ2VyLmRpc3Bvc2UoY29udHJvbCk7XHJcbiAgICAgICAgICAgIGNvbnRyb2wuZWxlbWVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIENvbnRyb2wucmVtb3ZlUGFyZW50KGNvbnRyb2wpO1xyXG4gICAgICAgICAgICBpZiAoY29udHJvbC5fX2luamVjdGFibGVfX3R5cGUgPT09IF9fU1RBVElDKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5qZWN0b3IgPSBjb250cm9sSW5qZWN0b3JzW2NvbnRyb2wudHlwZV07XHJcbiAgICAgICAgICAgICAgICByZWdpc3Rlci5jb250cm9sKGNvbnRyb2wudHlwZSwgY29udHJvbC5jb25zdHJ1Y3RvciwgaW5qZWN0b3IuZGVwZW5kZW5jaWVzLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3BsaWNlcyBhIGNvbnRyb2wgZnJvbSBpdHMgcGFyZW50J3MgY29udHJvbHMgbGlzdC4gU2V0cyB0aGUgY29udHJvbCdzIHBhcmVudFxyXG4gICAgICAgICAqIHRvIG51bGwuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LkNvbnRyb2x9IGNvbnRyb2wgVGhlIGNvbnRyb2wgd2hvc2UgcGFyZW50IHdpbGwgYmUgcmVtb3ZlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb250cm9sLnJlbW92ZVBhcmVudCA9IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcbiAgICAgICAgICAgIGlmIChpc051bGwoY29udHJvbCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gY29udHJvbC5wYXJlbnQ7XHJcbiAgICAgICAgICAgIGlmIChpc051bGwocGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjb250cm9scyA9IHBhcmVudC5jb250cm9scyB8fCBbXSwgaW5kZXggPSBjb250cm9scy5pbmRleE9mKGNvbnRyb2wpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBjb250cm9scy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRyb2wucGFyZW50ID0gbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgYWxsIGV2ZW50IGxpc3RlbmVycyBmb3IgYSBjb250cm9sIHdpdGggdGhlIGdpdmVuIHVpZC5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQuQ29udHJvbH0gY29udHJvbCBUaGUgY29udHJvbCBoYXZpbmcgaXRzIGV2ZW50IGxpc3RlbmVycyByZW1vdmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbnRyb2wucmVtb3ZlRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoY29udHJvbCkge1xyXG4gICAgICAgICAgICBpZiAoaXNOdWxsKGNvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJlbW92ZUxpc3RlbmVycyA9IENvbnRyb2wuX19ldmVudExpc3RlbmVycywgdWlkID0gY29udHJvbC51aWQ7XHJcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSByZW1vdmVMaXN0ZW5lcnNbdWlkXTtcclxuICAgICAgICAgICAgaWYgKGlzQXJyYXkobGlzdGVuZXJzKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbGlzdGVuZXJzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleC0tID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpbmRleF0oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KHJlbW92ZUxpc3RlbmVycywgdWlkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiBDb250cm9sLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbnRyb2wuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29udHJvbCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIGZ1bmN0aW9uIHRvIHJlbW92ZSBhbiBldmVudCBsaXN0ZW5lciBmb3IgdGhlIGNvbnRyb2wgc3BlY2lmaWVkXHJcbiAgICAgICAgICogYnkgaXRzIHVpZC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdWlkIFRoZSB1aWQgb2YgdGhlIGNvbnRyb2wgYXNzb2NpYXRlZCB3aXRoIHRoZSByZW1vdmUgZnVuY3Rpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LklSZW1vdmVMaXN0ZW5lcn0gbGlzdGVuZXIgVGhlIHJlbW92ZSBmdW5jdGlvbiB0byBhZGQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29udHJvbC5fX2FkZFJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKHVpZCwgbGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgdmFyIHJlbW92ZUxpc3RlbmVycyA9IENvbnRyb2wuX19ldmVudExpc3RlbmVycztcclxuICAgICAgICAgICAgaWYgKGlzQXJyYXkocmVtb3ZlTGlzdGVuZXJzW3VpZF0pKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcnNbdWlkXS5wdXNoKGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZW1vdmVMaXN0ZW5lcnNbdWlkXSA9IFtsaXN0ZW5lcl07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGEgSVJlbW92ZUxpc3RlbmVyIGZyb20gYSBjb250cm9sJ3MgbGlzdGVuZXJzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1aWQgVGhlIHVpZCBvZiB0aGUgY29udHJvbCBhc3NvY2lhdGVkIHdpdGggdGhlIHJlbW92ZSBmdW5jdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQuSVJlbW92ZUxpc3RlbmVyfSBsaXN0ZW5lciBUaGUgcmVtb3ZlIGZ1bmN0aW9uIHRvIGFkZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb250cm9sLl9fc3BsaWNlUmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAodWlkLCBsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICB2YXIgcmVtb3ZlTGlzdGVuZXJzID0gQ29udHJvbC5fX2V2ZW50TGlzdGVuZXJzLCBjb250cm9sTGlzdGVuZXJzID0gcmVtb3ZlTGlzdGVuZXJzW3VpZF07XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KGNvbnRyb2xMaXN0ZW5lcnMpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBjb250cm9sTGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRyb2xMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBjb250cm9scyB0aGF0IGhhdmUgYSBzcGVjaWZpYyBrZXkvdmFsdWUgc3RyaW5nIHBhaXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LkNvbnRyb2x9IGNvbnRyb2wgVGhlIGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZyBmb3Iga2V5L3ZhbHVlIHBhaXJzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yIG9uIGFsbCB0aGUgY29udHJvbHMgaW4gdGhlIHRyZWUuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSBleHBlY3RlZCB2YWx1ZSB1c2VkIHRvIGZpbmQgc2ltaWxhciBjb250cm9scy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb250cm9sLl9fZ2V0Q29udHJvbHMgPSBmdW5jdGlvbiAoY29udHJvbCwga2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgY29udHJvbHMgPSBbXSwgcm9vdCA9IENvbnRyb2wuZ2V0Um9vdENvbnRyb2woY29udHJvbCksIGNoaWxkO1xyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbChyb290KSAmJiByb290W2tleV0gPT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb250cm9scy5wdXNoKHJvb3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHJvb3QuY29udHJvbHM7XHJcbiAgICAgICAgICAgIGlmIChpc051bGwoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHF1ZXVlID0gW10uY29uY2F0KGNoaWxkcmVuKTtcclxuICAgICAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkID0gcXVldWUuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZFtrZXldID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xzLnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChjaGlsZC5jb250cm9scykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHF1ZXVlID0gcXVldWUuY29uY2F0KGNoaWxkLmNvbnRyb2xzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29udHJvbHM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgaW5pdGlhbGl6ZSBldmVudCBtZXRob2QgZm9yIGEgY29udHJvbC4gSW4gdGhpcyBtZXRob2QgYSBjb250cm9sIHNob3VsZCBpbml0aWFsaXplIGFsbCB0aGUgbmVjZXNzYXJ5XHJcbiAgICAgICAgICogdmFyaWFibGVzLiBUaGlzIG1ldGhvZCBpcyB0eXBpY2FsbHkgb25seSBuZWNlc3NhcnkgZm9yIHZpZXcgY29udHJvbHMuIElmIGEgY29udHJvbCBkb2VzIG5vdCBpbXBsZW1lbnRcclxuICAgICAgICAgKiBJQmFzZVZpZXdDb250cm9sIHRoZW4gaXQgaXMgbm90IHNhZmUgdG8gYWNjZXNzLCBvYnNlcnZlLCBvciBtb2RpZnlcclxuICAgICAgICAgKiB0aGUgY29udGV4dCBwcm9wZXJ0eSBpbiB0aGlzIG1ldGhvZC4gQSB2aWV3IGNvbnRyb2wgc2hvdWxkIGNhbGwgc2VydmljZXMvc2V0IGNvbnRleHQgaW4gdGhpcyBtZXRob2QgaW5cclxuICAgICAgICAgKiBvcmRlciB0byBmaXJlIHRoZSBsb2FkZWQgZXZlbnQuIE5vIGNvbnRyb2wgd2lsbCBiZSBsb2FkZWQgdW50aWwgdGhlIHZpZXcgY29udHJvbCBoYXMgc3BlY2lmaWVkIGEgY29udGV4dC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb250cm9sLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBsb2FkZWQgZXZlbnQgbWV0aG9kIGZvciBhIGNvbnRyb2wuIFRoaXMgZXZlbnQgaXMgZmlyZWQgYWZ0ZXIgYSBjb250cm9sIGhhcyBiZWVuIGxvYWRlZCxcclxuICAgICAgICAgKiBtZWFuaW5nIGFsbCBvZiBpdHMgY2hpbGRyZW4gaGF2ZSBhbHNvIGJlZW4gbG9hZGVkIGFuZCBpbml0aWFsIERPTSBoYXMgYmVlbiBjcmVhdGVkIGFuZCBwb3B1bGF0ZWQuIEl0IGlzIG5vd1xyXG4gICAgICAgICAqIHNhZmUgZm9yIGFsbCBjb250cm9scyB0byBhY2Nlc3MsIG9ic2VydmUsIGFuZCBtb2RpZnkgdGhlIGNvbnRleHQgcHJvcGVydHkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29udHJvbC5wcm90b3R5cGUubG9hZGVkID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHJpZXZlcyBhbGwgdGhlIGNvbnRyb2xzIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBzdHJpbmcgbmFtZSB3aXRoIHdoaWNoIHRvIHBvcHVsYXRlIHRoZSByZXR1cm5lZCBjb250cm9scyBhcnJheS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb250cm9sLnByb3RvdHlwZS5nZXRDb250cm9sc0J5TmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDb250cm9sLl9fZ2V0Q29udHJvbHModGhpcywgJ25hbWUnLCBuYW1lKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIENvbnRyb2wucHJvdG90eXBlLmdldENvbnRyb2xzQnlUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKHR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29udHJvbC5fX2dldENvbnRyb2xzKHRoaXMsICd0eXBlJywgdHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIENvbnRyb2wuX19nZXRDb250cm9scyh0aGlzLCAnY29uc3RydWN0b3InLCB0eXBlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIENvbnRyb2wucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgdHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcclxuICAgICAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oJ1wiQ29udHJvbC5hZGRFdmVudExpc3RlbmVyXCIgbXVzdCB0YWtlIGEgZnVuY3Rpb24gYXMgdGhlIHRoaXJkIGFyZ3VtZW50LicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vb3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICB2YXIgcmVtb3ZlTGlzdGVuZXIgPSB0aGlzLmRvbS5hZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSwgdWlkID0gdGhpcy51aWQ7XHJcbiAgICAgICAgICAgIENvbnRyb2wuX19hZGRSZW1vdmVMaXN0ZW5lcih1aWQsIHJlbW92ZUxpc3RlbmVyKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgICAgICBDb250cm9sLl9fc3BsaWNlUmVtb3ZlTGlzdGVuZXIodWlkLCByZW1vdmVMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDb250cm9sLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24gKGxpc3RlbmVyLCBpZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBjb250cm9sID0gaXNPYmplY3QodGhpcy5jb250ZXh0KSA/IHRoaXMgOiB0aGlzLnBhcmVudCwgcm9vdCA9IENvbnRyb2wuZ2V0Um9vdENvbnRyb2woY29udHJvbCk7XHJcbiAgICAgICAgICAgIGlmIChpc051bGwoY29udHJvbCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub29wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTnVsbChjb250cm9sLmFic29sdXRlQ29udGV4dFBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cud2FybignU2hvdWxkIG5vdCBjYWxsIHBsYXQuQ29udHJvbC5vYnNlcnZlIHByaW9yIHRvIHRoZSBjb250cm9sIGJlaW5nIGxvYWRlZCcpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vb3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGFic29sdXRlSWRlbnRpZmllcjtcclxuICAgICAgICAgICAgaWYgKGlzRW1wdHkoaWRlbnRpZmllcikpIHtcclxuICAgICAgICAgICAgICAgIGFic29sdXRlSWRlbnRpZmllciA9IGNvbnRyb2wuYWJzb2x1dGVDb250ZXh0UGF0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1N0cmluZyhpZGVudGlmaWVyKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkZW50aWZpZXJFeHByZXNzaW9uID0gKENvbnRyb2wuX3BhcnNlciB8fCBhY3F1aXJlKF9fUGFyc2VyKSkucGFyc2UoaWRlbnRpZmllciksIGlkZW50aWZpZXJzID0gaWRlbnRpZmllckV4cHJlc3Npb24uaWRlbnRpZmllcnM7XHJcbiAgICAgICAgICAgICAgICBpZiAoaWRlbnRpZmllcnMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKCdPbmx5IGEgc2luZ2xlIGlkZW50aWZpZXIgY2FuIGJlIG9ic2VydmVkIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb24gcGxhdC5Db250cm9sLm9ic2VydmUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gaWRlbnRpZmllckV4cHJlc3Npb24uaWRlbnRpZmllcnNbMF07XHJcbiAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvblswXSA9PT0gJ0AnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwbGl0ID0gZXhwcmVzc2lvbi5zcGxpdCgnLicpLCBzdGFydCA9IHNwbGl0LnNoaWZ0KCkuc2xpY2UoMSksIGpvaW4gPSBzcGxpdC5sZW5ndGggPiAwID8gKCcuJyArIHNwbGl0LmpvaW4oJy4nKSkgOiAnJztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT09IF9fUk9PVF9DT05URVhUX1JFU09VUkNFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFic29sdXRlSWRlbnRpZmllciA9IF9fQ09OVEVYVCArIGpvaW47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0ID09PSBfX0NPTlRFWFRfUkVTT1VSQ0UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVJZGVudGlmaWVyID0gY29udHJvbC5hYnNvbHV0ZUNvbnRleHRQYXRoICsgam9pbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFic29sdXRlSWRlbnRpZmllciA9IGNvbnRyb2wuYWJzb2x1dGVDb250ZXh0UGF0aCArICcuJyArIGV4cHJlc3Npb247XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVJZGVudGlmaWVyID0gY29udHJvbC5hYnNvbHV0ZUNvbnRleHRQYXRoICsgJy4nICsgZXhwcmVzc2lvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFic29sdXRlSWRlbnRpZmllciA9IGNvbnRyb2wuYWJzb2x1dGVDb250ZXh0UGF0aCArICcuJyArIGlkZW50aWZpZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIF9Db250ZXh0TWFuYWdlciA9IENvbnRyb2wuX0NvbnRleHRNYW5hZ2VyIHx8IGFjcXVpcmUoX19Db250ZXh0TWFuYWdlclN0YXRpYyksIGNvbnRleHRNYW5hZ2VyID0gX0NvbnRleHRNYW5hZ2VyLmdldE1hbmFnZXIocm9vdCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0TWFuYWdlci5vYnNlcnZlKGFic29sdXRlSWRlbnRpZmllciwge1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXI6IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYWxsKF90aGlzLCBuZXdWYWx1ZSwgb2xkVmFsdWUsIGlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHVpZDogdGhpcy51aWRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDb250cm9sLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiAobGlzdGVuZXIsIGlkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSBpc09iamVjdCh0aGlzLmNvbnRleHQpID8gdGhpcyA6IHRoaXMucGFyZW50LCBjb250ZXh0ID0gY29udHJvbC5jb250ZXh0O1xyXG4gICAgICAgICAgICBpZiAoaXNOdWxsKGNvbnRyb2wpIHx8ICFpc09iamVjdChjb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vb3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGFycmF5LCBhYnNvbHV0ZUlkZW50aWZpZXI7XHJcbiAgICAgICAgICAgIGlmIChpc0VtcHR5KGlkZW50aWZpZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBhcnJheSA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICBhYnNvbHV0ZUlkZW50aWZpZXIgPSBjb250cm9sLmFic29sdXRlQ29udGV4dFBhdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNTdHJpbmcoaWRlbnRpZmllcikpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpZGVudGlmaWVyRXhwcmVzc2lvbiA9IChDb250cm9sLl9wYXJzZXIgfHwgYWNxdWlyZShfX1BhcnNlcikpLnBhcnNlKGlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgYXJyYXkgPSBpZGVudGlmaWVyRXhwcmVzc2lvbi5ldmFsdWF0ZShjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIGFic29sdXRlSWRlbnRpZmllciA9IGNvbnRyb2wuYWJzb2x1dGVDb250ZXh0UGF0aCArICcuJyArIGlkZW50aWZpZXJFeHByZXNzaW9uLmlkZW50aWZpZXJzWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYXJyYXkgPSBjb250ZXh0W2lkZW50aWZpZXJdO1xyXG4gICAgICAgICAgICAgICAgYWJzb2x1dGVJZGVudGlmaWVyID0gY29udHJvbC5hYnNvbHV0ZUNvbnRleHRQYXRoICsgJy4nICsgaWRlbnRpZmllcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzQXJyYXkoYXJyYXkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9vcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbihsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIGlmICghbGlzdGVuZXJJc0Z1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9vcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLmJpbmQodGhpcyk7XHJcbiAgICAgICAgICAgIHZhciBDb250ZXh0TWFuYWdlciA9IENvbnRyb2wuX0NvbnRleHRNYW5hZ2VyIHx8IGFjcXVpcmUoX19Db250ZXh0TWFuYWdlclN0YXRpYyksIGNvbnRleHRNYW5hZ2VyID0gQ29udGV4dE1hbmFnZXIuZ2V0TWFuYWdlcihDb250cm9sLmdldFJvb3RDb250cm9sKGNvbnRyb2wpKSwgdWlkID0gdGhpcy51aWQsIGNhbGxiYWNrID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyKGNoYW5nZXMsIGlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICB9LCByZW1vdmVMaXN0ZW5lciA9IGNvbnRleHRNYW5hZ2VyLm9ic2VydmVBcnJheU11dGF0aW9uKHVpZCwgY2FsbGJhY2ssIGFic29sdXRlSWRlbnRpZmllciwgYXJyYXksIG51bGwpLCByZW1vdmVDYWxsYmFjayA9IGNvbnRleHRNYW5hZ2VyLm9ic2VydmUoYWJzb2x1dGVJZGVudGlmaWVyLCB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcjogZnVuY3Rpb24gKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIgPSBjb250ZXh0TWFuYWdlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAub2JzZXJ2ZUFycmF5TXV0YXRpb24odWlkLCBjYWxsYmFjaywgYWJzb2x1dGVJZGVudGlmaWVyLCBuZXdWYWx1ZSwgb2xkVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHVpZDogdWlkXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgIHJlbW92ZUNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDb250cm9sLnByb3RvdHlwZS5vYnNlcnZlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChsaXN0ZW5lciwgZXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoaXNFbXB0eShleHByZXNzaW9uKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vb3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGV4cHJlc3Npb24pKSB7XHJcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gKENvbnRyb2wuX3BhcnNlciB8fCBhY3F1aXJlKF9fUGFyc2VyKSkucGFyc2UoZXhwcmVzc2lvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzRnVuY3Rpb24oZXhwcmVzc2lvbi5ldmFsdWF0ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub29wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjb250cm9sID0gIWlzTnVsbCh0aGlzLnJlc291cmNlcykgP1xyXG4gICAgICAgICAgICAgICAgdGhpcyA6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudDtcclxuICAgICAgICAgICAgaWYgKGlzTnVsbChjb250cm9sKSB8fCAhaXNTdHJpbmcoY29udHJvbC5hYnNvbHV0ZUNvbnRleHRQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vb3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGFsaWFzZXMgPSBleHByZXNzaW9uLmFsaWFzZXMsIGFsaWFzLCBsZW5ndGggPSBhbGlhc2VzLmxlbmd0aCwgcmVzb3VyY2VzID0ge30sIHJlc291cmNlT2JqLCBDb250ZXh0TWFuYWdlciA9IENvbnRyb2wuX0NvbnRleHRNYW5hZ2VyIHx8IGFjcXVpcmUoX19Db250ZXh0TWFuYWdlclN0YXRpYyksIGdldE1hbmFnZXIgPSBDb250ZXh0TWFuYWdlci5nZXRNYW5hZ2VyLCBUZW1wbGF0ZUNvbnRyb2wgPSB1aS5UZW1wbGF0ZUNvbnRyb2wsIGZpbmRSZXNvdXJjZSA9IFRlbXBsYXRlQ29udHJvbC5maW5kUmVzb3VyY2UsIGV2YWx1YXRlRXhwcmVzc2lvbiA9IFRlbXBsYXRlQ29udHJvbC5ldmFsdWF0ZUV4cHJlc3Npb24sIHR5cGUsIGk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgYWxpYXMgPSBhbGlhc2VzW2ldO1xyXG4gICAgICAgICAgICAgICAgcmVzb3VyY2VPYmogPSBmaW5kUmVzb3VyY2UoY29udHJvbCwgYWxpYXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGwocmVzb3VyY2VPYmopKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHJlc291cmNlT2JqLnJlc291cmNlLnR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IF9fT0JTRVJWQUJMRV9SRVNPVVJDRSB8fCB0eXBlID09PSBfX0xJVEVSQUxfUkVTT1VSQ0UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VzW2FsaWFzXSA9IGdldE1hbmFnZXIocmVzb3VyY2VPYmouY29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpZGVudGlmaWVycyA9IGV4cHJlc3Npb24uaWRlbnRpZmllcnMsIGNvbnRleHRNYW5hZ2VyID0gZ2V0TWFuYWdlcihDb250cm9sLmdldFJvb3RDb250cm9sKGNvbnRyb2wpKSwgaWRlbnRpZmllciwgc3BsaXQgPSBbXSwgdG9wSWRlbnRpZmllciwgYWJzb2x1dGVDb250ZXh0UGF0aCA9IGNvbnRyb2wuYWJzb2x1dGVDb250ZXh0UGF0aCwgYWJzb2x1dGVQYXRoID0gYWJzb2x1dGVDb250ZXh0UGF0aCArICcuJywgbWFuYWdlcnMgPSB7fTtcclxuICAgICAgICAgICAgbGVuZ3RoID0gaWRlbnRpZmllcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSBpZGVudGlmaWVyc1tpXTtcclxuICAgICAgICAgICAgICAgIHNwbGl0ID0gaWRlbnRpZmllci5zcGxpdCgnLicpO1xyXG4gICAgICAgICAgICAgICAgdG9wSWRlbnRpZmllciA9IHNwbGl0WzBdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlkZW50aWZpZXJbMF0gPT09ICdAJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsaWFzID0gdG9wSWRlbnRpZmllci5zbGljZSgxKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxpYXMgPT09IF9fQ09OVEVYVF9SRVNPVVJDRSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYW5hZ2Vyc1thYnNvbHV0ZUNvbnRleHRQYXRoICsgaWRlbnRpZmllci5yZXBsYWNlKHRvcElkZW50aWZpZXIsICcnKV0gPSBjb250ZXh0TWFuYWdlcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYWxpYXMgPT09IF9fUk9PVF9DT05URVhUX1JFU09VUkNFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hbmFnZXJzW2lkZW50aWZpZXIucmVwbGFjZSh0b3BJZGVudGlmaWVyLCAnY29udGV4dCcpXSA9IGNvbnRleHRNYW5hZ2VyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllciA9IGlkZW50aWZpZXIucmVwbGFjZSh0b3BJZGVudGlmaWVyLCAncmVzb3VyY2VzLicgKyBhbGlhcyArICcudmFsdWUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc051bGwocmVzb3VyY2VzW2FsaWFzXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hbmFnZXJzW2lkZW50aWZpZXJdID0gcmVzb3VyY2VzW2FsaWFzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1hbmFnZXJzW2Fic29sdXRlUGF0aCArIGlkZW50aWZpZXJdID0gY29udGV4dE1hbmFnZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWRlbnRpZmllcnMgPSBPYmplY3Qua2V5cyhtYW5hZ2Vycyk7XHJcbiAgICAgICAgICAgIGxlbmd0aCA9IGlkZW50aWZpZXJzLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gZXZhbHVhdGVFeHByZXNzaW9uKGV4cHJlc3Npb24sIGNvbnRyb2wpLCBsaXN0ZW5lcnMgPSBbXSwgdWlkID0gdGhpcy51aWQsIG9ic2VydmFibGVMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGV2YWx1YXRlRXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250cm9sKTtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwoX3RoaXMsIHZhbHVlLCBvbGRWYWx1ZSwgZXhwcmVzc2lvbi5leHByZXNzaW9uKTtcclxuICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgaWRlbnRpZmllciA9IGlkZW50aWZpZXJzW2ldO1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2gobWFuYWdlcnNbaWRlbnRpZmllcl0ub2JzZXJ2ZShpZGVudGlmaWVyLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdWlkOiB1aWQsXHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXI6IG9ic2VydmFibGVMaXN0ZW5lclxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGlfMSA9IDA7IGlfMSA8IGxlbmd0aDsgKytpXzEpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbaV8xXSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ29udHJvbC5wcm90b3R5cGUuZXZhbHVhdGVFeHByZXNzaW9uID0gZnVuY3Rpb24gKGV4cHJlc3Npb24sIGFsaWFzZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVpLlRlbXBsYXRlQ29udHJvbC5ldmFsdWF0ZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgdGhpcy5wYXJlbnQsIGFsaWFzZXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmluZHMgdGhlIGZpcnN0IGluc3RhbmNlIG9mIHRoZSBzcGVjaWZpZWQgcHJvcGVydHlcclxuICAgICAgICAgKiBpbiB0aGUgcGFyZW50IGNvbnRyb2wgY2hhaW4uIFJldHVybnMgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIHByb3BlcnR5IGlkZW50aWZlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbnRyb2wucHJvdG90eXBlLmZpbmRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICB2YXIgY29udHJvbCA9IHRoaXMsIGV4cHJlc3Npb24gPSAoQ29udHJvbC5fcGFyc2VyIHx8IGFjcXVpcmUoX19QYXJzZXIpKS5wYXJzZShwcm9wZXJ0eSksIHZhbHVlO1xyXG4gICAgICAgICAgICB3aGlsZSAoIWlzTnVsbChjb250cm9sKSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBleHByZXNzaW9uLmV2YWx1YXRlKGNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGwodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc3Npb246IGV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2w6IGNvbnRyb2wsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250cm9sID0gY29udHJvbC5wYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIENvbnRyb2wucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtYW5hZ2VyID0gQ29udHJvbC5fRXZlbnRNYW5hZ2VyIHx8IGFjcXVpcmUoX19FdmVudE1hbmFnZXJTdGF0aWMpO1xyXG4gICAgICAgICAgICBpZiAoIW1hbmFnZXIuaGFzRGlyZWN0aW9uKGRpcmVjdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoZGlyZWN0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MudW5zaGlmdChkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gbWFuYWdlci5VUDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc2VuZGVyID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKCFpc051bGwoc2VuZGVyLnRlbXBsYXRlQ29udHJvbCkpIHtcclxuICAgICAgICAgICAgICAgIHNlbmRlciA9IHNlbmRlci50ZW1wbGF0ZUNvbnRyb2w7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWFuYWdlci5kaXNwYXRjaChuYW1lLCBzZW5kZXIsIGRpcmVjdGlvbiwgYXJncyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciBmb3IgYSBEaXNwYXRjaEV2ZW50LiBUaGUgbGlzdGVuZXIgd2lsbCBiZSBjYWxsZWQgd2hlbiBhXHJcbiAgICAgICAgICogRGlzcGF0Y2hFdmVudCBpcyBwcm9wYWdhdGluZyBvdmVyIHRoZSBjb250cm9sLiBBbnkgbnVtYmVyIG9mIGxpc3RlbmVycyBjYW4gZXhpc3RcclxuICAgICAgICAgKiBmb3IgYSBzaW5nbGUgZXZlbnQgbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQsIGNvb2luY2lkaW5nIHdpdGggdGhlIERpc3BhdGNoRXZlbnQgbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0geyhldjogcGxhdC5ldmVudHMuRGlzcGF0Y2hFdmVudCwgLi4uYXJnczogQXJyYXk8YW55PikgPT4gdm9pZH0gbGlzdGVuZXIgVGhlIG1ldGhvZCBjYWxsZWQgd2hlbiB0aGVcclxuICAgICAgICAgKiBEaXNwYXRjaEV2ZW50IGlzIGZpcmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbnRyb2wucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKG5hbWUsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIHZhciBfRXZlbnRNYW5hZ2VyID0gQ29udHJvbC5fRXZlbnRNYW5hZ2VyIHx8IGFjcXVpcmUoX19FdmVudE1hbmFnZXJTdGF0aWMpO1xyXG4gICAgICAgICAgICByZXR1cm4gX0V2ZW50TWFuYWdlci5vbih0aGlzLnVpZCwgbmFtZSwgbGlzdGVuZXIsIHRoaXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGRpc3Bvc2UgZXZlbnQgaXMgY2FsbGVkIHdoZW4gYSBjb250cm9sIGlzIGJlaW5nIHJlbW92ZWQgZnJvbSBtZW1vcnkuIEEgY29udHJvbCBzaG91bGQgcmVsZWFzZVxyXG4gICAgICAgICAqIGFsbCBvZiB0aGUgbWVtb3J5IGl0IGlzIHVzaW5nLCBpbmNsdWRpbmcgRE9NIGV2ZW50IGFuZCBwcm9wZXJ0eSBsaXN0ZW5lcnMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29udHJvbC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbiBvYmplY3QgY29udGFpbmluZyBhbGwgY29udHJvbHMnIHJlZ2lzdGVyZWQgZXZlbnQgbGlzdGVuZXJzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbnRyb2wuX19ldmVudExpc3RlbmVycyA9IHt9O1xyXG4gICAgICAgIHJldHVybiBDb250cm9sO1xyXG4gICAgfSgpKTtcclxuICAgIHBsYXRfMS5Db250cm9sID0gQ29udHJvbDtcclxuICAgIC8qKlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBJQ29udHJvbEZhY3RvcnkoX3BhcnNlciwgX0NvbnRleHRNYW5hZ2VyLCBfRXZlbnRNYW5hZ2VyLCBfUHJvbWlzZSwgX2RvbSwgX2xvZykge1xyXG4gICAgICAgIENvbnRyb2wuX3BhcnNlciA9IF9wYXJzZXI7XHJcbiAgICAgICAgQ29udHJvbC5fQ29udGV4dE1hbmFnZXIgPSBfQ29udGV4dE1hbmFnZXI7XHJcbiAgICAgICAgQ29udHJvbC5fRXZlbnRNYW5hZ2VyID0gX0V2ZW50TWFuYWdlcjtcclxuICAgICAgICBDb250cm9sLl9Qcm9taXNlID0gX1Byb21pc2U7XHJcbiAgICAgICAgQ29udHJvbC5fZG9tID0gX2RvbTtcclxuICAgICAgICBDb250cm9sLl9sb2cgPSBfbG9nO1xyXG4gICAgICAgIHJldHVybiBDb250cm9sO1xyXG4gICAgfVxyXG4gICAgcGxhdF8xLklDb250cm9sRmFjdG9yeSA9IElDb250cm9sRmFjdG9yeTtcclxuICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19Db250cm9sRmFjdG9yeSwgSUNvbnRyb2xGYWN0b3J5LCBbXHJcbiAgICAgICAgX19QYXJzZXIsXHJcbiAgICAgICAgX19Db250ZXh0TWFuYWdlclN0YXRpYyxcclxuICAgICAgICBfX0V2ZW50TWFuYWdlclN0YXRpYyxcclxuICAgICAgICBfX1Byb21pc2UsXHJcbiAgICAgICAgX19Eb20sXHJcbiAgICAgICAgX19Mb2dcclxuICAgIF0sIF9fRkFDVE9SWSk7XHJcbiAgICAvKipcclxuICAgICAqIEEgdHlwZSBvZiBjb250cm9sIHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gYXR0cmlidXRlIGJ1dCB3aWxsXHJcbiAgICAgKiBub3QgYmUgdXNlZCB0byBhZGQsIHJlbW92ZSwgb3IgbW9kaWZ5IERPTS5cclxuICAgICAqL1xyXG4gICAgdmFyIEF0dHJpYnV0ZUNvbnRyb2wgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhBdHRyaWJ1dGVDb250cm9sLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEF0dHJpYnV0ZUNvbnRyb2woKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU3BlY2lmaWVzIHRoZSBUZW1wbGF0ZUNvbnRyb2wgYXNzb2NpYXRlZCB3aXRoIHRoaXNcclxuICAgICAgICAgICAgICogY29udHJvbCdzIGVsZW1lbnQuIENhbiBiZSBudWxsIGlmIG5vIFRlbXBsYXRlQ29udHJvbFxyXG4gICAgICAgICAgICAgKiBleGlzdHMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlQ29udHJvbCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1ldGhvZCBmb3IgZGlzcG9zaW5nIGFuIGF0dHJpYnV0ZSBjb250cm9sLiBSZW1vdmVzIGFueVxyXG4gICAgICAgICAqIG5lY2Vzc2FyeSBvYmplY3RzIGZyb20gdGhlIGNvbnRyb2wuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LkF0dHJpYnV0ZUNvbnRyb2x9IGNvbnRyb2wgVGhlIEF0dHJpYnV0ZUNvbnRyb2wgdG8gZGlzcG9zZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBdHRyaWJ1dGVDb250cm9sLmRpc3Bvc2UgPSBmdW5jdGlvbiAoY29udHJvbCkge1xyXG4gICAgICAgICAgICBkZWxldGVQcm9wZXJ0eShjb250cm9sLCAndGVtcGxhdGVDb250cm9sJyk7XHJcbiAgICAgICAgICAgIENvbnRyb2wuZGlzcG9zZShjb250cm9sKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBuZXcgaW5zdGFuY2Ugb2YgQXR0cmlidXRlQ29udHJvbC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBdHRyaWJ1dGVDb250cm9sLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZUNvbnRyb2woKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBBdHRyaWJ1dGVDb250cm9sO1xyXG4gICAgfShDb250cm9sKSk7XHJcbiAgICBwbGF0XzEuQXR0cmlidXRlQ29udHJvbCA9IEF0dHJpYnV0ZUNvbnRyb2w7XHJcbiAgICAvKipcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gSUF0dHJpYnV0ZUNvbnRyb2xGYWN0b3J5KCkge1xyXG4gICAgICAgIHJldHVybiBBdHRyaWJ1dGVDb250cm9sO1xyXG4gICAgfVxyXG4gICAgcGxhdF8xLklBdHRyaWJ1dGVDb250cm9sRmFjdG9yeSA9IElBdHRyaWJ1dGVDb250cm9sRmFjdG9yeTtcclxuICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19BdHRyaWJ1dGVDb250cm9sRmFjdG9yeSwgSUF0dHJpYnV0ZUNvbnRyb2xGYWN0b3J5LCBudWxsLCBfX0ZBQ1RPUlkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIb2xkcyBhbGwgdGhlIGNsYXNzZXMgYW5kIGludGVyZmFjZXMgcmVsYXRlZCB0byBVSSBjb21wb25lbnRzIGZvciBwbGF0eXB1cy5cclxuICAgICAqL1xyXG4gICAgdmFyIHVpO1xyXG4gICAgKGZ1bmN0aW9uICh1aSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBiYXNlIGNvbnRyb2wgZm9yIGFueSBjb250cm9sIHRoYXQgYWZmZWN0cyB0aGUgVUkuIFRoZXkgcHJvdmlkZSBwcm9wZXJ0aWVzIGZvciB0aGUgY29udHJvbCB0byB1c2VcclxuICAgICAgICAgKiB0byBtYW5hZ2UgaXRzIGJvZHkgSFRNTC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgVGVtcGxhdGVDb250cm9sID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFRlbXBsYXRlQ29udHJvbCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gVGVtcGxhdGVDb250cm9sKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEJ5IGRlZmF1bHQgVGVtcGxhdGVDb250cm9scyBoYXZlIGEgcHJpb3JpdHkgb2YgMTAwLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByaW9yaXR5ID0gMTAwO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgY29udGV4dCBvZiBhbiBUZW1wbGF0ZUNvbnRyb2wsIHVzZWQgZm9yIGluaGVyaXRhbmNlIGFuZCBkYXRhLWJpbmRpbmcuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNwZWNpZmllcyB0aGUgYWJzb2x1dGUgcGF0aCBmcm9tIHdoZXJlIHRoZSBjb250ZXh0IHdhcyBjcmVhdGVkIHRvIHRoaXMgQ29udHJvbCdzIGNvbnRleHQuXHJcbiAgICAgICAgICAgICAgICAgKiBVc2VkIGJ5IHRoZSBDb250ZXh0TWFuYWdlciBmb3IgbWFpbnRhaW5pbmcgY29udGV4dCBwYXJpdHlcclxuICAgICAgICAgICAgICAgICAqIChlLmcuICdjb250ZXh0LmNoaWxkQ29udGV4dFByb3BlcnR5LmdyYW5kQ2hpbGRDb250ZXh0UHJvcGVydHknKS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hYnNvbHV0ZUNvbnRleHRQYXRoID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHRoZSBUZW1wbGF0ZUNvbnRyb2wgZGVmaW5lcyB0aGUgY29udGV4dCBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYXNPd25Db250ZXh0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFsbG93cyBhIFRlbXBsYXRlQ29udHJvbCB0byBlaXRoZXIgc3dhcCBpdHMgZWxlbWVudCB3aXRoIGFub3RoZXIgZWxlbWVudCAoZS5nLiBwbGF0LXNlbGVjdCksXHJcbiAgICAgICAgICAgICAgICAgKiBvciByZXBsYWNlIGl0cyBlbGVtZW50IGFsdG9nZXRoZXIuIElmIG51bGwgb3IgZW1wdHkgc3RyaW5nLCB0aGUgZWxlbWVudCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgRE9NLCBhbmQgdGhlXHJcbiAgICAgICAgICAgICAgICAgKiBjaGlsZE5vZGVzIG9mIHRoZSBlbGVtZW50IHdpbGwgYmUgaW4gaXRzIHBsYWNlLiBJbiBhZGRpdGlvbiwgd2hlbiB0aGUgZWxlbWVudCBpcyBwbGFjZWQgc3RhcnROb2RlIGFuZCBlbmROb2RlIENvbW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgKiBhcmUgY3JlYXRlZCwgYW5kIHRoZSBjaGlsZE5vZGVzIGFyZSBhZGRlZCB0byB0aGUgZWxlbWVudE5vZGVzIHByb3BlcnR5IG9uIHRoZSBjb250cm9sLiBUaGUgcmVwbGFjZVdpdGhcclxuICAgICAgICAgICAgICAgICAqIHByb3BlcnR5IGNhbiBiZSBhbnkgcHJvcGVydHkgdGhhdCB3b3JrcyB3aXRoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoKS4gSWYgdGhlIGNvbnRyb2wncyBlbGVtZW50IGhhZFxyXG4gICAgICAgICAgICAgICAgICogYXR0cmlidXRlcyAoYXMgd2VsbCBhcyBhdHRyaWJ1dGUgQ29udHJvbHMpLCB0aG9zZSBhdHRyaWJ1dGVzIHdpbGwgYmUgY2FycmllZCB0byB0aGUgc3dhcHBlZCBlbGVtZW50LiBUaGUgZGVmYXVsdFxyXG4gICAgICAgICAgICAgICAgICogcmVwbGFjZVdpdGggaXMgJ2FueSwnIG1lYW5pbmcgaXQgd2lsbCBkZWZhdWx0IHRvIGEgJ2RpdicgaW4gdGhlIGNhc2UgdGhhdCB0aGUgY29udHJvbCB0eXBlIGlzIHVzZWQgYXMgdGhlXHJcbiAgICAgICAgICAgICAgICAgKiBlbGVtZW50J3Mgbm9kZW5hbWUgKGUuZy4gYDxwbGF0LWZvcmVhY2ggcGxhdC1jb250ZXh0PVwiLi4uXCI+PC9wbGF0LWZvcmVhY2g+YCksIGJ1dCB3aWxsIG1haW50YWluIHdoYXRldmVyIGVsZW1lbnQgdHlwZVxyXG4gICAgICAgICAgICAgICAgICogaXMgdXNlZCBvdGhlcndpc2UgKGUuZy4gYDx0ciBwbGF0LWNvbnRyb2w9XCJwbGF0LWZvcmVhY2hcIiBwbGF0LWNvbnRleHQ9XCIuLi5cIj48L3RyPmApLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VXaXRoID0gJ2FueSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgVGVtcGxhdGVDb250cm9sLmV2YWx1YXRlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChleHByZXNzaW9uLCBjb250cm9sLCBhbGlhc2VzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShleHByZXNzaW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGV4cHJlc3Npb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IFRlbXBsYXRlQ29udHJvbC5fcGFyc2VyLnBhcnNlKGV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzRnVuY3Rpb24oZXhwcmVzc2lvbi5ldmFsdWF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoY29udHJvbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbi5ldmFsdWF0ZShudWxsLCBhbGlhc2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uLmFsaWFzZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsaWFzZXMgPSBUZW1wbGF0ZUNvbnRyb2wuZ2V0UmVzb3VyY2VzKGNvbnRyb2wsIGV4cHJlc3Npb24uYWxpYXNlcywgYWxpYXNlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkoYWxpYXNlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uLmV2YWx1YXRlKGNvbnRyb2wuY29udGV4dCwgYWxpYXNlcyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHaXZlbiBhIGNvbnRyb2wgYW5kIEFycmF5IG9mIGFsaWFzZXMsIGZpbmRzIHRoZSBhc3NvY2lhdGVkIHJlc291cmNlcyBhbmQgYnVpbGRzIGEgY29udGV4dCBvYmplY3QgY29udGFpbmluZ1xyXG4gICAgICAgICAgICAgKiB0aGUgdmFsdWVzLiBSZXR1cm5zIHRoZSBvYmplY3QuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5UZW1wbGF0ZUNvbnRyb2x9IGNvbnRyb2wgVGhlIGNvbnRyb2wgdXNlZCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yIGZpbmRpbmcgcmVzb3VyY2VzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGFsaWFzZXMgQW4gYXJyYXkgb2YgYWxpYXNlcyB0byBzZWFyY2ggZm9yLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0lPYmplY3Q8YW55Pn0gcmVzb3VyY2VzPyBBbiBvcHRpb25hbCByZXNvdXJjZXMgb2JqZWN0IHRvIGV4dGVuZCwgaWYgbm8gcmVzb3VyY2VzIG9iamVjdCBpcyBwYXNzZWQgaW4gYVxyXG4gICAgICAgICAgICAgKiBuZXcgb25lIHdpbGwgYmUgY3JlYXRlZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRlbXBsYXRlQ29udHJvbC5nZXRSZXNvdXJjZXMgPSBmdW5jdGlvbiAoY29udHJvbCwgYWxpYXNlcywgcmVzb3VyY2VzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGNvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGFsaWFzZXMubGVuZ3RoLCBhbGlhcywgcmVzb3VyY2UsIHJlc291cmNlT2JqLCBjYWNoZSA9IFRlbXBsYXRlQ29udHJvbC5fX3Jlc291cmNlQ2FjaGVbY29udHJvbC51aWRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChjYWNoZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWNoZSA9IFRlbXBsYXRlQ29udHJvbC5fX3Jlc291cmNlQ2FjaGVbY29udHJvbC51aWRdID0ge307XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXNvdXJjZXMgPSByZXNvdXJjZXMgfHwge307XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxpYXMgPSBhbGlhc2VzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGlhc1swXSA9PT0gJ0AnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWFzID0gYWxpYXMuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGlhcyA9PT0gX19DT05URVhUX1JFU09VUkNFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlc1thbGlhc10gPSBjb250cm9sLmNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhbGlhcyA9PT0gX19ST09UX0NPTlRFWFRfUkVTT1VSQ0UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VzW2FsaWFzXSA9IENvbnRyb2wuZ2V0Um9vdENvbnRyb2woY29udHJvbCkuY29udGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKHJlc291cmNlc1thbGlhc10pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNOdWxsKGNhY2hlW2FsaWFzXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc291cmNlQ29udHJvbCA9IGNhY2hlW2FsaWFzXS5jb250cm9sLCBjb250cm9sUmVzb3VyY2VzID0gcmVzb3VyY2VDb250cm9sLnJlc291cmNlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChjb250cm9sUmVzb3VyY2VzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VPYmogPSBUZW1wbGF0ZUNvbnRyb2wuZmluZFJlc291cmNlKGNvbnRyb2wsIGFsaWFzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlT2JqID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2w6IHJlc291cmNlQ29udHJvbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZTogY29udHJvbFJlc291cmNlc1thbGlhc11cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlT2JqID0gVGVtcGxhdGVDb250cm9sLmZpbmRSZXNvdXJjZShjb250cm9sLCBhbGlhcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwocmVzb3VyY2VPYmopKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sLnR5cGUuaW5kZXhPZihfX0NPTVBJTEVEKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFRlbXBsYXRlQ29udHJvbC5fbG9nLndhcm4oJ1Jlc291cmNlIGFsaWFzOiAnICsgYWxpYXMgKyAnIGlzIG5vdCBkZWZpbmVkLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVbYWxpYXNdID0gcmVzb3VyY2VPYmo7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UgPSByZXNvdXJjZU9iai5yZXNvdXJjZTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZXNbYWxpYXNdID0gaXNOdWxsKHJlc291cmNlKSA/IHJlc291cmNlIDogcmVzb3VyY2UudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb3VyY2VzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU3RhcnRzIGF0IGEgY29udHJvbCBhbmQgc2VhcmNoZXMgdXAgaXRzIHBhcmVudCBjaGFpbiBmb3IgYSBwYXJ0aWN1bGFyIHJlc291cmNlIGFsaWFzLlxyXG4gICAgICAgICAgICAgKiBJZiB0aGUgcmVzb3VyY2UgaXMgZm91bmQsIGl0IHdpbGwgYmUgcmV0dXJuZWQgYWxvbmcgd2l0aCB0aGUgY29udHJvbCBpbnN0YW5jZSBvbiB3aGljaFxyXG4gICAgICAgICAgICAgKiB0aGUgcmVzb3VyY2Ugd2FzIGZvdW5kLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVGVtcGxhdGVDb250cm9sfSBjb250cm9sIFRoZSBjb250cm9sIG9uIHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZyBmb3IgdGhlIHJlc291cmNlIGFsaWFzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWxpYXMgVGhlIGFsaWFzIHRvIHNlYXJjaCBmb3IuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUZW1wbGF0ZUNvbnRyb2wuZmluZFJlc291cmNlID0gZnVuY3Rpb24gKGNvbnRyb2wsIGFsaWFzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzb3VyY2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGNvbnRyb2wpIHx8IGlzTnVsbChjb250cm9sLnJlc291cmNlcykgfHwgIWlzU3RyaW5nKGFsaWFzKSB8fCBpc0VtcHR5KGFsaWFzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhbGlhc1swXSA9PT0gJ0AnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxpYXMgPSBhbGlhcy5zbGljZSgxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBpc1Jvb3RDb250ZXh0ID0gYWxpYXMgPT09IF9fUk9PVF9DT05URVhUX1JFU09VUkNFO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzUm9vdENvbnRleHQgfHwgYWxpYXMgPT09IF9fQ09OVEVYVF9SRVNPVVJDRSB8fCBhbGlhcyA9PT0gX19DT05UUk9MX1JFU09VUkNFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUm9vdENvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbCA9IENvbnRyb2wuZ2V0Um9vdENvbnRyb2woY29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlID0gKGNvbnRyb2wucmVzb3VyY2VzIHx8IHt9KVthbGlhc107XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChyZXNvdXJjZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZTogcmVzb3VyY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2w6IGNvbnRyb2xcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKCFpc051bGwoY29udHJvbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZSA9IChjb250cm9sLnJlc291cmNlcyB8fCB7fSlbYWxpYXNdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKHJlc291cmNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2U6IHJlc291cmNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbDogY29udHJvbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sID0gY29udHJvbC5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZWN1cnNpdmVseSBkaXNwb3NlcyBhIGNvbnRyb2wgYW5kIGl0cyBjaGlsZHJlbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlRlbXBsYXRlQ29udHJvbH0gY29udHJvbCBBIGNvbnRyb2wgdG8gZGlzcG9zZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRlbXBsYXRlQ29udHJvbC5kaXNwb3NlID0gZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoY29udHJvbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdWlkID0gY29udHJvbC51aWQsIGNoaWxkQ29udHJvbHMgPSBjb250cm9sLmNvbnRyb2xzLCBjb250cm9scyA9IChjaGlsZENvbnRyb2xzICYmIGNoaWxkQ29udHJvbHMuc2xpY2UoMCkpLCBDb250ZXh0TWFuYWdlciA9IENvbnRyb2wuX0NvbnRleHRNYW5hZ2VyLCBkZWZpbmUgPSBDb250ZXh0TWFuYWdlci5kZWZpbmVQcm9wZXJ0eTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKGNvbnRyb2xzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGhfOCA9IGNvbnRyb2xzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGxlbmd0aF84OyBpID49IDA7IC0taSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDb250cm9sLmRpc3Bvc2UoY29udHJvbHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGNvbnRyb2wuZGlzcG9zZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIENvbnRyb2wucmVtb3ZlRXZlbnRMaXN0ZW5lcnMoY29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICBUZW1wbGF0ZUNvbnRyb2wucmVtb3ZlRWxlbWVudChjb250cm9sKTtcclxuICAgICAgICAgICAgICAgIFRlbXBsYXRlQ29udHJvbC5fUmVzb3VyY2VzRmFjdG9yeS5kaXNwb3NlKGNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgVGVtcGxhdGVDb250cm9sLl9CaW5kYWJsZVRlbXBsYXRlc0ZhY3RvcnkuZGlzcG9zZShjb250cm9sKTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KFRlbXBsYXRlQ29udHJvbC5fX3Jlc291cmNlQ2FjaGUsIGNvbnRyb2wudWlkKTtcclxuICAgICAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLmRpc3Bvc2UoY29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICBldmVudHMuRXZlbnRNYW5hZ2VyLmRpc3Bvc2UoY29udHJvbC51aWQpO1xyXG4gICAgICAgICAgICAgICAgVGVtcGxhdGVDb250cm9sLl9tYW5hZ2VyQ2FjaGUucmVtb3ZlKHVpZCk7XHJcbiAgICAgICAgICAgICAgICBDb250cm9sLnJlbW92ZVBhcmVudChjb250cm9sKTtcclxuICAgICAgICAgICAgICAgIGRlZmluZShjb250cm9sLCBfX1JFU09VUkNFUywgbnVsbCwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sLmF0dHJpYnV0ZXMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgY29udHJvbC5iaW5kYWJsZVRlbXBsYXRlcyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sLmNvbnRyb2xzID0gW107XHJcbiAgICAgICAgICAgICAgICBjb250cm9sLnJvb3QgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgY29udHJvbC5pbm5lclRlbXBsYXRlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmIChjb250cm9sLl9faW5qZWN0YWJsZV9fdHlwZSA9PT0gX19TVEFUSUMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5qZWN0b3IgPSBjb250cm9sSW5qZWN0b3JzW2NvbnRyb2wudHlwZV07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXIuY29udHJvbChjb250cm9sLnR5cGUsIGNvbnRyb2wuY29uc3RydWN0b3IsIGluamVjdG9yLmRlcGVuZGVuY2llcywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBMb2FkcyB0aGUgY29udHJvbCB0cmVlIGRlcHRoIGZpcnN0ICh2aXNpdCBjaGlsZHJlbiwgdGhlbiB2aXNpdCBzZWxmKS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlRlbXBsYXRlQ29udHJvbH0gY29udHJvbCBUaGUgY29udHJvbCBzZXJ2aW5nIGFzIHRoZSByb290IGNvbnRyb2wgdG8gbG9hZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRlbXBsYXRlQ29udHJvbC5sb2FkQ29udHJvbCA9IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBjb250cm9sLmNvbnRyb2xzLCBsZW5ndGggPSBjaGlsZHJlbi5sZW5ndGgsIGNoaWxkO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc051bGwoY2hpbGQuY29udHJvbHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFRlbXBsYXRlQ29udHJvbC5sb2FkQ29udHJvbChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5sb2FkZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250cm9sLmxvYWRlZCgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTm90aWZpZXMgYSBjb250cm9sIHRoYXQgaXRzIGNvbnRleHQgaGFzIGJlZW4gY2hhbmdlZCBieVxyXG4gICAgICAgICAgICAgKiBjYWxsaW5nIHRoZSBgY29udHJvbC5jb250ZXh0Q2hhbmdlZGAgbWV0aG9kIGlmIGl0IGV4aXN0cy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlRlbXBsYXRlQ29udHJvbH0gY29udHJvbCBUaGUgY29udHJvbCB3aG9zZSBjb250ZXh0IGNoYW5nZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBuZXdWYWx1ZSBUaGUgbmV3IHZhbHVlIG9mIHRoZSBjb250cm9sJ3MgY29udGV4dC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgb2YgdGhlIGNvbnRyb2wncyBjb250ZXh0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVGVtcGxhdGVDb250cm9sLmNvbnRleHRDaGFuZ2VkID0gZnVuY3Rpb24gKGNvbnRyb2wsIG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgY29udHJvbC5jb250ZXh0ID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgICAgICBUZW1wbGF0ZUNvbnRyb2wuc2V0Q29udGV4dFJlc291cmNlcyhjb250cm9sKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGNvbnRyb2wuY29udGV4dENoYW5nZWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbC5jb250ZXh0Q2hhbmdlZChuZXdWYWx1ZSwgb2xkVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgYGNvbnRleHRgIHJlc291cmNlIHZhbHVlIG9uIGEgVGVtcGxhdGVDb250cm9sLiBJZiB0aGUgY29udHJvbCBzcGVjaWZpZXNcclxuICAgICAgICAgICAgICogaGFzT3duQ29udGV4dCBhcyB0cnVlLCB0aGUgYHJvb3RDb250ZXh0YCByZXNvdXJjZSB2YWx1ZSB3aWxsIGJlIHNldC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlRlbXBsYXRlQ29udHJvbH0gY29udHJvbCBUaGUgY29udHJvbCB3aG9zZSBjb250ZXh0IHJlc291cmNlcyB3aWxsIGJlIHNldC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRlbXBsYXRlQ29udHJvbC5zZXRDb250ZXh0UmVzb3VyY2VzID0gZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbnRyb2wuY29udGV4dDtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoY29udHJvbC5yZXNvdXJjZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbC5yZXNvdXJjZXMgPSBUZW1wbGF0ZUNvbnRyb2wuX1Jlc291cmNlc0ZhY3RvcnkuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sLnJlc291cmNlcy5pbml0aWFsaXplKGNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2wuaGFzT3duQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwoY29udHJvbC5yZXNvdXJjZXMucm9vdENvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2wucmVzb3VyY2VzLmFkZCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogX19PQlNFUlZBQkxFX1JFU09VUkNFLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2wucmVzb3VyY2VzLnJvb3RDb250ZXh0LnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChjb250cm9sLnJlc291cmNlcy5jb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wucmVzb3VyY2VzLmFkZCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IF9fT0JTRVJWQUJMRV9SRVNPVVJDRSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udHJvbC5yZXNvdXJjZXMuY29udGV4dC52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ29tcGxldGVseSByZW1vdmVzIGEgY29udHJvbCdzIGVsZW1lbnQgZnJvbSBpdHMgcGFyZW50Tm9kZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlRlbXBsYXRlQ29udHJvbH0gY29udHJvbCBUaGUgY29udHJvbCB3aG9zZSBlbGVtZW50IHNob3VsZCBiZSByZW1vdmVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVGVtcGxhdGVDb250cm9sLnJlbW92ZUVsZW1lbnQgPSBmdW5jdGlvbiAoY29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChjb250cm9sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gY29udHJvbC5lbGVtZW50LCBwYXJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2wucmVwbGFjZVdpdGggPT09IG51bGwgfHxcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sLnJlcGxhY2VXaXRoID09PSAnJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGlzRG9jdW1lbnRGcmFnbWVudChlbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUFsbChjb250cm9sLnN0YXJ0Tm9kZSwgY29udHJvbC5lbmROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sLmVsZW1lbnROb2RlcyA9IGNvbnRyb2wuc3RhcnROb2RlID0gY29udHJvbC5lbmROb2RlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc051bGwoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGwocGFyZW50Tm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udHJvbC5lbGVtZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIGFic29sdXRlQ29udGV4dFBhdGggcmVhZC1vbmx5IHByb3BlcnR5IG9uIGEgY29udHJvbC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlRlbXBsYXRlQ29udHJvbH0gY29udHJvbCBUaGUgY29udHJvbCBvbiB3aGljaCB0byBzZXQgdGhlIGFic29sdXRlQ29udGV4dFBhdGguXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIHNldCBvbiB0aGUgY29udHJvbC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRlbXBsYXRlQ29udHJvbC5zZXRBYnNvbHV0ZUNvbnRleHRQYXRoID0gZnVuY3Rpb24gKGNvbnRyb2wsIHBhdGgpIHtcclxuICAgICAgICAgICAgICAgIENvbnRyb2wuX0NvbnRleHRNYW5hZ2VyLmRlZmluZUdldHRlcihjb250cm9sLCAnYWJzb2x1dGVDb250ZXh0UGF0aCcsIHBhdGgsIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERldGVybWluZXMgdGhlIHRlbXBsYXRlIGZvciBhIGNvbnRyb2wgYnkgc2VhcmNoaW5nIGZvciBhIHRlbXBsYXRlVXJsLFxyXG4gICAgICAgICAgICAgKiB1c2luZyB0aGUgcHJvdmlkZWQgdGVtcGxhdGVVcmwsIG9yIHNlcmlhbGl6aW5nIHRoZSBjb250cm9sJ3MgdGVtcGxhdGVTdHJpbmcuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5UZW1wbGF0ZUNvbnRyb2x9IGNvbnRyb2wgVGhlIGNvbnRyb2wgd2hvc2UgdGVtcGxhdGUgaXMgYmVpbmcgZGV0ZXJtaW5lZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlVXJsPyBUaGUgcG90ZW50aWFsIHRlbXBsYXRlIFVSTCB0byB1c2UgdG8gZ3JhYiB0aGUgdGVtcGxhdGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUZW1wbGF0ZUNvbnRyb2wuZGV0ZXJtaW5lVGVtcGxhdGUgPSBmdW5jdGlvbiAoY29udHJvbCwgdGVtcGxhdGVVcmwpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZUNhY2hlID0gVGVtcGxhdGVDb250cm9sLl90ZW1wbGF0ZUNhY2hlLCBkb20gPSBjb250cm9sLmRvbSwgUHJvbWlzZSA9IFRlbXBsYXRlQ29udHJvbC5fUHJvbWlzZTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKHRlbXBsYXRlVXJsKSkge1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzTnVsbChjb250cm9sLnRlbXBsYXRlVXJsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsID0gY29udHJvbC50ZW1wbGF0ZVVybDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc051bGwoY29udHJvbC50ZW1wbGF0ZVN0cmluZykpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZV8xID0gY29udHJvbC50eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZUNhY2hlLnJlYWQodHlwZV8xKS5jYXRjaChmdW5jdGlvbiAodGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbCh0ZW1wbGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlID0gY29udHJvbC50ZW1wbGF0ZVN0cmluZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGVtcGxhdGVDYWNoZS5wdXQodHlwZV8xLCB0ZW1wbGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobnVsbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tLmdldFRlbXBsYXRlKHRlbXBsYXRlVXJsKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERldGFjaGVzIGEgVGVtcGxhdGVDb250cm9sLiBEaXNwb3NlcyBpdHMgY2hpbGRyZW4sXHJcbiAgICAgICAgICAgICAqIGJ1dCBkb2VzIG5vdCBkaXNwb3NlIHRoZSBUZW1wbGF0ZUNvbnRyb2wuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5UZW1wbGF0ZUNvbnRyb2x9IGNvbnRyb2wgVGhlIGNvbnRyb2wgdG8gYmUgZGV0YWNoZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUZW1wbGF0ZUNvbnRyb2wuZGV0YWNoID0gZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoY29udHJvbCkgfHwgaXNOdWxsKGNvbnRyb2wuY29udHJvbHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xzID0gY29udHJvbC5jb250cm9scy5zbGljZSgwKSwgbGVuZ3RoID0gY29udHJvbHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIENvbnRyb2wuZGlzcG9zZShjb250cm9sc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBDb250cm9sLnJlbW92ZUV2ZW50TGlzdGVuZXJzKGNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgVGVtcGxhdGVDb250cm9sLnJlbW92ZUVsZW1lbnQoY29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICBUZW1wbGF0ZUNvbnRyb2wuX1Jlc291cmNlc0ZhY3RvcnkuZGlzcG9zZShjb250cm9sLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KFRlbXBsYXRlQ29udHJvbC5fX3Jlc291cmNlQ2FjaGUsIGNvbnRyb2wudWlkKTtcclxuICAgICAgICAgICAgICAgIENvbnRyb2wuX0NvbnRleHRNYW5hZ2VyLmRpc3Bvc2UoY29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICBldmVudHMuRXZlbnRNYW5hZ2VyLmRpc3Bvc2UoY29udHJvbC51aWQpO1xyXG4gICAgICAgICAgICAgICAgVGVtcGxhdGVDb250cm9sLl9tYW5hZ2VyQ2FjaGUucmVtb3ZlKGNvbnRyb2wudWlkKTtcclxuICAgICAgICAgICAgICAgIENvbnRyb2wucmVtb3ZlUGFyZW50KGNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgY29udHJvbC5jb250cm9scyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgY29udHJvbC5hdHRyaWJ1dGVzID0gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgYSBuZXcgaW5zdGFuY2Ugb2YgVGVtcGxhdGVDb250cm9sLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVGVtcGxhdGVDb250cm9sLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZUNvbnRyb2woKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhbiBUZW1wbGF0ZUNvbnRyb2wncyBjb250ZXh0IHByb3BlcnR5XHJcbiAgICAgICAgICAgICAqIGlzIGNoYW5nZWQgYnkgYW4gYW5jZXN0b3IgY29udHJvbC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IG5ld1ZhbHVlPyBUaGUgbmV3IHZhbHVlIG9mIHRoZSBjb250ZXh0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBvZiB0aGUgY29udGV4dC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRlbXBsYXRlQ29udHJvbC5wcm90b3R5cGUuY29udGV4dENoYW5nZWQgPSBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlKSB7IH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIG1ldGhvZCBjYWxsZWQgZm9yIFRlbXBsYXRlQ29udHJvbHMgdG8gc2V0IHRoZWlyIHRlbXBsYXRlLlxyXG4gICAgICAgICAgICAgKiBEdXJpbmcgdGhpcyBtZXRob2QgYSBjb250cm9sIHNob3VsZCByZWFkeSBpdHMgdGVtcGxhdGUgZm9yIGNvbXBpbGF0aW9uLiBXaGF0ZXZlciBpcyBpbiB0aGUgY29udHJvbCdzXHJcbiAgICAgICAgICAgICAqIGVsZW1lbnQgKG9yIGVsZW1lbnROb2RlcyBpZiByZXBsYWNlV2l0aCBpcyBpbXBsZW1lbnRlZCkgYWZ0ZXIgdGhpcyBtZXRob2QncyBleGVjdXRpb24gd2lsbCBiZSBjb21waWxlZFxyXG4gICAgICAgICAgICAgKiBhbmQgYXBwZWFyIG9uIHRoZSBET00uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUZW1wbGF0ZUNvbnRyb2wucHJvdG90eXBlLnNldFRlbXBsYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRmluZHMgdGhlIGFzc29jaWF0ZWQgcmVzb3VyY2VzIGFuZCBidWlsZHMgYSBjb250ZXh0IG9iamVjdCBjb250YWluaW5nXHJcbiAgICAgICAgICAgICAqIHRoZSB2YWx1ZXMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYWxpYXNlcyBBbiBhcnJheSBvZiBhbGlhc2VzIHRvIHNlYXJjaCBmb3IuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7SU9iamVjdDxhbnk+fSByZXNvdXJjZXM/IEFuIG9wdGlvbmFsIHJlc291cmNlcyBvYmplY3QgdG8gZXh0ZW5kLFxyXG4gICAgICAgICAgICAgKiBpZiBubyByZXNvdXJjZXMgb2JqZWN0IGlzIHBhc3NlZCBpbiBhIG5ldyBvbmUgd2lsbCBiZSBjcmVhdGVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVGVtcGxhdGVDb250cm9sLnByb3RvdHlwZS5nZXRSZXNvdXJjZXMgPSBmdW5jdGlvbiAoYWxpYXNlcywgcmVzb3VyY2VzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVGVtcGxhdGVDb250cm9sLmdldFJlc291cmNlcyh0aGlzLCBhbGlhc2VzLCByZXNvdXJjZXMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU3RhcnRzIGF0IGEgY29udHJvbCBhbmQgc2VhcmNoZXMgdXAgaXRzIHBhcmVudCBjaGFpbiBmb3IgYSBwYXJ0aWN1bGFyIHJlc291cmNlIGFsaWFzLlxyXG4gICAgICAgICAgICAgKiBJZiB0aGUgcmVzb3VyY2UgaXMgZm91bmQsIGl0IHdpbGwgYmUgcmV0dXJuZWQgYWxvbmcgd2l0aCB0aGUgY29udHJvbCBpbnN0YW5jZSBvbiB3aGljaFxyXG4gICAgICAgICAgICAgKiB0aGUgcmVzb3VyY2Ugd2FzIGZvdW5kLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWxpYXMgVGhlIGFsaWFzIHRvIHNlYXJjaCBmb3IuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUZW1wbGF0ZUNvbnRyb2wucHJvdG90eXBlLmZpbmRSZXNvdXJjZSA9IGZ1bmN0aW9uIChhbGlhcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRlbXBsYXRlQ29udHJvbC5maW5kUmVzb3VyY2UodGhpcywgYWxpYXMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBUZW1wbGF0ZUNvbnRyb2wucHJvdG90eXBlLmV2YWx1YXRlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChleHByZXNzaW9uLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVGVtcGxhdGVDb250cm9sLmV2YWx1YXRlRXhwcmVzc2lvbihleHByZXNzaW9uLCB0aGlzLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFuIG9iamVjdCBmb3IgcXVpY2tseSByZXRyaWV2aW5nIHByZXZpb3VzbHkgYWNjZXNzZWQgcmVzb3VyY2VzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVGVtcGxhdGVDb250cm9sLl9fcmVzb3VyY2VDYWNoZSA9IHt9O1xyXG4gICAgICAgICAgICByZXR1cm4gVGVtcGxhdGVDb250cm9sO1xyXG4gICAgICAgIH0oQ29udHJvbCkpO1xyXG4gICAgICAgIHVpLlRlbXBsYXRlQ29udHJvbCA9IFRlbXBsYXRlQ29udHJvbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBJVGVtcGxhdGVDb250cm9sRmFjdG9yeShfUmVzb3VyY2VzRmFjdG9yeSwgX0JpbmRhYmxlVGVtcGxhdGVzRmFjdG9yeSwgX21hbmFnZXJDYWNoZSwgX3RlbXBsYXRlQ2FjaGUsIF9wYXJzZXIsIF9odHRwLCBfUHJvbWlzZSwgX2xvZykge1xyXG4gICAgICAgICAgICBUZW1wbGF0ZUNvbnRyb2wuX1Jlc291cmNlc0ZhY3RvcnkgPSBfUmVzb3VyY2VzRmFjdG9yeTtcclxuICAgICAgICAgICAgVGVtcGxhdGVDb250cm9sLl9CaW5kYWJsZVRlbXBsYXRlc0ZhY3RvcnkgPSBfQmluZGFibGVUZW1wbGF0ZXNGYWN0b3J5O1xyXG4gICAgICAgICAgICBUZW1wbGF0ZUNvbnRyb2wuX21hbmFnZXJDYWNoZSA9IF9tYW5hZ2VyQ2FjaGU7XHJcbiAgICAgICAgICAgIFRlbXBsYXRlQ29udHJvbC5fdGVtcGxhdGVDYWNoZSA9IF90ZW1wbGF0ZUNhY2hlO1xyXG4gICAgICAgICAgICBUZW1wbGF0ZUNvbnRyb2wuX3BhcnNlciA9IF9wYXJzZXI7XHJcbiAgICAgICAgICAgIFRlbXBsYXRlQ29udHJvbC5faHR0cCA9IF9odHRwO1xyXG4gICAgICAgICAgICBUZW1wbGF0ZUNvbnRyb2wuX1Byb21pc2UgPSBfUHJvbWlzZTtcclxuICAgICAgICAgICAgVGVtcGxhdGVDb250cm9sLl9sb2cgPSBfbG9nO1xyXG4gICAgICAgICAgICByZXR1cm4gVGVtcGxhdGVDb250cm9sO1xyXG4gICAgICAgIH1cclxuICAgICAgICB1aS5JVGVtcGxhdGVDb250cm9sRmFjdG9yeSA9IElUZW1wbGF0ZUNvbnRyb2xGYWN0b3J5O1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5LCBJVGVtcGxhdGVDb250cm9sRmFjdG9yeSwgW1xyXG4gICAgICAgICAgICBfX1Jlc291cmNlc0ZhY3RvcnksXHJcbiAgICAgICAgICAgIF9fQmluZGFibGVUZW1wbGF0ZXNGYWN0b3J5LFxyXG4gICAgICAgICAgICBfX01hbmFnZXJDYWNoZSxcclxuICAgICAgICAgICAgX19UZW1wbGF0ZUNhY2hlLFxyXG4gICAgICAgICAgICBfX1BhcnNlcixcclxuICAgICAgICAgICAgX19IdHRwLFxyXG4gICAgICAgICAgICBfX1Byb21pc2UsXHJcbiAgICAgICAgICAgIF9fTG9nXHJcbiAgICAgICAgXSwgX19GQUNUT1JZKTtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fVGVtcGxhdGVDb250cm9sSW5zdGFuY2UsIFRlbXBsYXRlQ29udHJvbCwgbnVsbCwgX19JTlNUQU5DRSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gZXh0ZW5kZWQgVGVtcGxhdGVDb250cm9sIHRoYXQgYWxsb3dzIGZvciB0aGUgYmluZGluZyBvZiBhIHZhbHVlIHRvXHJcbiAgICAgICAgICogYW5vdGhlciBsaXN0ZW5pbmcgY29udHJvbCAoZS5nLiBwbGF0LWJpbmQgY29udHJvbCkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEJpbmRDb250cm9sID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKEJpbmRDb250cm9sLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBCaW5kQ29udHJvbCgpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTZXQgdG8gMTIwLCBoaWdoZXIgdGhhbiBgcGxhdC1iaW5kYCB0byBlbnN1cmUgdGhhdCBCaW5Db250cm9scyBsb2FkXHJcbiAgICAgICAgICAgICAgICAgKiBwcmlvciB0byB0aGUgYHBsYXQtYmluZGAuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMucHJpb3JpdHkgPSAxMjA7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBzZXQgb2YgZnVuY3Rpb25zIGFkZGVkIGV4dGVybmFsbHkgdGhhdCBsaXN0ZW5zXHJcbiAgICAgICAgICAgICAgICAgKiBmb3IgcHJvcGVydHkgY2hhbmdlcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0byBiZSBjYWxsZWQgd2hlbiB0aGUgYmluZGFibGUgcHJvcGVydHkgY2hhbmdlcy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LklQcm9wZXJ0eUNoYW5nZWRMaXN0ZW5lcjxhbnk+fSBsaXN0ZW5lciBUaGUgZnVuY3Rpb24gdGhhdCBhY3RzIGFzIGEgbGlzdGVuZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kQ29udHJvbC5wcm90b3R5cGUub25JbnB1dCA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHRoaXMgY29udHJvbCB0byBvYnNlcnZlIGJvdGggdGhlIGJvdW5kIHByb3BlcnR5IGl0c2VsZiBhcyB3ZWxsIGFzXHJcbiAgICAgICAgICAgICAqIHBvdGVudGlhbCBjaGlsZCBwcm9wZXJ0aWVzIGlmIGJlaW5nIGJvdW5kIHRvIGFuIG9iamVjdC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0Lm9ic2VydmFibGUuSUltcGxlbWVudFR3b1dheUJpbmRpbmd9IGJpbmRlciBUaGUgY29udHJvbCB0aGF0IGZhY2lsaXRhdGVzIHRoZVxyXG4gICAgICAgICAgICAgKiBkYXRhYmluZGluZy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmRDb250cm9sLnByb3RvdHlwZS5vYnNlcnZlUHJvcGVydGllcyA9IGZ1bmN0aW9uIChiaW5kZXIpIHsgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gdGhhdCBzaWduaWZpZXMgd2hlbiB0aGlzIGNvbnRyb2wncyBiaW5kYWJsZSBwcm9wZXJ0eSBoYXMgY2hhbmdlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IG5ld1ZhbHVlIFRoZSBuZXcgdmFsdWUgb2YgdGhlIHByb3BlcnR5IGFmdGVyIHRoZSBjaGFuZ2UuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBvbGRWYWx1ZT8gVGhlIG9sZCB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgcHJpb3IgdG8gdGhlIGNoYW5nZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmRDb250cm9sLnByb3RvdHlwZS5pbnB1dENoYW5nZWQgPSBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycywgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbaV0obmV3VmFsdWUsIG9sZFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlbW92ZXMgcmVmZXJlbmNlcyB0byB0aGUgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgICAqIGRlZmluZWQgZXh0ZXJuYWxseS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmRDb250cm9sLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW107XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBCaW5kQ29udHJvbDtcclxuICAgICAgICB9KFRlbXBsYXRlQ29udHJvbCkpO1xyXG4gICAgICAgIHVpLkJpbmRDb250cm9sID0gQmluZENvbnRyb2w7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBjb250cm9sIHVzZWQgaW4gYSBWaWV3cG9ydCBmb3IgcGFnZSBuYXZpZ2F0aW9uLiBUaGVcclxuICAgICAgICAgKiBjb250cm9sIGhhcyBuYXZpZ2F0aW9uIGV2ZW50cyB0aGF0IGFyZSBjYWxsZWQgd2hlbiBuYXZpZ2F0aW5nIHRvIGFuZCBmcm9tIHRoZSBjb250cm9sLiBBIFZpZXdDb250cm9sXHJcbiAgICAgICAgICogcmVwcmVzZW50cyBhIHJvdXRpbmcgY29tcG9uZW50IG9uIGEgcGFnZSAoaS5lLiBhIHBpZWNlIG9mIGEgcGFnZSB0aGF0IGlzIGFzc29jaWF0ZWQgd2l0aCBhIHBhcnRpY3VsYXIgcm91dGUpLlxyXG4gICAgICAgICAqIEl0IGhhcyB0aGUgYWJpbGl0eSB0byBpbml0aWF0ZSwgYXBwcm92ZSwgYW5kIHJlamVjdCBuYXZpZ2F0aW9uIHRvL2Zyb20gaXRzZWxmLiBBIFZpZXdDb250cm9sIGFsc28gaGFzIHRoZVxyXG4gICAgICAgICAqIGFiaWxpdHkgdG8gaW5qZWN0IGEgUm91dGVyIGFuZCBjb25maWd1cmUgc3ViLW5hdmlnYXRpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFZpZXdDb250cm9sID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFZpZXdDb250cm9sLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBWaWV3Q29udHJvbCgpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTcGVjaWZpZXMgdGhhdCB0aGlzIGNvbnRyb2wgd2lsbCBoYXZlIGl0cyBvd24gY29udGV4dCwgYW5kIGl0IHNob3VsZCBub3QgaW5oZXJpdCBhIGNvbnRleHQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuaGFzT3duQ29udGV4dCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlY3Vyc2l2ZWx5IGRpc3Bvc2VzIGEgVmlld0NvbnRyb2wgYW5kIGl0cyBjaGlsZHJlbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlZpZXdDb250cm9sfSBjb250cm9sIEEgY29udHJvbCB0byBkaXNwb3NlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVmlld0NvbnRyb2wuZGlzcG9zZSA9IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcbiAgICAgICAgICAgICAgICBUZW1wbGF0ZUNvbnRyb2wuZGlzcG9zZShjb250cm9sKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgYSBuZXcgaW5zdGFuY2Ugb2YgYSBWaWV3Q29udHJvbC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFZpZXdDb250cm9sLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWaWV3Q29udHJvbCgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQWxsb3dzIGEgVmlld0NvbnRyb2wgdG8gYXN5bmNocm9ub3VzbHkgZGVjaWRlIGlmIHRoZSBhcHAgaXMgYWJsZSB0byBuYXZpZ2F0ZSBhd2F5IGZyb20gdGhlXHJcbiAgICAgICAgICAgICAqIGN1cnJlbnQgdmlldy4gQSBwb3NzaWJsZSB1c2Ugb2YgdGhpcyBtZXRob2QgbWlnaHQgYmUgdG8gcG9wdXAgYSBjb25maXJtYXRpb24gbW9kYWwuIFlvdSBjYW5cclxuICAgICAgICAgICAgICogcmV0dXJuIGEgYm9vbGVhbiBvciBJVGhlbmFibGU8Ym9vbGVhbj4gdG8gYWNjZXB0L3JlamVjdCBuYXZpZ2F0aW9uLlxyXG4gICAgICAgICAgICAgKiBBIHdvcmQgb2YgY2F1dGlvbiwgdGhpcyBpcyBhIG5hdmlnYXRpb24tYmxvY2tpbmcgZnVuY3Rpb24uIEl0IGlzIGJlc3QgdG8gYXZvaWQgbG9uZy1ydW5uaW5nIGZ1bmN0aW9ucy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFZpZXdDb250cm9sLnByb3RvdHlwZS5jYW5OYXZpZ2F0ZUZyb20gPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBbGxvd3MgYSBWaWV3Q29udHJvbCB0byBhc3luY2hyb25vdXNseSBkZWNpZGUgaWYgaXQgY2FuIGJlIG5hdmlnYXRlZCB0byB3aXRoIHRoZSBnaXZlbiBwYXJhbWV0ZXJzL3F1ZXJ5LlxyXG4gICAgICAgICAgICAgKiBZb3UgY2FuIHJldHVybiBhIGJvb2xlYW4gb3IgSVRoZW5hYmxlPGJvb2xlYW4+IHRvIGFjY2VwdC9yZWplY3QgbmF2aWdhdGlvbi5cclxuICAgICAgICAgICAgICogQSB3b3JkIG9mIGNhdXRpb24sIHRoaXMgaXMgYSBuYXZpZ2F0aW9uLWJsb2NraW5nIGZ1bmN0aW9uLiBJdCBpcyBiZXN0IHRvIGF2b2lkIGxvbmctcnVubmluZyBmdW5jdGlvbnMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBWaWV3Q29udHJvbC5wcm90b3R5cGUuY2FuTmF2aWdhdGVUbyA9IGZ1bmN0aW9uIChwYXJhbWV0ZXJzLCBxdWVyeSkgeyB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlIFZpZXdDb250cm9sIGlzIGdvaW5nIG91dCBvZiBzY29wZSBhcyBhIHJlc3VsdCBvZiBhIG5hdmlnYXRpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBWaWV3Q29udHJvbC5wcm90b3R5cGUubmF2aWdhdGluZ0Zyb20gPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGUgVmlld0NvbnRyb2wgaGFzIGNvbWUgaW50byBzY29wZSBhcyBhIHJlc3VsdCBvZiBuYXZpZ2F0aW9uLiBJdCBjYW5cclxuICAgICAgICAgICAgICogcmVjZWl2ZSB0aGUgcm91dGUgcGFyYW1ldGVycyBhbmQgcXVlcnkgaW4gb3JkZXIgdG8gc2V0IGl0cyBjb250ZXh0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVmlld0NvbnRyb2wucHJvdG90eXBlLm5hdmlnYXRlZFRvID0gZnVuY3Rpb24gKHBhcmFtZXRlcnMsIHF1ZXJ5KSB7IH07XHJcbiAgICAgICAgICAgIHJldHVybiBWaWV3Q29udHJvbDtcclxuICAgICAgICB9KFRlbXBsYXRlQ29udHJvbCkpO1xyXG4gICAgICAgIHVpLlZpZXdDb250cm9sID0gVmlld0NvbnRyb2w7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gZXh0ZW5zaWJsZSBjbGFzcyBkZWFsaW5nIHdpdGggdGhlIGNyZWF0aW9uLCBkZWxldGlvbiwgYW5kIG1vZGlmaWNhdGlvblxyXG4gICAgICAgICAqIG9mIERPTS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgRG9tID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gRG9tKCkge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIERvbUV2ZW50cyBpbmplY3RhYmxlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kb21FdmVudHMgPSBhY3F1aXJlKF9fRG9tRXZlbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBEb20ucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgdHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kb21FdmVudHMuYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCB0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIERvbS5wcm90b3R5cGUuYXBwZW5kQ2hpbGRyZW4gPSBmdW5jdGlvbiAobm9kZUxpc3QsIHJvb3QpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcHBlbmRDaGlsZHJlbihub2RlTGlzdCwgcm9vdCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIERvbS5wcm90b3R5cGUuY2xvbmVDaGlsZHJlbiA9IGZ1bmN0aW9uIChub2RlTGlzdCwgcm9vdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGVuZENoaWxkcmVuKG5vZGVMaXN0LCByb290LCB0cnVlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENsZWFycyBhIERPTSBOb2RlIGJ5IHJlbW92aW5nIGFsbCBvZiBpdHMgY2hpbGROb2Rlcy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBET00gTm9kZSB0byBjbGVhci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbS5wcm90b3R5cGUuY2xlYXJOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjbGVhck5vZGUobm9kZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIERvbS5wcm90b3R5cGUuY2xlYXJOb2RlQmxvY2sgPSBmdW5jdGlvbiAobm9kZUxpc3QsIHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFyTm9kZUJsb2NrKG5vZGVMaXN0LCBwYXJlbnQpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgaW5uZXJIVE1MIG9mIGEgTm9kZS4gQ2FuIHRha2UgaW4gYSBOb2RlIHJhdGhlciB0aGFuIGFuIEVsZW1lbnRcclxuICAgICAgICAgICAgICogYmVjYXVzZSBpdCBkb2VzIG5vdCB1c2UgaW5uZXJIVE1MIG9uIHRoZSBwYXNzZWQtaW4gTm9kZSAoaXQgYXBwZW5kcyBpdHNcclxuICAgICAgICAgICAgICogY2hpbGROb2RlcykuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgTm9kZSB0byBzZXQgaW5uZXJIVE1MLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaHRtbCBIVE1MIHN0cmluZyB0byBiZSBwdXQgaW5zaWRlIHRoZSBub2RlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tLnByb3RvdHlwZS5zZXRJbm5lckh0bWwgPSBmdW5jdGlvbiAobm9kZSwgaHRtbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldElubmVySHRtbChub2RlLCBodG1sKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgRG9tLnByb3RvdHlwZS5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiAocGFyZW50LCBub2RlcywgZW5kTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc2VydEJlZm9yZShwYXJlbnQsIG5vZGVzLCBlbmROb2RlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRha2VzIHRoZSBjaGlsZCBub2RlcyBvZiB0aGUgZ2l2ZW4gbm9kZSBhbmQgcGxhY2VzIHRoZW0gYWJvdmUgdGhlIG5vZGVcclxuICAgICAgICAgICAgICogaW4gdGhlIERPTS4gVGhlbiByZW1vdmVzIHRoZSBnaXZlbiBub2RlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIE5vZGUgdG8gcmVwbGFjZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZShub2RlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgRG9tLnByb3RvdHlwZS5yZXBsYWNlV2l0aCA9IGZ1bmN0aW9uIChub2RlLCBuZXdOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZVdpdGgobm9kZSwgbmV3Tm9kZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUYWtlcyBpbiBhIHN0cmluZyByZXByZXNlbnRpbmcgaW5uZXJIVE1MIGFuZCByZXR1cm5zIGEgRG9jdW1lbnRGcmFnbWVudFxyXG4gICAgICAgICAgICAgKiBjb250YWluaW5nIHRoZSBzZXJpYWxpemVkIERPTS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGh0bWwgVGhlIERPTSBzdHJpbmcuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb20ucHJvdG90eXBlLnNlcmlhbGl6ZUh0bWwgPSBmdW5jdGlvbiAoaHRtbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUh0bWwoaHRtbCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUYWtlcyBpbiBhIHN0YXJ0Tm9kZSBhbmQgZW5kTm9kZSwgZWFjaCBoYXZpbmcgdGhlIHNhbWUgcGFyZW50Tm9kZS5cclxuICAgICAgICAgICAgICogUmVtb3ZlcyBldmVyeSBub2RlIGluIGJldHdlZW4gdGhlIHN0YXJ0Tm9kZS4gIElmIGVuZE5vZGUgaXMgbm90IHNwZWNpZmllZCxcclxuICAgICAgICAgICAgICogRE9NIHdpbGwgYmUgcmVtb3ZlZCB1bnRpbCB0aGUgZW5kIG9mIHRoZSBwYXJlbnROb2RlJ3MgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Tm9kZX0gc3RhcnROb2RlIFRoZSBzdGFydGluZyBub2RlLCB3aGljaCB3aWxsIG5vdCBiZSByZW1vdmVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge05vZGV9IGVuZE5vZGUgVGhlIGVuZGluZyBub2RlLCB3aGljaCB3aWxsIG5vdCBiZSByZW1vdmVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tLnByb3RvdHlwZS5yZW1vdmVCZXR3ZWVuID0gZnVuY3Rpb24gKHN0YXJ0Tm9kZSwgZW5kTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUJldHdlZW4oc3RhcnROb2RlLCBlbmROb2RlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRha2VzIGluIGEgc3RhcnROb2RlIGFuZCBlbmROb2RlLCBlYWNoIGhhdmluZyB0aGUgc2FtZSBwYXJlbnROb2RlLlxyXG4gICAgICAgICAgICAgKiBSZW1vdmVzIGV2ZXJ5IG5vZGUgaW4gYmV0d2VlbiB0aGUgc3RhcnROb2RlIGFuZCBlbmROb2RlIGFzIHdlbGwgYXNcclxuICAgICAgICAgICAgICogdGhlIHN0YXJ0Tm9kZSBhbmQgdGhlIGVuZE5vZGUuICBJZiBlbmROb2RlIGlzIG5vdCBzcGVjaWZpZWQsIERPTVxyXG4gICAgICAgICAgICAgKiB3aWxsIGJlIHJlbW92ZWQgdW50aWwgdGhlIGVuZCBvZiB0aGUgcGFyZW50Tm9kZSdzIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge05vZGV9IHN0YXJ0Tm9kZSBUaGUgZmlyc3Qgbm9kZSB0byByZW1vdmUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Tm9kZX0gZW5kTm9kZSBUaGUgbGFzdCBub2RlIHRvIHJlbW92ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbS5wcm90b3R5cGUucmVtb3ZlQWxsID0gZnVuY3Rpb24gKHN0YXJ0Tm9kZSwgZW5kTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUFsbChzdGFydE5vZGUsIGVuZE5vZGUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQWRkcyBhIGNsYXNzIG9yIG11bHRpcGxlIGNsYXNzZXMgdG8gdGhlIHNwZWNpZmllZCBlbGVtZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gd2hpY2ggdGhlIGNsYXNzIG5hbWUgaXMgYmVpbmcgYWRkZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgVGhlIGNsYXNzIG5hbWUgb3Igc3BhY2UgZGVsaW1pdGVkIGNsYXNzIG5hbWVzIHRvIGFkZCB0byB0aGUgZWxlbWVudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbS5wcm90b3R5cGUuYWRkQ2xhc3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlbW92ZXMgYSBjbGFzcyBvciBtdWx0aXBsZSBjbGFzc2VzIGZyb20gdGhlIHNwZWNpZmllZCBlbGVtZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgZnJvbSB3aGljaCB0aGUgY2xhc3MgbmFtZSBpcyBiZWluZyByZW1vdmVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIFRoZSBjbGFzcyBuYW1lIG9yIHNwYWNlIGRlbGltaXRlZCBjbGFzcyBuYW1lcyB0byByZW1vdmUgZnJvbSB0aGUgZWxlbWVudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbS5wcm90b3R5cGUucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRvZ2dsZXMgYSBjbGFzcyBvciBtdWx0aXBsZSBjbGFzc2VzIGZyb20gdGhlIHNwZWNpZmllZCBlbGVtZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgb24gd2hpY2ggdGhlIGNsYXNzIG5hbWUgaXMgYmVpbmcgdG9nZ2xlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSBUaGUgY2xhc3MgbmFtZSBvciBzcGFjZSBkZWxpbWl0ZWQgY2xhc3MgbmFtZXMgdG8gdG9nZ2xlIG9uIHRoZSBlbGVtZW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tLnByb3RvdHlwZS50b2dnbGVDbGFzcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0b2dnbGVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVwbGFjZXMgYSBzaW5nbGUgY2xhc3Mgd2l0aCBhbm90aGVyIGNsYXNzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgb24gd2hpY2ggdGhlIGNsYXNzIG5hbWUgaXMgYmVpbmcgdG9nZ2xlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9sZENsYXNzIFRoZSBjbGFzcyBuYW1lIGJlaW5nIHJlcGxhY2VkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3Q2xhc3MgVGhlIGNsYXNzIG5hbWUgZG9pbmcgdGhlIHJlcGxhY2luZy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbS5wcm90b3R5cGUucmVwbGFjZUNsYXNzID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9sZENsYXNzLCBuZXdDbGFzcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VDbGFzcyhlbGVtZW50LCBvbGRDbGFzcywgbmV3Q2xhc3MpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhbiBlbGVtZW50IGhhcyBhIHBhcnRpY3VsYXIgY2xhc3Mgb3IgY2xhc3NlcyBhc3NpZ25lZCB0byBpdC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IG9uIHdoaWNoIHRoZSBjbGFzcyBuYW1lIGlzIGJlaW5nIGNoZWNrZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgVGhlIGNsYXNzIG5hbWUgb3Igc3BhY2UgZGVsaW1pdGVkIGNsYXNzIG5hbWVzIHRvIGNoZWNrIG9uIHRoZSBlbGVtZW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tLnByb3RvdHlwZS5oYXNDbGFzcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBoYXNDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0cmlldmVzIGFuZCBzZXJpYWxpemVzIEhUTUwgZnJvbSBhbiBIVE1MIHRlbXBsYXRlIGZpbGUgdXNpbmcgYWpheC4gV2lsbCBmYWNpbGl0YXRlIGNhY2hpbmcgdGhlIHRlbXBsYXRlXHJcbiAgICAgICAgICAgICAqIGFzIHdlbGwuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZVVybCBUaGUgdXJsIHdoZXJlIHRoZSBIVE1MIHRlbXBsYXRlIGlzIHN0b3JlZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbS5wcm90b3R5cGUuZ2V0VGVtcGxhdGUgPSBmdW5jdGlvbiAodGVtcGxhdGVVcmwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRUZW1wbGF0ZSh0ZW1wbGF0ZVVybCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbnNwZWN0cyB0aGUgRWxlbWVudCBhbmQgcmVzb2x2ZXMgd2hlbiB0aGUgRWxlbWVudCBpcyBwcmVzZW50IGluIHRoZSBET00gYm9keS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHsoKSA9PiB2b2lkfSBjYiBBIGNhbGxiYWNrIHRoYXQgd2lsbCBmaXJlIHdoZW4gdGhlIGVsZW1lbnQgaXMgcHJlc2VudCBpbiB0aGUgRE9NIGJvZHkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB3aG9zZSBwcmVzZW5jZSBpcyBiZWluZyBpbnNwZWN0ZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb20ucHJvdG90eXBlLndoZW5QcmVzZW50ID0gZnVuY3Rpb24gKGNiLCBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gd2hlblByZXNlbnQoY2IsIGVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5zcGVjdHMgdGhlIEVsZW1lbnQgYW5kIHJlc29sdmVzIHdoZW4gdGhlIEVsZW1lbnQgaXMgdmlzaWJsZSBpbiB0aGUgRE9NLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geygpID0+IHZvaWR9IGNiIEEgY2FsbGJhY2sgdGhhdCB3aWxsIGZpcmUgd2hlbiB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIGluIHRoZSBET00uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB3aG9zZSB2aXNpYmlsaXR5IGlzIGJlaW5nIGluc3BlY3RlZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbS5wcm90b3R5cGUud2hlblZpc2libGUgPSBmdW5jdGlvbiAoY2IsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB3aGVuVmlzaWJsZShjYiwgZWxlbWVudCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIERvbS5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICAgICAgX2RvbUV2ZW50czogX19Eb21FdmVudHNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIERvbTtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIHVpLkRvbSA9IERvbTtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fRG9tLCBEb20pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjbGFzcyB3aGljaCBwcm92aWRlcyBhIHdheSBmb3IgVGVtcGxhdGVDb250cm9scyB0byBiaW5kIGEgdGVtcGxhdGVcclxuICAgICAgICAgKiB0byBhIGNvbnRleHQuIFVzZWZ1bCBmb3IgbmFycm93aW5nIGNvbnRleHQgd2l0aG91dCBuZWVkaW5nIGFub3RoZXJcclxuICAgICAgICAgKiBUZW1wbGF0ZUNvbnRyb2wuIEluIGFkZGl0aW9uLCB0aGlzIG9iamVjdCBwcm92aWRlcyBhIHBlcmZvcm1hbmNlIGluY3JlYXNlIGJlY2F1c2VcclxuICAgICAgICAgKiBpdCB3aWxsIG9ubHkgY29tcGlsZSB0aGUgdGVtcGxhdGUgb25jZS4gVGhpcyBvYmplY3QgaXMgYWxzbyB1c2VmdWwgd2hlbiBhXHJcbiAgICAgICAgICogVGVtcGxhdGVDb250cm9scyBleHBlY3RzIG11bHRpcGxlIGNvbmZpZ3VyYXRpb24gdGVtcGxhdGVzIGluIGl0cyBpbm5lckhUTUwuIEl0IGNhblxyXG4gICAgICAgICAqIHNlcGFyYXRlIHRob3NlIHRlbXBsYXRlcyBhbmQgcmV1c2UgdGhlbSBhY2NvcmRpbmdseS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgQmluZGFibGVUZW1wbGF0ZXMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBCaW5kYWJsZVRlbXBsYXRlcygpIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSBJUmVzb3VyY2VzRmFjdG9yeSBpbmplY3RhYmxlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9SZXNvdXJjZXNGYWN0b3J5ID0gYWNxdWlyZShfX1Jlc291cmNlc0ZhY3RvcnkpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIElDb250cm9sRmFjdG9yeSBpbmplY3RhYmxlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9Db250cm9sRmFjdG9yeSA9IGFjcXVpcmUoX19Db250cm9sRmFjdG9yeSk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgSVRlbXBsYXRlQ29udHJvbEZhY3RvcnkgaW5qZWN0YWJsZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fVGVtcGxhdGVDb250cm9sRmFjdG9yeSA9IGFjcXVpcmUoX19UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5KTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSBJQ29udGV4dE1hbmFnZXJTdGF0aWMgaW5qZWN0YWJsZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fQ29udGV4dE1hbmFnZXIgPSBhY3F1aXJlKF9fQ29udGV4dE1hbmFnZXJTdGF0aWMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIElQcm9taXNlIGluamVjdGFibGUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX1Byb21pc2UgPSBhY3F1aXJlKF9fUHJvbWlzZSk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlZmVyZW5jZSB0byBhIGNhY2hlIGluamVjdGFibGUgdGhhdCBzdG9yZXMgRWxlbWVudE1hbmFnZXJzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYW5hZ2VyQ2FjaGUgPSBhY3F1aXJlKF9fTWFuYWdlckNhY2hlKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSBEb2N1bWVudCBpbmplY3RhYmxlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kb2N1bWVudCA9IGFjcXVpcmUoX19Eb2N1bWVudCk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgSUVsZW1lbnRNYW5hZ2VyRmFjdG9yeSBpbmplY3RhYmxlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9FbGVtZW50TWFuYWdlckZhY3RvcnkgPSBhY3F1aXJlKF9fRWxlbWVudE1hbmFnZXJGYWN0b3J5KTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSBCaW5kYWJsZVRlbXBsYXRlc0ZhY3RvcnkgaW5qZWN0YWJsZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fQmluZGFibGVUZW1wbGF0ZXNGYWN0b3J5ID0gYWNxdWlyZShfX0JpbmRhYmxlVGVtcGxhdGVzRmFjdG9yeSk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgTG9nIGluamVjdGFibGUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZyA9IGFjcXVpcmUoX19Mb2cpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTdG9yZXMgcHJvbWlzZXMgdGhhdCByZXNvbHZlIHRvIGFsbCB0aGUgY29tcGlsZWQgdGVtcGxhdGVzIGZvciB0aGlzIG9iamVjdCwgcmVhZHkgdG8gYmUgYm91bmQgdG8gYSBkYXRhIGNvbnRleHQuXHJcbiAgICAgICAgICAgICAgICAgKiBBbGwgY3JlYXRlZCB0ZW1wbGF0ZXMgYXJlIERvY3VtZW50RnJhZ21lbnRzLCBhbGxvd2luZyBhbiBUZW1wbGF0ZUNvbnRyb2wgdG9cclxuICAgICAgICAgICAgICAgICAqIGVhc2lseSBpbnNlcnQgdGhlIHRlbXBsYXRlIGludG8gdGhlIERPTSAod2l0aG91dCBpdGVyYXRpbmcgb3ZlciBjaGlsZE5vZGVzKS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZXMgPSB7fTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBrZXllZCBjYWNoZSBvZiBFbGVtZW50TWFuYWdlcnMgdGhhdCByZXByZXNlbnQgdGhlIHJvb3RzIG9mIGNvbXBpbGVkIHRlbXBsYXRlc1xyXG4gICAgICAgICAgICAgICAgICogY3JlYXRlZCBieSB0aGlzIGluc3RhbmNlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlID0ge307XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgY29sbGVjdGlvbiBvZiBhbGwgdGhlIGNvbnRyb2xzIGNyZWF0ZWQgd2hpbGUgY29tcGlsaW5nIGFuIGFkZGVkIHRlbXBsYXRlLiBVc2VmdWwgZHVyaW5nIGRpc3Bvc2FsLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fY29tcGlsZWRDb250cm9scyA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIEJpbmRhYmxlVGVtcGxhdGVzIGFuZCByZXR1cm5zIGl0LiBJZiBhIEJpbmRhYmxlVGVtcGxhdGVzIGlzXHJcbiAgICAgICAgICAgICAqIHBhc3NlZCBpbiwgaXQgd2lsbCB1c2UgdGhlIHByb3BlcnRpZXMgb24gdGhlIG9yaWdpbmFsIEJpbmRhYmxlVGVtcGxhdGVzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVGVtcGxhdGVDb250cm9sfSBjb250cm9sIFRoZSBUZW1wbGF0ZUNvbnRyb2xcclxuICAgICAgICAgICAgICogY29udGFpbmluZyB0aGUgbmV3IEJpbmRhYmxlVGVtcGxhdGVzIG9iamVjdCwgdXNlZCBmb3IgZGF0YVxyXG4gICAgICAgICAgICAgKiBjb250ZXh0IGluaGVyaXRhbmNlIGZvciB0ZW1wbGF0ZXMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5CaW5kYWJsZVRlbXBsYXRlc30gb3JpZ2luYWw/IEFuIG9wdGlvbmFsIEJpbmRhYmxlVGVtcGxhdGVzXHJcbiAgICAgICAgICAgICAqIG9iamVjdCB0byBjb3B5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZGFibGVUZW1wbGF0ZXMuY3JlYXRlID0gZnVuY3Rpb24gKGNvbnRyb2wsIG9yaWdpbmFsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmluZGFibGVUZW1wbGF0ZXMgPSBuZXcgQmluZGFibGVUZW1wbGF0ZXMoKTtcclxuICAgICAgICAgICAgICAgIGJpbmRhYmxlVGVtcGxhdGVzLmNvbnRyb2wgPSBjb250cm9sO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGwob3JpZ2luYWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmluZGFibGVUZW1wbGF0ZXMudGVtcGxhdGVzID0gb3JpZ2luYWwudGVtcGxhdGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGJpbmRhYmxlVGVtcGxhdGVzLmNhY2hlID0gb3JpZ2luYWwuY2FjaGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmluZGFibGVUZW1wbGF0ZXM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDbGVhcnMgdGhlIG1lbW9yeSBiZWluZyBoZWxkIGJ5IGNvbnRyb2wncyBiaW5kYWJsZVRlbXBsYXRlcy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlRlbXBsYXRlQ29udHJvbH0gY29udHJvbCBUaGUgY29udHJvbCB3aG9zZSBiaW5kYWJsZVRlbXBsYXRlcyB3aWxsIGJlIGRpc3Bvc2VkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZGFibGVUZW1wbGF0ZXMuZGlzcG9zZSA9IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGNvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gY29udHJvbC5iaW5kYWJsZVRlbXBsYXRlcztcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoaW5zdGFuY2UpIHx8ICFpc0Z1bmN0aW9uKGluc3RhbmNlLmRpc3Bvc2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCBhIGNvbnRyb2wgd2FzIGNyZWF0ZWQgdXNpbmcgYmluZGFibGVUZW1wbGF0ZXMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5UZW1wbGF0ZUNvbnRyb2x9IGNvbnRyb2wgVGhlIHBvdGVudGlhbCBib3VuZCBjb250cm9sLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZGFibGVUZW1wbGF0ZXMuaXNCb3VuZENvbnRyb2wgPSBmdW5jdGlvbiAoY29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChjb250cm9sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBjb250cm9sLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwocGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sLnR5cGUuaW5kZXhPZihwYXJlbnQudHlwZSArIF9fQk9VTkRfUFJFRklYKSA9PT0gMDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQmluZGFibGVUZW1wbGF0ZXMucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiAodGVtcGxhdGUsIHJlbGF0aXZlSWRlbnRpZmllciwgcmVzb3VyY2VzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbCh0ZW1wbGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2RvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1N0cmluZyh0ZW1wbGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHNlcmlhbGl6ZUh0bWwodGVtcGxhdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNEb2N1bWVudEZyYWdtZW50KHRlbXBsYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGVtcGxhdGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOb2RlKHRlbXBsYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZCh0ZW1wbGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlKHRlbXBsYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRDaGlsZHJlbih0ZW1wbGF0ZSwgZnJhZ21lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UucmVzb2x2ZShmcmFnbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCEoaXNOdWxsKHJlbGF0aXZlSWRlbnRpZmllcikgfHwgaXNOdW1iZXIocmVsYXRpdmVJZGVudGlmaWVyKSB8fCBpc1N0cmluZyhyZWxhdGl2ZUlkZW50aWZpZXIpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKHRoaXMuY29udHJvbC50eXBlICsgJyBjYW5ub3QgYmluZCB0ZW1wbGF0ZSB3aXRoIHJlbGF0aXZlSWRlbnRpZmllcjogJyArIHJlbGF0aXZlSWRlbnRpZmllciArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICcuIElkZW50aWZpZXIgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuY29udHJvbCwgY29udHJvbE1hbmFnZXIgPSB0aGlzLl9tYW5hZ2VyQ2FjaGUucmVhZChwYXJlbnQudWlkKSwgbWFuYWdlciA9IHRoaXMuX0VsZW1lbnRNYW5hZ2VyRmFjdG9yeS5nZXRJbnN0YW5jZSgpLCBjb250cm9sID0gdGhpcy5fY3JlYXRlQm91bmRDb250cm9sKCcnLCBmcmFnbWVudCwgcmVsYXRpdmVJZGVudGlmaWVyLCByZXNvdXJjZXMpLCBub2RlTWFwID0gdGhpcy5fY3JlYXRlTm9kZU1hcChjb250cm9sLCBmcmFnbWVudCwgcmVsYXRpdmVJZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudC5jb250cm9scy5wdXNoKGNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgY29udHJvbE1hbmFnZXIuY2hpbGRyZW4gPSBbXTtcclxuICAgICAgICAgICAgICAgIG1hbmFnZXIuaW5pdGlhbGl6ZShub2RlTWFwLCBjb250cm9sTWFuYWdlcik7XHJcbiAgICAgICAgICAgICAgICBtYW5hZ2VyLnNldFVpQ29udHJvbFRlbXBsYXRlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFuYWdlci5mdWxmaWxsQW5kTG9hZCgpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfZG9jdW1lbnQgPSBfdGhpcy5fZG9jdW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbC5zdGFydE5vZGUgPSBmcmFnbWVudC5pbnNlcnRCZWZvcmUoX2RvY3VtZW50LmNyZWF0ZUNvbW1lbnQoY29udHJvbC50eXBlICsgX19TVEFSVF9OT0RFKSwgZnJhZ21lbnQuZmlyc3RDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbC5lbmROb2RlID0gZnJhZ21lbnQuaW5zZXJ0QmVmb3JlKF9kb2N1bWVudC5jcmVhdGVDb21tZW50KGNvbnRyb2wudHlwZSArIF9fRU5EX05PREUpLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQmluZGFibGVUZW1wbGF0ZXMucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoa2V5LCByZWxhdGl2ZUlkZW50aWZpZXIsIHJlc291cmNlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmQoa2V5LCByZWxhdGl2ZUlkZW50aWZpZXIsIHJlc291cmNlcyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEJpbmRhYmxlVGVtcGxhdGVzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoa2V5LCB0ZW1wbGF0ZSwgb3ZlcndyaXRlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKHRoaXMuY29udHJvbC50eXBlICsgJyBtdXN0IHVzZSBhIHZhbGlkIGtleSB0byBhZGQgYSB0ZW1wbGF0ZSB0byBCaW5kYWJsZVRlbXBsYXRlcy4nKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdGVtcGxhdGVQcm9taXNlID0gdGhpcy50ZW1wbGF0ZXNba2V5XTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKHRlbXBsYXRlUHJvbWlzZSkgJiYgIW92ZXJ3cml0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwodGVtcGxhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNTdHJpbmcodGVtcGxhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29tcGlsZShrZXksIHNlcmlhbGl6ZUh0bWwodGVtcGxhdGUpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0RvY3VtZW50RnJhZ21lbnQodGVtcGxhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29tcGlsZShrZXksIHRlbXBsYXRlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOb2RlKHRlbXBsYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHRlbXBsYXRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlKHRlbXBsYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFwcGVuZENoaWxkcmVuKHRlbXBsYXRlLCBmcmFnbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb21waWxlKGtleSwgZnJhZ21lbnQpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBCaW5kYWJsZVRlbXBsYXRlcy5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIChpbmRleCwga2V5LCByZWxhdGl2ZUlkZW50aWZpZXIsIHJlc291cmNlcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSB0aGlzLmNvbnRyb2wuY29udHJvbHNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFCaW5kYWJsZVRlbXBsYXRlcy5pc0JvdW5kQ29udHJvbChjb250cm9sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKCdUaGUgY2hpbGQgY29udHJvbCBvZiAnICsgdGhpcy5jb250cm9sLnR5cGUgKyAnIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXg6ICcgKyBpbmRleCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICcgaXMgbm90IGEgYm91bmQgY29udHJvbCBhbmQgdGh1cyBjYW5ub3QgYmUgcmVwbGFjZWQgYnkgQmluZGFibGVUZW1wbGF0ZXMuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UucmVzb2x2ZShbXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kTm9kZSA9IGNvbnRyb2wuZW5kTm9kZTtcclxuICAgICAgICAgICAgICAgIGlmICghKGlzTm9kZShlbmROb2RlKSAmJiBpc05vZGUoZW5kTm9kZS5wYXJlbnROb2RlKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cud2FybignVGhlIGNoaWxkIGNvbnRyb2wgb2YgJyArIHRoaXMuY29udHJvbC50eXBlICsgJyBhdCB0aGUgc3BlY2lmaWVkIGluZGV4OiAnICsgaW5kZXggK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnIGhhZCBlaXRoZXIgbm8gcGxhY2Vob2xkaW5nIGNvbW1lbnQgbm9kZXMgb3IgaXRzIGNvbW1lbnQgbm9kZXMgaGFkIG5vIHBhcmVudCBhbmQgdGh1cyAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Nhbm5vdCBiZSByZXBsYWNlZCBieSBCaW5kYWJsZVRlbXBsYXRlcy4nKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5yZXNvbHZlKFtdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9iaW5kKGtleSwgcmVsYXRpdmVJZGVudGlmaWVyLCByZXNvdXJjZXMsIGluZGV4KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENsZWFycyB0aGUgbWVtb3J5IGJlaW5nIGhlbGQgYnkgdGhpcyBpbnN0YW5jZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmRhYmxlVGVtcGxhdGVzLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpc3Bvc2UgPSB0aGlzLl9UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5LmRpc3Bvc2UsIGNvbXBpbGVkQ29udHJvbHMgPSB0aGlzLl9fY29tcGlsZWRDb250cm9scywgbGVuZ3RoID0gY29tcGlsZWRDb250cm9scy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zZShjb21waWxlZENvbnRyb2xzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX19jb21waWxlZENvbnRyb2xzID0gW107XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2wgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZXMgPSB7fTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE1ldGhvZCBmb3IgbGlua2luZyBhIHRlbXBsYXRlIHRvIGEgZGF0YSBjb250ZXh0IGFuZCByZXR1cm5pbmcgYSBjbG9uZSBvZiB0aGUgdGVtcGxhdGUsXHJcbiAgICAgICAgICAgICAqIHdpdGggYWxsIG5ldyBDb250cm9scyBjcmVhdGVkIGlmIHRoZSB0ZW1wbGF0ZSBjb250YWlucyBjb250cm9scy4gSWYgbm8gZGF0YSBjb250ZXh0XHJcbiAgICAgICAgICAgICAqIGlzIHNwZWNpZmllZCwgaXQgd2lsbCBiZSBpbmhlcml0ZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB1c2VkIHRvIHJldHJpZXZlIHRoZSB0ZW1wbGF0ZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlSWRlbnRpZmllcj8gVGhlIGlkZW50aWZpZXIgc3RyaW5nIHJlbGF0aXZlIHRvIHRoaXMgY29udHJvbCdzIGNvbnRleHRcclxuICAgICAgICAgICAgICogKGUuZy4gJ2Zvby5iYXIuYmF6JyB3b3VsZCBzaWduaWZ5IHRoZSBvYmplY3QgdGhpcy5jb250ZXh0LmZvby5iYXIuYmF6KS4gVGhpcyBpcyB0aGVcclxuICAgICAgICAgICAgICogbW9zdCBlZmZpY2llbnQgd2F5IG9mIHNwZWNpZnlpbmcgY29udGV4dCwgZWxzZSB0aGUgZnJhbWV3b3JrIGhhcyB0byBzZWFyY2ggZm9yIHRoZVxyXG4gICAgICAgICAgICAgKiBvYmplY3QuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5JT2JqZWN0PHBsYXQuSVJlc291cmNlPn0gcmVzb3VyY2VzPyBBbiBvYmplY3QgdXNlZCBhcyB0aGUgcmVzb3VyY2VzIGZvciBhbnkgdG9wLWxldmVsXHJcbiAgICAgICAgICAgICAqIGNvbnRyb2xzIGNyZWF0ZWQgaW4gdGhlIHRlbXBsYXRlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXg/IEFuIG9wdGlvbmFsIGluZGV4IG9ubHkgdG8gYmUgdXNlZCBpZiB0aGUgbmV3bHkgYm91bmQgdGVtcGxhdGUgaXMgaW50ZW5kZWQgdG9cclxuICAgICAgICAgICAgICogcmVwbGFjZSBhbiBleGlzdGluZyBDb250cm9sIGluIHRoZSBjaGlsZCBjb250cm9scyBBcnJheSBhbmQgaXRzIGVsZW1lbnQgaW4gdGhlIERPTS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmRhYmxlVGVtcGxhdGVzLnByb3RvdHlwZS5fYmluZCA9IGZ1bmN0aW9uIChrZXksIHJlbGF0aXZlSWRlbnRpZmllciwgcmVzb3VyY2VzLCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZVByb21pc2UgPSB0aGlzLnRlbXBsYXRlc1trZXldLCBub0luZGV4ID0gaXNOdWxsKGluZGV4KTtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwodGVtcGxhdGVQcm9taXNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5lcnJvcihuZXcgRXJyb3IodGhpcy5jb250cm9sLnR5cGUgKyAnIGNhbm5vdCBiaW5kIHRlbXBsYXRlLCBubyB0ZW1wbGF0ZSBzdG9yZWQgd2l0aCBrZXk6ICcgKyBrZXkpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIShpc051bGwocmVsYXRpdmVJZGVudGlmaWVyKSB8fCBpc051bWJlcihyZWxhdGl2ZUlkZW50aWZpZXIpIHx8IGlzU3RyaW5nKHJlbGF0aXZlSWRlbnRpZmllcikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4odGhpcy5jb250cm9sLnR5cGUgKyAnIGNhbm5vdCBiaW5kIHRlbXBsYXRlIHdpdGggcmVsYXRpdmVJZGVudGlmaWVyOiAnICsgcmVsYXRpdmVJZGVudGlmaWVyICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJy4gSWRlbnRpZmllciBtdXN0IGJlIGVpdGhlciBhIHN0cmluZyBvciBudW1iZXInKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVByb21pc2UgPSB0ZW1wbGF0ZVByb21pc2UudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlID0gcmVzdWx0LmNsb25lTm9kZSh0cnVlKSwgY29udHJvbCA9IF90aGlzLl9jcmVhdGVCb3VuZENvbnRyb2woa2V5LCB0ZW1wbGF0ZSwgcmVsYXRpdmVJZGVudGlmaWVyLCByZXNvdXJjZXMpLCBub2RlTWFwID0gX3RoaXMuX2NyZWF0ZU5vZGVNYXAoY29udHJvbCwgdGVtcGxhdGUsIHJlbGF0aXZlSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29udHJvbC5jb250cm9scy5wdXNoKGNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2JpbmRUZW1wbGF0ZShrZXksIG5vZGVNYXApO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW5vSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGVtcGxhdGVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZE5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJhZ21lbnQuY2hpbGROb2RlcyksIG9sZENvbnRyb2wgPSBfdGhpcy5jb250cm9sLmNvbnRyb2xzW2luZGV4XSwgZW5kTm9kZSA9IG9sZENvbnRyb2wuZW5kTm9kZSwgcGFyZW50Tm9kZSA9IGVuZE5vZGUucGFyZW50Tm9kZSwgbmV4dFNpYmxpbmcgPSBlbmROb2RlLm5leHRTaWJsaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fVGVtcGxhdGVDb250cm9sRmFjdG9yeS5kaXNwb3NlKG9sZENvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShmcmFnbWVudCwgbmV4dFNpYmxpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGROb2RlcztcclxuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKG51bGwsIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0cG9uZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcoZXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2RvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZVByb21pc2UudGhlbihudWxsLCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3N0cG9uZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhlcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2RvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ3JlYXRlcyB0aGUgdGVtcGxhdGUncyBib3VuZCBjb250cm9sIGFuZCBJTm9kZU1hcCBhbmQgaW5pdGlhdGVzXHJcbiAgICAgICAgICAgICAqIHRoZSBiaW5kaW5nIG9mIHRoZSBJTm9kZU1hcCBmb3IgYSBjbG9uZWQgdGVtcGxhdGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHRlbXBsYXRlIGtleS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnByb2Nlc3NpbmcuSU5vZGVNYXB9IG5vZGVNYXAgVGhlIG5vZGUgbWFwIHRvIGJpbmQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kYWJsZVRlbXBsYXRlcy5wcm90b3R5cGUuX2JpbmRUZW1wbGF0ZSA9IGZ1bmN0aW9uIChrZXksIG5vZGVNYXApIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbCA9IG5vZGVNYXAudWlDb250cm9sTm9kZS5jb250cm9sLCBkaXNwb3NlZCA9IGZhbHNlLCBkaXNwb3NlID0gaXNGdW5jdGlvbihjb250cm9sLmRpc3Bvc2UpID8gY29udHJvbC5kaXNwb3NlLmJpbmQoY29udHJvbCkgOiBub29wO1xyXG4gICAgICAgICAgICAgICAgY29udHJvbC5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbC5kaXNwb3NlID0gZGlzcG9zZTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYmluZE5vZGVNYXAoa2V5LCBub2RlTWFwKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2RvY3VtZW50ID0gX3RoaXMuX2RvY3VtZW50LCB0ZW1wbGF0ZSA9IG5vZGVNYXAuZWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzcG9zZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wuc3RhcnROb2RlID0gdGVtcGxhdGUuaW5zZXJ0QmVmb3JlKF9kb2N1bWVudC5jcmVhdGVDb21tZW50KGNvbnRyb2wudHlwZSArIF9fU1RBUlRfTk9ERSksIHRlbXBsYXRlLmZpcnN0Q2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wuZW5kTm9kZSA9IHRlbXBsYXRlLmluc2VydEJlZm9yZShfZG9jdW1lbnQuY3JlYXRlQ29tbWVudChjb250cm9sLnR5cGUgKyBfX0VORF9OT0RFKSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xyXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zdHBvbmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcoZXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENsb25lcyB0aGUgY29tcGlsZWQgRWxlbWVudE1hbmFnZXIgdXNpbmcgdGhlIG5ld2x5IGNyZWF0ZWRcclxuICAgICAgICAgICAgICogSU5vZGVNYXAgYW5kIGJpbmRzIGFuZCBsb2FkcyB0aGlzIGNvbnRyb2wnc1xyXG4gICAgICAgICAgICAgKiBFbGVtZW50TWFuYWdlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgdGVtcGxhdGUga2V5IHVzZWQgdG8gZ3JhYiB0aGUgRWxlbWVudE1hbmFnZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5wcm9jZXNzaW5nLklOb2RlTWFwfSBub2RlTWFwIFRoZSBub2RlIG1hcCB0byBiaW5kLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZGFibGVUZW1wbGF0ZXMucHJvdG90eXBlLl9iaW5kTm9kZU1hcCA9IGZ1bmN0aW9uIChrZXksIG5vZGVNYXApIHtcclxuICAgICAgICAgICAgICAgIHZhciBtYW5hZ2VyID0gdGhpcy5jYWNoZVtrZXldLCBjaGlsZCA9IG5vZGVNYXAudWlDb250cm9sTm9kZS5jb250cm9sLCB0ZW1wbGF0ZSA9IG5vZGVNYXAuZWxlbWVudCwgX21hbmFnZXJDYWNoZSA9IHRoaXMuX21hbmFnZXJDYWNoZTtcclxuICAgICAgICAgICAgICAgIG1hbmFnZXIuY2xvbmUodGVtcGxhdGUsIF9tYW5hZ2VyQ2FjaGUucmVhZCh0aGlzLmNvbnRyb2wudWlkKSwgbm9kZU1hcCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX21hbmFnZXJDYWNoZS5yZWFkKGNoaWxkLnVpZCkuYmluZEFuZExvYWQoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENyZWF0ZXMgdGhlIHRlbXBsYXRlJ3MgY29tcGlsZWQsIGJvdW5kIGNvbnRyb2wgYW5kIElOb2RlTWFwIGFuZCBpbml0aWF0ZXNcclxuICAgICAgICAgICAgICogdGhlIGNvbXBpbGF0aW9uIG9mIHRoZSB0ZW1wbGF0ZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgdGVtcGxhdGUga2V5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IHRlbXBsYXRlIFRoZSBIVE1MIHRlbXBsYXRlIGJlaW5nIGJvdW5kLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZGFibGVUZW1wbGF0ZXMucHJvdG90eXBlLl9jb21waWxlID0gZnVuY3Rpb24gKGtleSwgdGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb250cm9sID0gdGhpcy5fY3JlYXRlQm91bmRDb250cm9sKGtleSArIF9fQ09NUElMRUQsIHRlbXBsYXRlKSwgbm9kZU1hcCA9IHRoaXMuX2NyZWF0ZU5vZGVNYXAoY29udHJvbCwgdGVtcGxhdGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2NvbXBpbGVkQ29udHJvbHMucHVzaChjb250cm9sKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVOb2RlTWFwKGNvbnRyb2wsIG5vZGVNYXAsIGtleSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbnN0YW50aWF0ZXMgYSBuZXcgRWxlbWVudE1hbmFnZXIgZm9yIHRoZSByb290IG9mIHRoaXNcclxuICAgICAgICAgICAgICogdGVtcGxhdGUgYW5kIHJlc29sdmVzIGFueSBhc3luY2hyb25vdXMgdXJsIHRlbXBsYXRlcyB3aXRoaW4gdGhlIHRlbXBsYXRlIGJlaW5nIGNvbXBpbGVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVGVtcGxhdGVDb250cm9sfSBjb250cm9sIFRoZSBuZXdseSBjcmVhdGVkIGNvbnRyb2wgdXNlZCB0byBiaW5kIHRoZSB0ZW1wbGF0ZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnByb2Nlc3NpbmcuSU5vZGVNYXB9IG5vZGVNYXAgVGhlIG5ld2x5IGNyZWF0ZWQgbm9kZSBtYXAgdG8gYmluZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgdGVtcGxhdGUga2V5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZGFibGVUZW1wbGF0ZXMucHJvdG90eXBlLl9jb21waWxlTm9kZU1hcCA9IGZ1bmN0aW9uIChjb250cm9sLCBub2RlTWFwLCBrZXkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWFuYWdlciA9IHRoaXMuX0VsZW1lbnRNYW5hZ2VyRmFjdG9yeS5nZXRJbnN0YW5jZSgpLCBwcm9taXNlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgbWFuYWdlci5pc0Nsb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIG1hbmFnZXIuaW5pdGlhbGl6ZShub2RlTWFwLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIG1hbmFnZXIuc2V0VWlDb250cm9sVGVtcGxhdGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVba2V5XSA9IG1hbmFnZXI7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKG1hbmFnZXIuZnVsZmlsbFRlbXBsYXRlKCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZXNba2V5XSA9IHRoaXMuX1Byb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IG5vZGVNYXAuZWxlbWVudCwgY2xvbmUgPSBlbGVtZW50LmNsb25lTm9kZSh0cnVlKSwgX2RvY3VtZW50ID0gX3RoaXMuX2RvY3VtZW50LCBzdGFydE5vZGUgPSBjb250cm9sLnN0YXJ0Tm9kZSA9IF9kb2N1bWVudC5jcmVhdGVDb21tZW50KGNvbnRyb2wudHlwZSArIF9fU1RBUlRfTk9ERSksIGVuZE5vZGUgPSBjb250cm9sLmVuZE5vZGUgPSBfZG9jdW1lbnQuY3JlYXRlQ29tbWVudChjb250cm9sLnR5cGUgKyBfX0VORF9OT0RFKTtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lmluc2VydEJlZm9yZShzdGFydE5vZGUsIGVsZW1lbnQuZmlyc3RDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5pbnNlcnRCZWZvcmUoZW5kTm9kZSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGFuIElOb2RlTWFwIGZvciBlaXRoZXIgYSB0ZW1wbGF0ZSBiZWluZyBjb21waWxlZCBvciBhXHJcbiAgICAgICAgICAgICAqIHRlbXBsYXRlIGJlaW5nIGJvdW5kLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVGVtcGxhdGVDb250cm9sfSB1aUNvbnRyb2wgVGhlIG5ld2x5IGNyZWF0ZWQgY29udHJvbCB1c2VkIHRvIGJpbmQgdGhlIHRlbXBsYXRlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge05vZGV9IHRlbXBsYXRlIFRoZSB0ZW1wbGF0ZSBiZWluZyBjb21waWxlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNoaWxkQ29udGV4dD8gQSBwb3RlbnRpYWwgY2hpbGQgY29udGV4dCBzdHJpbmcgaWRlbnRpZmllci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmRhYmxlVGVtcGxhdGVzLnByb3RvdHlwZS5fY3JlYXRlTm9kZU1hcCA9IGZ1bmN0aW9uICh1aUNvbnRyb2wsIHRlbXBsYXRlLCBjaGlsZENvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogdGVtcGxhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkQ29udGV4dDogY2hpbGRDb250ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgIHVpQ29udHJvbE5vZGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbDogdWlDb250cm9sLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlTmFtZTogdWlDb250cm9sLnR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5qZWN0b3I6IG51bGxcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIFRlbXBsYXRlQ29udHJvbCB1c2VkIGZvciBiaW5kaW5nIGVpdGhlciBhIHRlbXBsYXRlIGJlaW5nIGNvbXBpbGVkXHJcbiAgICAgICAgICAgICAqIG9yIGEgdGVtcGxhdGUgYmVpbmcgYm91bmQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHRlbXBsYXRlIGtleS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSB0ZW1wbGF0ZSBUaGUgdGVtcGxhdGUgYmVpbmcgY29tcGlsZWQgb3IgYmVpbmcgYm91bmQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5JT2JqZWN0PHBsYXQudWkuSVJlc291cmNlPn0gcmVzb3VyY2VzPyBBIHNldCBvZiByZXNvdXJjZXMgdG8gYWRkIHRvIHRoZSBjb250cm9sIHVzZWQgdG9cclxuICAgICAgICAgICAgICogY29tcGlsZS9iaW5kIHRoaXMgdGVtcGxhdGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kYWJsZVRlbXBsYXRlcy5wcm90b3R5cGUuX2NyZWF0ZUJvdW5kQ29udHJvbCA9IGZ1bmN0aW9uIChrZXksIHRlbXBsYXRlLCBjaGlsZENvbnRleHQsIHJlc291cmNlcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5ID0gdGhpcy5fVGVtcGxhdGVDb250cm9sRmFjdG9yeSwgY29udHJvbCA9IF9UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5LmdldEluc3RhbmNlKCksIF9SZXNvdXJjZXNGYWN0b3J5ID0gdGhpcy5fUmVzb3VyY2VzRmFjdG9yeSwgcGFyZW50ID0gdGhpcy5jb250cm9sLCBjb21waWxlZE1hbmFnZXIgPSB0aGlzLmNhY2hlW2tleV0sIGlzQ29tcGlsZWQgPSBpc09iamVjdChjb21waWxlZE1hbmFnZXIpLCBfcmVzb3VyY2VzID0gX1Jlc291cmNlc0ZhY3RvcnkuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0NvbXBpbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBpbGVkQ29udHJvbCA9IGNvbXBpbGVkTWFuYWdlci5nZXRVaUNvbnRyb2woKTtcclxuICAgICAgICAgICAgICAgICAgICBfcmVzb3VyY2VzLmluaXRpYWxpemUoY29udHJvbCwgY29tcGlsZWRDb250cm9sLnJlc291cmNlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Jlc291cmNlcy5hZGQocmVzb3VyY2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIF9yZXNvdXJjZXMuaW5pdGlhbGl6ZShjb250cm9sLCByZXNvdXJjZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udHJvbC5yZXNvdXJjZXMgPSBfcmVzb3VyY2VzO1xyXG4gICAgICAgICAgICAgICAgX1Jlc291cmNlc0ZhY3RvcnkuYWRkQ29udHJvbFJlc291cmNlcyhjb250cm9sKTtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2wuYmluZGFibGVUZW1wbGF0ZXMgPSB0aGlzLl9CaW5kYWJsZVRlbXBsYXRlc0ZhY3RvcnkuY3JlYXRlKGNvbnRyb2wsIHBhcmVudC5iaW5kYWJsZVRlbXBsYXRlcyk7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2wuY29udHJvbHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2wuZWxlbWVudCA9IHRlbXBsYXRlO1xyXG4gICAgICAgICAgICAgICAgY29udHJvbC50eXBlID0gcGFyZW50LnR5cGUgKyBfX0JPVU5EX1BSRUZJWCArIGtleTtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2wucm9vdCA9IHRoaXMuX0NvbnRyb2xGYWN0b3J5LmdldFJvb3RDb250cm9sKGNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzQ29tcGlsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dE1hbmFnZXIgPSB0aGlzLl9Db250ZXh0TWFuYWdlci5nZXRNYW5hZ2VyKGNvbnRyb2wucm9vdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbC5hYnNvbHV0ZUNvbnRleHRQYXRoID0gcGFyZW50LmFic29sdXRlQ29udGV4dFBhdGggfHwgX19DT05URVhUO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKGNoaWxkQ29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbC5hYnNvbHV0ZUNvbnRleHRQYXRoICs9ICcuJyArIGNoaWxkQ29udGV4dDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbC5jb250ZXh0ID0gY29udGV4dE1hbmFnZXIuZ2V0Q29udGV4dChjb250cm9sLmFic29sdXRlQ29udGV4dFBhdGguc3BsaXQoJy4nKSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2w7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBCaW5kYWJsZVRlbXBsYXRlcztcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIHVpLkJpbmRhYmxlVGVtcGxhdGVzID0gQmluZGFibGVUZW1wbGF0ZXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gSUJpbmRhYmxlVGVtcGxhdGVzRmFjdG9yeSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEJpbmRhYmxlVGVtcGxhdGVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB1aS5JQmluZGFibGVUZW1wbGF0ZXNGYWN0b3J5ID0gSUJpbmRhYmxlVGVtcGxhdGVzRmFjdG9yeTtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fQmluZGFibGVUZW1wbGF0ZXNGYWN0b3J5LCBJQmluZGFibGVUZW1wbGF0ZXNGYWN0b3J5LCBudWxsLCBfX0ZBQ1RPUlkpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjbGFzcyB0aGF0IHN0b3JlcyB0aGUgaW5mb3JtYXRpb24gYWJvdXQgYW4gRWxlbWVudCdzIGF0dHJpYnV0ZXMgKE5hbWVkTm9kZU1hcCkuXHJcbiAgICAgICAgICogTWV0aG9kcyBhcmUgaW1wbGVtZW50ZWQgdG8gYWxsb3cgeW91IHRvIG9ic2VydmUgZm9yIGNoYW5nZXMgb24gYW4gYXR0cmlidXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBBdHRyaWJ1dGVzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gQXR0cmlidXRlcygpIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIHNldCBvZiBmdW5jdGlvbnMgYWRkZWQgZXh0ZXJuYWxseSB0aGF0IGxpc3RlbnNcclxuICAgICAgICAgICAgICAgICAqIGZvciBhdHRyaWJ1dGUgY2hhbmdlcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2xpc3RlbmVycyA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEF0dHJpYnV0ZXMuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZXMoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluaXRpYWxpemVzIHRoaXMgaW5zdGFuY2Ugd2l0aCBhIENvbnRyb2wgYW5kIHRoZSBjYW1lbENhc2VkXHJcbiAgICAgICAgICAgICAqIGF0dHJpYnV0ZSBwcm9wZXJ0aWVzIGFuZCB0aGVpciB2YWx1ZXMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5Db250cm9sfSBjb250cm9sIFRoZSBmdW5jdGlvbiB0aGF0IGFjdHMgYXMgYSBsaXN0ZW5lci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LklPYmplY3Q8c3RyaW5nPn0gYXR0cmlidXRlcyBUaGUgY2FtZWxDYXNlZCBhdHRyaWJ1dGUgcHJvcGVydGllcyBhbmQgdGhlaXIgdmFsdWVzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQXR0cmlidXRlcy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChjb250cm9sLCBhdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fY29udHJvbCA9IGNvbnRyb2w7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLCBhdHRyaWJ1dGVMaXN0ZW5lcnMgPSB0aGlzLl9fbGlzdGVuZXJzLCBrZXksIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGtleXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc1trZXldID0gYXR0cmlidXRlc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUxpc3RlbmVyc1trZXldID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQcm92aWRlcyBhIHdheSB0byBvYnNlcnZlIGFuIGF0dHJpYnV0ZSBmb3IgY2hhbmdlcy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LklQcm9wZXJ0eUNoYW5nZWRMaXN0ZW5lcn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBhdHRyaWJ1dGUgY2hhbmdlcy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgYXR0cmlidXRlIHRvIG9ic2VydmUgZm9yIGNoYW5nZXMgKGUuZy4gJ3NyYycpLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQXR0cmlidXRlcy5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uIChsaXN0ZW5lciwga2V5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fX2xpc3RlbmVyc1tjYW1lbENhc2Uoa2V5KV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGxpc3RlbmVycykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9vcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIuYmluZCh0aGlzLl9fY29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVXNlZCB0byBzaG93IGFuIGF0dHJpYnV0ZSBoYXMgYmVlbiBjaGFuZ2VkIGFuZCBmb3JjZXMgbGlzdGVuZXJzIHRvIGJlIGZpcmVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBhdHRyaWJ1dGUgYmVpbmcgb2JzZXJ2ZWQgZm9yIGNoYW5nZXMgKGUuZy4gJ3NyYycpLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gbmV3VmFsdWUgVGhlIG5ldyB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2xkVmFsdWUgVGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBBdHRyaWJ1dGVzLnByb3RvdHlwZS5fYXR0cmlidXRlQ2hhbmdlZCA9IGZ1bmN0aW9uIChrZXksIG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX19saXN0ZW5lcnNbY2FtZWxDYXNlKGtleSldLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpXShuZXdWYWx1ZSwgb2xkVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gQXR0cmlidXRlcztcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIHVpLkF0dHJpYnV0ZXMgPSBBdHRyaWJ1dGVzO1xyXG4gICAgICAgIGZ1bmN0aW9uIElBdHRyaWJ1dGVzRmFjdG9yeSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEF0dHJpYnV0ZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVpLklBdHRyaWJ1dGVzRmFjdG9yeSA9IElBdHRyaWJ1dGVzRmFjdG9yeTtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fQXR0cmlidXRlc0luc3RhbmNlLCBBdHRyaWJ1dGVzLCBudWxsLCBfX0lOU1RBTkNFKTtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fQXR0cmlidXRlc0ZhY3RvcnksIElBdHRyaWJ1dGVzRmFjdG9yeSwgbnVsbCwgX19GQUNUT1JZKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXNvdXJjZXMgYXJlIHVzZWQgZm9yIHByb3ZpZGluZyBhbGlhc2VzIHRvIHVzZSBpbiBtYXJrdXAgZXhwcmVzc2lvbnMuIFRoZXlcclxuICAgICAgICAgKiBhcmUgcGFydGljdWxhcmx5IHVzZWZ1bCB3aGVuIHRyeWluZyB0byBhY2Nlc3MgcHJvcGVydGllcyBvdXRzaWRlIG9mIHRoZVxyXG4gICAgICAgICAqIGN1cnJlbnQgY29udGV4dCwgYXMgd2VsbCBhcyByZWFzc2lnbmluZyBjb250ZXh0IGF0IGFueSBwb2ludCBpbiBhbiBhcHAuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFJlc291cmNlcyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFJlc291cmNlcygpIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQW4gb2JqZWN0IHJlcHJlc2VudGluZyBhbGwgb2YgdGhlIGN1cnJlbnRseSBhdmFpbGFibGUgcmVzb3VyY2VzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fcmVzb3VyY2VzID0ge307XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgdGhpcyBSZXNvdXJjZXMgaW5zdGFuY2UgaGFzIGJlZW4gYm91bmQgeWV0LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fYm91bmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUG9wdWxhdGVzIGFuIElSZXNvdXJjZSB2YWx1ZSBpZiBuZWNlc3NhcnksIGFuZCBhZGRzIGl0IHRvIHRoZSBnaXZlblxyXG4gICAgICAgICAgICAgKiBjb250cm9sJ3MgcmVzb3VyY2VzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVGVtcGxhdGVDb250cm9sfSBjb250cm9sIFRoZSBjb250cm9sIGZvciB3aGljaCB0byBjcmVhdGUgYSByZXNvdXJjZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklSZXNvdXJjZX0gcmVzb3VyY2UgVGhlIG9iamVjdCB1c2VkIHRvIHNldCB0aGUgcmVzb3VyY2UgdmFsdWVzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUmVzb3VyY2VzLmNyZWF0ZSA9IGZ1bmN0aW9uIChjb250cm9sLCByZXNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChyZXNvdXJjZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb3VyY2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJlc291cmNlLnR5cGUudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgX19JTkpFQ1RBQkxFX1JFU09VUkNFOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5qZWN0b3IgPSBpbmplY3RhYmxlSW5qZWN0b3JzW3Jlc291cmNlLnZhbHVlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc051bGwoaW5qZWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZS52YWx1ZSA9IGluamVjdG9yLmluamVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgX19PQlNFUlZBQkxFX1JFU09VUkNFOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBSZXNvdXJjZXMuX29ic2VydmVSZXNvdXJjZShjb250cm9sLCByZXNvdXJjZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgX19PQkpFQ1RfUkVTT1VSQ0U6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzb3VyY2UudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlLnZhbHVlID0gY29udHJvbC5ldmFsdWF0ZUV4cHJlc3Npb24odmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgX19MSVRFUkFMX1JFU09VUkNFOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIF9fRlVOQ1RJT05fUkVTT1VSQ0U6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzb3VyY2UudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY29udHJvbFt2YWx1ZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZS52YWx1ZSA9IHZhbHVlLmJpbmQoY29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZXNvdXJjZXMuX2xvZy53YXJuKCdBdHRlbXB0ZWQgdG8gY3JlYXRlIGEgXCJmdW5jdGlvblwiICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndHlwZSBSZXNvdXJjZSwgYnV0IHRoZSBmdW5jdGlvbiAnICsgdmFsdWUgKyAnY2Fubm90IGJlIGZvdW5kIG9uIHlvdXIgY29udHJvbC4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZS52YWx1ZSA9IG5vb3A7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb3VyY2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBZGRzIHJlc291cmNlIGFsaWFzZXMgZm9yIGBAY29udHJvbGAgYW5kIGBAY29udGV4dGAuIFRoZSByZXNvdXJjZXMgYXJlXHJcbiAgICAgICAgICAgICAqIGFsaWFzZXMgZm9yIHRoZSBjb250cm9sIGluc3RhbmNlIGFuZCB0aGUgY29udHJvbC5jb250ZXh0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVGVtcGxhdGVDb250cm9sfSBjb250cm9sIFRoZSBjb250cm9sIG9uIHdoaWNoIHRvIGFkZCB0aGUgcmVzb3VyY2VzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUmVzb3VyY2VzLmFkZENvbnRyb2xSZXNvdXJjZXMgPSBmdW5jdGlvbiAoY29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgY29udHJvbC5yZXNvdXJjZXMuYWRkKHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb250cm9sLmNvbnRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IF9fT0JTRVJWQUJMRV9SRVNPVVJDRVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29udHJvbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogX19PQkpFQ1RfUkVTT1VSQ0VcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChjb250cm9sLmhhc093bkNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBSZXNvdXJjZXMuX19hZGRSb290KGNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBSZXNvdXJjZXMuYmluZFJlc291cmNlcyA9IGZ1bmN0aW9uIChyZXNvdXJjZXNJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc291cmNlcyA9IHJlc291cmNlc0luc3RhbmNlLl9fcmVzb3VyY2VzO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChyZXNvdXJjZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSByZXNvdXJjZXNJbnN0YW5jZS5fX2NvbnRyb2xJbnN0YW5jZSwgYWxpYXNlcyA9IE9iamVjdC5rZXlzKHJlc291cmNlcyksIGNvbnRyb2xSZXNvdXJjZXMgPSBSZXNvdXJjZXMuX19jb250cm9sUmVzb3VyY2VzLCBsZW5ndGggPSBhbGlhc2VzLmxlbmd0aCwgYWxpYXM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxpYXMgPSBhbGlhc2VzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sUmVzb3VyY2VzW2FsaWFzXSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VzSW5zdGFuY2VbYWxpYXNdID0gcmVzb3VyY2VzW2FsaWFzXSA9IFJlc291cmNlcy5jcmVhdGUoY29udHJvbCwgcmVzb3VyY2VzSW5zdGFuY2VbYWxpYXNdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc291cmNlc0luc3RhbmNlLl9fYm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGlzcG9zZXMgYSByZXNvdXJjZSBpbnN0YW5jZSwgcmVtb3ZpbmcgaXRzIHJlZmVyZW5jZVxyXG4gICAgICAgICAgICAgKiBmcm9tIGEgY29udHJvbCBhbmQgYnJlYWtpbmcgcmVmZXJlbmNlcyB0byBhbGwgcmVzb3VyY2VcclxuICAgICAgICAgICAgICogb2JqZWN0cy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlRlbXBsYXRlQ29udHJvbH0gY29udHJvbCBUaGUgY29udHJvbCB3aG9zZSByZXNvdXJjZXMgd2lsbCBiZSBkaXNwb3NlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBwZXJzaXN0PyBXaGV0aGVyIG9yIG5vdCB0byBwZXJzaXN0IGEgcmVzb3VyY2Ugb2JqZWN0IHBvc3RcclxuICAgICAgICAgICAgICogZGlzcG9zYWwgb3Igc2V0IGl0IHRvIG51bGwuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSZXNvdXJjZXMuZGlzcG9zZSA9IGZ1bmN0aW9uIChjb250cm9sLCBwZXJzaXN0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzb3VyY2VzID0gY29udHJvbC5yZXNvdXJjZXM7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHJlc291cmNlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlc291cmNlcy5fX3Jlc291cmNlcyksIGtleSwgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGRlZmluZSA9IFJlc291cmNlcy5fQ29udGV4dE1hbmFnZXIuZGVmaW5lUHJvcGVydHksIHJlc291cmNlO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGtleXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UgPSByZXNvdXJjZXNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChyZXNvdXJjZSkgJiYgKHJlc291cmNlLnR5cGUgPT09IF9fT0JTRVJWQUJMRV9SRVNPVVJDRSB8fCByZXNvdXJjZS50eXBlID09PSBfX0xJVEVSQUxfUkVTT1VSQ0UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluZShyZXNvdXJjZXMsIGtleSwgcGVyc2lzdCA/IF9jbG9uZShyZXNvdXJjZSwgdHJ1ZSkgOiBudWxsLCB0cnVlLCB0cnVlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBSZXNvdXJjZXMuX3JlbW92ZUxpc3RlbmVycyhyZXNvdXJjZXMuX19jb250cm9sSW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGFyc2VzIGEgcmVzb3VyY2VzIEVsZW1lbnQgKGA8cGxhdC1yZXNvdXJjZXM+YCkgYW5kIGNyZWF0ZXNcclxuICAgICAgICAgICAgICogYW4gSU9iamVjdDxJUmVzb3VyY2U+IHdpdGggaXRzIGVsZW1lbnQgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgcmVzb3VyY2VzIGVsZW1lbnQgdG8gcGFyc2UuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSZXNvdXJjZXMucGFyc2VFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGVsZW1lbnQuY2hpbGRyZW4pLCBjaGlsZCwgX3JlZ2V4ID0gUmVzb3VyY2VzLl9yZWdleCwgd2hpdGVTcGFjZVJlZ2V4ID0gX3JlZ2V4LndoaXRlU3BhY2VSZWdleCwgcXVvdGF0aW9uUmVnZXggPSBfcmVnZXgucXVvdGF0aW9uUmVnZXgsIHJlc291cmNlcyA9IHt9LCByZXNvdXJjZSwgdHlwZXMgPSBSZXNvdXJjZXMuX19yZXNvdXJjZVR5cGVzLCBhdHRycywgYXR0ciwgbm9kZU5hbWUsIHRleHQ7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW4ucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZU5hbWUgPSBjaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdHlwZXNbbm9kZU5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhdHRycyA9IGNoaWxkLmF0dHJpYnV0ZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBhdHRyID0gYXR0cnMuZ2V0TmFtZWRJdGVtKF9fQUxJQVMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwoYXR0cikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlLmFsaWFzID0gYXR0ci52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gY2hpbGQudGV4dENvbnRlbnQucmVwbGFjZSh3aGl0ZVNwYWNlUmVnZXgsICckMScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KHRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZS52YWx1ZSA9IChub2RlTmFtZSA9PT0gX19JTkpFQ1RBQkxFX1JFU09VUkNFIHx8IG5vZGVOYW1lID09PSBfX0xJVEVSQUxfUkVTT1VSQ0UpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dC5yZXBsYWNlKHF1b3RhdGlvblJlZ2V4LCAnJykgOiB0ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlLnR5cGUgPSBub2RlTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZXNbcmVzb3VyY2UuYWxpYXNdID0gcmVzb3VyY2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb3VyY2VzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyBhIG5ldyBpbnN0YW5jZSB3aXRoIHR5cGUgUmVzb3VyY2VzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUmVzb3VyY2VzLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNvdXJjZXMoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE9ic2VydmVzIHRoZSByZXNvdXJjZSBpZiB0aGUgdHlwZSBpcyBgb2JzZXJ2YWJsZWAuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5UZW1wbGF0ZUNvbnRyb2x9IGNvbnRyb2wgVGhlIGNvbnRyb2wgaW4gY2hhcmdlIG9mIHRoZSBvYnNlcnZhYmxlIHJlc291cmNlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSVJlc291cmNlfSByZXNvdXJjZSBUaGUgcmVzb3VyY2UgdG8gb2JzZXJ2ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJlc291cmNlcy5fb2JzZXJ2ZVJlc291cmNlID0gZnVuY3Rpb24gKGNvbnRyb2wsIHJlc291cmNlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSByZXNvdXJjZS52YWx1ZSwgdWlkID0gY29udHJvbC51aWQsIHJlbW92ZUxpc3RlbmVycyA9IFJlc291cmNlcy5fX29ic2VydmFibGVSZXNvdXJjZVJlbW92ZUxpc3RlbmVyc1t1aWRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChyZW1vdmVMaXN0ZW5lcnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzID0gUmVzb3VyY2VzLl9fb2JzZXJ2YWJsZVJlc291cmNlUmVtb3ZlTGlzdGVuZXJzW3VpZF0gPSBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChyZXNvdXJjZS5pbml0aWFsVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzb3VyY2UuaW5pdGlhbFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UuaW5pdGlhbFZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGNvbnRyb2wub2JzZXJ2ZUV4cHJlc3Npb24oZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlLnZhbHVlID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlLnZhbHVlID0gY29udHJvbC5ldmFsdWF0ZUV4cHJlc3Npb24odmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlbW92ZXMgb2JzZXJ2YWJsZSByZXNvdXJjZSBsaXN0ZW5lcnMgZm9yIGEgc3BlY2lmaWVkIGNvbnRyb2wuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5UZW1wbGF0ZUNvbnRyb2x9IGNvbnRyb2wgVGhlIGNvbnRyb2wgd2hvc2UgbGlzdGVuZXJzIGFyZSBiZWluZyByZW1vdmVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUmVzb3VyY2VzLl9yZW1vdmVMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoY29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChjb250cm9sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB1aWQgPSBjb250cm9sLnVpZCwgcmVtb3ZlTGlzdGVuZXJzID0gUmVzb3VyY2VzLl9fb2JzZXJ2YWJsZVJlc291cmNlUmVtb3ZlTGlzdGVuZXJzW3VpZF07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShyZW1vdmVMaXN0ZW5lcnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aF85ID0gcmVtb3ZlTGlzdGVuZXJzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aF85OyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzW2ldKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkoUmVzb3VyY2VzLl9fb2JzZXJ2YWJsZVJlc291cmNlUmVtb3ZlTGlzdGVuZXJzLCB1aWQpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQWRkcyBhIGBAcm9vdGAgYWxpYXMgYW5kIGBAcm9vdENvbnRleHRgIHRvIGEgY29udHJvbCwgc3BlY2lmeWluZyB0aGF0IGl0IGNvbnRhaW5zIHRoZSByb290XHJcbiAgICAgICAgICAgICAqIGFuZCByb290IGNvbnRleHQuIFJvb3QgY29udHJvbHMgYXJlIGdlbmVyYWxseSB0aGUgcm9vdCBWaWV3Q29udHJvbC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlRlbXBsYXRlQ29udHJvbH0gY29udHJvbCBUaGUgcm9vdCBjb250cm9sLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUmVzb3VyY2VzLl9fYWRkUm9vdCA9IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sLnJlc291cmNlcy5hZGQoe1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3Q6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbnRyb2wsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IF9fT0JKRUNUX1JFU09VUkNFLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlhczogX19ST09UX1JFU09VUkNFXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICByb290Q29udGV4dDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29udHJvbC5jb250ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBfX09CU0VSVkFCTEVfUkVTT1VSQ0UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWFzOiBfX1JPT1RfQ09OVEVYVF9SRVNPVVJDRVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBSZXNvdXJjZXMucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoY29udHJvbEluc3RhbmNlLCByZXNvdXJjZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19jb250cm9sSW5zdGFuY2UgPSBjb250cm9sSW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHJlc291cmNlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc05vZGUocmVzb3VyY2VzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlcyA9IFJlc291cmNlcy5wYXJzZUVsZW1lbnQocmVzb3VyY2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHJlc291cmNlcy5yZXNvdXJjZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VzID0gcmVzb3VyY2VzLnJlc291cmNlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX19yZXNvdXJjZXMgPSByZXNvdXJjZXM7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlc291cmNlcyksIGtleSwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSByZXNvdXJjZXNba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUmVzb3VyY2VzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAocmVzb3VyY2VzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHJlc291cmNlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc05vZGUocmVzb3VyY2VzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlcyA9IFJlc291cmNlcy5wYXJzZUVsZW1lbnQocmVzb3VyY2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVzb3VyY2VzKSwgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIHJlc291cmNlLCBjb250cm9sID0gdGhpcy5fX2NvbnRyb2xJbnN0YW5jZSwgYm91bmQgPSB0aGlzLl9fYm91bmQsIGtleSwgY3JlYXRlID0gUmVzb3VyY2VzLmNyZWF0ZTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlID0gcmVzb3VyY2VzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UuYWxpYXMgPSBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc1trZXldID0gdGhpcy5fX3Jlc291cmNlc1trZXldID0gYm91bmQgPyBjcmVhdGUoY29udHJvbCwgcmVzb3VyY2UpIDogcmVzb3VyY2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgaW5qZWN0YWJsZSByZXNvdXJjZSB0eXBlIHRva2VuLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUmVzb3VyY2VzLklOSkVDVEFCTEUgPSBfX0lOSkVDVEFCTEVfUkVTT1VSQ0U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgb2JqZWN0IHJlc291cmNlIHR5cGUgdG9rZW4uIE9iamVjdHMgc2hvdWxkIGJlIGxpdGVyYWwgb2JqZWN0cyBhbmQgd29uJ3QgYmUgb2JzZXJ2ZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSZXNvdXJjZXMuT0JKRUNUID0gX19PQkpFQ1RfUkVTT1VSQ0U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgb2JzZXJ2YWJsZSByZXNvdXJjZSB0eXBlIHRva2VuLiBPYnNlcnZhYmxlIHJlc291cmNlcyBhcmUgZXhwZWN0ZWQgdG8gYmVcclxuICAgICAgICAgICAgICogc3RyaW5nIGlkZW50aWZpZXJzIGFuZCB3aWxsIGJlIG9ic2VydmVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUmVzb3VyY2VzLk9CU0VSVkFCTEUgPSBfX09CU0VSVkFCTEVfUkVTT1VSQ0U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgbGl0ZXJhbCByZXNvdXJjZSB0eXBlIHRva2VuLiBMaXRlcmFscyB3aWxsIGJlIG9ic2VydmVkIG9uIHRoZSByZXNvdXJjZSBvYmplY3QsXHJcbiAgICAgICAgICAgICAqIHNvIGlmIHlvdSBjaGFuZ2UgYHJlc291cmNlcy48YWxpYXM+LnZhbHVlYCBpdCB3aWxsIGJlIHJlZmxlY3RlZCBldmVyeXdoZXJlIGl0IGlzXHJcbiAgICAgICAgICAgICAqIG9ic2VydmVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUmVzb3VyY2VzLkxJVEVSQUwgPSBfX0xJVEVSQUxfUkVTT1VSQ0U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgZnVuY3Rpb24gcmVzb3VyY2UgdHlwZSB0b2tlbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJlc291cmNlcy5GVU5DVElPTiA9IF9fRlVOQ1RJT05fUkVTT1VSQ0U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBbiBvYmplY3QgY29uc2lzdGluZyBvZiBrZXllZCBhcnJheXMgY29udGFpbmluZyBmdW5jdGlvbnMgZm9yIHJlbW92aW5nIG9ic2VydmF0aW9uIGxpc3RlbmVycy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJlc291cmNlcy5fX29ic2VydmFibGVSZXNvdXJjZVJlbW92ZUxpc3RlbmVycyA9IHt9O1xyXG4gICAgICAgICAgICByZXR1cm4gUmVzb3VyY2VzO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgdWkuUmVzb3VyY2VzID0gUmVzb3VyY2VzO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIElSZXNvdXJjZXNGYWN0b3J5KF9Db250ZXh0TWFuYWdlciwgX3JlZ2V4LCBfbG9nKSB7XHJcbiAgICAgICAgICAgIFJlc291cmNlcy5fQ29udGV4dE1hbmFnZXIgPSBfQ29udGV4dE1hbmFnZXI7XHJcbiAgICAgICAgICAgIFJlc291cmNlcy5fcmVnZXggPSBfcmVnZXg7XHJcbiAgICAgICAgICAgIFJlc291cmNlcy5fbG9nID0gX2xvZztcclxuICAgICAgICAgICAgdmFyIGNvbnRyb2xSZXNvdXJjZXMgPSB7fSwgcmVzb3VyY2VUeXBlcyA9IHt9O1xyXG4gICAgICAgICAgICBjb250cm9sUmVzb3VyY2VzW19fQ09OVFJPTF9SRVNPVVJDRV0gPSBjb250cm9sUmVzb3VyY2VzW19fQ09OVEVYVF9SRVNPVVJDRV0gPSBjb250cm9sUmVzb3VyY2VzW19fUk9PVF9SRVNPVVJDRV0gPSBjb250cm9sUmVzb3VyY2VzW19fUk9PVF9DT05URVhUX1JFU09VUkNFXSA9IHRydWU7XHJcbiAgICAgICAgICAgIHJlc291cmNlVHlwZXNbX19JTkpFQ1RBQkxFX1JFU09VUkNFXSA9IHJlc291cmNlVHlwZXNbX19PQkpFQ1RfUkVTT1VSQ0VdID0gcmVzb3VyY2VUeXBlc1tfX09CU0VSVkFCTEVfUkVTT1VSQ0VdID0gcmVzb3VyY2VUeXBlc1tfX0ZVTkNUSU9OX1JFU09VUkNFXSA9IHJlc291cmNlVHlwZXNbX19MSVRFUkFMX1JFU09VUkNFXSA9IHRydWU7XHJcbiAgICAgICAgICAgIFJlc291cmNlcy5fX2NvbnRyb2xSZXNvdXJjZXMgPSBjb250cm9sUmVzb3VyY2VzO1xyXG4gICAgICAgICAgICBSZXNvdXJjZXMuX19yZXNvdXJjZVR5cGVzID0gcmVzb3VyY2VUeXBlcztcclxuICAgICAgICAgICAgcmV0dXJuIFJlc291cmNlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdWkuSVJlc291cmNlc0ZhY3RvcnkgPSBJUmVzb3VyY2VzRmFjdG9yeTtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fUmVzb3VyY2VzRmFjdG9yeSwgSVJlc291cmNlc0ZhY3RvcnksIFtcclxuICAgICAgICAgICAgX19Db250ZXh0TWFuYWdlclN0YXRpYyxcclxuICAgICAgICAgICAgX19SZWdleCxcclxuICAgICAgICAgICAgX19Mb2dcclxuICAgICAgICBdLCBfX0ZBQ1RPUlkpO1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19SZXNvdXJjZXNJbnN0YW5jZSwgUmVzb3VyY2VzLCBudWxsLCBfX0lOU1RBTkNFKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGNsYXNzIGZvciBtYW5hZ2luZyBET00gZXZlbnQgcmVnaXN0cmF0aW9uIGFuZCBoYW5kbGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgRG9tRXZlbnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHJpZXZlIHRoZSB0eXBlIG9mIHRvdWNoIGV2ZW50cyBmb3IgdGhpcyBicm93c2VyIGFuZCBjcmVhdGUgdGhlIGRlZmF1bHQgZ2VzdHVyZSBzdHlsZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIERvbUV2ZW50cygpIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGV2ZW50IHR5cGVzIGZvciBhbGwgb2YgdGhlXHJcbiAgICAgICAgICAgICAgICAgKiBzdXBwb3J0ZWQgZ2VzdHVyZXMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX2dlc3R1cmVzID0gRG9tRXZlbnRzLmdlc3R1cmVzO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgdmVyc2lvbiBvZiBhbmRyb2lkLCBvciAtMSBpZiBub3Qgb24gYW5kcm9pZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYW5kcm9pZFZlcnNpb24gPSBpc1VuZGVmaW5lZCh0aGlzLl9jb21wYXQuQU5EUk9JRCkgPyAtMSA6IHRoaXMuX2NvbXBhdC5BTkRST0lEO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB3ZSdyZSBvbiBBbmRyb2lkIDQuNC54IG9yIGJlbG93LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hbmRyb2lkNDRvckJlbG93ID0gdGhpcy5fYW5kcm9pZFZlcnNpb24gPiAtMSAmJiBNYXRoLmZsb29yKHRoaXMuX2FuZHJvaWRWZXJzaW9uIC8gMTApIDw9IDQ0O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgdXNlciBpcyB1c2luZyBtb3VzZSB3aGVuIHRvdWNoIGV2ZW50cyBhcmUgcHJlc2VudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5Nb3VzZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBbiBvYmplY3Qgd2l0aCBrZXllZCBzdWJzY3JpYmVycyB0aGF0IGtlZXAgdHJhY2sgb2YgYWxsIG9mIHRoZVxyXG4gICAgICAgICAgICAgICAgICogZXZlbnRzIHJlZ2lzdGVyZWQgb24gYSBwYXJ0aWN1bGFyIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZXJzID0ge307XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBudW1iZXIgb2YgY3VycmVudGx5IGFjdGl2ZVxyXG4gICAgICAgICAgICAgICAgICogZXZlbnRzIG9mIGVhY2ggYmFzZSB0eXBlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXN0dXJlQ291bnQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJHRhcDogMCxcclxuICAgICAgICAgICAgICAgICAgICAkZGJsdGFwOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICRob2xkOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICRyZWxlYXNlOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICRzd2lwZTogMCxcclxuICAgICAgICAgICAgICAgICAgICAkdHJhY2s6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgJHRyYWNrZW5kOiAwXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgdXNlciBtb3ZlZCB3aGlsZSBpbiB0b3VjaC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2hhc01vdmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZWlyIGlzIGEgcmVnaXN0ZXJlZCBcInJlbGVhc2VcIiBldmVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2hhc1JlbGVhc2UgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3Qgd2Ugc2hvdWxkIGJlIGRldGVjdGluZyBtb3ZlIGV2ZW50cy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2RldGVjdGluZ01vdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGN1cnJlbnQgdGFwIGNvdW50IHRvIGhlbHAgZGlzdGluZ3Vpc2ggc2luZ2xlIGZyb20gZG91YmxlIHRhcHMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX190YXBDb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgdG91Y2hlcyBvbiB0aGUgc2NyZWVuLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fdG91Y2hDb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gdG8gcmVtb3ZlIGEgZGVmZXJyZWQgdGFwIGdpdmVuIHRoZSBjYXNlIHRoYXQgYSB0YXAgZGVsYXkgd2FzIG5lZWRlZCBmb3JcclxuICAgICAgICAgICAgICAgICAqIHNvbWV0aGluZyBzdWNoIGFzIGEgZG91YmxlIHRhcCB0byB6b29tIGZlYXR1cmUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX19jYW5jZWxEZWZlcnJlZFRhcCA9IG5vb3A7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gZm9yIHJlbW92aW5nIGEgZGVmZXJyZWQgaG9sZCBldmVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2NhbmNlbERlZmVycmVkSG9sZCA9IG5vb3A7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgcmVndWxhciBleHByZXNzaW5vIGZvciBkZXRlcm1pbmluZyBhIFwiY2FuY2VsXCIgZXZlbnQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX19jYW5jZWxSZWdleCA9IC9jYW5jZWwvaTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSByZWd1bGFyIGV4cHJlc3Npbm8gZm9yIGRldGVybWluaW5nIGEgcG9pbnRlciBlbmQgZXZlbnQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX19wb2ludGVyRW5kUmVnZXggPSAvdXB8Y2FuY2VsL2k7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZXJlIGFyZSBhbnkgc3dpcGUgc3Vic2NyaWJlcnMgZm9yIHRoZSBjdXJyZW50IHRhcmdldCBkdXJpbmcgdG91Y2ggbW92ZSBldmVudHMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX19oYXZlU3dpcGVTdWJzY3JpYmVycyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIGZ1bmN0aW9uIHRvIHN0b3AgbGlzdGVuaW5nIGZvciBibHVyIGV2ZW50cyBvbiB0aGUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2JsdXJSZW1vdmVyID0gbm9vcDtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBzZXQgb2YgZmxhZ3Mgc2lnbmlmeWluZyB3aGV0aGVyIHdlIHNob3VsZCBpZ25vcmUgbmF0aXZlIGV2ZW50cyBvciBub3QuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX19pZ25vcmVFdmVudCA9IHsgbW91c2Vkb3duOiBmYWxzZSwgbW91c2V1cDogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBmdW5jdGlvbiB3aXRoIGEgYm91bmQgY29udGV4dCB0aGF0IHByZXZlbnRzIGRlZmF1bHQgYW5kIHN0b3BzIHByb3BhZ2F0aW9uIGZvciBkZWxheWVkIG9yIHBoYW50b20gY2xpY2tzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fYm91bmRQcmV2ZW50RGVmYXVsdENsaWNrID0gdGhpcy5fX3ByZXZlbnREZWZhdWx0Q2xpY2suYmluZCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBoYXNoIG1hcCBmb3IgbWFwcGluZyBjdXN0b20gZXZlbnRzIHRvIHN0YW5kYXJkIGV2ZW50cy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3JldmVyc2VNYXAgPSB7fTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG51bWJlciBvZiBjdXJyZW50bHkgYWN0aXZlIG1hcHBlZCB0b3VjaFxyXG4gICAgICAgICAgICAgICAgICogZXZlbnRzIG9mIGVhY2ggdHlwZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX21hcHBlZENvdW50ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICR0b3VjaHN0YXJ0OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICR0b3VjaG1vdmU6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgJHRvdWNoZW5kOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICR0b3VjaGNhbmNlbDogMFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBoYXNoIG9mIHRoZSBjdXJyZW50IHBvaW50ZXIgdG91Y2ggcG9pbnRzIG9uIHRoZSBwYWdlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fcG9pbnRlckhhc2ggPSB7fTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQW4gYXJyYXkgY29udGFpbmluZyBhbGwgY3VycmVudCBwb2ludGVyIHRvdWNoIHBvaW50cyBvbiB0aGUgcGFnZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3BvaW50ZXJFdmVudHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBzZXQgb2YgdG91Y2ggc3RhcnQsIG1vdmUsIGFuZCBlbmQgbGlzdGVuZXJzIHRvIGJlIHBsYWNlIG9uIHRoZSBkb2N1bWVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2xpc3RlbmVycyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2dldFR5cGVzKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBEb21FdmVudHMucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgdHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NvbXBhdCA9IHRoaXMuX2NvbXBhdCwgbWFwcGVkR2VzdHVyZXMgPSBfY29tcGF0Lm1hcHBlZEV2ZW50cywgbWFwcGVkVHlwZSA9IG1hcHBlZEdlc3R1cmVzW3R5cGVdLCBtYXBwaW5nRXhpc3RzID0gIWlzTnVsbChtYXBwZWRUeXBlKSwgbWFwcGVkQ291bnQgPSB0aGlzLl9fbWFwcGVkQ291bnQsIGdlc3R1cmVzID0gdGhpcy5fZ2VzdHVyZXMsIGxpc3RlbmVyUmVtb3ZlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hcHBpbmdFeGlzdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fcmV2ZXJzZU1hcFttYXBwZWRUeXBlXSA9IHR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3JlZ2lzdGVyRWxlbWVudChlbGVtZW50LCB0eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICBtYXBwZWRDb3VudFt0eXBlXSsrO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfY29tcGF0Lmhhc1RvdWNoRXZlbnRzICYmICF0aGlzLl9fY2FuY2VsUmVnZXgudGVzdChtYXBwZWRUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwZWRUeXBlID0gbWFwcGVkVHlwZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJ3RvdWNoJywgJ21vdXNlJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdzdGFydCcsICdkb3duJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdlbmQnLCAndXAnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3JldmVyc2VNYXBbbWFwcGVkVHlwZV0gPSB0eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGVsZW1lbnRbJ29uJyArIHR5cGVdKSB8fCBpc1VuZGVmaW5lZChnZXN0dXJlc1t0eXBlXSkgfHwgbWFwcGluZ0V4aXN0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lclJlbW92ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXBwaW5nRXhpc3RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFwcGVkQ291bnRbdHlwZV0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGVkQ291bnRbdHlwZV0tLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fdW5yZWdpc3RlckVsZW1lbnQoZWxlbWVudCwgdHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJSZW1vdmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHN3aXBlR2VzdHVyZSA9IGdlc3R1cmVzLiRzd2lwZSwgdHJhY2tHZXN0dXJlID0gZ2VzdHVyZXMuJHRyYWNrLCBjb3VudFR5cGUgPSB0eXBlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUuaW5kZXhPZih0cmFja0dlc3R1cmUpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFja2VuZCA9IGdlc3R1cmVzLiR0cmFja2VuZDtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudFR5cGUgPSB0eXBlID09PSB0cmFja2VuZCA/IHRyYWNrZW5kIDogdHJhY2tHZXN0dXJlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZS5pbmRleE9mKHN3aXBlR2VzdHVyZSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRUeXBlID0gc3dpcGVHZXN0dXJlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2VzdHVyZUNvdW50W2NvdW50VHlwZV0rKztcclxuICAgICAgICAgICAgICAgIHRoaXMuX19yZWdpc3RlckVsZW1lbnQoZWxlbWVudCwgdHlwZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lclJlbW92ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lclJlbW92ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9fcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbGVtZW50LCB0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSWYgRG9tRXZlbnRzIGlzIGluYWN0aXZlLCB3aWxsIGluaXRpYWxpemUgYmVoYXZpb3IgYW5kXHJcbiAgICAgICAgICAgICAqIGJlZ2luIGxpc3RlbmluZyBmb3IgZXZlbnRzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzQWN0aXZlID0gdGhpcy5faXNBY3RpdmU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNBY3RpdmUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkIGFuZCB3YXMgbmV2ZXIgZGlzcG9zZWQgXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3JlZ2lzdGVyVHlwZXMoKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoaXNBY3RpdmUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2FwcGVuZEdlc3R1cmVTdHlsZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNBY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU3RvcHMgbGlzdGVuaW5nIGZvciB0b3VjaCBldmVudHMgYW5kIHJlc2V0cyB0aGUgRG9tRXZlbnRzXHJcbiAgICAgICAgICAgICAqIGluc3RhbmNlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3VucmVnaXN0ZXJUeXBlcygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2JsdXJSZW1vdmVyKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fYmx1clJlbW92ZXIgPSBub29wO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2VzdHVyZUNvdW50ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICR0YXA6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgJGRibHRhcDogMCxcclxuICAgICAgICAgICAgICAgICAgICAkaG9sZDogMCxcclxuICAgICAgICAgICAgICAgICAgICAkcmVsZWFzZTogMCxcclxuICAgICAgICAgICAgICAgICAgICAkc3dpcGU6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgJHRyYWNrOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICR0cmFja2VuZDogMFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19tYXBwZWRDb3VudCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAkdG91Y2hzdGFydDogMCxcclxuICAgICAgICAgICAgICAgICAgICAkdG91Y2htb3ZlOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICR0b3VjaGVuZDogMCxcclxuICAgICAgICAgICAgICAgICAgICAkdG91Y2hjYW5jZWw6IDBcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0FjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlcnMgPSB7fTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19wb2ludGVyRXZlbnRzID0gW107XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fcG9pbnRlckhhc2ggPSB7fTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19yZXZlcnNlTWFwID0ge307XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9faWdub3JlRXZlbnQgPSB7IG1vdXNlZG93bjogZmFsc2UsIG1vdXNldXA6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fdGFwQ291bnQgPSB0aGlzLl9fdG91Y2hDb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZGV0ZWN0aW5nTW92ZSA9IHRoaXMuX19oYXNNb3ZlZCA9IHRoaXMuX19oYXNSZWxlYXNlID0gdGhpcy5fX2hhdmVTd2lwZVN1YnNjcmliZXJzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fbGFzdE1vdmVFdmVudCA9IHRoaXMuX19sYXN0VG91Y2hEb3duID0gdGhpcy5fX2xhc3RUb3VjaFVwID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19zd2lwZU9yaWdpbiA9IHRoaXMuX19jYXB0dXJlZFRhcmdldCA9IHRoaXMuX19mb2N1c2VkRWxlbWVudCA9IHRoaXMuX19kZWxheWVkQ2xpY2tSZW1vdmVyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19jYW5jZWxEZWZlcnJlZEhvbGQgPSB0aGlzLl9fY2FuY2VsRGVmZXJyZWRUYXAgPSBub29wO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBsaXN0ZW5lciBmb3IgdG91Y2gvbW91c2Ugc3RhcnQgZXZlbnRzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSVBvaW50ZXJFdmVudH0gZXYgVGhlIHRvdWNoIHN0YXJ0IGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX29uVG91Y2hTdGFydCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciBldmVudFR5cGUgPSBldi50eXBlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19pZ25vcmVFdmVudFtldmVudFR5cGVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2lnbm9yZUV2ZW50W2V2ZW50VHlwZV0gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fZGVsYXllZENsaWNrUmVtb3ZlcltldmVudFR5cGVdKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2LnRhcmdldCAhPT0gdGhpcy5fX2ZvY3VzZWRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldi5jYW5jZWxhYmxlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9fdG91Y2hDb3VudCsrID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50VHlwZSAhPT0gJ21vdXNlZG93bicpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pblRvdWNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2luVG91Y2ggPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gaW1tZWRpYXRlbHkgaWYgbW91c2UgZXZlbnQgYW5kIGN1cnJlbnRseSBpbiBhIHRvdWNoIFxyXG4gICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fY29tcGF0Lmhhc1RvdWNoRXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5Nb3VzZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBldiA9IHRoaXMuX19zdGFuZGFyZGl6ZUV2ZW50T2JqZWN0KGV2KTtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoZXYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBzZXQgbGFzdCBtb3ZlIGJhY2sgdG8gbnVsbCBhbmQgaGFzTW92ZWQgdG8gZmFsc2UgXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fbGFzdE1vdmVFdmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9faGFzTW92ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHZhciBjbGllbnRYID0gZXYuY2xpZW50WCwgY2xpZW50WSA9IGV2LmNsaWVudFksIHRpbWVTdGFtcCA9IGV2LnRpbWVTdGFtcCwgdGFyZ2V0ID0gZXYudGFyZ2V0LCBnZXN0dXJlcyA9IHRoaXMuX2dlc3R1cmVzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2xhc3RUb3VjaERvd24gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2J1dHRvbnM6IGV2Ll9idXR0b25zLFxyXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFg6IGNsaWVudFgsXHJcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50WTogY2xpZW50WSxcclxuICAgICAgICAgICAgICAgICAgICB0aW1lU3RhbXA6IHRpbWVTdGFtcCxcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcclxuICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBldi5pZGVudGlmaWVyXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3N3aXBlT3JpZ2luID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFg6IGNsaWVudFgsXHJcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50WTogY2xpZW50WSxcclxuICAgICAgICAgICAgICAgICAgICB4VGltZXN0YW1wOiB0aW1lU3RhbXAsXHJcbiAgICAgICAgICAgICAgICAgICAgeVRpbWVzdGFtcDogdGltZVN0YW1wLFxyXG4gICAgICAgICAgICAgICAgICAgIHhUYXJnZXQ6IHRhcmdldCxcclxuICAgICAgICAgICAgICAgICAgICB5VGFyZ2V0OiB0YXJnZXRcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYW5kcm9pZDQ0b3JCZWxvdykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19oYXZlU3dpcGVTdWJzY3JpYmVycyA9IHRoaXMuX19maW5kRmlyc3RTdWJzY3JpYmVycyh0YXJnZXQsIFtnZXN0dXJlcy4kc3dpcGUsIGdlc3R1cmVzLiRzd2lwZWRvd24sIGdlc3R1cmVzLiRzd2lwZWxlZnQsIGdlc3R1cmVzLiRzd2lwZXJpZ2h0LCBnZXN0dXJlcy4kc3dpcGV1cF0pLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZ2VzdHVyZUNvdW50ID0gdGhpcy5fZ2VzdHVyZUNvdW50LCBub0hvbGRzID0gZ2VzdHVyZUNvdW50LiRob2xkIDw9IDAsIG5vUmVsZWFzZSA9IGdlc3R1cmVDb3VudC4kcmVsZWFzZSA8PSAwLCBtYXBwZWRDb3VudCA9IHRoaXMuX19tYXBwZWRDb3VudDtcclxuICAgICAgICAgICAgICAgIC8vIGlmIGFueSBtb3ZpbmcgZXZlbnRzIHJlZ2lzdGVyZWQsIHJlZ2lzdGVyIG1vdmUgXHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRUeXBlID09PSAndG91Y2hzdGFydCcgfHwgbWFwcGVkQ291bnQuJHRvdWNobW92ZSA+IDAgfHwgZ2VzdHVyZUNvdW50LiR0cmFjayA+IDAgfHxcclxuICAgICAgICAgICAgICAgICAgICBnZXN0dXJlQ291bnQuJHRyYWNrZW5kID4gMCB8fCBnZXN0dXJlQ291bnQuJHN3aXBlID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19yZWdpc3RlclR5cGUodGhpcy5fbW92ZUV2ZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2RldGVjdGluZ01vdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgbWFwcGVkIGV2ZW50cyBcclxuICAgICAgICAgICAgICAgIHZhciBtYXBwZWRUeXBlID0gdGhpcy5fX3JldmVyc2VNYXBbZXZlbnRUeXBlXTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXBwZWRDb3VudFttYXBwZWRUeXBlXSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWFwcGVkRG9tRXZlbnQgPSB0aGlzLl9fZmluZEZpcnN0U3Vic2NyaWJlcihldi50YXJnZXQsIG1hcHBlZFR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKG1hcHBlZERvbUV2ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwZWREb21FdmVudC50cmlnZ2VyKGV2KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gaWYgbm8gaG9sZCBvciByZWxlYXNlIGV2ZW50cyBhcmUgcmVnaXN0ZXJlZCBcclxuICAgICAgICAgICAgICAgIGlmIChub0hvbGRzICYmIG5vUmVsZWFzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGhvbGRJbnRlcnZhbCA9IERvbUV2ZW50cy5jb25maWcuaW50ZXJ2YWxzLmhvbGRJbnRlcnZhbCwgZG9tRXZlbnQsIHN1YnNjcmliZUZuLCBkb21FdmVudEZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9Ib2xkcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19oYXNSZWxlYXNlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2NhbmNlbERlZmVycmVkSG9sZCA9IGRlZmVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19oYXNSZWxlYXNlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBob2xkSW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9SZWxlYXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9tRXZlbnQgPSB0aGlzLl9fZmluZEZpcnN0U3Vic2NyaWJlcihldi50YXJnZXQsIHRoaXMuX2dlc3R1cmVzLiRob2xkKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGRvbUV2ZW50Rm91bmQgPSAhaXNOdWxsKGRvbUV2ZW50KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlRm4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21FdmVudC50cmlnZ2VyKGV2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fY2FuY2VsRGVmZXJyZWRIb2xkID0gbm9vcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9faGFzUmVsZWFzZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhcyBib3RoIGhvbGQgYW5kIHJlbGVhc2UgZXZlbnRzIHJlZ2lzdGVyZWQgXHJcbiAgICAgICAgICAgICAgICAgICAgZG9tRXZlbnQgPSB0aGlzLl9fZmluZEZpcnN0U3Vic2NyaWJlcihldi50YXJnZXQsIHRoaXMuX2dlc3R1cmVzLiRob2xkKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGRvbUV2ZW50Rm91bmQgPSAhaXNOdWxsKGRvbUV2ZW50KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlRm4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21FdmVudC50cmlnZ2VyKGV2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9faGFzUmVsZWFzZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fX2NhbmNlbERlZmVycmVkSG9sZCA9IG5vb3A7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gc2V0IHRpbWVvdXQgdG8gZmlyZSB0aGUgc3Vic2NyaWJlRm4gXHJcbiAgICAgICAgICAgICAgICBpZiAoZG9tRXZlbnRGb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19jYW5jZWxEZWZlcnJlZEhvbGQgPSBkZWZlcihzdWJzY3JpYmVGbiwgaG9sZEludGVydmFsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgbGlzdGVuZXIgZm9yIHRvdWNoL21vdXNlIG1vdmUgZXZlbnRzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSVBvaW50ZXJFdmVudH0gZXYgVGhlIHRvdWNoIG1vdmUgZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fb25Ub3VjaE1vdmUgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNsZWFyIGhvbGQgZXZlbnQgXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fY2FuY2VsRGVmZXJyZWRIb2xkKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fY2FuY2VsRGVmZXJyZWRIb2xkID0gbm9vcDtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudFR5cGUgPSBldi50eXBlO1xyXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBtdWx0aXBsZSB0b3VjaGVzIHByZXNlbnQsIG9yIFxyXG4gICAgICAgICAgICAgICAgLy8gaWYgaXQgaXMgYSBtb3VzZSBldmVudCBhbmQgY3VycmVudGx5IGluIGEgdG91Y2ggXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5Ub3VjaCA9PT0gdHJ1ZSAmJiBldmVudFR5cGUgPT09ICdtb3VzZW1vdmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZ0ID0gdGhpcy5fX3N0YW5kYXJkaXplRXZlbnRPYmplY3QoZXYpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChldnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBtYXBwZWQgZXZlbnRzIFxyXG4gICAgICAgICAgICAgICAgdmFyIG1hcHBlZFR5cGUgPSB0aGlzLl9fcmV2ZXJzZU1hcFtldmVudFR5cGVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19tYXBwZWRDb3VudFttYXBwZWRUeXBlXSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWFwcGVkRG9tRXZlbnQgPSB0aGlzLl9fZmluZEZpcnN0U3Vic2NyaWJlcihldi50YXJnZXQsIG1hcHBlZFR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKG1hcHBlZERvbUV2ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwZWREb21FdmVudC50cmlnZ2VyKGV2dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGdlc3R1cmVDb3VudCA9IHRoaXMuX2dlc3R1cmVDb3VudCwgbm9UcmFja2luZyA9IGdlc3R1cmVDb3VudC4kdHJhY2sgPD0gMCwgbm9Td2lwaW5nID0gZ2VzdHVyZUNvdW50LiRzd2lwZSA8PSAwLCBjb25maWcgPSBEb21FdmVudHMuY29uZmlnLCBzd2lwZU9yaWdpbiA9IHRoaXMuX19zd2lwZU9yaWdpbiwgeCA9IGV2dC5jbGllbnRYLCB5ID0gZXZ0LmNsaWVudFksIG1pbk1vdmUgPSB0aGlzLl9faGFzTW92ZWQgfHxcclxuICAgICAgICAgICAgICAgICAgICAodGhpcy5fX2dldERpc3RhbmNlKHN3aXBlT3JpZ2luLmNsaWVudFgsIHgsIHN3aXBlT3JpZ2luLmNsaWVudFksIHkpID49IGNvbmZpZy5kaXN0YW5jZXMubWluU2Nyb2xsRGlzdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgbWluaW11bSBkaXN0YW5jZSBub3QgbWV0IFxyXG4gICAgICAgICAgICAgICAgaWYgKCFtaW5Nb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9faGFzTW92ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gbW92aW5nIGV2ZW50cyByZXR1cm4gXHJcbiAgICAgICAgICAgICAgICBpZiAobm9UcmFja2luZyAmJiBub1N3aXBpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBsYXN0TW92ZSA9IHRoaXMuX19sYXN0TW92ZUV2ZW50IHx8IHN3aXBlT3JpZ2luLCBkaXJlY3Rpb24gPSBldnQuZGlyZWN0aW9uID0gdGhpcy5fX2dldERpcmVjdGlvbih4IC0gbGFzdE1vdmUuY2xpZW50WCwgeSAtIGxhc3RNb3ZlLmNsaWVudFkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2hhbmRsZU9yaWdpbkNoYW5nZShkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGR4ID0gTWF0aC5hYnMoeCAtIHN3aXBlT3JpZ2luLmNsaWVudFgpLCBkeSA9IE1hdGguYWJzKHkgLSBzd2lwZU9yaWdpbi5jbGllbnRZKTtcclxuICAgICAgICAgICAgICAgIGV2dC52ZWxvY2l0eSA9IHRoaXMuX19nZXRWZWxvY2l0eShkeCwgZHksIGV2dC50aW1lU3RhbXAgLSBzd2lwZU9yaWdpbi54VGltZXN0YW1wLCBldnQudGltZVN0YW1wIC0gc3dpcGVPcmlnaW4ueVRpbWVzdGFtcCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW5vU3dpcGluZyAmJiB0aGlzLl9hbmRyb2lkNDRvckJlbG93ICYmIHRoaXMuX19oYXZlU3dpcGVTdWJzY3JpYmVycykge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0cmFja2luZyBldmVudHMgZXhpc3QgXHJcbiAgICAgICAgICAgICAgICBpZiAoIW5vVHJhY2tpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9faGFuZGxlVHJhY2soZXZ0LCBldik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fbGFzdE1vdmVFdmVudCA9IGV2dDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgbGlzdGVuZXIgZm9yIHRvdWNoL21vdXNlIGVuZCBldmVudHMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JUG9pbnRlckV2ZW50fSBldiBUaGUgdG91Y2ggZW5kIGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX29uVG91Y2hFbmQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRUeXBlID0gZXYudHlwZTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9faWdub3JlRXZlbnRbZXZlbnRUeXBlXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19pZ25vcmVFdmVudFtldmVudFR5cGVdID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2RlbGF5ZWRDbGlja1JlbW92ZXJbZXZlbnRUeXBlXSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldi50YXJnZXQgIT09IHRoaXMuX19mb2N1c2VkRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXYuY2FuY2VsYWJsZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0cG9uZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gKF90aGlzLl9fbGFzdFRvdWNoVXAgfHwge30pLnRhcmdldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fZG9jdW1lbnQuYm9keS5jb250YWlucyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19oYW5kbGVJbnB1dCh0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBoYXNNb3ZlZCA9IHRoaXMuX19oYXNNb3ZlZCwgbm90TW91c2VVcCA9IGV2ZW50VHlwZSAhPT0gJ21vdXNldXAnO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX190b3VjaENvdW50IDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdG91Y2hDb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdG91Y2hDb3VudC0tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5vdE1vdXNlVXApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhbGwgbm9uIG1vdXNlIGNhc2VzIFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudFR5cGUgPT09ICd0b3VjaGVuZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxsIHRvIGhhbmRsZSBhIHN0cmFuZ2UgaXNzdWUgd2hlbiB0b3VjaCBjbGlja2luZyBjZXJ0YWluIHR5cGVzIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiBET00gZWxlbWVudHMgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNNb3ZlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2hlY2sgZXYuY2FuY2VsYWJsZSBpbiB0aGUgRU5EIGNhc2UgaW4gY2FzZSBvZiBzY3JvbGxpbmcgY29uZGl0aW9ucyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldi5jYW5jZWxhYmxlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9pblRvdWNoID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbW1lZGlhdGVseSBoYW5kbGUgdGhlIGlucHV0IGRlcGVuZGluZyBvbiB0eXBlIGZvciBtb3JlIG5hdGl2ZS1saWtlIGV4cGVyaWVuY2UgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXYudGFyZ2V0ICE9PSB0aGlzLl9fZm9jdXNlZEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2hhbmRsZUlucHV0KGV2LnRhcmdldCkgJiYgZXYuY2FuY2VsYWJsZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldi5jYW5jZWxhYmxlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19wcmV2ZW50Q2xpY2tGcm9tVG91Y2goKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19wcmV2ZW50Q2xpY2tGcm9tVG91Y2goKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNVbmRlZmluZWQodGhpcy5faW5Ub3VjaCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2luTW91c2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBjYXNlIHdoZXJlIHRvdWNoZW5kIGZpcmVkIGFuZCBub3cgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vdXNlIGVuZCBpcyBhbHNvIGJlaW5nIGZpcmVkIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXYuY2FuY2VsYWJsZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luTW91c2UgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBjYW5jZWwgZXZlbnQgXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2NhbmNlbFJlZ2V4LnRlc3QoZXZlbnRUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19oYW5kbGVDYW5jZWxlZChldik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZUV2ZW50T2JqZWN0IGNyZWF0ZXMgdG91Y2hlcyBcclxuICAgICAgICAgICAgICAgIGV2ID0gdGhpcy5fX3N0YW5kYXJkaXplRXZlbnRPYmplY3QoZXYpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChldikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vdE1vdXNlVXApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pblRvdWNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBtYXBwZWQgZXZlbnRzIFxyXG4gICAgICAgICAgICAgICAgdmFyIG1hcHBlZFR5cGUgPSB0aGlzLl9fcmV2ZXJzZU1hcFtldmVudFR5cGVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19tYXBwZWRDb3VudFttYXBwZWRUeXBlXSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWFwcGVkRG9tRXZlbnQgPSB0aGlzLl9fZmluZEZpcnN0U3Vic2NyaWJlcihldi50YXJnZXQsIG1hcHBlZFR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKG1hcHBlZERvbUV2ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwZWREb21FdmVudC50cmlnZ2VyKGV2KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBhZGRpdGlvbmFsIGNoZWNrIGZvciBtb3VzZWRvd24vdG91Y2hzdGFydCAtIG1vdXNldXAvdG91Y2hlbmQgaW5jb25zaXN0ZW5jaWVzIFxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX190b3VjaENvdW50ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190b3VjaENvdW50ID0gZXYudG91Y2hlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fY2xlYXJUZW1wU3RhdGVzKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgcmVsZWFzZSBldmVudCBcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9faGFzUmVsZWFzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19oYW5kbGVSZWxlYXNlKGV2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBzd2lwZSBldmVudHMgXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9faGFuZGxlU3dpcGUoKTtcclxuICAgICAgICAgICAgICAgIHZhciBjb25maWcgPSBEb21FdmVudHMuY29uZmlnLCBpbnRlcnZhbHMgPSBjb25maWcuaW50ZXJ2YWxzLCB0b3VjaEVuZCA9IGV2LnRpbWVTdGFtcCwgdG91Y2hEb3duID0gdGhpcy5fX2xhc3RUb3VjaERvd247XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdXNlciBtb3ZlZCB0aGVpciBmaW5nZXIgKGZvciBzY3JvbGwpIHdlIGhhbmRsZSAkdHJhY2tlbmQgYW5kIHJldHVybiwgXHJcbiAgICAgICAgICAgICAgICAvLyBlbHNlIGlmIHRoZXkgaGFkIHRoZWlyIGZpbmdlciBkb3duIHRvbyBsb25nIHRvIGJlIGNvbnNpZGVyZWQgYSB0YXAsIHdlIHdhbnQgdG8gcmV0dXJuIFxyXG4gICAgICAgICAgICAgICAgaWYgKGhhc01vdmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2hhbmRsZVRyYWNrRW5kKGV2KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdGFwQ291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIGNhcHR1cmVkIHRhcmdldCBcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fY2FwdHVyZWRUYXJnZXQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNOdWxsKHRvdWNoRG93bikgfHwgKCh0b3VjaEVuZCAtIHRvdWNoRG93bi50aW1lU3RhbXApID4gaW50ZXJ2YWxzLnRhcEludGVydmFsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190YXBDb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgY2FwdHVyZWQgdGFyZ2V0IFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19jYXB0dXJlZFRhcmdldCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFRvdWNoVXAgPSB0aGlzLl9fbGFzdFRvdWNoVXAsIHggPSBldi5jbGllbnRYLCB5ID0gZXYuY2xpZW50WTtcclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGNhbiBiZSBhIGRvdWJsZSB0YXAgZXZlbnQgYnkgY2hlY2tpbmcgbnVtYmVyIG9mIHRhcHMsIGRpc3RhbmNlIGJldHdlZW4gdGFwcywgXHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgdGltZSBiZXR3ZWVuIHRhcHMgXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3RhcENvdW50ID4gMCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19nZXREaXN0YW5jZSh4LCBsYXN0VG91Y2hVcC5jbGllbnRYLCB5LCBsYXN0VG91Y2hVcC5jbGllbnRZKSA8PSBjb25maWcuZGlzdGFuY2VzLm1heERibFRhcERpc3RhbmNlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKCh0b3VjaEVuZCAtIGxhc3RUb3VjaFVwLnRpbWVTdGFtcCkgPD0gaW50ZXJ2YWxzLmRibFRhcEludGVydmFsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBkYmx0YXAgZXZlbnRzIFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19oYW5kbGVEYmx0YXAoZXYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RhcENvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSB0YXAgZXZlbnRzIFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2hhbmRsZVRhcChldik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fbGFzdFRvdWNoVXAgPSBldjtcclxuICAgICAgICAgICAgICAgIC8vIGNsZWFyIGNhcHR1cmVkIHRhcmdldCBcclxuICAgICAgICAgICAgICAgIHRoaXMuX19jYXB0dXJlZFRhcmdldCA9IG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDbGVhcnMgYWxsIHRlbXBvcmFyeSBzdGF0ZXMgbGlrZSBtb3ZlIGFuZCBob2xkIGV2ZW50cy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19jbGVhclRlbXBTdGF0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjbGVhciBob2xkIGV2ZW50IFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2NhbmNlbERlZmVycmVkSG9sZCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2NhbmNlbERlZmVycmVkSG9sZCA9IG5vb3A7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2RldGVjdGluZ01vdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdW5yZWdpc3RlclR5cGUodGhpcy5fbW92ZUV2ZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2RldGVjdGluZ01vdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gZm9yIHJlc2V0dGluZyBhbGwgdmFsdWVzIHBvdGVudGlhbGx5IG1vZGlmaWVkIGR1cmluZyB0aGUgdG91Y2ggZXZlbnQgc2VxdWVuY2UuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMucHJvdG90eXBlLl9fcmVzZXRUb3VjaEVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX190YXBDb3VudCA9IHRoaXMuX190b3VjaENvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luVG91Y2ggPSB0aGlzLl9faGFzUmVsZWFzZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3BvaW50ZXJIYXNoID0ge307XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fcG9pbnRlckV2ZW50cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLy8gY2xlYXIgY2FwdHVyZWQgdGFyZ2V0IFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2NhcHR1cmVkVGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy8gZ2VzdHVyZSBoYW5kbGluZyBtZXRob2RzIFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBmdW5jdGlvbiBmb3IgaGFuZGxpbmcgd2hlbiBnZXN0dXJlcyBhcmUgY2FuY2VsZWQgdmlhIHRoZSBCcm93c2VyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSVBvaW50ZXJFdmVudH0gZXYgVGhlIHRvdWNoIGNhbmNlbCBldmVudCBvYmplY3QuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMucHJvdG90eXBlLl9faGFuZGxlQ2FuY2VsZWQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0b3VjaGVzID0gZXYudG91Y2hlcyB8fCB0aGlzLl9fcG9pbnRlckV2ZW50cywgaW5kZXggPSB0aGlzLl9fZ2V0VG91Y2hJbmRleCh0b3VjaGVzKTtcclxuICAgICAgICAgICAgICAgIGV2ID0gaW5kZXggPj0gMCA/IHRvdWNoZXNbaW5kZXhdIDogdGhpcy5fX3N0YW5kYXJkaXplRXZlbnRPYmplY3QoZXYpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5Ub3VjaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2NsZWFyVGVtcFN0YXRlcygpO1xyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgbWFwcGVkIGV2ZW50cyBcclxuICAgICAgICAgICAgICAgIHZhciBtYXBwZWRUeXBlID0gdGhpcy5fX3JldmVyc2VNYXBbZXYudHlwZV07XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX21hcHBlZENvdW50W21hcHBlZFR5cGVdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXBwZWREb21FdmVudCA9IHRoaXMuX19maW5kRmlyc3RTdWJzY3JpYmVyKGV2LnRhcmdldCwgbWFwcGVkVHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc051bGwobWFwcGVkRG9tRXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBlZERvbUV2ZW50LnRyaWdnZXIoZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9faGFzTW92ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBbmRyb2lkIDQuNC54IGZpcmVzIHRvdWNoY2FuY2VsIHdoZW4gdGhlIGZpbmdlciBtb3ZlcyBvZmYgYW4gZWxlbWVudCB0aGF0IFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIGxpc3RlbmluZyBmb3IgdG91Y2ggZXZlbnRzLCBzbyB3ZSBzaG91bGQgaGFuZGxlIHN3aXBlcyBoZXJlIGluIHRoYXQgY2FzZS4gXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FuZHJvaWQ0NG9yQmVsb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2hhbmRsZVN3aXBlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19oYW5kbGVUcmFja0VuZChldik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fcmVzZXRUb3VjaEVuZCgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBmdW5jdGlvbiBmb3IgaGFuZGxpbmcgYW5kIGZpcmluZyB0YXAgZXZlbnRzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSVBvaW50ZXJFdmVudH0gZXYgVGhlIHRvdWNoIGVuZCBldmVudCBvYmplY3QuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMucHJvdG90eXBlLl9faGFuZGxlVGFwID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3RhcENvdW50Kys7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZ2VzdHVyZUNvdW50LiR0YXAgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBnZXN0dXJlcyA9IHRoaXMuX2dlc3R1cmVzLCBkb21FdmVudCA9IHRoaXMuX19maW5kRmlyc3RTdWJzY3JpYmVyKGV2LnRhcmdldCwgZ2VzdHVyZXMuJHRhcCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGRvbUV2ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGZpcmUgdGFwIGV2ZW50IGltbWVkaWF0ZWx5IGlmIG5vIGRibHRhcCB6b29tIGRlbGF5IFxyXG4gICAgICAgICAgICAgICAgLy8gb3IgYSBtb3VzZSBpcyBiZWluZyB1c2VkIFxyXG4gICAgICAgICAgICAgICAgaWYgKERvbUV2ZW50cy5jb25maWcuaW50ZXJ2YWxzLmRibFRhcFpvb21EZWxheSA8PSAwIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZXYucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZXYudHlwZSA9PT0gJ21vdXNldXAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXYuX2J1dHRvbnMgPSB0aGlzLl9fbGFzdFRvdWNoRG93bi5fYnV0dG9ucztcclxuICAgICAgICAgICAgICAgICAgICBkb21FdmVudC50cmlnZ2VyKGV2KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBkZWZlciBmb3IgdGFwIGRlbGF5IGluIGNhc2Ugb2Ygc29tZXRoaW5nIGxpa2UgZGVzaXJlZCBcclxuICAgICAgICAgICAgICAgIC8vIGRibHRhcCB6b29tIFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2NhbmNlbERlZmVycmVkVGFwID0gZGVmZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2Ll9idXR0b25zID0gX3RoaXMuX19sYXN0VG91Y2hEb3duLl9idXR0b25zO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbUV2ZW50LnRyaWdnZXIoZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9fdGFwQ291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9fY2FuY2VsRGVmZXJyZWRUYXAgPSBub29wO1xyXG4gICAgICAgICAgICAgICAgfSwgRG9tRXZlbnRzLmNvbmZpZy5pbnRlcnZhbHMuZGJsVGFwWm9vbURlbGF5KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gZm9yIGhhbmRsaW5nIGFuZCBmaXJpbmcgZG91YmxlIHRhcCBldmVudHMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JUG9pbnRlckV2ZW50fSBldiBUaGUgdG91Y2ggZW5kIGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19oYW5kbGVEYmx0YXAgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX190YXBDb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fY2FuY2VsRGVmZXJyZWRUYXAoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19jYW5jZWxEZWZlcnJlZFRhcCA9IG5vb3A7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZ2VzdHVyZUNvdW50LiRkYmx0YXAgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBkb21FdmVudCA9IHRoaXMuX19maW5kRmlyc3RTdWJzY3JpYmVyKGV2LnRhcmdldCwgdGhpcy5fZ2VzdHVyZXMuJGRibHRhcCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGRvbUV2ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV2Ll9idXR0b25zID0gdGhpcy5fX2xhc3RUb3VjaERvd24uX2J1dHRvbnM7XHJcbiAgICAgICAgICAgICAgICBkb21FdmVudC50cmlnZ2VyKGV2KTtcclxuICAgICAgICAgICAgICAgIC8vIHNldCB0b3VjaCBjb3VudCB0byAtMSB0byBwcmV2ZW50IHJlcGVhdGVkIGZpcmUgb24gc2VxdWVudGlhbCB0YXBzIFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3RhcENvdW50ID0gLTE7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIGZ1bmN0aW9uIGZvciBoYW5kbGluZyBhbmQgZmlyaW5nIHJlbGVhc2UgZXZlbnRzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSVBvaW50ZXJFdmVudH0gZXYgVGhlIHRvdWNoIGVuZCBldmVudCBvYmplY3QuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMucHJvdG90eXBlLl9faGFuZGxlUmVsZWFzZSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRvbUV2ZW50ID0gdGhpcy5fX2ZpbmRGaXJzdFN1YnNjcmliZXIoZXYudGFyZ2V0LCB0aGlzLl9nZXN0dXJlcy4kcmVsZWFzZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChkb21FdmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb21FdmVudC50cmlnZ2VyKGV2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX19oYXNSZWxlYXNlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIGZ1bmN0aW9uIGZvciBoYW5kbGluZyBhbmQgZmlyaW5nIHN3aXBlIGV2ZW50cy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19oYW5kbGVTd2lwZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHN3aXBpbmcgZXZlbnRzIGV4aXN0IFxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2dlc3R1cmVDb3VudC4kc3dpcGUgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBsYXN0TW92ZSA9IHRoaXMuX19sYXN0TW92ZUV2ZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChsYXN0TW92ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luID0gdGhpcy5fX3N3aXBlT3JpZ2luLCBkeCA9IE1hdGguYWJzKGxhc3RNb3ZlLmNsaWVudFggLSBvcmlnaW4uY2xpZW50WCksIGR5ID0gTWF0aC5hYnMobGFzdE1vdmUuY2xpZW50WSAtIG9yaWdpbi5jbGllbnRZKSwgc3dpcGVTdWJzY3JpYmVycyA9IHRoaXMuX19nZXRSZWdpc3RlcmVkU3dpcGVzKGxhc3RNb3ZlLmRpcmVjdGlvbiwgbGFzdE1vdmUudmVsb2NpdHksIGR4LCBkeSk7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3dpcGVTdWJzY3JpYmVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpcGVTdWJzY3JpYmVycy5wb3AoKS50cmlnZ2VyKGxhc3RNb3ZlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX19sYXN0TW92ZUV2ZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gZm9yIGhhbmRsaW5nIGFuZCBmaXJpbmcgdHJhY2sgZXZlbnRzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSVBvaW50ZXJFdmVudH0gZXYgVGhlIHRvdWNoIG1vdmUgZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSVBvaW50ZXJFdmVudH0gb3JpZ2luYWxFdiBUaGUgb3JpZ2luYWwgdG91Y2ggbW92ZSBldmVudCBvYmplY3RcclxuICAgICAgICAgICAgICogdXNlZCBmb3IgcHJldmVudGluZyBkZWZhdWx0IGluIHRoZSBjYXNlIG9mIGFuIEFORFJPSUQgZGV2aWNlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX2hhbmRsZVRyYWNrID0gZnVuY3Rpb24gKGV2LCBvcmlnaW5hbEV2KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ2VzdHVyZXMgPSB0aGlzLl9nZXN0dXJlcywgdHJhY2tHZXN0dXJlID0gZ2VzdHVyZXMuJHRyYWNrLCBkaXJlY3Rpb24gPSBldi5kaXJlY3Rpb24sIGV2ZW50VGFyZ2V0ID0gdGhpcy5fX2NhcHR1cmVkVGFyZ2V0IHx8IGV2LnRhcmdldDtcclxuICAgICAgICAgICAgICAgIHZhciBkb21FdmVudHMgPSB0aGlzLl9fZmluZEZpcnN0U3Vic2NyaWJlcnMoZXZlbnRUYXJnZXQsIFt0cmFja0dlc3R1cmUsICh0cmFja0dlc3R1cmUgKyBkaXJlY3Rpb24ueCksICh0cmFja0dlc3R1cmUgKyBkaXJlY3Rpb24ueSldKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hbmRyb2lkNDRvckJlbG93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFueUV2ZW50cyA9IHRoaXMuX19maW5kRmlyc3RTdWJzY3JpYmVycyhldmVudFRhcmdldCwgW3RyYWNrR2VzdHVyZSwgZ2VzdHVyZXMuJHRyYWNrZG93biwgZ2VzdHVyZXMuJHRyYWNrdXAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlc3R1cmVzLiR0cmFja2xlZnQsIGdlc3R1cmVzLiR0cmFja3JpZ2h0LCBnZXN0dXJlcy4kdHJhY2tlbmRdKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYW55RXZlbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChkb21FdmVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hbmRyb2lkVmVyc2lvbiA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGRvbUV2ZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbUV2ZW50cy5wb3AoKS50cmlnZ2VyKGV2KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIGZ1bmN0aW9uIGZvciBoYW5kbGluZyBhbmQgZmlyaW5nIHRyYWNrIGVuZCBldmVudHMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JUG9pbnRlckV2ZW50fSBldiBUaGUgdG91Y2ggZW5kIGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19oYW5kbGVUcmFja0VuZCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2dlc3R1cmVDb3VudC4kdHJhY2tlbmQgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBldmVudFRhcmdldCA9IHRoaXMuX19jYXB0dXJlZFRhcmdldCB8fCBldi50YXJnZXQsIGRvbUV2ZW50ID0gdGhpcy5fX2ZpbmRGaXJzdFN1YnNjcmliZXIoZXZlbnRUYXJnZXQsIHRoaXMuX2dlc3R1cmVzLiR0cmFja2VuZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGRvbUV2ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRvbUV2ZW50LnRyaWdnZXIoZXYpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyB0b3VjaCB0eXBlIGFuZCBlbGVtZW50IHJlZ2lzdHJhdGlvbiBcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gZm9yIGRldGVybWluaW5nIHRoZSBwcm9wZXIgdG91Y2ggZXZlbnRzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX2dldFR5cGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jb21wYXQgPSB0aGlzLl9jb21wYXQsIHRvdWNoRXZlbnRzID0gX2NvbXBhdC5tYXBwZWRFdmVudHMsIGxpc3RlbmVycyA9IHRoaXMuX19saXN0ZW5lcnMsIHN0YXJ0RXZlbnRzLCBtb3ZlRXZlbnRzLCBlbmRFdmVudHM7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2NvbXBhdC5oYXNQb2ludGVyRXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRFdmVudHMgPSB0aGlzLl9zdGFydEV2ZW50cyA9IHRvdWNoRXZlbnRzLiR0b3VjaHN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdmVFdmVudHMgPSB0aGlzLl9tb3ZlRXZlbnRzID0gdG91Y2hFdmVudHMuJHRvdWNobW92ZTtcclxuICAgICAgICAgICAgICAgICAgICBlbmRFdmVudHMgPSB0aGlzLl9lbmRFdmVudHMgPSB0b3VjaEV2ZW50cy4kdG91Y2hlbmQgKyAnICcgKyB0b3VjaEV2ZW50cy4kdG91Y2hjYW5jZWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfY29tcGF0Lmhhc1RvdWNoRXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRFdmVudHMgPSB0aGlzLl9zdGFydEV2ZW50cyA9IHRvdWNoRXZlbnRzLiR0b3VjaHN0YXJ0ICsgJyBtb3VzZWRvd24nO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdmVFdmVudHMgPSB0aGlzLl9tb3ZlRXZlbnRzID0gdG91Y2hFdmVudHMuJHRvdWNobW92ZSArICcgbW91c2Vtb3ZlJztcclxuICAgICAgICAgICAgICAgICAgICBlbmRFdmVudHMgPSB0aGlzLl9lbmRFdmVudHMgPSB0b3VjaEV2ZW50cy4kdG91Y2hlbmQgKyAnIG1vdXNldXAgJyArIHRvdWNoRXZlbnRzLiR0b3VjaGNhbmNlbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjYW5jZWxFdmVudCA9IHRvdWNoRXZlbnRzLiR0b3VjaGNhbmNlbDtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydEV2ZW50cyA9IHRoaXMuX3N0YXJ0RXZlbnRzID0gdG91Y2hFdmVudHMuJHRvdWNoc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbW92ZUV2ZW50cyA9IHRoaXMuX21vdmVFdmVudHMgPSB0b3VjaEV2ZW50cy4kdG91Y2htb3ZlO1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZEV2ZW50cyA9IHRoaXMuX2VuZEV2ZW50cyA9IHRvdWNoRXZlbnRzLiR0b3VjaGVuZCArICghY2FuY2VsRXZlbnQgPyAnJyA6ICgnICcgKyBjYW5jZWxFdmVudCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzW3N0YXJ0RXZlbnRzXSA9IHRoaXMuX29uVG91Y2hTdGFydC5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzW21vdmVFdmVudHNdID0gdGhpcy5fb25Ub3VjaE1vdmUuYmluZCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tlbmRFdmVudHNdID0gdGhpcy5fb25Ub3VjaEVuZC5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVnaXN0ZXJzIGZvciBhbmQgc3RhcnRzIGxpc3RlbmluZyB0byBzdGFydCBhbmQgZW5kIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMucHJvdG90eXBlLl9fcmVnaXN0ZXJUeXBlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19yZWdpc3RlclR5cGUodGhpcy5fc3RhcnRFdmVudHMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3JlZ2lzdGVyVHlwZSh0aGlzLl9lbmRFdmVudHMpO1xyXG4gICAgICAgICAgICAgICAgLy8gZHJhZ3N0YXJ0IHdpbGwgY2F1c2UgdG91Y2hlbmQgdG8gbm90IGZpcmUgXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9fcHJldmVudERlZmF1bHQsIGZhbHNlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFVucmVnaXN0ZXJzIGZvciBhbmQgc3RvcHMgbGlzdGVuaW5nIHRvIGFsbCB0b3VjaCBldmVudHMgb24gdGhlIGRvY3VtZW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX3VucmVnaXN0ZXJUeXBlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX191bnJlZ2lzdGVyVHlwZSh0aGlzLl9zdGFydEV2ZW50cyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fdW5yZWdpc3RlclR5cGUodGhpcy5fZW5kRXZlbnRzKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fZGV0ZWN0aW5nTW92ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX191bnJlZ2lzdGVyVHlwZSh0aGlzLl9tb3ZlRXZlbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fZGV0ZWN0aW5nTW92ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpcy5fX3ByZXZlbnREZWZhdWx0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZWdpc3RlcnMgZm9yIGFuZCBiZWdpbnMgbGlzdGVuaW5nIHRvIGEgcGFydGljdWxhciB0b3VjaCBldmVudCB0eXBlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRzIFRoZSBldmVudHMgdG8gYmVnaW4gbGlzdGVuaW5nIGZvci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19yZWdpc3RlclR5cGUgPSBmdW5jdGlvbiAoZXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLl9fbGlzdGVuZXJzW2V2ZW50c10sIF9kb2N1bWVudCA9IHRoaXMuX2RvY3VtZW50LCBldmVudFNwbGl0ID0gZXZlbnRzLnNwbGl0KCcgJyksIGluZGV4ID0gZXZlbnRTcGxpdC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXgtLSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBfZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFNwbGl0W2luZGV4XSwgbGlzdGVuZXIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFVucmVnaXN0ZXJzIGZvciBhbmQgc3RvcHMgbGlzdGVuaW5nIHRvIGEgcGFydGljdWxhciB0b3VjaCBldmVudCB0eXBlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRzIFRoZSBldmVudHMgdG8gc3RvcCBsaXN0ZW5pbmcgZm9yLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX3VucmVnaXN0ZXJUeXBlID0gZnVuY3Rpb24gKGV2ZW50cykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gdGhpcy5fX2xpc3RlbmVyc1tldmVudHNdLCBfZG9jdW1lbnQgPSB0aGlzLl9kb2N1bWVudCwgZXZlbnRTcGxpdCA9IGV2ZW50cy5zcGxpdCgnICcpLCBpbmRleCA9IGV2ZW50U3BsaXQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4LS0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2RvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRTcGxpdFtpbmRleF0sIGxpc3RlbmVyLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZWdpc3RlcnMgYW5kIGFzc29jaWF0ZXMgYW4gZWxlbWVudCB3aXRoIGFuIGV2ZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSUN1c3RvbUVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgYmVpbmcgdGllZCB0byBhIGN1c3RvbSBldmVudC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIHR5cGUgb2YgZXZlbnQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMucHJvdG90eXBlLl9fcmVnaXN0ZXJFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIHR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpZCwgX3BsYXQgPSBlbGVtZW50Ll9fcGxhdDtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoX3BsYXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQgPSB1bmlxdWVJZCgnZG9tRXZlbnRfJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5fX3BsYXQgPSBfcGxhdCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tRXZlbnQ6IGlkXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzTnVsbChfcGxhdC5kb21FdmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZCA9IHVuaXF1ZUlkKCdkb21FdmVudF8nKTtcclxuICAgICAgICAgICAgICAgICAgICBfcGxhdC5kb21FdmVudCA9IGlkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIF9kb21FdmVudDtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoaWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1YnNjcmliZXIgPSB0aGlzLl9zdWJzY3JpYmVyc1tfcGxhdC5kb21FdmVudF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHN1YnNjcmliZXJbdHlwZV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kb21FdmVudCA9IG5ldyBDdXN0b21Eb21FdmVudChlbGVtZW50LCB0eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlclt0eXBlXSA9IF9kb21FdmVudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJbdHlwZV0uY291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5nZXN0dXJlQ291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3U3Vic2NyaWJlciA9IHsgZ2VzdHVyZUNvdW50OiAxIH07XHJcbiAgICAgICAgICAgICAgICBfZG9tRXZlbnQgPSBuZXcgQ3VzdG9tRG9tRXZlbnQoZWxlbWVudCwgdHlwZSk7XHJcbiAgICAgICAgICAgICAgICBuZXdTdWJzY3JpYmVyW3R5cGVdID0gX2RvbUV2ZW50O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlcnNbaWRdID0gbmV3U3Vic2NyaWJlcjtcclxuICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoZWxlbWVudC5jbGFzc05hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgRG9tRXZlbnRzLmNvbmZpZy5zdHlsZUNvbmZpZ1swXS5jbGFzc05hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3JlbW92ZVNlbGVjdGlvbnMoZWxlbWVudCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBVbnJlZ2lzdGVycyBhbmQgZGlzYXNzb2NpYXRlcyBhbiBlbGVtZW50IHdpdGggYW4gZXZlbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JQ3VzdG9tRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCBiZWluZyBkaXNhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGN1c3RvbSBldmVudC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIHR5cGUgb2YgZXZlbnQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMucHJvdG90eXBlLl9fdW5yZWdpc3RlckVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgdHlwZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9wbGF0ID0gZWxlbWVudC5fX3BsYXQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKF9wbGF0KSB8fCBpc051bGwoX3BsYXQuZG9tRXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGRvbUV2ZW50SWQgPSBfcGxhdC5kb21FdmVudCwgZXZlbnRTdWJzY3JpYmVyID0gdGhpcy5fc3Vic2NyaWJlcnNbZG9tRXZlbnRJZF0sIGRvbUV2ZW50ID0gZXZlbnRTdWJzY3JpYmVyW3R5cGVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChkb21FdmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkb21FdmVudC5jb3VudC0tO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRvbUV2ZW50LmNvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkoZXZlbnRTdWJzY3JpYmVyLCB0eXBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV2ZW50U3Vic2NyaWJlci5nZXN0dXJlQ291bnQtLTtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudFN1YnNjcmliZXIuZ2VzdHVyZUNvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkodGhpcy5fc3Vic2NyaWJlcnMsIGRvbUV2ZW50SWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19yZW1vdmVFbGVtZW50KGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgY3VycmVudCB0b3VjaCBwb2ludCBhbmQgaGVscHMgc3RhbmRhcmRpemUgdGhlIGdpdmVuIGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklQb2ludGVyRXZlbnR9IGV2IFRoZSBjdXJyZW50IHBvaW50IGJlaW5nIHRvdWNoZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMucHJvdG90eXBlLl9fc2V0VG91Y2hQb2ludCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50VHlwZSA9IGV2LnR5cGUsIF9jb21wYXQgPSB0aGlzLl9jb21wYXQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2NvbXBhdC5oYXNQb2ludGVyRXZlbnRzIHx8IF9jb21wYXQuaGFzTXNQb2ludGVyRXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3VwZGF0ZVBvaW50ZXJzKGV2LCB0aGlzLl9fcG9pbnRlckVuZFJlZ2V4LnRlc3QoZXZlbnRUeXBlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXYucG9pbnRlclR5cGUgPSBldmVudFR5cGUuaW5kZXhPZignbW91c2UnKSA9PT0gLTEgPyAndG91Y2gnIDogJ21vdXNlJztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIGNhcHR1cmVkIHRhcmdldC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0IFRoZSB0YXJnZXQgdG8gY2FwdHVyZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19zZXRDYXB0dXJlID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbCh0aGlzLl9fY2FwdHVyZWRUYXJnZXQpICYmICFpc0RvY3VtZW50KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fY2FwdHVyZWRUYXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBjYXB0dXJlZCB0YXJnZXQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JUG9pbnRlckV2ZW50fSBldiBUaGUgY3VycmVudCB0b3VjaCBwb2ludC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSByZW1vdmUgV2hldGhlciB0byByZW1vdmUgdGhlIHRvdWNoIHBvaW50IG9yIGFkZCBpdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX191cGRhdGVQb2ludGVycyA9IGZ1bmN0aW9uIChldiwgcmVtb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBldi5wb2ludGVySWQsIHBvaW50ZXJIYXNoID0gdGhpcy5fX3BvaW50ZXJIYXNoLCBwb2ludGVyID0gcG9pbnRlckhhc2hbaWRdLCBpbmRleDtcclxuICAgICAgICAgICAgICAgIGlmIChyZW1vdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHBvaW50ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5fX3BvaW50ZXJFdmVudHMuaW5kZXhPZihwb2ludGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19wb2ludGVyRXZlbnRzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkodGhpcy5fX3BvaW50ZXJIYXNoLCBpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkID09PSAxICYmICFpc0VtcHR5KHBvaW50ZXJIYXNoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgbW91c2UgbW92ZW1lbnQgd2hpbGUgbWlkIHRvdWNoIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGV2LmlkZW50aWZpZXIgPSBldi5wb2ludGVySWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHBvaW50ZXIpIHx8IChpbmRleCA9IHRoaXMuX19wb2ludGVyRXZlbnRzLmluZGV4T2YocG9pbnRlcikpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fcG9pbnRlckV2ZW50cy5wdXNoKGV2KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19wb2ludGVyRXZlbnRzLnNwbGljZShpbmRleCwgMSwgZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwb2ludGVySGFzaFtpZF0gPSBldjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy8gZXZlbnQgYW5kIHN1YnNjcmlwdGlvbiBoYW5kbGluZyBcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNlYXJjaGVzIGZyb20gdGhlIEV2ZW50VGFyZ2V0IHVwIHRoZSBET00gdHJlZSBsb29raW5nIGZvciBhbiBlbGVtZW50IHdpdGggdGhlXHJcbiAgICAgICAgICAgICAqIHJlZ2lzdGVyZWQgZXZlbnQgdHlwZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklDdXN0b21FbGVtZW50fSBldmVudFRhcmdldCBUaGUgY3VycmVudCB0YXJnZXQgb2YgdGhlIHRvdWNoIGV2ZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiBldmVudCBiZWluZyBzZWFyY2hlZCBmb3IuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMucHJvdG90eXBlLl9fZmluZEZpcnN0U3Vic2NyaWJlciA9IGZ1bmN0aW9uIChldmVudFRhcmdldCwgdHlwZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChldmVudFRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgX3BsYXQsIHN1YnNjcmliZXIsIGRvbUV2ZW50O1xyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIF9wbGF0ID0gZXZlbnRUYXJnZXQuX19wbGF0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChfcGxhdCkgfHwgaXNVbmRlZmluZWQoX3BsYXQuZG9tRXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyID0gdGhpcy5fc3Vic2NyaWJlcnNbX3BsYXQuZG9tRXZlbnRdO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbUV2ZW50ID0gc3Vic2NyaWJlclt0eXBlXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoZG9tRXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9tRXZlbnQ7XHJcbiAgICAgICAgICAgICAgICB9IHdoaWxlICghaXNOdWxsKGV2ZW50VGFyZ2V0ID0gZXZlbnRUYXJnZXQucGFyZW50Tm9kZSkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2VhcmNoZXMgZnJvbSB0aGUgRXZlbnRUYXJnZXQgdXAgdGhlIERPTSB0cmVlIGxvb2tpbmcgZm9yIGFsbCBlbGVtZW50cyB3aXRoIHRoZVxyXG4gICAgICAgICAgICAgKiByZWdpc3RlcmVkIGV2ZW50IHR5cGVzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSUN1c3RvbUVsZW1lbnR9IGV2ZW50VGFyZ2V0IFRoZSBjdXJyZW50IHRhcmdldCBvZiB0aGUgdG91Y2ggZXZlbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gdHlwZXMgQW4gYXJyYXkgb2YgdGhlIHR5cGVzIG9mIGV2ZW50cyBiZWluZyBzZWFyY2hlZCBmb3IuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMucHJvdG90eXBlLl9fZmluZEZpcnN0U3Vic2NyaWJlcnMgPSBmdW5jdGlvbiAoZXZlbnRUYXJnZXQsIHR5cGVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGV2ZW50VGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBfcGxhdCwgc3Vic2NyaWJlciwgc3Vic2NyaWJlcktleXMsIHN1YnNjcmliZXJLZXksIGRvbUV2ZW50cyA9IFtdLCBpbmRleDtcclxuICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICBfcGxhdCA9IGV2ZW50VGFyZ2V0Ll9fcGxhdDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoX3BsYXQpIHx8IGlzVW5kZWZpbmVkKF9wbGF0LmRvbUV2ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlciA9IHRoaXMuX3N1YnNjcmliZXJzW19wbGF0LmRvbUV2ZW50XTtcclxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyS2V5cyA9IE9iamVjdC5rZXlzKHN1YnNjcmliZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdWJzY3JpYmVyS2V5cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJLZXkgPSBzdWJzY3JpYmVyS2V5cy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0eXBlcy5pbmRleE9mKHN1YnNjcmliZXJLZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21FdmVudHMucHVzaChzdWJzY3JpYmVyW3N1YnNjcmliZXJLZXldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IHdoaWxlICh0eXBlcy5sZW5ndGggPiAwICYmICFpc051bGwoZXZlbnRUYXJnZXQgPSBldmVudFRhcmdldC5wYXJlbnROb2RlKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tRXZlbnRzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVtb3ZlcyBhbiBldmVudCBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudCB0eXBlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSUN1c3RvbUVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBmcm9tLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiBldmVudCBiZWluZyByZW1vdmVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSUdlc3R1cmVMaXN0ZW5lcn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGJlaW5nIHJlbW92ZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlQ2FwdHVyZT8gV2hldGhlciB0aGUgbGlzdGVuZXIgaXMgZmlyZWQgb24gdGhlIGNhcHR1cmUgb3IgYnViYmxlIHBoYXNlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX3JlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgdHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBnZXN0dXJlcyA9IHRoaXMuX2dlc3R1cmVzO1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcclxuICAgICAgICAgICAgICAgIHZhciBzd2lwZUdlc3R1cmUgPSBnZXN0dXJlcy4kc3dpcGUsIHRyYWNrR2VzdHVyZSA9IGdlc3R1cmVzLiR0cmFjaywgY291bnRUeXBlID0gdHlwZTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlLmluZGV4T2YodHJhY2tHZXN0dXJlKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhY2tlbmQgPSBnZXN0dXJlcy4kdHJhY2tlbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRUeXBlID0gdHlwZSA9PT0gdHJhY2tlbmQgPyB0cmFja2VuZCA6IHRyYWNrR2VzdHVyZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUuaW5kZXhPZihzd2lwZUdlc3R1cmUpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50VHlwZSA9IHN3aXBlR2VzdHVyZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2dlc3R1cmVDb3VudFtjb3VudFR5cGVdLS07XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fdW5yZWdpc3RlckVsZW1lbnQoZWxlbWVudCwgdHlwZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZW1vdmVzIGFuIGVsZW1lbnQgZnJvbSB0aGUgc3Vic2NyaWJlciBvYmplY3QuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JQ3VzdG9tRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCBiZWluZyByZW1vdmVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX3JlbW92ZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3JldHVyblNlbGVjdGlvbnMoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGVsZW1lbnQuY2xhc3NOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsIERvbUV2ZW50cy5jb25maWcuc3R5bGVDb25maWdbMF0uY2xhc3NOYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBwbGF0ID0gZWxlbWVudC5fX3BsYXQ7XHJcbiAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eShwbGF0LCAnZG9tRXZlbnQnKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KHBsYXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkoZWxlbWVudCwgJ19fcGxhdCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU3RhbmRhcmRpemVzIGNlcnRhaW4gcHJvcGVydGllcyBvbiB0aGUgZXZlbnQgb2JqZWN0IGZvciBjdXN0b20gZXZlbnRzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSUV4dGVuZGVkRXZlbnR9IGV2IFRoZSBldmVudCBvYmplY3QgdG8gYmUgc3RhbmRhcmRpemVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX3N0YW5kYXJkaXplRXZlbnRPYmplY3QgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19zZXRUb3VjaFBvaW50KGV2KTtcclxuICAgICAgICAgICAgICAgIHZhciBpc1N0YXJ0ID0gdGhpcy5fc3RhcnRFdmVudHMuaW5kZXhPZihldi50eXBlKSAhPT0gLTEsIHRvdWNoZXMgPSBldi50b3VjaGVzIHx8IHRoaXMuX19wb2ludGVyRXZlbnRzLCBjaGFuZ2VkVG91Y2hlcyA9IGV2LmNoYW5nZWRUb3VjaGVzLCBjaGFuZ2VkVG91Y2hlc0V4aXN0ID0gIWlzVW5kZWZpbmVkKGNoYW5nZWRUb3VjaGVzKSwgcHJldmVudERlZmF1bHQsIHRpbWVTdGFtcCA9IGV2LnRpbWVTdGFtcDtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkVG91Y2hlc0V4aXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQgPSBldi5wcmV2ZW50RGVmYXVsdC5iaW5kKGV2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXYgPSBjaGFuZ2VkVG91Y2hlc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQgPSBwcmV2ZW50RGVmYXVsdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VkVG91Y2hJbmRleCA9IHRoaXMuX19nZXRUb3VjaEluZGV4KGNoYW5nZWRUb3VjaGVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZWRUb3VjaEluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0ID0gZXYucHJldmVudERlZmF1bHQuYmluZChldik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldiA9IGNoYW5nZWRUb3VjaGVzW2NoYW5nZWRUb3VjaEluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0ID0gcHJldmVudERlZmF1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fX2dldFRvdWNoSW5kZXgodG91Y2hlcykgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugd2FudCB0byByZXR1cm4gbnVsbCBiZWNhdXNlIG91ciBwb2ludCBvZiBpbnRlcmVzdCBpcyBpbiB0b3VjaGVzIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHdhcyBub3QgaW4gY2hhbmdlZFRvdWNoZXMgc28gaXQgaXMgc3RpbGwgcGxheWluZyBhIHBhcnQgb24gdGhlIHBhZ2UgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc1N0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3NldENhcHR1cmUoZXYudGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX19ub3JtYWxpemVCdXR0b25zKGV2KTtcclxuICAgICAgICAgICAgICAgIGV2LnRvdWNoZXMgPSB0b3VjaGVzO1xyXG4gICAgICAgICAgICAgICAgZXYub2Zmc2V0ID0gdGhpcy5fX2dldE9mZnNldChldik7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoZXYudGltZVN0YW1wKSB8fCB0aW1lU3RhbXAgPiBldi50aW1lU3RhbXApIHtcclxuICAgICAgICAgICAgICAgICAgICBldi50aW1lU3RhbXAgPSB0aW1lU3RhbXA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXY7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBOb3JtYWxpemVzIHRoZSAnYnV0dG9ucycgcHJvcGVydHkgb24gYW4gSUV4ZXRlbmRlZEV2ZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSUV4dGVuZGVkRXZlbnR9IGV2IFRoZSBldmVudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19ub3JtYWxpemVCdXR0b25zID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYnV0dG9ucztcclxuICAgICAgICAgICAgICAgIGlmIChpc051bWJlcihldi5idXR0b25zKSAmJiBldi5idXR0b25zICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9ucyA9IGV2LmJ1dHRvbnM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc051bWJlcihldi53aGljaCkgJiYgZXYud2hpY2ggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9ucyA9IGV2LndoaWNoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChldi5idXR0b24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAtMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnMgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnMgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnMgPSA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnMgPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnMgPSA4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnMgPSAxNjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9ucyA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBldi5fYnV0dG9ucyA9IGJ1dHRvbnM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZWFyY2hlcyB0aHJvdWdoIHRoZSBpbnB1dCBhcnJheSBsb29raW5nIGZvciB0aGUgcHJpbWFyeVxyXG4gICAgICAgICAgICAgKiB0b3VjaCBkb3duIGluZGV4LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHBsYXQudWkuSUV4dGVuZGVkRXZlbnQ+fSBldiBUaGUgYXJyYXkgb2YgdG91Y2ggZXZlbnQgb2JqZWN0c1xyXG4gICAgICAgICAgICAgKiB0byBzZWFyY2ggdGhyb3VnaC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19nZXRUb3VjaEluZGV4ID0gZnVuY3Rpb24gKHRvdWNoZXMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpZGVudGlmaWVyID0gKHRoaXMuX19sYXN0VG91Y2hEb3duIHx8IHt9KS5pZGVudGlmaWVyLCBsZW5ndGggPSB0b3VjaGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG91Y2hlc1tpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdyYWJzIHRoZSB4IGFuZCB5IG9mZnNldHMgb2YgYW4gZXZlbnQgb2JqZWN0J3MgdGFyZ2V0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSUV4dGVuZGVkRXZlbnR9IGV2IFRoZSBjdXJyZW50IGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19nZXRPZmZzZXQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9fY2FwdHVyZWRUYXJnZXQgfHwgZXYudGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRG9jdW1lbnQodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IGV2LmNsaWVudFgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGV2LmNsaWVudFlcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzVW5kZWZpbmVkKGV2Lm9mZnNldFgpICYmICFpc1VuZGVmaW5lZChldi5vZmZzZXRZKSAmJiB0YXJnZXQgPT09IGV2LnRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IGV2Lm9mZnNldFgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGV2Lm9mZnNldFlcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHgsIHk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSByZWN0LmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IHJlY3QudG9wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IHRhcmdldC5vZmZzZXRMZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSB0YXJnZXQub2Zmc2V0VG9wO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICghaXNOdWxsKHRhcmdldCA9IHRhcmdldC5vZmZzZXRQYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gdGFyZ2V0Lm9mZnNldExlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gdGFyZ2V0Lm9mZnNldFRvcDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IChldi5jbGllbnRYIC0geCksXHJcbiAgICAgICAgICAgICAgICAgICAgeTogKGV2LmNsaWVudFkgLSB5KVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy8gdXRpbGl0eSBtZXRob2RzIFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gKHgsIHkpIGNvb3JkaW5hdGUgcG9pbnRzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geDEgVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgcG9pbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MiBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgcG9pbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBmaXJzdCBwb2ludC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHkyIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBwb2ludC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19nZXREaXN0YW5jZSA9IGZ1bmN0aW9uICh4MSwgeDIsIHkxLCB5Mikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSB4MiAtIHgxLCB5ID0geTIgLSB5MTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoKHggKiB4KSArICh5ICogeSkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgdmVsb2NpdHkgYmV0d2VlbiB0d28gKHgsIHkpIGNvb3JkaW5hdGUgcG9pbnRzIG92ZXIgYSBnaXZlbiB0aW1lLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZHggVGhlIGNoYW5nZSBpbiB4IHBvc2l0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZHkgVGhlIGNoYW5nZSBpbiB5IHBvc2l0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZHR4IFRoZSBjaGFuZ2UgaW4gdGltZSBpbiB4IGRpcmVjdGlvbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGR0eSBUaGUgY2hhbmdlIGluIHRpbWUgaW4geSBkaXJlY3Rpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMucHJvdG90eXBlLl9fZ2V0VmVsb2NpdHkgPSBmdW5jdGlvbiAoZHgsIGR5LCBkdHgsIGR0eSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSAwLCB5ID0gMDtcclxuICAgICAgICAgICAgICAgIGlmIChkdHggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IChkeCAvIGR0eCkgfHwgMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChkdHkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IChkeSAvIGR0eSkgfHwgMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogeCxcclxuICAgICAgICAgICAgICAgICAgICB5OiB5XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgZGlyZWN0aW9uIG9mIG1vdmVtZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZHggVGhlIGNoYW5nZSBpbiB4IHBvc2l0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZHkgVGhlIGNoYW5nZSBpbiB5IHBvc2l0aW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX2dldERpcmVjdGlvbiA9IGZ1bmN0aW9uIChkeCwgZHkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZVggPSBNYXRoLmFicyhkeCksIGRpc3RhbmNlWSA9IE1hdGguYWJzKGR5KSwgbGFzdERpcmVjdGlvbiA9ICh0aGlzLl9fbGFzdE1vdmVFdmVudCB8fCB7fSkuZGlyZWN0aW9uIHx8IHt9LCBob3Jpem9udGFsID0gZHggPT09IDAgPyAobGFzdERpcmVjdGlvbi54IHx8ICdub25lJykgOiAoZHggPCAwID8gJ2xlZnQnIDogJ3JpZ2h0JyksIHZlcnRpY2FsID0gZHkgPT09IDAgPyAobGFzdERpcmVjdGlvbi55IHx8ICdub25lJykgOiAoZHkgPCAwID8gJ3VwJyA6ICdkb3duJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IGhvcml6b250YWwsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogdmVydGljYWwsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJpbWFyeTogKGRpc3RhbmNlWCA9PT0gZGlzdGFuY2VZID8gKGxhc3REaXJlY3Rpb24ucHJpbWFyeSB8fCAnbm9uZScpIDogKGRpc3RhbmNlWCA+IGRpc3RhbmNlWSA/IGhvcml6b250YWwgOiB2ZXJ0aWNhbCkpXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2hlY2tzIHRvIHNlZSBpZiBhIHN3aXBlIGRpcmVjdGlvbiBoYXMgY2hhbmdlZCB0byByZWNhbGN1bGF0ZVxyXG4gICAgICAgICAgICAgKiBhbiBvcmlnaW4gcG9pbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JRGlyZWN0aW9ufSBkaXJlY3Rpb24gVGhlIGN1cnJlbnQgdmVydGljYWwgYW5kIGhvcml6dG9uYWwgZGlyZWN0aW9ucyBvZiBtb3ZlbWVudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19oYW5kbGVPcmlnaW5DaGFuZ2UgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGFzdE1vdmUgPSB0aGlzLl9fbGFzdE1vdmVFdmVudDtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwobGFzdE1vdmUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHN3aXBlRGlyZWN0aW9uID0gbGFzdE1vdmUuZGlyZWN0aW9uLCB4U2FtZSA9IHN3aXBlRGlyZWN0aW9uLnggPT09IGRpcmVjdGlvbi54LCB5U2FtZSA9IHN3aXBlRGlyZWN0aW9uLnkgPT09IGRpcmVjdGlvbi55O1xyXG4gICAgICAgICAgICAgICAgaWYgKHhTYW1lICYmIHlTYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbiA9IHRoaXMuX19zd2lwZU9yaWdpbiwgZ2VzdHVyZXMgPSB0aGlzLl9nZXN0dXJlcywgc3dpcGVzID0gW2dlc3R1cmVzLiRzd2lwZSwgZ2VzdHVyZXMuJHN3aXBlZG93biwgZ2VzdHVyZXMuJHN3aXBlbGVmdCwgZ2VzdHVyZXMuJHN3aXBlcmlnaHQsIGdlc3R1cmVzLiRzd2lwZXVwXTtcclxuICAgICAgICAgICAgICAgIGlmICgheFNhbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW4uY2xpZW50WCA9IGxhc3RNb3ZlLmNsaWVudFg7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luLnhUaW1lc3RhbXAgPSBsYXN0TW92ZS50aW1lU3RhbXA7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luLnhUYXJnZXQgPSBsYXN0TW92ZS50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FuZHJvaWQ0NG9yQmVsb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2hhdmVTd2lwZVN1YnNjcmliZXJzID0gdGhpcy5fX2ZpbmRGaXJzdFN1YnNjcmliZXJzKG9yaWdpbi54VGFyZ2V0LCBzd2lwZXMpLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCF5U2FtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbi5jbGllbnRZID0gbGFzdE1vdmUuY2xpZW50WTtcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW4ueVRpbWVzdGFtcCA9IGxhc3RNb3ZlLnRpbWVTdGFtcDtcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW4ueVRhcmdldCA9IGxhc3RNb3ZlLnRhcmdldDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYW5kcm9pZDQ0b3JCZWxvdykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9faGF2ZVN3aXBlU3Vic2NyaWJlcnMgPSB0aGlzLl9fZmluZEZpcnN0U3Vic2NyaWJlcnMob3JpZ2luLnlUYXJnZXQsIHN3aXBlcykubGVuZ3RoID4gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDaGVja3MgdG8gc2VlIGlmIGEgc3dpcGUgZXZlbnQgaGFzIGJlZW4gcmVnaXN0ZXJlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklEaXJlY3Rpb259IGRpcmVjdGlvbiBUaGUgY3VycmVudCBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBkaXJlY3Rpb25zIG9mIG1vdmVtZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSVZlbG9jaXR5fSB2ZWxvY2l0eSBUaGUgY3VycmVudCBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCB2ZWxvY2l0aWVzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZHggVGhlIGRpc3RhbmNlIGluIHRoZSB4IGRpcmVjdGlvbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGR5IFRoZSBkaXN0YW5jZSBpbiB0aGUgeSBkaXJlY3Rpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMucHJvdG90eXBlLl9fZ2V0UmVnaXN0ZXJlZFN3aXBlcyA9IGZ1bmN0aW9uIChkaXJlY3Rpb24sIHZlbG9jaXR5LCBkeCwgZHkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzd2lwZVRhcmdldCwgc3dpcGVHZXN0dXJlID0gdGhpcy5fZ2VzdHVyZXMuJHN3aXBlLCBtaW5Td2lwZVZlbG9jaXR5ID0gRG9tRXZlbnRzLmNvbmZpZy52ZWxvY2l0aWVzLm1pblN3aXBlVmVsb2NpdHksIGV2ZW50cyA9IFtzd2lwZUdlc3R1cmVdLCBvcmlnaW4gPSAodGhpcy5fX3N3aXBlT3JpZ2luIHx8IHt9KTtcclxuICAgICAgICAgICAgICAgIGlmIChkeCA+IGR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpcGVUYXJnZXQgPSBvcmlnaW4ueFRhcmdldDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmVsb2NpdHkueCA+PSBtaW5Td2lwZVZlbG9jaXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cy5wdXNoKHN3aXBlR2VzdHVyZSArIGRpcmVjdGlvbi54KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkeSA+IGR4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpcGVUYXJnZXQgPSBvcmlnaW4ueVRhcmdldDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmVsb2NpdHkueSA+PSBtaW5Td2lwZVZlbG9jaXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cy5wdXNoKHN3aXBlR2VzdHVyZSArIGRpcmVjdGlvbi55KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX2ZpbmRGaXJzdFN1YnNjcmliZXJzKHN3aXBlVGFyZ2V0LCBldmVudHMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2hlY2tzIHRvIHNlZSBpZiBhIHN3aXBlIGV2ZW50IGhhcyBiZWVuIHJlZ2lzdGVyZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaXJlY3Rpb24gVGhlIGN1cnJlbnQgZGlyZWN0aW9uIG9mIG1vdmVtZW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX2lzSG9yaXpvbnRhbCA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24gPT09ICdsZWZ0JyB8fCBkaXJlY3Rpb24gPT09ICdyaWdodCc7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBcHBlbmRzIENTUyB0byB0aGUgaGVhZCBmb3IgZ2VzdHVyZXMgaWYgbmVlZGVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX2FwcGVuZEdlc3R1cmVTdHlsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfZG9jdW1lbnQgPSB0aGlzLl9kb2N1bWVudCwgc3R5bGVDbGFzc2VzLCBjbGFzc0xlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jb21wYXQucGxhdENzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc051bGwoX2RvY3VtZW50LnN0eWxlU2hlZXRzKSAmJiBfZG9jdW1lbnQuc3R5bGVTaGVldHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZVNoZWV0ID0gX2RvY3VtZW50LnN0eWxlU2hlZXRzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlQ2xhc3NlcyA9IERvbUV2ZW50cy5jb25maWcuc3R5bGVDb25maWc7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NMZW5ndGggPSBzdHlsZUNsYXNzZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjbGFzc0xlbmd0aC0tID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZVNoZWV0Lmluc2VydFJ1bGUodGhpcy5fX2NyZWF0ZVN0eWxlKHN0eWxlQ2xhc3Nlc1tjbGFzc0xlbmd0aF0pLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGhlYWQgPSBfZG9jdW1lbnQuaGVhZCwgc3R5bGUgPSBfZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKSwgdGV4dENvbnRlbnQgPSAnJztcclxuICAgICAgICAgICAgICAgIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xyXG4gICAgICAgICAgICAgICAgc3R5bGVDbGFzc2VzID0gRG9tRXZlbnRzLmNvbmZpZy5zdHlsZUNvbmZpZztcclxuICAgICAgICAgICAgICAgIGNsYXNzTGVuZ3RoID0gc3R5bGVDbGFzc2VzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChjbGFzc0xlbmd0aC0tID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHRDb250ZW50ID0gdGhpcy5fX2NyZWF0ZVN0eWxlKHN0eWxlQ2xhc3Nlc1tjbGFzc0xlbmd0aF0pICsgdGV4dENvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzdHlsZS50ZXh0Q29udGVudCA9IHRleHRDb250ZW50O1xyXG4gICAgICAgICAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgc3R5bGUgdGV4dCB0byBhcHBlbmQgdG8gdGhlIGRvY3VtZW50IGhlYWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JRGVmYXVsdFN0eWxlfSBzdHlsZUNsYXNzIFRoZSBvYmplY3QgY29udGFpbmluZyB0aGUgY3VzdG9tIHN0eWxlcyBmb3JcclxuICAgICAgICAgICAgICogZ2VzdHVyZXMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMucHJvdG90eXBlLl9fY3JlYXRlU3R5bGUgPSBmdW5jdGlvbiAoc3R5bGVDbGFzcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlcyA9IHN0eWxlQ2xhc3Muc3R5bGVzIHx8IFtdLCBzdHlsZUxlbmd0aCA9IHN0eWxlcy5sZW5ndGgsIHN0eWxlID0gJy4nICsgc3R5bGVDbGFzcy5jbGFzc05hbWUgKyAnIHsgJywgdGV4dENvbnRlbnQgPSAnJztcclxuICAgICAgICAgICAgICAgIHN0eWxlTGVuZ3RoID0gc3R5bGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3R5bGVMZW5ndGg7ICsraikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHRDb250ZW50ICs9IHN0eWxlc1tqXSArICc7JztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN0eWxlICs9IHRleHRDb250ZW50ICsgJyB9ICc7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBCbHVycyB0aGUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19ibHVyRm9jdXNlZEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm9jdXNlZEVsZW1lbnQgPSB0aGlzLl9fZm9jdXNlZEVsZW1lbnQgfHwge307XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihmb2N1c2VkRWxlbWVudC5ibHVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzZWRFbGVtZW50LmJsdXIoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIExpc3RlbnMgZm9yIGJsdXIgYW5kIHRoZW4gc2V0cyB0aGUgZm9jdXNlZCBlbGVtZW50IGJhY2sgdG8gbnVsbCBmb3IgdGhlIG5leHQgY2FzZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSB0YXJnZXQgVGhlIHRhcmdldCB0byBsaXN0ZW4gZm9yIHRoZSBibHVyIGV2ZW50IG9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX3dhaXRGb3JCbHVyID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHRoaXMuX19ibHVyUmVtb3ZlciA9IHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0YXJnZXQsICdibHVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9fYmx1clJlbW92ZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fX2JsdXJSZW1vdmVyID0gbm9vcDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ID09PSBfdGhpcy5fX2ZvY3VzZWRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fZm9jdXNlZEVsZW1lbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEhhbmRsZXMgYSBjbGljayB0YXJnZXQgY2FzZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSB0YXJnZXQgVGhlIHRhcmdldCB0byBoYW5kbGUgY2xpY2sgZnVuY3Rpb25hbGl5IGZvci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19jbGlja1RhcmdldCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2xpY2tlZCA9IGZhbHNlLCBoYW5kbGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVyLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBwb3N0cG9uZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsaWNrZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVyLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9kb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRhcmdldCkgJiYgaXNGdW5jdGlvbih0YXJnZXQuY2xpY2spKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5jbGljaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSGFuZGxlcyBIVE1MSW5wdXRFbGVtZW50cyBpbiBXZWJLaXQgYmFzZWQgdG91Y2ggYXBwbGljYXRpb25zLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IHRhcmdldCBUaGUgdGFyZ2V0IHRvIGhhbmRsZSBmdW5jdGlvbmFsaXR5IGZvci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19oYW5kbGVJbnB1dCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19ibHVyUmVtb3ZlcigpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGVOYW1lID0gdGFyZ2V0Lm5vZGVOYW1lO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1N0cmluZyhub2RlTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fZm9jdXNlZEVsZW1lbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19ibHVyRm9jdXNlZEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJldmVudERlZmF1bHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaW5wdXQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhcmdldC50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyYW5nZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2JsdXJGb2N1c2VkRWxlbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndGV4dCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwYXNzd29yZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlbWFpbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndGVsJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NlYXJjaCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1cmwnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5mb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX193YWl0Rm9yQmx1cih0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fYmx1ckZvY3VzZWRFbGVtZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2NsaWNrVGFyZ2V0KHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYSc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYnV0dG9uJzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdsYWJlbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19ibHVyRm9jdXNlZEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2NsaWNrVGFyZ2V0KHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RleHRhcmVhJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX193YWl0Rm9yQmx1cih0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzZWxlY3QnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fYmx1ckZvY3VzZWRFbGVtZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19jbGlja1RhcmdldCh0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX19mb2N1c2VkRWxlbWVudCA9IHRhcmdldDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2ZW50RGVmYXVsdDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEhhbmRsZXMgdGhlIHBoYW50b20gY2xpY2sgaW4gV2ViS2l0IGJhc2VkIHRvdWNoIGFwcGxpY2F0aW9ucy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19wcmV2ZW50Q2xpY2tGcm9tVG91Y2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2RvY3VtZW50ID0gdGhpcy5fZG9jdW1lbnQsIGlnbm9yZUV2ZW50cyA9IHRoaXMuX19pZ25vcmVFdmVudCwgYm91bmRQcmV2ZW50RGVmYXVsdCA9IHRoaXMuX19ib3VuZFByZXZlbnREZWZhdWx0Q2xpY2ssIGludGVydmFsID0gRG9tRXZlbnRzLmNvbmZpZy5pbnRlcnZhbHMuZGVsYXllZENsaWNrSW50ZXJ2YWw7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJ2YWwgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX19kZWxheWVkQ2xpY2tSZW1vdmVyID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdXNlZG93bjogZGVmZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZ25vcmVFdmVudHMubW91c2Vkb3duID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgaW50ZXJ2YWwpLFxyXG4gICAgICAgICAgICAgICAgICAgIG1vdXNldXA6IGRlZmVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWdub3JlRXZlbnRzLm1vdXNldXAgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBpbnRlcnZhbCksXHJcbiAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGRlZmVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2RvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYm91bmRQcmV2ZW50RGVmYXVsdCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgaW50ZXJ2YWwpXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaWdub3JlRXZlbnRzLm1vdXNlZG93biA9IGlnbm9yZUV2ZW50cy5tb3VzZXVwID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHBvc3Rwb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBib3VuZFByZXZlbnREZWZhdWx0LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUHJldmVudHMgZGVmYXVsdCBhbmQgc3RvcHMgcHJvcGFnYXRpb24gZm9yIGRlbGF5ZWQgb3IgcGhhbnRvbSBjbGlja3MuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2IFRoZSBldmVudCBvYmplY3QuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMucHJvdG90eXBlLl9fcHJldmVudERlZmF1bHRDbGljayA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGV2LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9fYm91bmRQcmV2ZW50RGVmYXVsdENsaWNrLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19kZWxheWVkQ2xpY2tSZW1vdmVyLmNsaWNrKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZW1vdmVzIHNlbGVjdGlvbiBjYXBhYmlsaXR5IGZyb20gdGhlIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Tm9kZX0gZWxlbWVudCBUaGUgZWxlbWVudCB0byByZW1vdmUgc2VsZWN0aW9ucyBvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19yZW1vdmVTZWxlY3Rpb25zID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChlbGVtZW50Lm9uc2VsZWN0c3RhcnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIHRoaXMuX19wcmV2ZW50RGVmYXVsdCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChlbGVtZW50Lm9uZHJhZ3N0YXJ0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpcy5fX3ByZXZlbnREZWZhdWx0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHNlbGVjdGlvbiBjYXBhYmlsaXR5IGZyb20gdGhlIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Tm9kZX0gZWxlbWVudCBUaGUgZWxlbWVudCB0byByZXR1cm4gc2VsZWN0aW9ucyBvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19yZXR1cm5TZWxlY3Rpb25zID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChlbGVtZW50Lm9uc2VsZWN0c3RhcnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIHRoaXMuX19wcmV2ZW50RGVmYXVsdCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChlbGVtZW50Lm9uZHJhZ3N0YXJ0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpcy5fX3ByZXZlbnREZWZhdWx0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQcmV2ZW50cyBkZWZhdWx0IGFuZCBzdG9wcyBwcm9wYWdhdGlvbiBpbiBhbGwgZWxlbWVudHMgb3RoZXIgdGhhblxyXG4gICAgICAgICAgICAgKiBpbnB1dHMgYW5kIHRleHRhcmVhcy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXYgVGhlIGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGVOYW1lID0gZXYudGFyZ2V0Lm5vZGVOYW1lO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKG5vZGVOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVOYW1lID0gbm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChub2RlTmFtZSA9PT0gJ2lucHV0JyB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgRG9tRXZlbnRzLl9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgICAgICBfZG9jdW1lbnQ6IF9fRG9jdW1lbnQsXHJcbiAgICAgICAgICAgICAgICBfY29tcGF0OiBfX0NvbXBhdFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYWxsIERPTSBldmVudHMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMuY29uZmlnID0ge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGludGVydmFsczoge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcEludGVydmFsOiAzMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgZGJsVGFwSW50ZXJ2YWw6IDMwMCxcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBob2xkSW50ZXJ2YWw6IDQwMCxcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBkYmxUYXBab29tRGVsYXk6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgZGVsYXllZENsaWNrSW50ZXJ2YWw6IDQwMFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBkaXN0YW5jZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBtaW5TY3JvbGxEaXN0YW5jZTogMyxcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBtYXhEYmxUYXBEaXN0YW5jZTogMTBcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmVsb2NpdGllczoge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIG1pblN3aXBlVmVsb2NpdHk6IDAuNjQ1XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHN0eWxlQ29uZmlnOiBbe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ3BsYXQtZ2VzdHVyZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLW1vei11c2VyLXNlbGVjdDogbm9uZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLWtodG1sLXVzZXItc2VsZWN0OiBub25lJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICctd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJy13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJy13ZWJraXQtdXNlci1kcmFnOiBub25lJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHRyYW5zcGFyZW50JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICctd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzogdG91Y2gnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJy1tcy11c2VyLXNlbGVjdDogbm9uZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLW1zLXRvdWNoLWFjdGlvbjogbWFuaXB1bGF0aW9uJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0b3VjaC1hY3Rpb246IG1hbmlwdWxhdGlvbidcclxuICAgICAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdwbGF0LW5vLXRvdWNoLWFjdGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLW1zLXRvdWNoLWFjdGlvbjogbm9uZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndG91Y2gtYWN0aW9uOiBub25lJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICAgICAgfV1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBldmVudCB0eXBlcyBmb3IgYWxsIG9mIHRoZVxyXG4gICAgICAgICAgICAgKiBzdXBwb3J0ZWQgZ2VzdHVyZXMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMuZ2VzdHVyZXMgPSB7XHJcbiAgICAgICAgICAgICAgICAkdGFwOiBfX3RhcCxcclxuICAgICAgICAgICAgICAgICRkYmx0YXA6IF9fZGJsdGFwLFxyXG4gICAgICAgICAgICAgICAgJGhvbGQ6IF9faG9sZCxcclxuICAgICAgICAgICAgICAgICRyZWxlYXNlOiBfX3JlbGVhc2UsXHJcbiAgICAgICAgICAgICAgICAkc3dpcGU6IF9fc3dpcGUsXHJcbiAgICAgICAgICAgICAgICAkc3dpcGVsZWZ0OiBfX3N3aXBlbGVmdCxcclxuICAgICAgICAgICAgICAgICRzd2lwZXJpZ2h0OiBfX3N3aXBlcmlnaHQsXHJcbiAgICAgICAgICAgICAgICAkc3dpcGV1cDogX19zd2lwZXVwLFxyXG4gICAgICAgICAgICAgICAgJHN3aXBlZG93bjogX19zd2lwZWRvd24sXHJcbiAgICAgICAgICAgICAgICAkdHJhY2s6IF9fdHJhY2ssXHJcbiAgICAgICAgICAgICAgICAkdHJhY2tsZWZ0OiBfX3RyYWNrbGVmdCxcclxuICAgICAgICAgICAgICAgICR0cmFja3JpZ2h0OiBfX3RyYWNrcmlnaHQsXHJcbiAgICAgICAgICAgICAgICAkdHJhY2t1cDogX190cmFja3VwLFxyXG4gICAgICAgICAgICAgICAgJHRyYWNrZG93bjogX190cmFja2Rvd24sXHJcbiAgICAgICAgICAgICAgICAkdHJhY2tlbmQ6IF9fdHJhY2tlbmRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIERvbUV2ZW50cztcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIHVpLkRvbUV2ZW50cyA9IERvbUV2ZW50cztcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fRG9tRXZlbnRzLCBEb21FdmVudHMpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIElEb21FdmVudHNDb25maWcoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBEb21FdmVudHMuY29uZmlnO1xyXG4gICAgICAgIH1cclxuICAgICAgICB1aS5JRG9tRXZlbnRzQ29uZmlnID0gSURvbUV2ZW50c0NvbmZpZztcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fSURvbUV2ZW50c0NvbmZpZywgSURvbUV2ZW50c0NvbmZpZyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBjbGFzcyBmb3IgbWFuYWdpbmcgYSBzaW5nbGUgY3VzdG9tIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBEb21FdmVudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIERvbUV2ZW50KCkge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIERvY3VtZW50IGluamVjdGFibGUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX2RvY3VtZW50ID0gYWNxdWlyZShfX0RvY3VtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBEb21FdmVudC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudCwgZXZlbnRUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudFR5cGUgPSBpc1N0cmluZyhldmVudFR5cGUpID8gZXZlbnRUeXBlIDogJ0N1c3RvbUV2ZW50JztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRyaWdnZXJzIGl0cyBldmVudCBvbiBpdHMgZWxlbWVudC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50RXh0ZW5zaW9uPyBBbiBldmVudCBleHRlbnNpb24gdG8gZXh0ZW5kIHRoZSBkaXNwYXRjaGVkIEN1c3RvbUV2ZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gZGV0YWlsQXJnPyBUaGUgZGV0YWlsIGFyZyB0byBpbmNsdWRlIGluIHRoZSBldmVudCBvYmplY3RcclxuICAgICAgICAgICAgICogQHBhcmFtIHtOb2RlfSBkaXNwYXRjaEVsZW1lbnQ/IFRoZSBlbGVtZW50IHRvIGRpc3BhdGNoIHRoZSBFdmVudCBmcm9tLiBJZiBub3Qgc3BlY2lmaWVkLFxyXG4gICAgICAgICAgICAgKiB0aGlzIGluc3RhbmNlJ3MgZWxlbWVudCB3aWxsIGJlIHVzZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudC5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudEV4dGVuc2lvbiwgZGV0YWlsQXJnLCBkaXNwYXRjaEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjdXN0b21FdiA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUV2ZW50KHRoaXMuZXZlbnRUeXBlKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChldmVudEV4dGVuc2lvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBfZXh0ZW5kKGZhbHNlLCBmYWxzZSwgY3VzdG9tRXYsIGV2ZW50RXh0ZW5zaW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN1c3RvbUV2LmluaXRDdXN0b21FdmVudCh0aGlzLmV2ZW50LCB0cnVlLCB0cnVlLCBpc051bGwoZGV0YWlsQXJnKSA/IDAgOiBkZXRhaWxBcmcpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChkaXNwYXRjaEVsZW1lbnQgfHwgdGhpcy5lbGVtZW50KS5kaXNwYXRjaEV2ZW50KGN1c3RvbUV2KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIERvbUV2ZW50O1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgdWkuRG9tRXZlbnQgPSBEb21FdmVudDtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fRG9tRXZlbnRJbnN0YW5jZSwgRG9tRXZlbnQsIG51bGwsIF9fSU5TVEFOQ0UpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgc3BlY2lhbGl6ZWQgY2xhc3MgZm9yIG1hbmFnaW5nIGEgc2luZ2xlIGN1c3RvbSB0b3VjaCBldmVudCBpbiBEb21FdmVudHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEN1c3RvbURvbUV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKEN1c3RvbURvbUV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBDdXN0b21Eb21FdmVudChlbGVtZW50LCBldmVudCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGFkZGVkIGZvciB0aGlzIGV2ZW50IG9uIHRoaXMgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUcmlnZ2VycyBpdHMgZXZlbnQgb24gaXRzIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JUG9pbnRlckV2ZW50fSBldiBUaGUgY3VycmVudCB0b3VjaCBldmVudCBvYmplY3QgdXNlZCB0byBleHRlbmQgdGhlXHJcbiAgICAgICAgICAgICAqIG5ld2x5IGNyZWF0ZWQgY3VzdG9tIGV2ZW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ3VzdG9tRG9tRXZlbnQucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjdXN0b21FdiA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpLCBlbGVtZW50ID0gdGhpcy5lbGVtZW50LCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZXh0ZW5kRXZlbnRPYmplY3QoY3VzdG9tRXYsIGV2KTtcclxuICAgICAgICAgICAgICAgIGN1c3RvbUV2LmluaXRDdXN0b21FdmVudCh0aGlzLmV2ZW50LCB0cnVlLCB0cnVlLCAwKTtcclxuICAgICAgICAgICAgICAgIHZhciBzdWNjZXNzID0gaXNEb2N1bWVudChlbGVtZW50KSB8fCBlbGVtZW50LmNvbnRhaW5zKHRhcmdldCkgPyB0YXJnZXQuZGlzcGF0Y2hFdmVudChjdXN0b21FdikgOiBlbGVtZW50LmRpc3BhdGNoRXZlbnQoY3VzdG9tRXYpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZXNzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRXh0ZW5kcyB0aGUgY3VzdG9tIGV2ZW50IHRvIG1pbWljIGEgc3RhbmRhcmRpemVkIHRvdWNoIGV2ZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSUdlc3R1cmVFdmVudH0gY3VzdG9tRXYgVGhlIG5ld2x5IGNyZWF0ZWQgY3VzdG9tIGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklQb2ludGVyRXZlbnR9IGV2IFRoZSBjdXJyZW50IHRvdWNoIGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEN1c3RvbURvbUV2ZW50LnByb3RvdHlwZS5fX2V4dGVuZEV2ZW50T2JqZWN0ID0gZnVuY3Rpb24gKGN1c3RvbUV2LCBldikge1xyXG4gICAgICAgICAgICAgICAgLy8gbm90IHVzaW5nIGV4dGVuZCBmdW5jdGlvbiBiZWNhdXNlIHRoaXMgZ2V0cyBjYWxsZWQgc28gb2Z0ZW4gZm9yIGNlcnRhaW4gZXZlbnRzLiBcclxuICAgICAgICAgICAgICAgIHZhciBwb2ludGVyVHlwZSA9IGV2LnBvaW50ZXJUeXBlO1xyXG4gICAgICAgICAgICAgICAgY3VzdG9tRXYuY2xpZW50WCA9IGV2LmNsaWVudFg7XHJcbiAgICAgICAgICAgICAgICBjdXN0b21Fdi5jbGllbnRZID0gZXYuY2xpZW50WTtcclxuICAgICAgICAgICAgICAgIGN1c3RvbUV2Lm9mZnNldFggPSBldi5vZmZzZXQueDtcclxuICAgICAgICAgICAgICAgIGN1c3RvbUV2Lm9mZnNldFkgPSBldi5vZmZzZXQueTtcclxuICAgICAgICAgICAgICAgIGN1c3RvbUV2LmRpcmVjdGlvbiA9IGV2LmRpcmVjdGlvbiB8fCB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogJ25vbmUnLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6ICdub25lJyxcclxuICAgICAgICAgICAgICAgICAgICBwcmltYXJ5OiAnbm9uZSdcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBjdXN0b21Fdi50b3VjaGVzID0gZXYudG91Y2hlcztcclxuICAgICAgICAgICAgICAgIGN1c3RvbUV2LnZlbG9jaXR5ID0gZXYudmVsb2NpdHkgfHwgeyB4OiAwLCB5OiAwIH07XHJcbiAgICAgICAgICAgICAgICBjdXN0b21Fdi5pZGVudGlmaWVyID0gZXYuaWRlbnRpZmllciB8fCAwO1xyXG4gICAgICAgICAgICAgICAgY3VzdG9tRXYucG9pbnRlclR5cGUgPSBpc051bWJlcihwb2ludGVyVHlwZSkgPyB0aGlzLl9fY29udmVydFBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlLCBldi50eXBlKSA6IHBvaW50ZXJUeXBlO1xyXG4gICAgICAgICAgICAgICAgY3VzdG9tRXYuc2NyZWVuWCA9IGV2LnNjcmVlblg7XHJcbiAgICAgICAgICAgICAgICBjdXN0b21Fdi5zY3JlZW5ZID0gZXYuc2NyZWVuWTtcclxuICAgICAgICAgICAgICAgIGN1c3RvbUV2LnBhZ2VYID0gZXYucGFnZVg7XHJcbiAgICAgICAgICAgICAgICBjdXN0b21Fdi5wYWdlWSA9IGV2LnBhZ2VZO1xyXG4gICAgICAgICAgICAgICAgY3VzdG9tRXYuYnV0dG9ucyA9IGV2Ll9idXR0b25zO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ29udmVydHMgcG9pbnRlciB0eXBlIHRvIGEgc3RhbmRhcmRpemVkIHN0cmluZy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IHBvaW50ZXJUeXBlIFRoZSBwb2ludGVyIHR5cGUgYXMgZWl0aGVyIGEgbnVtYmVyIG9yIGEgc3RyaW5nLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIFRoZSB0b3VjaCBldmVudCB0eXBlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ3VzdG9tRG9tRXZlbnQucHJvdG90eXBlLl9fY29udmVydFBvaW50ZXJUeXBlID0gZnVuY3Rpb24gKHBvaW50ZXJUeXBlLCBldmVudFR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAocG9pbnRlclR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIE1TUG9pbnRlckV2ZW50Lk1TUE9JTlRFUl9UWVBFX01PVVNFOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ21vdXNlJztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIE1TUG9pbnRlckV2ZW50Lk1TUE9JTlRFUl9UWVBFX1BFTjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdwZW4nO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTVNQb2ludGVyRXZlbnQuTVNQT0lOVEVSX1RZUEVfVE9VQ0g6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndG91Y2gnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChldmVudFR5cGUuaW5kZXhPZignbW91c2UnKSA9PT0gLTEpID8gJ3RvdWNoJyA6ICdtb3VzZSc7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBDdXN0b21Eb21FdmVudDtcclxuICAgICAgICB9KERvbUV2ZW50KSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSG9sZHMgYWxsIHRoZSBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIHJlbGF0ZWQgdG8gVUkgYW5pbWF0aW9uIGNvbXBvbmVudHMgZm9yIHBsYXR5cHVzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBhbmltYXRpb25zO1xyXG4gICAgICAgIChmdW5jdGlvbiAoYW5pbWF0aW9ucykge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBjbGFzcyB1c2VkIGZvciBhbmltYXRpbmcgZWxlbWVudHMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgQW5pbWF0b3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gQW5pbWF0b3IoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogT2JqZWN0cyByZXByZXNlbnRpbmcgY29sbGVjdGlvbnMgb2YgYWxsIGN1cnJlbnRseSBhbmltYXRlZCBlbGVtZW50cy5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRlZEVsZW1lbnRzID0ge307XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBBbmltYXRvci5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGVsZW1lbnRzLCBrZXksIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlKGVsZW1lbnRzLCBrZXksIG9wdGlvbnMsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgQW5pbWF0b3IucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbiAoZWxlbWVudHMsIGtleSwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbmltYXRlKGVsZW1lbnRzLCBrZXksIG9wdGlvbnMsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgQW5pbWF0b3IucHJvdG90eXBlLmVudGVyID0gZnVuY3Rpb24gKGVsZW1lbnRzLCBrZXksIHBhcmVudCwgcmVmQ2hpbGQsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYW5pbWF0ZShlbGVtZW50cywga2V5LCBvcHRpb25zLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2VudGVyJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBwYXJlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZkNoaWxkOiByZWZDaGlsZFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIEFuaW1hdG9yLnByb3RvdHlwZS5sZWF2ZSA9IGZ1bmN0aW9uIChlbGVtZW50cywga2V5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FuaW1hdGUoZWxlbWVudHMsIGtleSwgb3B0aW9ucywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdsZWF2ZSdcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBBbmltYXRvci5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uIChlbGVtZW50cywga2V5LCBwYXJlbnQsIHJlZkNoaWxkLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FuaW1hdGUoZWxlbWVudHMsIGtleSwgb3B0aW9ucywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdtb3ZlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBwYXJlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZkNoaWxkOiByZWZDaGlsZFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIEFuaW1hdG9yLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKGVsZW1lbnRzLCBrZXksIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYW5pbWF0ZShlbGVtZW50cywga2V5LCBvcHRpb25zLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ3Nob3cnXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgQW5pbWF0b3IucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoZWxlbWVudHMsIGtleSwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbmltYXRlKGVsZW1lbnRzLCBrZXksIG9wdGlvbnMsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnaGlkZSdcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgd2hlbiBldmVyeSBhbmltYXRpb24gcHJvbWlzZSBpbiB0aGUgaW5wdXQgYXJyYXkgaXMgZnVsZmlsbGVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBBbmltYXRvci5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gcHJvbWlzZXMubGVuZ3RoLCBhcmdzID0gW10sIGFuaW1hdGlvblByb21pc2UgPSBuZXcgQW5pbWF0aW9uUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChwcm9taXNlc1tpXS5nZXRJbnN0YW5jZXMoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvblByb21pc2UuaW5pdGlhbGl6ZShhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uUHJvbWlzZS50aGVuKG5vb3ApO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogSW1tZWRpYXRlbHkgcmVzb2x2ZXMgYW4gZW1wdHkgQW5pbWF0aW9uUHJvbWlzZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgQW5pbWF0b3IucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvblByb21pc2UgPSBuZXcgQW5pbWF0aW9uUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhbmltYXRpb25Qcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uUHJvbWlzZTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFuaW1hdGVzIHRoZSBwYXNzZWQgaW4gZWxlbWVudHMgd2l0aCB0aGUgZ2l2ZW4ga2V5IGFuZCBoYW5kbGVzIHNwZWNpYWwgYW5pbWF0aW9uIGZ1bmN0aW9uYWxpdHkuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gZWxlbWVudHMgVGhlIE5vZGVzIHRvIGJlIGFuaW1hdGVkLiBBbGwgbm9kZXMgaW4gdGhlIEFycmF5IG11c3QgaGF2ZVxyXG4gICAgICAgICAgICAgICAgICogdGhlIHNhbWUgcGFyZW50LCBvdGhlcndpc2UgdGhlIGFuaW1hdGlvbiB3aWxsIG5vdCBmdW5jdGlvbiBjb3JyZWN0bHkuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBpZGVudGlmaWVyIHNwZWNpZnlpbmcgdGhlIHR5cGUgb2YgYW5pbWF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IG9wdGlvbnM/IFNwZWNpZmllZCBvcHRpb25zIGZvciB0aGUgYW5pbWF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLmFuaW1hdGlvbnMuSUFuaW1hdGlvbkZ1bmN0aW9ufSBmdW5jdGlvbmFsaXR5IEFuIG9iamVjdCBjb250YWluaW5nIGRldGFpbGVkIGluZm9ybWF0aW9uIGFib3V0XHJcbiAgICAgICAgICAgICAgICAgKiBzcGVjaWFsIGFuaW1hdGlvbiBmdW5jdGlvbmFsaXR5LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBBbmltYXRvci5wcm90b3R5cGUuX2FuaW1hdGUgPSBmdW5jdGlvbiAoZWxlbWVudHMsIGtleSwgb3B0aW9ucywgZnVuY3Rpb25hbGl0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb24gPSB0aGlzLl9jcmVhdGUoZWxlbWVudHMsIGtleSwgb3B0aW9ucywgZnVuY3Rpb25hbGl0eSksIGN1cnJlbnQgPSBhbmltYXRpb24uY3VycmVudDtcclxuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24ucHJldmlvdXMudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZUdsb2JhbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LnN0YXJ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQW5pbWF0ZXMgdGhlIHBhc3NlZCBpbiBlbGVtZW50cyB3aXRoIHRoZSBnaXZlbiBrZXkgYW5kIGhhbmRsZXMgc3BlY2lhbCBhbmltYXRpb24gZnVuY3Rpb25hbGl0eS4gUmV0dXJucyBib3RoXHJcbiAgICAgICAgICAgICAgICAgKiB0aGUgcHJldmlvdXMgYW5kIGN1cnJlbnQgYW5pbWF0aW9ucyBmb3IgdGhlIGdpdmVuIGVsZW1lbnQocykuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gZWxlbWVudHMgVGhlIE5vZGVzIHRvIGJlIGFuaW1hdGVkLiBBbGwgbm9kZXMgaW4gdGhlIEFycmF5IG11c3QgaGF2ZVxyXG4gICAgICAgICAgICAgICAgICogdGhlIHNhbWUgcGFyZW50LCBvdGhlcndpc2UgdGhlIGFuaW1hdGlvbiB3aWxsIG5vdCBmdW5jdGlvbiBjb3JyZWN0bHkuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBpZGVudGlmaWVyIHNwZWNpZnlpbmcgdGhlIHR5cGUgb2YgYW5pbWF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IG9wdGlvbnM/IFNwZWNpZmllZCBvcHRpb25zIGZvciB0aGUgYW5pbWF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLmFuaW1hdGlvbnMuSUFuaW1hdGlvbkZ1bmN0aW9ufSBmdW5jdGlvbmFsaXR5IEFuIG9iamVjdCBjb250YWluaW5nIGRldGFpbGVkIGluZm9ybWF0aW9uIGFib3V0XHJcbiAgICAgICAgICAgICAgICAgKiBzcGVjaWFsIGFuaW1hdGlvbiBmdW5jdGlvbmFsaXR5LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBBbmltYXRvci5wcm90b3R5cGUuX2NyZWF0ZSA9IGZ1bmN0aW9uIChlbGVtZW50cywga2V5LCBvcHRpb25zLCBmdW5jdGlvbmFsaXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uSW5qZWN0b3IgPSBhbmltYXRpb25JbmplY3RvcnNba2V5XSwgYW5pbWF0aW9uSW5zdGFuY2VzID0gW10sIGVsZW1lbnROb2RlcyA9IFtdLCBpbW1lZGlhdGVSZXNvbHZlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fY29tcGF0LmFuaW1hdGlvblN1cHBvcnRlZCB8fCBpc1VuZGVmaW5lZChhbmltYXRpb25JbmplY3RvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uSW5qZWN0b3IgPSBqc0FuaW1hdGlvbkluamVjdG9yc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoYW5pbWF0aW9uSW5qZWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IHRoaXMuX19jb25zdHJ1Y3RBbmltYXRhYmxlRWxlbWVudHMoZWxlbWVudHMsIHsgaW5qZWN0OiBub29wIH0sIGVsZW1lbnROb2RlcywgYW5pbWF0aW9uSW5zdGFuY2VzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZVByZUluaXRGdW5jdGlvbmFsaXR5KGVsZW1lbnRzLCBlbGVtZW50Tm9kZXMsIGZ1bmN0aW9uYWxpdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlUG9zdEluaXRGdW5jdGlvbmFsaXR5KGVsZW1lbnRzLCBlbGVtZW50Tm9kZXMsIGZ1bmN0aW9uYWxpdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlRW5kRnVuY3Rpb25hbGl0eShlbGVtZW50cywgZWxlbWVudE5vZGVzLCBmdW5jdGlvbmFsaXR5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltbWVkaWF0ZVJlc29sdmUgPSB0aGlzLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHByZXZpb3VzOiBpbW1lZGlhdGVSZXNvbHZlLCBjdXJyZW50OiBpbW1lZGlhdGVSZXNvbHZlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSB0aGlzLl9fY29uc3RydWN0QW5pbWF0YWJsZUVsZW1lbnRzKGVsZW1lbnRzLCBhbmltYXRpb25JbmplY3RvciwgZWxlbWVudE5vZGVzLCBhbmltYXRpb25JbnN0YW5jZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBlbGVtZW50Tm9kZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlUHJlSW5pdEZ1bmN0aW9uYWxpdHkoZWxlbWVudHMsIGVsZW1lbnROb2RlcywgZnVuY3Rpb25hbGl0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZVBvc3RJbml0RnVuY3Rpb25hbGl0eShlbGVtZW50cywgZWxlbWVudE5vZGVzLCBmdW5jdGlvbmFsaXR5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlRW5kRnVuY3Rpb25hbGl0eShlbGVtZW50cywgZWxlbWVudE5vZGVzLCBmdW5jdGlvbmFsaXR5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1tZWRpYXRlUmVzb2x2ZSA9IHRoaXMucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBwcmV2aW91czogaW1tZWRpYXRlUmVzb2x2ZSwgY3VycmVudDogaW1tZWRpYXRlUmVzb2x2ZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVQcmVJbml0RnVuY3Rpb25hbGl0eShlbGVtZW50cywgZWxlbWVudE5vZGVzLCBmdW5jdGlvbmFsaXR5KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSB1bmlxdWVJZCgnYW5pbWF0aW9uXycpLCBwcmV2aW91c0FuaW1hdGlvbnMgPSB0aGlzLl9fc2V0QW5pbWF0aW9uSWQoaWQsIGVsZW1lbnROb2RlcyksIHByZXZpb3VzUHJvbWlzZSwgYW5pbWF0aW9uUHJvbWlzZSA9IG5ldyBBbmltYXRpb25Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfUHJvbWlzZSA9IF90aGlzLl9Qcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1Byb21pc2UgPSBfUHJvbWlzZS5hbGwocHJldmlvdXNBbmltYXRpb25zKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25Qcm9taXNlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvblByb21pc2VzLnB1c2goYW5pbWF0aW9uSW5zdGFuY2VzW2ldLmluc3RhbnRpYXRlKGVsZW1lbnROb2Rlc1tpXSwgb3B0aW9ucykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2hhbmRsZVBvc3RJbml0RnVuY3Rpb25hbGl0eShlbGVtZW50cywgZWxlbWVudE5vZGVzLCBmdW5jdGlvbmFsaXR5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25zRmluaXNoZWQgPSBfUHJvbWlzZS5hbGwoYW5pbWF0aW9uUHJvbWlzZXMpLCBhbmltYXRpbmdQYXJlbnRJZCA9IF90aGlzLl9faXNQYXJlbnRBbmltYXRpbmcoZWxlbWVudE5vZGVzKSwgYW5pbWF0ZWRFbGVtZW50ID0gX3RoaXMuX19nZW5lcmF0ZUFuaW1hdGVkRWxlbWVudChpZCwgZWxlbWVudE5vZGVzLCBhbmltYXRpb25Qcm9taXNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKGFuaW1hdGluZ1BhcmVudElkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9oYW5kbGVFbmRGdW5jdGlvbmFsaXR5KGVsZW1lbnRzLCBlbGVtZW50Tm9kZXMsIGZ1bmN0aW9uYWxpdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGVkRWxlbWVudC5hbmltYXRpb25FbmQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudF8xID0gX3RoaXMuX2FuaW1hdGVkRWxlbWVudHNbYW5pbWF0aW5nUGFyZW50SWRdLCByZXNvbHZlZFByb21pc2VfMSA9IGlzUHJvbWlzZShwYXJlbnRfMS5wcm9taXNlKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRfMS5wcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uUHJvbWlzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbnNGaW5pc2hlZC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNvbHZlZFByb21pc2VfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fX3N0b3BDaGlsZEFuaW1hdGlvbnMoZWxlbWVudE5vZGVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGVkRWxlbWVudC5wcm9taXNlID0gYW5pbWF0aW9uUHJvbWlzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbnNGaW5pc2hlZC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5faGFuZGxlRW5kRnVuY3Rpb25hbGl0eShlbGVtZW50cywgZWxlbWVudE5vZGVzLCBmdW5jdGlvbmFsaXR5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlZEVsZW1lbnQuYW5pbWF0aW9uRW5kKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhbmltYXRpb25Qcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvblByb21pc2UuaW5pdGlhbGl6ZShhbmltYXRpb25JbnN0YW5jZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHByZXZpb3VzOiBwcmV2aW91c1Byb21pc2UsIGN1cnJlbnQ6IGFuaW1hdGlvblByb21pc2UgfTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEhhbmRsZXMgZGlmZmVyZW50IHNwZWNpYWxpemVkIGZ1bmN0aW9uYWxpdGllcyBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGluaXQgcG9ydGlvbiBvZiB0aGUgYW5pbWF0aW9uIGN5Y2xlLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxOb2RlPn0gbm9kZXMgQWxsIHRoZSBub2RlcyBiZWluZyBhbmltYXRlZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8RWxlbWVudD59IGVsZW1lbnROb2RlcyBUaGUgYW5pbWF0YWJsZSBub2RlcyBiZWluZyBhbmltYXRlZCAob25seSBvZiB0eXBlIE5vZGUuRUxFTUVOVF9OT0RFKS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5hbmltYXRpb25zLklBbmltYXRpb25GdW5jdGlvbn0gZnVuY3Rpb25hbGl0eSBUaGUgc3BlY2lhbGl6ZWQgYW5pbWF0aW9uIGZ1bmN0aW9uIGF0dHJpYnV0ZXMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEFuaW1hdG9yLnByb3RvdHlwZS5faGFuZGxlUHJlSW5pdEZ1bmN0aW9uYWxpdHkgPSBmdW5jdGlvbiAobm9kZXMsIGVsZW1lbnROb2RlcywgZnVuY3Rpb25hbGl0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZnVuY3Rpb25hbGl0eS5rZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbW92ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShub2Rlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEhhbmRsZXMgZGlmZmVyZW50IHNwZWNpYWxpemVkIGZ1bmN0aW9uYWxpdGllcyBpbW1lZGlhdGVseSBhZnRlciB0aGUgaW5pdCBwb3J0aW9uIG9mIHRoZSBhbmltYXRpb24gY3ljbGUuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PE5vZGU+fSBub2RlcyBBbGwgdGhlIG5vZGVzIGJlaW5nIGFuaW1hdGVkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxFbGVtZW50Pn0gZWxlbWVudE5vZGVzIFRoZSBhbmltYXRhYmxlIG5vZGVzIGJlaW5nIGFuaW1hdGVkIChvbmx5IG9mIHR5cGUgTm9kZS5FTEVNRU5UX05PREUpLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLmFuaW1hdGlvbnMuSUFuaW1hdGlvbkZ1bmN0aW9ufSBmdW5jdGlvbmFsaXR5IFRoZSBzcGVjaWFsaXplZCBhbmltYXRpb24gZnVuY3Rpb24gYXR0cmlidXRlcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgQW5pbWF0b3IucHJvdG90eXBlLl9oYW5kbGVQb3N0SW5pdEZ1bmN0aW9uYWxpdHkgPSBmdW5jdGlvbiAobm9kZXMsIGVsZW1lbnROb2RlcywgZnVuY3Rpb25hbGl0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGgsIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChmdW5jdGlvbmFsaXR5LmtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlbnRlcic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ21vdmUnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZkNoaWxkID0gZnVuY3Rpb25hbGl0eS5yZWZDaGlsZCwgcGFyZW50XzI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOb2RlKHJlZkNoaWxkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudF8yID0gcmVmQ2hpbGQucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudF8yID0gZnVuY3Rpb25hbGl0eS5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmQ2hpbGQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05vZGUocGFyZW50XzIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBub2Rlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRfMi5pbnNlcnRCZWZvcmUobm9kZXNbaV0sIHJlZkNoaWxkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzaG93JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IGVsZW1lbnROb2Rlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50Tm9kZXNbaV0ucmVtb3ZlQXR0cmlidXRlKF9fSGlkZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEhhbmRsZXMgZGlmZmVyZW50IHNwZWNpYWxpemVkIGZ1bmN0aW9uYWxpdGllcyBhdCB0aGUgZW5kIHBvcnRpb24gb2YgdGhlIGFuaW1hdGlvbiBjeWNsZS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8Tm9kZT59IG5vZGVzIEFsbCB0aGUgbm9kZXMgYmVpbmcgYW5pbWF0ZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PEVsZW1lbnQ+fSBlbGVtZW50Tm9kZXMgVGhlIGFuaW1hdGFibGUgbm9kZXMgYmVpbmcgYW5pbWF0ZWQgKG9ubHkgb2YgdHlwZSBOb2RlLkVMRU1FTlRfTk9ERSkuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuYW5pbWF0aW9ucy5JQW5pbWF0aW9uRnVuY3Rpb259IGZ1bmN0aW9uYWxpdHkgVGhlIHNwZWNpYWxpemVkIGFuaW1hdGlvbiBmdW5jdGlvbiBhdHRyaWJ1dGVzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBBbmltYXRvci5wcm90b3R5cGUuX2hhbmRsZUVuZEZ1bmN0aW9uYWxpdHkgPSBmdW5jdGlvbiAobm9kZXMsIGVsZW1lbnROb2RlcywgZnVuY3Rpb25hbGl0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGgsIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChmdW5jdGlvbmFsaXR5LmtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdsZWF2ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBub2Rlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlKG5vZGVzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdoaWRlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IGVsZW1lbnROb2Rlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50Tm9kZXNbaV0uc2V0QXR0cmlidXRlKF9fSGlkZSwgJycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTZXRzIGEgbmV3LCB1bmlxdWUgYW5pbWF0aW9uIElEIGFuZCBkZW5vdGVzIHRoZSBlbGVtZW50cyBhcyBjdXJyZW50bHkgYmVpbmcgYW5pbWF0ZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIGFuaW1hdGlvbiBJRC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8RWxlbWVudD59IGVsZW1lbnRzIFRoZSBBcnJheSBvZiBFbGVtZW50cyBiZWluZyBhbmltYXRlZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgQW5pbWF0b3IucHJvdG90eXBlLl9fc2V0QW5pbWF0aW9uSWQgPSBmdW5jdGlvbiAoaWQsIGVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGVkRWxlbWVudHMgPSB0aGlzLl9hbmltYXRlZEVsZW1lbnRzLCBhbmltYXRlZEVsZW1lbnQsIF9wbGF0LCBwcm9taXNlcyA9IFtdLCBsZW5ndGggPSBlbGVtZW50cy5sZW5ndGgsIGVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9wbGF0ID0gZWxlbWVudC5fX3BsYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChfcGxhdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuX19wbGF0ID0geyBhbmltYXRpb246IGlkIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBfX0FuaW1hdGluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNVbmRlZmluZWQoX3BsYXQuYW5pbWF0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3BsYXQuYW5pbWF0aW9uID0gaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBfX0FuaW1hdGluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlZEVsZW1lbnQgPSBhbmltYXRlZEVsZW1lbnRzW19wbGF0LmFuaW1hdGlvbl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGFuaW1hdGVkRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGFuaW1hdGVkRWxlbWVudC5wcm9taXNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlZEVsZW1lbnQuYW5pbWF0aW9uRW5kKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3BsYXQuYW5pbWF0aW9uID0gaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VzO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR2VuZXJhdGVzIGEgbmV3IGFuaW1hdGVkIGVsZW1lbnQgZm9yIHRoZSBBbmltYXRvciB0byBlYXNpbHkgcmVmZXJlbmNlIGFuZCBiZSBhYmxlXHJcbiAgICAgICAgICAgICAgICAgKiB0byBlbmQgbGF0ZXIgb24uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIGFuaW1hdGlvbiBJRC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8RWxlbWVudD59IGVsZW1lbnRzIFRoZSBBcnJheSBvZiBFbGVtZW50cyBiZWluZyBhbmltYXRlZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5hbmltYXRpb25zLkFuaW1hdGlvblByb21pc2V9IGFuaW1hdGlvblByb21pc2UgVGhlIGFuaW1hdGlvbidzIGFzc29jaWF0ZWQgcHJvbWlzZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgQW5pbWF0b3IucHJvdG90eXBlLl9fZ2VuZXJhdGVBbmltYXRlZEVsZW1lbnQgPSBmdW5jdGlvbiAoaWQsIGVsZW1lbnRzLCBhbmltYXRpb25Qcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGVkRWxlbWVudHMgPSB0aGlzLl9hbmltYXRlZEVsZW1lbnRzLCByZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChjYW5jZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9wbGF0LCBlbGVtZW50LCBsZW5ndGggPSBlbGVtZW50cy5sZW5ndGgsIGFuaW1hdGlvbklkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FuY2VsID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25Qcm9taXNlLmNhbmNlbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkoYW5pbWF0ZWRFbGVtZW50cywgaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wbGF0ID0gZWxlbWVudC5fX3BsYXQgfHwge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25JZCA9IF9wbGF0LmFuaW1hdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChhbmltYXRpb25JZCkgfHwgYW5pbWF0aW9uSWQgIT09IGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCBfX0FuaW1hdGluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eShfcGxhdCwgJ2FuaW1hdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkoX3BsYXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkoZWxlbWVudCwgJ19fcGxhdCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KGFuaW1hdGVkRWxlbWVudHMsIGlkKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhbmltYXRlZEVsZW1lbnRzW2lkXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uRW5kOiByZW1vdmVMaXN0ZW5lclxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgYW55IHBhcmVudCBlbGVtZW50cyBhcmUgYW5pbWF0aW5nLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxFbGVtZW50Pn0gZWxlbWVudHMgVGhlIEVsZW1lbnRzIHdob3NlIHBhcmVudHMgd2UgbmVlZCB0byBjaGVjay5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgQW5pbWF0b3IucHJvdG90eXBlLl9faXNQYXJlbnRBbmltYXRpbmcgPSBmdW5jdGlvbiAoZWxlbWVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uSWQsIGVsZW1lbnQgPSBlbGVtZW50c1swXTtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIShpc0RvY3VtZW50KGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGUpIHx8IGlzTnVsbChlbGVtZW50KSB8fCBlbGVtZW50Lm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0NsYXNzKGVsZW1lbnQsIF9fQW5pbWF0aW5nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9wbGF0ID0gZWxlbWVudC5fX3BsYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25JZCA9IChfcGxhdCB8fCB7fSkuYW5pbWF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGFuaW1hdGlvbklkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKHRoaXMuX2FuaW1hdGVkRWxlbWVudHNbYW5pbWF0aW9uSWRdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KF9wbGF0LCAnYW5pbWF0aW9uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkoX3BsYXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KGVsZW1lbnQsICdfX3BsYXQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgX19BbmltYXRpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRm9yY2VzIGNoaWxkIG5vZGVzIG9mIGFuIGFuaW1hdGluZyBlbGVtZW50IHRvIHN0b3AgYW5pbWF0aW5nLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IGJlaW5nIGFuaW1hdGVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBBbmltYXRvci5wcm90b3R5cGUuX19zdG9wQ2hpbGRBbmltYXRpb25zID0gZnVuY3Rpb24gKGVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGluZ0VsZW1lbnRzID0gdGhpcy5fYW5pbWF0ZWRFbGVtZW50cywgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UsIGN1c3RvbUFuaW1hdGlvbkVsZW1lbnRzLCBhbmltYXRlZEVsZW1lbnQsIF9wbGF0LCBpZDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbUFuaW1hdGlvbkVsZW1lbnRzID0gc2xpY2UuY2FsbChlbGVtZW50c1tpXS5xdWVyeVNlbGVjdG9yQWxsKCcuJyArIF9fQW5pbWF0aW5nKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChjdXN0b21BbmltYXRpb25FbGVtZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcGxhdCA9IGN1c3RvbUFuaW1hdGlvbkVsZW1lbnRzLnBvcCgpLl9fcGxhdCB8fCB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gX3BsYXQuYW5pbWF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChpZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGVkRWxlbWVudCA9IGFuaW1hdGluZ0VsZW1lbnRzW2lkXSB8fCB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGFuaW1hdGVkRWxlbWVudC5hbmltYXRpb25FbmQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZWRFbGVtZW50LmFuaW1hdGlvbkVuZCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNpZnRzIHRocm91Z2ggYW4gQXJyYXkgb2YgTm9kZXMgYW5kIGZpbmRzIGFsbCBhbmltYXRhYmxlIEVsZW1lbnRzIGFuZCBjcmVhdGVzXHJcbiAgICAgICAgICAgICAgICAgKiBCYXNlQW5pbWF0aW9ucyBmb3IgdGhlbS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBlbGVtZW50cyBUaGUgQXJyYXkgb2YgTm9kZXMsIERvY3VtZW50RnJhZ21lbnQsIG9yIGVsZW1lbnQgdG8gc2lmdCB0aHJvdWdoLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LmRlcGVuZGVuY3kuSW5qZWN0b3I8cGxhdC51aS5hbmltYXRpb25zLkJhc2VBbmltYXRpb24+fSBhbmltYXRpb25JbmplY3RvciBUaGUgaW5qZWN0b3IgdG8gaW5zdGFudGlhdGVcclxuICAgICAgICAgICAgICAgICAqIEJhc2VBbmltYXRpb25zLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxFbGVtZW50Pn0gZWxlbWVudE5vZGVzIFRoZSBBcnJheSBvZiBvbmx5IGFuaW1hdGFibGUgZWxlbWVudHMuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHBsYXQudWkuYW5pbWF0aW9ucy5CYXNlQW5pbWF0aW9uPj59IGFuaW1hdGlvbkluc3RhbmNlcyBBbiBlbXB0eSBBcnJheSBvZiBhbmltYXRpb24gaW5zdGFuY2VzIHRvIGFkZCB0by5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgQW5pbWF0b3IucHJvdG90eXBlLl9fY29uc3RydWN0QW5pbWF0YWJsZUVsZW1lbnRzID0gZnVuY3Rpb24gKGVsZW1lbnRzLCBhbmltYXRpb25JbmplY3RvciwgZWxlbWVudE5vZGVzLCBhbmltYXRpb25JbnN0YW5jZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkoZWxlbWVudHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0RvY3VtZW50RnJhZ21lbnQoZWxlbWVudHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGVsZW1lbnRzLmNoaWxkTm9kZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlKGVsZW1lbnRzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlbGVtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIShpc05vZGUoZWxlbWVudHMpICYmIGVsZW1lbnRzLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gW2VsZW1lbnRzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoLCBlbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOb2RlKGVsZW1lbnQpICYmIGVsZW1lbnQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50Tm9kZXMucHVzaChlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkluc3RhbmNlcy5wdXNoKGFuaW1hdGlvbkluamVjdG9yLmluamVjdCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudHM7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgQW5pbWF0b3IuX2luamVjdCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBfY29tcGF0OiBfX0NvbXBhdCxcclxuICAgICAgICAgICAgICAgICAgICBfUHJvbWlzZTogX19Qcm9taXNlLFxyXG4gICAgICAgICAgICAgICAgICAgIF9kb2N1bWVudDogX19Eb2N1bWVudFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBBbmltYXRvcjtcclxuICAgICAgICAgICAgfSgpKTtcclxuICAgICAgICAgICAgYW5pbWF0aW9ucy5BbmltYXRvciA9IEFuaW1hdG9yO1xyXG4gICAgICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fQW5pbWF0b3IsIEFuaW1hdG9yKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERlc2NyaWJlcyBhIHR5cGUgb2YgUHJvbWlzZSB0aGF0IGNhbiBiZSBvcHRpb25hbGx5IGNhbmNlbGxlZC5cclxuICAgICAgICAgICAgICogRnVydGhlciwgaW4gdGhlIGNhc2Ugd2hlcmUgaXQgbWF5IGhhdmUgYSBwYXJlbnQgdGhhdCBpcyBhbmltYXRpbmcgKHdoaWNoIHdpbGwgY2F1c2UgaXQgdG8gaW1tZWRpYXRlbHkgY2FuY2VsIGFuZCBmdWxmaWxsXHJcbiAgICAgICAgICAgICAqIGl0c2VsZiwgaXQgcmVzb2x2ZXMgd2l0aCBhIElHZXRBbmltYXRpbmdUaGVuYWJsZSBmb3IgYWNjY2Vzc2luZ1xyXG4gICAgICAgICAgICAgKiB0aGUgSUFuaW1hdGlvblRoZW5hYmxlIG9mIHRoZSBhbmltYXRpbmcgcGFyZW50IGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgQW5pbWF0aW9uUHJvbWlzZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgICAgICBfX2V4dGVuZHMoQW5pbWF0aW9uUHJvbWlzZSwgX3N1cGVyKTtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblByb21pc2UocmVzb2x2ZUZ1bmN0aW9uLCBwcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgcmVzb2x2ZUZ1bmN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIElQcm9taXNlIGluamVjdGFibGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fUHJvbWlzZSA9IGFjcXVpcmUoX19Qcm9taXNlKTtcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBUaGUgc3RhdGUgb2YgdGhlIGFuaW1hdGlvbi4gMCBwcmlvciB0byBzdGFydCwgMSBpZiBzdGFydGVkLCBhbmRcclxuICAgICAgICAgICAgICAgICAgICAgKiAyIGlmIGNhbmNlbGVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19hbmltYXRpb25TdGF0ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQW4gQXJyYXkgb2YgYW5pbWF0aW9uIGluc3RhbmNlcyBsaW5rZWQgdG8gdGhpcyBwcm9taXNlLlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19hbmltYXRpb25JbnN0YW5jZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChwcm9taXNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fYW5pbWF0aW9uSW5zdGFuY2VzID0gcHJvbWlzZS5fX2FuaW1hdGlvbkluc3RhbmNlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2FuaW1hdGlvblN0YXRlID0gcHJvbWlzZS5fX2FuaW1hdGlvblN0YXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIEFuaW1hdGlvblByb21pc2UucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoaW5zdGFuY2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkodGhpcy5fX2FuaW1hdGlvbkluc3RhbmNlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoaW5zdGFuY2VzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2FuaW1hdGlvbkluc3RhbmNlcyA9IGluc3RhbmNlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc09iamVjdChpbnN0YW5jZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fYW5pbWF0aW9uSW5zdGFuY2VzID0gW2luc3RhbmNlc107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSBhc3NvY2lhdGVkIGFuaW1hdGlvbiBpbnN0YW5jZXMgb3IgYW5pbWF0ZWQgcHJvbWlzZXMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEFuaW1hdGlvblByb21pc2UucHJvdG90eXBlLmdldEluc3RhbmNlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX2FuaW1hdGlvbkluc3RhbmNlcztcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEZpcmVzIHRoZSBzdGFydCBtZXRob2Qgb24gdGhlIGFuaW1hdGlvbiBpbnN0YW5jZXMgdG8ga2lja29mZiB0aGUgYW5pbWF0aW9ucy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgQW5pbWF0aW9uUHJvbWlzZS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX19hbmltYXRpb25TdGF0ZSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uSW5zdGFuY2VzID0gdGhpcy5fX2FuaW1hdGlvbkluc3RhbmNlcywgYW5pbWF0aW9uSW5zdGFuY2UsIGxlbmd0aCA9IGFuaW1hdGlvbkluc3RhbmNlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25JbnN0YW5jZSA9IGFuaW1hdGlvbkluc3RhbmNlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oYW5pbWF0aW9uSW5zdGFuY2Uuc3RhcnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25JbnN0YW5jZS5zdGFydCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19hbmltYXRpb25TdGF0ZSA9IDE7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBGaXJlcyB0aGUgcGF1c2UgbWV0aG9kIG9uIHRoZSBhbmltYXRpb24gaW5zdGFuY2UuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEFuaW1hdGlvblByb21pc2UucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fYW5pbWF0aW9uU3RhdGUgIT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uSW5zdGFuY2VzID0gdGhpcy5fX2FuaW1hdGlvbkluc3RhbmNlcywgcGF1c2VQcm9taXNlcyA9IFtdLCBhbmltYXRpb25JbnN0YW5jZSwgbGVuZ3RoID0gYW5pbWF0aW9uSW5zdGFuY2VzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkluc3RhbmNlID0gYW5pbWF0aW9uSW5zdGFuY2VzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihhbmltYXRpb25JbnN0YW5jZS5wYXVzZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdXNlUHJvbWlzZXMucHVzaChhbmltYXRpb25JbnN0YW5jZS5wYXVzZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5hbGwocGF1c2VQcm9taXNlcykudGhlbihub29wKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEZpcmVzIHRoZSByZXN1bWUgbWV0aG9kIG9uIHRoZSBhbmltYXRpb24gaW5zdGFuY2UuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEFuaW1hdGlvblByb21pc2UucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2FuaW1hdGlvblN0YXRlICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbkluc3RhbmNlcyA9IHRoaXMuX19hbmltYXRpb25JbnN0YW5jZXMsIHJlc3VtZVByb21pc2VzID0gW10sIGFuaW1hdGlvbkluc3RhbmNlLCBsZW5ndGggPSBhbmltYXRpb25JbnN0YW5jZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uSW5zdGFuY2UgPSBhbmltYXRpb25JbnN0YW5jZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGFuaW1hdGlvbkluc3RhbmNlLnJlc3VtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VtZVByb21pc2VzLnB1c2goYW5pbWF0aW9uSW5zdGFuY2UucmVzdW1lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLmFsbChyZXN1bWVQcm9taXNlcykudGhlbihub29wKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgbWV0aG9kIHRvIGNhbmNlbCB0aGUgYXNzb2NpYXRlZCBhbmltYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEFuaW1hdGlvblByb21pc2UucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2FuaW1hdGlvblN0YXRlID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uSW5zdGFuY2VzID0gdGhpcy5fX2FuaW1hdGlvbkluc3RhbmNlcywgYW5pbWF0aW9uSW5zdGFuY2UsIGxlbmd0aCA9IGFuaW1hdGlvbkluc3RhbmNlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25JbnN0YW5jZSA9IGFuaW1hdGlvbkluc3RhbmNlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oYW5pbWF0aW9uSW5zdGFuY2UuY2FuY2VsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uSW5zdGFuY2UuY2FuY2VsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oYW5pbWF0aW9uSW5zdGFuY2UuZW5kKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uSW5zdGFuY2UuZW5kKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2FuaW1hdGlvblN0YXRlID0gMjtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgbWV0aG9kIHRvIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHByb21pc2UgaGFzIGJlZW4gY2FuY2VsZWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEFuaW1hdGlvblByb21pc2UucHJvdG90eXBlLmlzQ2FuY2VsZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19hbmltYXRpb25TdGF0ZSA9PT0gMjtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBBbmltYXRpb25Qcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKG9uRnVsZmlsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUudGhlbi5jYWxsKHRoaXMsIG9uRnVsZmlsbGVkKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBBbmltYXRpb25Qcm9taXNlLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuY2F0Y2guY2FsbCh0aGlzLCBvblJlamVjdGVkKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQW5pbWF0aW9uUHJvbWlzZTtcclxuICAgICAgICAgICAgfShhc3luYy5Qcm9taXNlKSk7XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbnMuQW5pbWF0aW9uUHJvbWlzZSA9IEFuaW1hdGlvblByb21pc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIHNpbmdsZSBhbmltYXRpb24gZm9yIGEgc2luZ2xlIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgQmFzZUFuaW1hdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBCYXNlQW5pbWF0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEFuIEFycmF5IG9mIHJlbW92ZSBmdW5jdGlvbnMgdG8gZGlzcG9zZSBvZiBldmVudCBsaXN0ZW5lcnMuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2V2ZW50TGlzdGVuZXJzID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gZm9yIGluaXRpYWxpemluZyB0aGUgYW5pbWF0aW9uIG9yIGFueSBvZiBpdHMgcHJvcGVydGllcyBiZWZvcmUgc3RhcnQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEJhc2VBbmltYXRpb24ucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gZGVub3RpbmcgdGhlIHN0YXJ0IG9mIHRoZSBhbmltYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEJhc2VBbmltYXRpb24ucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBhbmltYXRpb24gaXMgb3Zlci5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgQmFzZUFuaW1hdGlvbi5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudExpc3RlbmVycyA9IHRoaXMuX19ldmVudExpc3RlbmVycztcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZXZlbnRMaXN0ZW5lcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudExpc3RlbmVycy5wb3AoKSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzLl9yZXNvbHZlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHRvIHBhdXNlIHRoZSBhbmltYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEJhc2VBbmltYXRpb24ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHRvIHJlc3VtZSBhIHBhdXNlZCBhbmltYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEJhc2VBbmltYXRpb24ucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB0byBsZXQgaXQgYmUga25vd24gdGhlIGFuaW1hdGlvbiBpcyBiZWluZyBjYW5jZWxsZWQuIEFsdGhvdWdoIG5vdFxyXG4gICAgICAgICAgICAgICAgICogbmVjZXNzYXJ5LCB3ZSBjYWxsIGVuZCgpIGluIHRoaXMgZnVuY3Rpb24gYXMgd2VsbCBmb3Igc2FmZSBtZWFzdXJlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBCYXNlQW5pbWF0aW9uLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQoKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgb2YgdGhlIHNwZWNpZmllZCB0eXBlIHRvIHRoaXMgYW5pbWF0aW9uJ3MgZWxlbWVudC4gUmVtb3ZhbCBvZiB0aGVcclxuICAgICAgICAgICAgICAgICAqIGV2ZW50IGlzIGhhbmRsZWQgYXV0b21hdGljYWxseSB1cG9uIGFuaW1hdGlvbiBlbmQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiBldmVudCB0byBsaXN0ZW4gdG8uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0V2ZW50TGlzdGVuZXJ9IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBmaXJlIHdoZW4gdGhlIGV2ZW50IG9jY3Vycy5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlQ2FwdHVyZT8gV2hldGhlciB0byBmaXJlIHRoZSBldmVudCBvbiB0aGUgY2FwdHVyZSBvciB0aGUgYnViYmxlIHBoYXNlXHJcbiAgICAgICAgICAgICAgICAgKiBvZiBldmVudCBwcm9wYWdhdGlvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgQmFzZUFuaW1hdGlvbi5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oJ0FuIGFuaW1hdGlvblxcJ3MgXCJhZGRFdmVudExpc3RlbmVyXCIgbXVzdCB0YWtlIGEgZnVuY3Rpb24gYXMgdGhlIHNlY29uZCBhcmd1bWVudC4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vb3A7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIuYmluZCh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlTGlzdGVuZXIgPSB0aGlzLmRvbS5hZGRFdmVudExpc3RlbmVyKHRoaXMuZWxlbWVudCwgdHlwZSwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcihldik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdXNlQ2FwdHVyZSksIGV2ZW50TGlzdGVuZXJzID0gdGhpcy5fX2V2ZW50TGlzdGVuZXJzO1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TGlzdGVuZXJzLnB1c2gocmVtb3ZlTGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGV2ZW50TGlzdGVuZXJzLmluZGV4T2YocmVtb3ZlTGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudExpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEluaXRpYWxpemVzIHRoZSBlbGVtZW50IGFuZCBrZXkgcHJvcGVydGllcyBvZiB0aGlzIGFuaW1hdGlvbiBhbmQgZ3JhYnMgYVxyXG4gICAgICAgICAgICAgICAgICogcmVmZXJlbmNlIHRvIGl0cyByZXNvbHZlIGZ1bmN0aW9uLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IG9uIHdoaWNoIHRoZSBhbmltYXRpb24gd2lsbCBvY2N1ci5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBvcHRpb25zIFNwZWNpZmllZCBvcHRpb25zIGZvciB0aGUgYW5pbWF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBCYXNlQW5pbWF0aW9uLnByb3RvdHlwZS5pbnN0YW50aWF0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgQW5pbWF0aW9uUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmluaXRpYWxpemUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLmluaXRpYWxpemUodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgQmFzZUFuaW1hdGlvbi5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIF93aW5kb3c6IF9fV2luZG93LFxyXG4gICAgICAgICAgICAgICAgICAgIF9jb21wYXQ6IF9fQ29tcGF0LFxyXG4gICAgICAgICAgICAgICAgICAgIF9sb2c6IF9fTG9nLFxyXG4gICAgICAgICAgICAgICAgICAgIF9Qcm9taXNlOiBfX1Byb21pc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgZG9tOiBfX0RvbSxcclxuICAgICAgICAgICAgICAgICAgICB1dGlsczogX19VdGlsc1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBCYXNlQW5pbWF0aW9uO1xyXG4gICAgICAgICAgICB9KCkpO1xyXG4gICAgICAgICAgICBhbmltYXRpb25zLkJhc2VBbmltYXRpb24gPSBCYXNlQW5pbWF0aW9uO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBjbGFzcyByZXByZXNlbnRpbmcgYSBzaW5nbGUgQ1NTIGFuaW1hdGlvbiBmb3IgYSBzaW5nbGUgZWxlbWVudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBDc3NBbmltYXRpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICAgICAgX19leHRlbmRzKENzc0FuaW1hdGlvbiwgX3N1cGVyKTtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIENzc0FuaW1hdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBBIHNldCBvZiBicm93c2VyIGNvbXBhdGlibGUgQ1NTIGFuaW1hdGlvbiBldmVudHMgY2FwYWJsZSBvZiBiZWluZyBsaXN0ZW5lZCB0by5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRpb25FdmVudHMgPSB0aGlzLl9jb21wYXQuYW5pbWF0aW9uRXZlbnRzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIGZ1bmN0aW9uIHRvIGxpc3RlbiB0byB0aGUgc3RhcnQgb2YgYW4gYW5pbWF0aW9uIGV2ZW50LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsoKSA9PiB2b2lkfSBsaXN0ZW5lciBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBhbmltYXRpb24gYmVnaW5zLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBDc3NBbmltYXRpb24ucHJvdG90eXBlLmFuaW1hdGlvblN0YXJ0ID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9hbmltYXRpb25FdmVudHMuJGFuaW1hdGlvblN0YXJ0LCBsaXN0ZW5lciwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBmdW5jdGlvbiB0byBsaXN0ZW4gdG8gdGhlIGVuZCBvZiBhbiBhbmltYXRpb24gZXZlbnQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyhldj86IEFuaW1hdGlvbkV2ZW50KSA9PiB2b2lkfSBsaXN0ZW5lciBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBhbmltYXRpb24gZW5kcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgQ3NzQW5pbWF0aW9uLnByb3RvdHlwZS5hbmltYXRpb25FbmQgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRFdmVudExpc3RlbmVyKHRoaXMuX2FuaW1hdGlvbkV2ZW50cy4kYW5pbWF0aW9uRW5kLCBsaXN0ZW5lciwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBmdW5jdGlvbiB0byBsaXN0ZW4gdG8gdGhlIGNvbXBsZXRpb24gb2YgYW4gYW5pbWF0aW9uIGl0ZXJhdGlvbi5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7KGV2PzogQW5pbWF0aW9uRXZlbnQpID0+IHZvaWR9IGxpc3RlbmVyIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGFuaW1hdGlvbiBpdGVyYXRpb24gY29tcGxldGVzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBDc3NBbmltYXRpb24ucHJvdG90eXBlLmFuaW1hdGlvbkl0ZXJhdGlvbiA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5fYW5pbWF0aW9uRXZlbnRzLiRhbmltYXRpb25JdGVyYXRpb24sIGxpc3RlbmVyLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIGZ1bmN0aW9uIHRvIGxpc3RlbiB0byB0aGUgc3RhcnQgb2YgYSB0cmFuc2l0aW9uIGV2ZW50LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsoZXY/OiBUcmFuc2l0aW9uRXZlbnQpID0+IHZvaWR9IGxpc3RlbmVyIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHRyYW5zaXRpb24gYmVnaW5zLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBDc3NBbmltYXRpb24ucHJvdG90eXBlLnRyYW5zaXRpb25TdGFydCA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5fYW5pbWF0aW9uRXZlbnRzLiR0cmFuc2l0aW9uU3RhcnQsIGxpc3RlbmVyLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIGZ1bmN0aW9uIHRvIGxpc3RlbiB0byB0aGUgZW5kIG9mIGEgdHJhbnNpdGlvbiBldmVudC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7KGV2PzogVHJhbnNpdGlvbkV2ZW50KSA9PiB2b2lkfSBsaXN0ZW5lciBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSB0cmFuc2l0aW9uIGVuZHMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIENzc0FuaW1hdGlvbi5wcm90b3R5cGUudHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5fYW5pbWF0aW9uRXZlbnRzLiR0cmFuc2l0aW9uRW5kLCBsaXN0ZW5lciwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDc3NBbmltYXRpb247XHJcbiAgICAgICAgICAgIH0oQmFzZUFuaW1hdGlvbikpO1xyXG4gICAgICAgICAgICBhbmltYXRpb25zLkNzc0FuaW1hdGlvbiA9IENzc0FuaW1hdGlvbjtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgc2ltcGxlIENTUyBBbmltYXRpb24gY2xhc3MgdGhhdCBwbGFjZXMgdGhlICdwbGF0LWFuaW1hdGlvbicgY2xhc3Mgb24gYW5cclxuICAgICAgICAgICAgICogZWxlbWVudCwgY2hlY2tzIGZvciBhbmltYXRpb24gcHJvcGVydGllcywgYW5kIHdhaXRzIGZvciB0aGUgYW5pbWF0aW9uIHRvIGVuZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBTaW1wbGVDc3NBbmltYXRpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICAgICAgX19leHRlbmRzKFNpbXBsZUNzc0FuaW1hdGlvbiwgX3N1cGVyKTtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFNpbXBsZUNzc0FuaW1hdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBUaGUgY2xhc3MgbmFtZSBhZGRlZCB0byB0aGUgYW5pbWF0ZWQgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IF9fU2ltcGxlQW5pbWF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gZm9yIHN0b3BwaW5nIGEgcG90ZW50aWFsIGNhbGxiYWNrIGluIHRoZSBhbmltYXRpb24gY2hhaW4uXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsQW5pbWF0aW9uID0gbm9vcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQWRkcyB0aGUgY2xhc3MgdG8gaW5pdGlhbGl6ZSB0aGUgYW5pbWF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBTaW1wbGVDc3NBbmltYXRpb24ucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3ModGhpcy5lbGVtZW50LCB0aGlzLmNsYXNzTmFtZSArIF9fSU5JVF9TVUZGSVgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBmdW5jdGlvbiBkZW5vdGluZyB0aGUgc3RhcnQgb2YgdGhlIGFuaW1hdGlvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgU2ltcGxlQ3NzQW5pbWF0aW9uLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbmNlbEFuaW1hdGlvbiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZUdsb2JhbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gX3RoaXMuZWxlbWVudCwgY2xhc3NOYW1lID0gX3RoaXMuY2xhc3NOYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5vZmZzZXRQYXJlbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbmQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uSWQgPSBfdGhpcy5fYW5pbWF0aW9uRXZlbnRzLiRhbmltYXRpb24sIG9wdGlvbnMgPSBfdGhpcy5vcHRpb25zIHx8IHt9LCBjb21wdXRlZFN0eWxlID0gX3RoaXMuX3dpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG9wdGlvbnMucHNldWRvKSwgYW5pbWF0aW9uTmFtZSA9IGNvbXB1dGVkU3R5bGVbKGFuaW1hdGlvbklkICsgJ05hbWUnKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25OYW1lID09PSAnJyB8fCBhbmltYXRpb25OYW1lID09PSAnbm9uZScgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkU3R5bGVbKGFuaW1hdGlvbklkICsgJ1BsYXlTdGF0ZScpXSA9PT0gJ3BhdXNlZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbmQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMucHJlc2VydmVJbml0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUgKyBfX0lOSVRfU1VGRklYKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY2FuY2VsQW5pbWF0aW9uID0gX3RoaXMuYW5pbWF0aW9uRW5kKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9jYW5jZWxBbmltYXRpb24gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWVHbG9iYWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW5kKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB0byBwYXVzZSB0aGUgYW5pbWF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBTaW1wbGVDc3NBbmltYXRpb24ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhbmNlbEFuaW1hdGlvbiA9PT0gbm9vcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25FdmVudHMgPSB0aGlzLl9jb21wYXQuYW5pbWF0aW9uRXZlbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5fUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWVHbG9iYWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9jYW5jZWxBbmltYXRpb24gIT09IG5vb3ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbGVtZW50LnN0eWxlWyhhbmltYXRpb25FdmVudHMuJGFuaW1hdGlvbiArICdQbGF5U3RhdGUnKV0gPSAncGF1c2VkJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB0byByZXN1bWUgYSBwYXVzZWQgYW5pbWF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBTaW1wbGVDc3NBbmltYXRpb24ucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYW5jZWxBbmltYXRpb24gPT09IG5vb3ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uRXZlbnRzID0gdGhpcy5fY29tcGF0LmFuaW1hdGlvbkV2ZW50cztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuX1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lR2xvYmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fY2FuY2VsQW5pbWF0aW9uICE9PSBub29wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZWxlbWVudC5zdHlsZVsoYW5pbWF0aW9uRXZlbnRzLiRhbmltYXRpb24gKyAnUGxheVN0YXRlJyldID0gJ3J1bm5pbmcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHRvIGxldCBpdCBiZSBrbm93biB0aGUgYW5pbWF0aW9uIGlzIGJlaW5nIGNhbmNlbGxlZC5cclxuICAgICAgICAgICAgICAgICAqIFJlbW92ZXMgdGhlIGFuaW1hdGlvbiBjbGFzcyBhbmQgdGhlIGFuaW1hdGlvbiBcIi1pbml0XCIgY2xhc3MuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFNpbXBsZUNzc0FuaW1hdGlvbi5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbmNlbEFuaW1hdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZCgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVtb3ZlcyB0aGUgYW5pbWF0aW9uIGNsYXNzIGFuZCB0aGUgYW5pbWF0aW9uIFwiLWluaXRcIiBjbGFzcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgU2ltcGxlQ3NzQW5pbWF0aW9uLnByb3RvdHlwZS5fZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5lbGVtZW50LCBjbGFzc05hbWUgKyAnICcgKyBjbGFzc05hbWUgKyBfX0lOSVRfU1VGRklYKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYW5jZWxBbmltYXRpb24gPSBub29wO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTaW1wbGVDc3NBbmltYXRpb247XHJcbiAgICAgICAgICAgIH0oQ3NzQW5pbWF0aW9uKSk7XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbnMuU2ltcGxlQ3NzQW5pbWF0aW9uID0gU2ltcGxlQ3NzQW5pbWF0aW9uO1xyXG4gICAgICAgICAgICByZWdpc3Rlci5hbmltYXRpb24oX19TaW1wbGVBbmltYXRpb24sIFNpbXBsZUNzc0FuaW1hdGlvbik7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBbiBhbmltYXRpb24gY29udHJvbCB0aGF0IGZhZGVzIGluIGFuIGVsZW1lbnQgYXMgZGVmaW5lZCBieSB0aGUgaW5jbHVkZWQgQ1NTLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIEZhZGVJbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgICAgICBfX2V4dGVuZHMoRmFkZUluLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gRmFkZUluKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFRoZSBjbGFzcyBuYW1lIGFkZGVkIHRvIHRoZSBlbGVtZW50IGZhZGluZyBpbi5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IF9fRmFkZUluO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZhZGVJbjtcclxuICAgICAgICAgICAgfShTaW1wbGVDc3NBbmltYXRpb24pKTtcclxuICAgICAgICAgICAgYW5pbWF0aW9ucy5GYWRlSW4gPSBGYWRlSW47XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyLmFuaW1hdGlvbihfX0ZhZGVJbiwgRmFkZUluKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFuIGFuaW1hdGlvbiBjb250cm9sIHRoYXQgZmFkZXMgb3V0IGFuIGVsZW1lbnQgYXMgZGVmaW5lZCBieSB0aGUgaW5jbHVkZWQgQ1NTLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIEZhZGVPdXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICAgICAgX19leHRlbmRzKEZhZGVPdXQsIF9zdXBlcik7XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBGYWRlT3V0KCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFRoZSBjbGFzcyBuYW1lIGFkZGVkIHRvIHRoZSBlbGVtZW50IGZhZGluZyBvdXQuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBfX0ZhZGVPdXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRmFkZU91dDtcclxuICAgICAgICAgICAgfShTaW1wbGVDc3NBbmltYXRpb24pKTtcclxuICAgICAgICAgICAgYW5pbWF0aW9ucy5GYWRlT3V0ID0gRmFkZU91dDtcclxuICAgICAgICAgICAgcmVnaXN0ZXIuYW5pbWF0aW9uKF9fRmFkZU91dCwgRmFkZU91dCk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBbiBhbmltYXRpb24gY29udHJvbCB0aGF0IGNhdXNlcyBhbiBlbGVtZW50IHRvIGVudGVyIGFzIGRlZmluZWQgYnkgdGhlIGluY2x1ZGVkIENTUy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBFbnRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgICAgICBfX2V4dGVuZHMoRW50ZXIsIF9zdXBlcik7XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBFbnRlcigpIHtcclxuICAgICAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBUaGUgY2xhc3MgbmFtZSBhZGRlZCB0byB0aGUgZW50ZXJpbmcgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IF9fRW50ZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRW50ZXI7XHJcbiAgICAgICAgICAgIH0oU2ltcGxlQ3NzQW5pbWF0aW9uKSk7XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbnMuRW50ZXIgPSBFbnRlcjtcclxuICAgICAgICAgICAgcmVnaXN0ZXIuYW5pbWF0aW9uKF9fRW50ZXIsIEVudGVyKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFuIGFuaW1hdGlvbiBjb250cm9sIHRoYXQgY2F1c2VzIGFuIGVsZW1lbnQgdG8gbGVhdmUgYXMgZGVmaW5lZCBieSB0aGUgaW5jbHVkZWQgQ1NTLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIExlYXZlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgICAgIF9fZXh0ZW5kcyhMZWF2ZSwgX3N1cGVyKTtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIExlYXZlKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFRoZSBjbGFzcyBuYW1lIGFkZGVkIHRvIHRoZSBsZWF2aW5nIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBfX0xlYXZlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIExlYXZlO1xyXG4gICAgICAgICAgICB9KFNpbXBsZUNzc0FuaW1hdGlvbikpO1xyXG4gICAgICAgICAgICBhbmltYXRpb25zLkxlYXZlID0gTGVhdmU7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyLmFuaW1hdGlvbihfX0xlYXZlLCBMZWF2ZSk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBbiBhbmltYXRpb24gY29udHJvbCB0aGF0IGNhdXNlcyBhbiBlbGVtZW50IHRvIG1vdmUgYXMgZGVmaW5lZCBieSB0aGUgaW5jbHVkZWQgQ1NTLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIE1vdmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICAgICAgX19leHRlbmRzKE1vdmUsIF9zdXBlcik7XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBNb3ZlKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFRoZSBjbGFzcyBuYW1lIGFkZGVkIHRvIHRoZSBsZWF2aW5nIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBfX01vdmU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTW92ZTtcclxuICAgICAgICAgICAgfShTaW1wbGVDc3NBbmltYXRpb24pKTtcclxuICAgICAgICAgICAgYW5pbWF0aW9ucy5Nb3ZlID0gTW92ZTtcclxuICAgICAgICAgICAgcmVnaXN0ZXIuYW5pbWF0aW9uKF9fTW92ZSwgTW92ZSk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIHNpbXBsZSBDU1MgQW5pbWF0aW9uIGNsYXNzIHRoYXQgcGxhY2VzIHRoZSAncGxhdC10cmFuc2l0aW9uJyBjbGFzcyBvbiBhblxyXG4gICAgICAgICAgICAgKiBlbGVtZW50LCBjaGVja3MgZm9yIHRyYW5zaXRpb24gcHJvcGVydGllcywgYW5kIHdhaXRzIGZvciB0aGUgdHJhbnNpdGlvbiB0byBlbmQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgU2ltcGxlQ3NzVHJhbnNpdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgICAgICBfX2V4dGVuZHMoU2ltcGxlQ3NzVHJhbnNpdGlvbiwgX3N1cGVyKTtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFNpbXBsZUNzc1RyYW5zaXRpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogVGhlIGNsYXNzIG5hbWUgYWRkZWQgdG8gdGhlIGFuaW1hdGVkIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBfX1NpbXBsZVRyYW5zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQSBmdW5jdGlvbiBmb3Igc3RvcHBpbmcgYSBwb3RlbnRpYWwgY2FsbGJhY2sgaW4gdGhlIGFuaW1hdGlvbiBjaGFpbi5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRpb25DYW5jZWxlZCA9IG5vb3A7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQSByZWd1bGFyIGV4cHJlc3Npb24gdG8gbm9ybWFsaXplIG1vZGlmaWVkIHByb3BlcnR5IGtleXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbm9ybWFsaXplUmVnZXggPSAvLS9nO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEEgcmVndWxhciBleHByZXNzaW9uIGdyYWIgZXZlcnl0aGluZyB0aGF0IGlzIG5vdCBhIG51bWJlci5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ub25OdW1SZWdleCA9IC9bXlxcLTAtOVxcLl0vZztcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBBbiBPYmplY3Qgd2hvc2Uga2V5cyBhcmUgdGhlIG5vcm1hbGl6ZWQga2V5cyBvZiBtb2RpZmllZCBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25vcm1hbGl6ZWRLZXlzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogVGhlIFwidHJhbnNpdGlvbmVuZFwiIGV2ZW50IGhhbmRsZXIgY2FsbCBjb3VudC5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uQ291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFRoZSB1c2VyIGRlZmluZWQgXCJ0cmFuc2l0aW9uZW5kXCIgZXZlbnQgaGFuZGxlciBjYWxsIGNvdW50LlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBEZW5vdGVzIHdoZXRoZXIgb3Igbm90IHRoZSB0cmFuc2l0aW9uIHdhcyBldmVyIHN0YXJ0ZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIERlbm90ZXMgd2hldGhlciBvciBub3QgdGhlIHRyYW5zaXRpb24gY2hhbmdlcyBhcmUgYmVpbmcgcGVyZm9ybWVkXHJcbiAgICAgICAgICAgICAgICAgICAgICogd2l0aCBDU1Mgb3Igd2l0aCBKUyB0aHJvdWdoIHRoaXMub3B0aW9ucy5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91c2luZ0NzcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBZGRzIHRoZSBjbGFzcyB0byBlbmFibGUgdGhlIHRyYW5zaXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFNpbXBsZUNzc1RyYW5zaXRpb24ucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3ModGhpcy5lbGVtZW50LCB0aGlzLmNsYXNzTmFtZSArIF9fSU5JVF9TVUZGSVgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBmdW5jdGlvbiBkZW5vdGluZyB0aGUgc3RhcnQgb2YgdGhlIGFuaW1hdGlvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgU2ltcGxlQ3NzVHJhbnNpdGlvbi5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRpb25DYW5jZWxlZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZUdsb2JhbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gX3RoaXMuZWxlbWVudCwgY2xhc3NOYW1lID0gX3RoaXMuY2xhc3NOYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5vZmZzZXRQYXJlbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hbmltYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW5kKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXRpbHMgPSBfdGhpcy51dGlscywgdHJhbnNpdGlvbklkID0gX3RoaXMuX2FuaW1hdGlvbkV2ZW50cy4kdHJhbnNpdGlvbiwgb3B0aW9ucyA9IF90aGlzLm9wdGlvbnMgfHwge30sIGNvbXB1dGVkU3R5bGUgPSBfdGhpcy5fd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgb3B0aW9ucy5wc2V1ZG8pLCBwcm9wZXJ0aWVzID0gX3RoaXMuX3Byb3BlcnRpZXMgPSBjb21wdXRlZFN0eWxlWyh0cmFuc2l0aW9uSWQgKyAnUHJvcGVydHknKV0uc3BsaXQoJywnKSwgZHVyYXRpb25zID0gY29tcHV0ZWRTdHlsZVsodHJhbnNpdGlvbklkICsgJ0R1cmF0aW9uJyldLnNwbGl0KCcsJyksIGxlbmd0aCA9IHByb3BlcnRpZXMubGVuZ3RoLCBwcm9wTGVuZ3RoID0gbGVuZ3RoLCBub1RyYW5zaXRpb24gPSBmYWxzZSwgcHJvcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGxlbmd0aC0tID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcCA9IHByb3BlcnRpZXNbbGVuZ3RoXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSAnJyB8fCBwcm9wID09PSAnbm9uZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnNwbGljZShsZW5ndGgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcExlbmd0aCA+IDEgJiYgcHJvcCA9PT0gJ2FsbCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3N0IGxpa2VseSBkZXZlbG9wZXIgZXJyb3IgKGV4dHJhIGNvbW1hIGF0IGVuZCBvZiBzaG9ydGhhbmQgbXVsdGkgdHJhbnNpdGlvbiBkZWNsYXJhdGlvbikgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gd2Ugd2lsbCBzcGxpY2UgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5kZWJ1ZyhcIkltcHJvcGVyIHRyYW5zaXRpb24gZGVjbGFyYXRpb24gb24gY2xhc3MgXFxcIlwiICsgZWxlbWVudC5jbGFzc05hbWUgKyBcIlxcXCJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcy5zcGxpY2UobGVuZ3RoLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vVHJhbnNpdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBkdXJhdGlvbnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGxlbmd0aC0tID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3AgPSBkdXJhdGlvbnNbbGVuZ3RoXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShwcm9wID09PSAnJyB8fCBwcm9wID09PSAnMHMnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vVHJhbnNpdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vVHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FuaW1hdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbmQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXRpbHMuaXNOdW1iZXIob3B0aW9ucy5jb3VudCkgJiYgb3B0aW9ucy5jb3VudCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9jb3VudCA9IG9wdGlvbnMuY291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucHJlc2VydmVJbml0ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lICsgX19JTklUX1NVRkZJWCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FuaW1hdGlvbkNhbmNlbGVkID0gX3RoaXMudHJhbnNpdGlvbkVuZChfdGhpcy5fZG9uZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fYW5pbWF0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodXRpbHMuaXNFbXB0eShvcHRpb25zLnByb3BlcnRpZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fX2Nzc1RyYW5zaXRpb24oY29tcHV0ZWRTdHlsZSwgZHVyYXRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbmQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHRvIGxldCBpdCBiZSBrbm93biB0aGUgYW5pbWF0aW9uIGlzIGJlaW5nIGNhbmNlbGxlZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgU2ltcGxlQ3NzVHJhbnNpdGlvbi5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbkNhbmNlbGVkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kKCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZW1vdmVzIHRoZSBhbmltYXRpb24gY2xhc3MgYW5kIHRoZSBhbmltYXRpb24gXCItaW5pdFwiIGNsYXNzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBTaW1wbGVDc3NUcmFuc2l0aW9uLnByb3RvdHlwZS5fZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5lbGVtZW50LCBjbGFzc05hbWUgKyAnICcgKyBjbGFzc05hbWUgKyBfX0lOSVRfU1VGRklYKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRpb25DYW5jZWxlZCA9IG5vb3A7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIGhhbmRsZXIgZm9yIHRoZSBcInRyYW5zaXRpb25lbmRcIiBldmVudC4gV2lsbCBjbGVhbiB1cCB0aGUgY2xhc3MgYW5kIHJlc29sdmUgdGhlXHJcbiAgICAgICAgICAgICAgICAgKiBwcm9taXNlIHdoZW4gbmVjZXNzYXJ5IGJhc2VkIG9uIHRoZSBvcHRpb25zIHRoYXQgd2VyZSBpbnB1dC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7VHJhbnNpdGlvbkV2ZW50fSBldj8gVGhlIHRyYW5zaXRpb24gZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBpbW1lZGlhdGU/IFdoZXRoZXIgY2xlYW4gdXAgc2hvdWxkIGJlIGltbWVkaWF0ZSBvciBjb25kaXRpb25hbC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgU2ltcGxlQ3NzVHJhbnNpdGlvbi5wcm90b3R5cGUuX2RvbmUgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlOYW1lID0gZXYucHJvcGVydHlOYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhwcm9wZXJ0eU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3VudCA9ICsrdGhpcy5fdHJhbnNpdGlvbkNvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWUucmVwbGFjZSh0aGlzLl9ub3JtYWxpemVSZWdleCwgJycpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY291bnQgPCB0aGlzLl9jb3VudCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICghdGhpcy5fdXNpbmdDc3MgJiYgdGhpcy5fbm9ybWFsaXplZEtleXNbcHJvcGVydHlOYW1lXSA9PT0gdHJ1ZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50IDwgdGhpcy5fcHJvcGVydGllcy5sZW5ndGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kKCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBbmltYXRlIHRoZSBlbGVtZW50IGJhc2VkIG9uIHRoZSBvcHRpb25zIHBhc3NlZCBpbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgU2ltcGxlQ3NzVHJhbnNpdGlvbi5wcm90b3R5cGUuX2FuaW1hdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5lbGVtZW50LnN0eWxlIHx8IHt9LCBwcm9wZXJ0aWVzID0gKHRoaXMub3B0aW9ucyB8fCB7fSkucHJvcGVydGllcyB8fCB7fSwga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCBub3JtYWxpemVkS2V5cyA9IHRoaXMuX25vcm1hbGl6ZWRLZXlzLCBub3JtYWxpemVSZWdleCA9IHRoaXMuX25vcm1hbGl6ZVJlZ2V4LCBjdXJyZW50UHJvcGVydHksIG5ld1Byb3BlcnR5LCB1bmNoYW5nZWQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5cy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvcGVydHkgPSBzdHlsZVtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQcm9wZXJ0eSA9IHByb3BlcnRpZXNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1N0cmluZyhuZXdQcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuY2hhbmdlZCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVba2V5XSA9IG5ld1Byb3BlcnR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFByb3BlcnR5ID09PSBzdHlsZVtrZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmNoYW5nZWQrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRLZXlzW2tleS5yZXBsYWNlKG5vcm1hbGl6ZVJlZ2V4LCAnJykudG9Mb3dlckNhc2UoKV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmNoYW5nZWQgPCBsZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBIYW5kbGVzIGVsZW1lbnQgdHJhbnNpdGlvbnMgdGhhdCBhcmUgZGVmaW5lZCB3aXRoIENTUy5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gY29tcHV0ZWRTdHlsZSBUaGUgY29tcHV0ZWQgc3R5bGUgb2YgdGhlXHJcbiAgICAgICAgICAgICAgICAgKiBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBkdXJhdGlvbnMgVGhlIGFycmF5IG9mIGRlY2xhcmVkIHRyYW5zaXRpb24gZHVyYXRpb24gdmFsdWVzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBTaW1wbGVDc3NUcmFuc2l0aW9uLnByb3RvdHlwZS5fX2Nzc1RyYW5zaXRpb24gPSBmdW5jdGlvbiAoY29tcHV0ZWRTdHlsZSwgZHVyYXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNpdGlvbklkID0gdGhpcy5fYW5pbWF0aW9uRXZlbnRzLiR0cmFuc2l0aW9uLCBkZWxheXMgPSBjb21wdXRlZFN0eWxlWyh0cmFuc2l0aW9uSWQgKyAnRGVsYXknKV0uc3BsaXQoJywnKSwgcHJvcGVydGllcyA9IHRoaXMuX3Byb3BlcnRpZXMsIHByb3BlcnR5LCBkdXJhdGlvbiwgZGVsYXksIGxlbmd0aCA9IHByb3BlcnRpZXMubGVuZ3RoLCBjb21wdXRlZFByb3BlcnR5LCBub3JtYWxpemVkS2V5cyA9IHRoaXMuX25vcm1hbGl6ZWRLZXlzLCBub3JtYWxpemVSZWdleCA9IHRoaXMuX25vcm1hbGl6ZVJlZ2V4LCBpID0gMCwgY291bnQgPSAwLCBjaGFuZ2VkID0gZmFsc2UsIGRlZmVyID0gdGhpcy51dGlscy5kZWZlci5iaW5kKHRoaXMsIGZ1bmN0aW9uIChwcm9wLCBjb21wdXRlZFByb3ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9hbmltYXRpb25DYW5jZWxlZCA9PT0gbm9vcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlzcG9zYWwgaGFzIGFscmVhZHkgb2NjdXJyZWQgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcCA9PT0gJ2FsbCcgfHwgY29tcHV0ZWRTdHlsZVtwcm9wXSAhPT0gY29tcHV0ZWRQcm9wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW4ndCBrbm93IGlmIHRoZSB0cmFuc2l0aW9uIHN0YXJ0ZWQgZHVlIHRvICdhbGwnIGJlaW5nIHNldCBhbmQgaGF2ZSB0byByZWx5IG9uIHRoaXMub3B0aW9ucy5jb3VudCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Uga25vdyB0aGUgdHJhbnNpdGlvbiBzdGFydGVkIGR1ZSB0byB0aGUgcHJvcGVydGllcyBiZWluZyBkaWZmZXJlbnQgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKytjb3VudCA8IGxlbmd0aCB8fCBjaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Rpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW5kKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXNpbmdDc3MgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvdW50ID0gdGhpcy5fY291bnQgfHwgbGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldID0gcHJvcGVydGllc1tpXS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gZHVyYXRpb25zLmxlbmd0aCA+IGkgPyBkdXJhdGlvbnNbaV0udHJpbSgpIDogZHVyYXRpb25zW2R1cmF0aW9ucy5sZW5ndGggLSAxXS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gZGVsYXlzLmxlbmd0aCA+IGkgPyBkZWxheXNbaV0udHJpbSgpIDogZGVsYXlzW2RlbGF5cy5sZW5ndGggLSAxXS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRLZXlzW3Byb3BlcnR5LnJlcGxhY2Uobm9ybWFsaXplUmVnZXgsICcnKS50b0xvd2VyQ2FzZSgpXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkUHJvcGVydHkgPSBjb21wdXRlZFN0eWxlW3Byb3BlcnR5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIodGhpcy5fdG9NcyhkdXJhdGlvbikgKyB0aGlzLl90b01zKGRlbGF5KSwgW3Byb3BlcnR5LCBjb21wdXRlZFByb3BlcnR5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBmdW5jdGlvbiB0aGF0IGNvbnZlcnRzIGEgc3RyaW5nIHZhbHVlIGV4cHJlc3NlZCBhcyBlaXRoZXIgc2Vjb25kcyBvciBtaWxsaXNlY29uZHNcclxuICAgICAgICAgICAgICAgICAqIHRvIGEgbnVtZXJpY2FsIG1pbGxpc2Vjb25kIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGR1cmF0aW9uIFRoZSB0cmFuc2l0aW9uIGR1cmF0aW9uIHNwZWNpZmllZCBieSB0aGUgY29tcHV0ZWQgc3R5bGUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFNpbXBsZUNzc1RyYW5zaXRpb24ucHJvdG90eXBlLl90b01zID0gZnVuY3Rpb24gKGR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZ2V4ID0gdGhpcy5fbm9uTnVtUmVnZXgsIHVuaXRzID0gZHVyYXRpb24ubWF0Y2gocmVnZXgpWzBdLCB0aW1lID0gTnVtYmVyKGR1cmF0aW9uLnJlcGxhY2UocmVnZXgsICcnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnV0aWxzLmlzTnVtYmVyKHRpbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh1bml0cyA9PT0gJ3MnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aW1lICogMTAwMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodW5pdHMgPT09ICdtcycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTaW1wbGVDc3NUcmFuc2l0aW9uO1xyXG4gICAgICAgICAgICB9KENzc0FuaW1hdGlvbikpO1xyXG4gICAgICAgICAgICBhbmltYXRpb25zLlNpbXBsZUNzc1RyYW5zaXRpb24gPSBTaW1wbGVDc3NUcmFuc2l0aW9uO1xyXG4gICAgICAgICAgICByZWdpc3Rlci5hbmltYXRpb24oX19TaW1wbGVUcmFuc2l0aW9uLCBTaW1wbGVDc3NUcmFuc2l0aW9uKTtcclxuICAgICAgICB9KShhbmltYXRpb25zID0gdWkuYW5pbWF0aW9ucyB8fCAodWkuYW5pbWF0aW9ucyA9IHt9KSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSG9sZHMgY2xhc3NlcyBhbmQgaW50ZXJmYWNlcyByZWxhdGVkIHRvIFVJIGNvbnRyb2wgY29tcG9uZW50cyBpbiBwbGF0eXB1cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgY29udHJvbHM7XHJcbiAgICAgICAgKGZ1bmN0aW9uIChjb250cm9sc18xKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIGNvbnRyb2wgdGhhdCBmYWNpbGl0YXRlcyByb3V0aW5nIGJldHdlZW4gVmlld0NvbnRyb2xzLiBBIFZpZXdwb3J0IGlzXHJcbiAgICAgICAgICAgICAqIHRoZSBsaW5rIGJldHdlZW4gYSBWaWV3Q29udHJvbCwgYSBOYXZpZ2F0b3IsIGFuZCBhIFJvdXRlci5cclxuICAgICAgICAgICAgICogSXQgcmVnaXN0ZXJzIHdpdGggYSByb3V0ZXIgYW5kIHJlY2VpdmVzIHJvdXRlIGNoYW5nZSBldmVudHMuIEl0IHRoZW4gaW5zdGFudGlhdGVzIHRoZSBwcm9wZXIgdmlld2NvbnRyb2wgYW5kIGFwcGVuZHMgaXRcclxuICAgICAgICAgICAgICogdG8gdGhlIERPTS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBWaWV3cG9ydCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgICAgICBfX2V4dGVuZHMoVmlld3BvcnQsIF9zdXBlcik7XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBWaWV3cG9ydCgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQWxsb3dzIHRoZSB2aWV3cG9ydCB0byBpbml0aWFsaXplIGl0cyBuYXZpZ2F0b3Igd2l0aCB0aGUgY3VycmVudFxyXG4gICAgICAgICAgICAgICAgICogcm91dGVyLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBWaWV3cG9ydC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcm91dGVyID0gdGhpcy5fcm91dGVyID0gdGhpcy5fUm91dGVyLmN1cnJlbnRSb3V0ZXIoKSwgcGFyZW50Vmlld3BvcnQgPSB0aGlzLl9nZXRQYXJlbnRWaWV3cG9ydCgpLCBwYXJlbnRSb3V0ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoaXNOdWxsKHBhcmVudFZpZXdwb3J0KSB8fCBpc051bGwocGFyZW50Vmlld3BvcnQuX3JvdXRlcikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFJvdXRlciA9IHRoaXMuX3BhcmVudFJvdXRlciA9IHBhcmVudFZpZXdwb3J0Ll9yb3V0ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFJvdXRlci5hZGRDaGlsZChyb3V0ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uYXZpZ2F0b3IuaW5pdGlhbGl6ZShyb3V0ZXIpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIHZpZXdwb3J0IHJlZ2lzdGVycyBpdHNlbGYgd2l0aCBpdHMgcm91dGVyLCBub3RpZnlpbmcgdGhlXHJcbiAgICAgICAgICAgICAgICAgKiByb3V0ZXIgdGhhdCBpdCBpcyByZWFkeSB0byByZWNlaXZlIG5hdmlnYXRpb24gZXZlbnRzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBWaWV3cG9ydC5wcm90b3R5cGUubG9hZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHRoaXMub3B0aW9ucykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGUgPSB0aGlzLm9wdGlvbnMudmFsdWUuYW5pbWF0ZSA9PT0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmFkZENsYXNzKHRoaXMuZWxlbWVudCwgX19WaWV3cG9ydCArICctYW5pbWF0ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGUgPSBhbmltYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9Qcm9taXNlLnJlc29sdmUodGhpcy5fcm91dGVyLmZpbmlzaE5hdmlnYXRpbmcpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcm91dGVyLnJlZ2lzdGVyKF90aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSB2aWV3cG9ydCdzIHJvdXRlciBoYXMgbWF0Y2hlZCBhIHJvdXRlIGFuZCBpcyBhc2tpbmcgdGhlIHZpZXdwb3J0IGlmIGl0IGlzIHNhZmUgdG9cclxuICAgICAgICAgICAgICAgICAqIG5hdmlnYXRlLiBIZXJlIHRoZSB2aWV3cG9ydCBjYW4gaW5zdGFudGlhdGUgdGhlIG5ldyB2aWV3IGFuZCBhc2sgaXQgaWYgaXQgaXMgc2FmZSB0b1xyXG4gICAgICAgICAgICAgICAgICogbmF2aWdhdGUgdG8gdGhlIHZpZXcuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucm91dGluZy5JUm91dGVJbmZvfSByb3V0ZUluZm8gQ29udGFpbnMgdGhlIGluZm9ybWF0aW9uIG5lY2Vzc2FyeSB0byBpbnN0YW50aWF0ZVxyXG4gICAgICAgICAgICAgICAgICogdGhlIHZpZXcgYW5kIGZlZWQgaXQgdGhlIHJvdXRlIHBhcmFtZXRlcnMvcXVlcnkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFZpZXdwb3J0LnByb3RvdHlwZS5jYW5OYXZpZ2F0ZVRvID0gZnVuY3Rpb24gKHJvdXRlSW5mbykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdldFJvdXRlciA9IHRoaXMuX1JvdXRlci5jdXJyZW50Um91dGVyLCBjdXJyZW50Um91dGVyID0gZ2V0Um91dGVyKCksIHJlc3BvbnNlID0gdHJ1ZSwgaW5qZWN0b3IgPSB0aGlzLl9JbmplY3Rvci5nZXREZXBlbmRlbmN5KHJvdXRlSW5mby5kZWxlZ2F0ZS52aWV3KSwgdmlldyA9IGluamVjdG9yLmluamVjdCgpLCBwYXJhbWV0ZXJzID0gcm91dGVJbmZvLnBhcmFtZXRlcnMsIG5leHRSb3V0ZXIgPSBnZXRSb3V0ZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzT2JqZWN0KHZpZXcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLnJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Um91dGVyICE9PSBuZXh0Um91dGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRSb3V0ZXIuaW5pdGlhbGl6ZSh0aGlzLl9yb3V0ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmF2aWdhdG9yXzEgPSBhY3F1aXJlKF9fTmF2aWdhdG9ySW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3Lm5hdmlnYXRvciA9IG5hdmlnYXRvcl8xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3JfMS5pbml0aWFsaXplKG5leHRSb3V0ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5uYXZpZ2F0b3IgPSB0aGlzLl9uYXZpZ2F0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHZpZXcuY2FuTmF2aWdhdGVUbykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB2aWV3LmNhbk5hdmlnYXRlVG8ocGFyYW1ldGVycywgcm91dGVJbmZvLnF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UucmVzb2x2ZShyZXNwb25zZSkudGhlbihmdW5jdGlvbiAoY2FuTmF2aWdhdGVUbykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbmV4dEluamVjdG9yID0gaW5qZWN0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9uZXh0VmlldyA9IHZpZXc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYW5OYXZpZ2F0ZVRvO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIHZpZXdwb3J0J3Mgcm91dGVyIGhhcyBtYXRjaGVkIGEgcm91dGUgYW5kIGlzIGFza2luZyB0aGUgdmlld3BvcnQgaWYgaXQgaXMgc2FmZSB0b1xyXG4gICAgICAgICAgICAgICAgICogbmF2aWdhdGUgZnJvbSB0aGUgY3VycmVudCBzdGF0ZS4gSGVyZSB0aGUgdmlld3BvcnQgY2FuIHF1ZXJ5IHRoZSBjdXJyZW50IFZpZXdDb250cm9sIGFuZFxyXG4gICAgICAgICAgICAgICAgICogYXNrIGl0IGlmIGl0IGlzIHNhZmUgdG8gbmF2aWdhdGUgZnJvbSBpdHMgY3VycmVudCBzdGF0ZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgVmlld3BvcnQucHJvdG90eXBlLmNhbk5hdmlnYXRlRnJvbSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMuY29udHJvbHNbMF0sIHJlc3BvbnNlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QodmlldykgJiYgaXNGdW5jdGlvbih2aWV3LmNhbk5hdmlnYXRlRnJvbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB2aWV3LmNhbk5hdmlnYXRlRnJvbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSB2aWV3cG9ydCdzIHJvdXRlciBoYXMgbWF0Y2hlZCBhIHJvdXRlIGFuZCBkZXRlcm1pbmVkIHRoYXQgaXQgaXMgc2FmZSB0byBuYXZpZ2F0ZSB0byB0aGVcclxuICAgICAgICAgICAgICAgICAqIG5leHQgdmlldy4gVGhlIHZpZXdwb3J0IHdpbGwgbm93IGdvIHRocm91Z2ggdGhlIHN0ZXBzIHRvIGNvbXBpbGUgYW5kIGxpbmsgdGhlIG5leHQgdmlldyB0aGVuIGFwcGVuZFxyXG4gICAgICAgICAgICAgICAgICogaXQgdG8gdGhlIERPTS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5yb3V0aW5nLklSb3V0ZUluZm99IHJvdXRlSW5mbyBDb250YWlucyB0aGUgaW5mb3JtYXRpb24gbmVjZXNzYXJ5IHRvIGluc3RhbnRpYXRlXHJcbiAgICAgICAgICAgICAgICAgKiB0aGUgdmlldyBhbmQgZmVlZCBpdCB0aGUgcm91dGUgcGFyYW1ldGVycy9xdWVyeS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgVmlld3BvcnQucHJvdG90eXBlLm5hdmlnYXRlVG8gPSBmdW5jdGlvbiAocm91dGVJbmZvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluamVjdG9yID0gdGhpcy5fbmV4dEluamVjdG9yIHx8IHRoaXMuX0luamVjdG9yLmdldERlcGVuZGVuY3kocm91dGVJbmZvLmRlbGVnYXRlLnZpZXcpLCBub2RlTWFwID0gdGhpcy5fY3JlYXRlTm9kZU1hcChpbmplY3RvciksIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsIG5vZGUgPSBub2RlTWFwLmVsZW1lbnQsIHBhcmFtZXRlcnMgPSByb3V0ZUluZm8ucGFyYW1ldGVycywgcXVlcnkgPSByb3V0ZUluZm8ucXVlcnksIGNvbnRyb2wgPSBub2RlTWFwLnVpQ29udHJvbE5vZGUuY29udHJvbDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXh0SW5qZWN0b3IgPSB0aGlzLl9uZXh0VmlldyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYW5pbWF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvciwgZG9tXzEgPSB0aGlzLmRvbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX25hdmlnYXRvci5pc0JhY2tOYXZpZ2F0aW9uKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbV8xLmFkZENsYXNzKG5vZGUsIF9fTmF2aWdhdGluZ0JhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0b3IuZW50ZXIobm9kZSwgX19FbnRlciwgZWxlbWVudCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tXzEucmVtb3ZlQ2xhc3Mobm9kZSwgX19OYXZpZ2F0aW5nQmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdG9yLmVudGVyKG5vZGUsIF9fRW50ZXIsIGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lmluc2VydEJlZm9yZShub2RlLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZpZXdwb3J0TWFuYWdlciA9IHRoaXMuX21hbmFnZXJDYWNoZS5yZWFkKHRoaXMudWlkKSwgbWFuYWdlciA9IHRoaXMuX0VsZW1lbnRNYW5hZ2VyRmFjdG9yeS5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0TWFuYWdlci5jaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hbmFnZXIuaW5pdGlhbGl6ZShub2RlTWFwLCB2aWV3cG9ydE1hbmFnZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGNvbnRyb2wubmF2aWdhdGVkVG8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2wubmF2aWdhdGVkVG8ocm91dGVJbmZvLnBhcmFtZXRlcnMsIHF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbWFuYWdlci5zZXRVaUNvbnRyb2xUZW1wbGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sLmhhc093bkNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hbmFnZXIub2JzZXJ2ZVJvb3RDb250ZXh0KGNvbnRyb2wsIG1hbmFnZXIuZnVsZmlsbEFuZExvYWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFuYWdlci5mdWxmaWxsQW5kTG9hZCgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIHZpZXdwb3J0J3Mgcm91dGVyIGhhcyBtYXRjaGVkIGEgcm91dGUgYW5kIGRldGVybWluZWQgdGhhdCBpdCBpcyBzYWZlIHRvIG5hdmlnYXRlIHRvIHRoZVxyXG4gICAgICAgICAgICAgICAgICogbmV4dCB2aWV3LiBJdCBpcyBub3cgc2FmZSBmb3IgdGhlIHZpZXdwb3J0IHRvIGRpc3Bvc2Ugb2YgdGhlIGN1cnJlbnQgc3RhdGUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFZpZXdwb3J0LnByb3RvdHlwZS5uYXZpZ2F0ZUZyb20gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMuY29udHJvbHNbMF0sIHByb21pc2UsIHZpZXdFeGlzdHMgPSBpc09iamVjdCh2aWV3KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmlld0V4aXN0cyAmJiBpc0Z1bmN0aW9uKHZpZXcubmF2aWdhdGluZ0Zyb20pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSB0aGlzLl9Qcm9taXNlLnJlc29sdmUodmlldy5uYXZpZ2F0aW5nRnJvbSgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSB0aGlzLl9Qcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChlcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhlcnJvci5tZXNzYWdlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuZGVidWcoX3RoaXMudHlwZSArICcgZXJyb3I6ICcgKyBlcnJvci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmRlYnVnKF90aGlzLnR5cGUgKyAnIGVycm9yOiAnICsgSlNPTi5zdHJpbmdpZnkoZXJyb3IpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmRlYnVnKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoX3RoaXMuX2FuaW1hdGUgJiYgdmlld0V4aXN0cykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnRyb2wuZGlzcG9zZSh2aWV3KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkRWxlbWVudCA9IHZpZXcuZWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9uYXZpZ2F0b3IuaXNCYWNrTmF2aWdhdGlvbigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kb20uYWRkQ2xhc3Mob2xkRWxlbWVudCwgX19OYXZpZ2F0aW5nQmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FuaW1hdG9yLmxlYXZlKG9sZEVsZW1lbnQsIF9fTGVhdmUpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udHJvbC5kaXNwb3NlKHZpZXcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSB2aWV3cG9ydCBpcyBnb2luZyBvdXQgb2Ygc2NvcGUsIHNvIGl0IG5lZWRzIHRvIHVucmVnaXN0ZXIgZnJvbSBpdHMgcm91dGVyIGluIG9yZGVyIHRvIHN0b3AgcmVjZWl2aW5nIHJvdXRpbmdcclxuICAgICAgICAgICAgICAgICAqIGV2ZW50cy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgVmlld3BvcnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcm91dGVyLnVucmVnaXN0ZXIodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmF2aWdhdG9yLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIENyZWF0ZXMgYW4gSU5vZGVNYXAgZm9yIGEgVmlld0NvbnRyb2wgaW4gb3JkZXIgdG8gY29tcGlsZSBpdC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5kZXBlbmRlbmN5LkluamVjdG9yPHBsYXQudWkuVmlld0NvbnRyb2w+fSBUaGUgaW5qZWN0b3IgdXNlZCB0byBpbnN0YW50aWF0ZSB0aGUgVmlld0NvbnRyb2wuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFZpZXdwb3J0LnByb3RvdHlwZS5fY3JlYXRlTm9kZU1hcCA9IGZ1bmN0aW9uIChpbmplY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250cm9sID0gdGhpcy5fbmV4dFZpZXcgfHwgaW5qZWN0b3IuaW5qZWN0KCksIGRvYyA9IHRoaXMuX2RvY3VtZW50LCB0eXBlID0gaW5qZWN0b3IubmFtZSwgcmVwbGFjZVdpdGggPSBjb250cm9sLnJlcGxhY2VXaXRoLCBub2RlID0gKGlzRW1wdHkocmVwbGFjZVdpdGgpIHx8IHJlcGxhY2VXaXRoID09PSAnYW55JykgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2MuY3JlYXRlRWxlbWVudCgnZGl2JykgOiBkb2MuY3JlYXRlRWxlbWVudChyZXBsYWNlV2l0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoX19Db250cm9sLCB0eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmNsYXNzTmFtZSA9IF9fVmlld0NvbnRyb2w7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogbm9kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdWlDb250cm9sTm9kZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbDogY29udHJvbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVOYW1lOiB0eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5qZWN0b3I6IGluamVjdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRmluZHMgdGhlIGZpcnN0IFZpZXdwb3J0IGluIHRoZSBwYXJlbnQgY2hhaW4uIFRoaXMgaXMgdXNlZnVsIGluIG9yZGVyIHRvIHByb3Blcmx5IGluaXRpYWxpemUgdGhlIHZpZXdwb3J0J3NcclxuICAgICAgICAgICAgICAgICAqIHJvdXRlciBhcyBhIGNoaWxkIG9mIHRoZSBwYXJlbnQgdmlld3BvcnQncyByb3V0ZXIuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFZpZXdwb3J0LnByb3RvdHlwZS5fZ2V0UGFyZW50Vmlld3BvcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZpZXdwb3J0ID0gdGhpcy5wYXJlbnQsIHR5cGUgPSB0aGlzLnR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFpc051bGwodmlld3BvcnQpICYmIHZpZXdwb3J0LnR5cGUgIT09IHR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnQgPSB2aWV3cG9ydC5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2aWV3cG9ydDtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBWaWV3cG9ydC5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIF9Sb3V0ZXI6IF9fUm91dGVyU3RhdGljLFxyXG4gICAgICAgICAgICAgICAgICAgIF9Qcm9taXNlOiBfX1Byb21pc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgX0luamVjdG9yOiBfX0luamVjdG9yU3RhdGljLFxyXG4gICAgICAgICAgICAgICAgICAgIF9FbGVtZW50TWFuYWdlckZhY3Rvcnk6IF9fRWxlbWVudE1hbmFnZXJGYWN0b3J5LFxyXG4gICAgICAgICAgICAgICAgICAgIF9kb2N1bWVudDogX19Eb2N1bWVudCxcclxuICAgICAgICAgICAgICAgICAgICBfbWFuYWdlckNhY2hlOiBfX01hbmFnZXJDYWNoZSxcclxuICAgICAgICAgICAgICAgICAgICBfYW5pbWF0b3I6IF9fQW5pbWF0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgX25hdmlnYXRvcjogX19OYXZpZ2F0b3JJbnN0YW5jZVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBWaWV3cG9ydDtcclxuICAgICAgICAgICAgfShUZW1wbGF0ZUNvbnRyb2wpKTtcclxuICAgICAgICAgICAgY29udHJvbHNfMS5WaWV3cG9ydCA9IFZpZXdwb3J0O1xyXG4gICAgICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fVmlld3BvcnQsIFZpZXdwb3J0KTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgVGVtcGxhdGVDb250cm9sIGZvciBlYXNpbHkgcmV1c2luZyBhXHJcbiAgICAgICAgICAgICAqIGRlZmluZWQgSFRNTCB0ZW1wbGF0ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBUZW1wbGF0ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgICAgICBfX2V4dGVuZHMoVGVtcGxhdGUsIF9zdXBlcik7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBjb25zdHJ1Y3RvciBmb3IgYSBUZW1wbGF0ZS4gQ3JlYXRlcyB0aGUgY29udHJvbCBjYWNoZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gVGVtcGxhdGUoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogUmVtb3ZlcyB0aGUgYDxwbGF0LXRlbXBsYXRlPmAgbm9kZSBmcm9tIHRoZSBET01cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VXaXRoID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiB0aGUgY29udHJvbCxcclxuICAgICAgICAgICAgICAgICAgICAgKiBzcGVjaWZ5aW5nIHRoYXQgaXQgZGVmaW5lcyB0aGUgdGVtcGxhdGUgdG8gY29weS5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9faXNGaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfQ2FjaGVGYWN0b3J5ID0gYWNxdWlyZShfX0NhY2hlRmFjdG9yeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RlbXBsYXRlQ29udHJvbENhY2hlID0gX0NhY2hlRmFjdG9yeS5jcmVhdGUoX19UZW1wbGF0ZUNvbnRyb2xDYWNoZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEluaXRpYWxpemVzIHRoZSBjcmVhdGlvbiBvZiB0aGUgdGVtcGxhdGUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFRlbXBsYXRlLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zT2JqID0gdGhpcy5vcHRpb25zIHx8IHt9LCBvcHRpb25zID0gb3B0aW9uc09iai52YWx1ZSB8fCB7fSwgaWQgPSB0aGlzLl9pZCA9IG9wdGlvbnMuaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChpZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4odGhpcy50eXBlICsgJyBpbnN0YW50aWF0ZWQgd2l0aG91dCBhbiBpZCBvcHRpb24nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cmwgPSBvcHRpb25zLnRlbXBsYXRlVXJsO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZVByb21pc2UgPSB0aGlzLl9fdGVtcGxhdGVDb250cm9sQ2FjaGUucmVhZChpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc051bGwodGVtcGxhdGVQcm9taXNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdGVtcGxhdGVQcm9taXNlID0gdGVtcGxhdGVQcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19pc0ZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplVGVtcGxhdGUoKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIERlY2lkZXMgaWYgdGhpcyBpcyBhIHRlbXBsYXRlIGRlZmluaXRpb24gb3JcclxuICAgICAgICAgICAgICAgICAqIGEgdGVtcGxhdGUgaW5zdGFuY2UuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFRlbXBsYXRlLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9faXNGaXJzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl93YWl0Rm9yVGVtcGxhdGVDb250cm9sKHRoaXMuX190ZW1wbGF0ZVByb21pc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlbW92ZXMgdGhlIHRlbXBsYXRlIGZyb20gdGhlIHRlbXBsYXRlIGNhY2hlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBUZW1wbGF0ZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2lzRmlyc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhY2hlID0gdGhpcy5fX3RlbXBsYXRlQ29udHJvbENhY2hlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5yZW1vdmUodGhpcy5faWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGUuaW5mbygpLnNpemUgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIERldGVybWluZXMgd2hldGhlciBhIFVSTCBvciBpbm5lckhUTUwgaXMgYmVpbmcgdXNlZCxcclxuICAgICAgICAgICAgICAgICAqIGNyZWF0ZXMgdGhlIGJpbmRhYmxlIHRlbXBsYXRlLCBhbmQgc3RvcmVzIHRoZSB0ZW1wbGF0ZVxyXG4gICAgICAgICAgICAgICAgICogaW4gYSB0ZW1wbGF0ZSBjYWNoZSBmb3IgbGF0ZXIgdXNlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBUZW1wbGF0ZS5wcm90b3R5cGUuX2luaXRpYWxpemVUZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IHRoaXMuX2lkO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwoaWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSB0aGlzLmVuZE5vZGUucGFyZW50Tm9kZSwgdXJsID0gdGhpcy5fdXJsLCB0ZW1wbGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbCh1cmwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlID0gdGhpcy5fdGVtcGxhdGVDYWNoZS5yZWFkKHVybCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyTm9kZUJsb2NrKHRoaXMuZWxlbWVudE5vZGVzLCBwYXJlbnROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRDaGlsZHJlbih0aGlzLmVsZW1lbnROb2RlcywgdGVtcGxhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbFByb21pc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJvbWlzZSh0ZW1wbGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbFByb21pc2UgPSB0ZW1wbGF0ZS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwoZXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRlbXBsYXRlQ29udHJvbC5kZXRlcm1pbmVUZW1wbGF0ZShfdGhpcywgdXJsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAodGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmJpbmRhYmxlVGVtcGxhdGVzLmFkZChpZCwgdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJpbmRhYmxlVGVtcGxhdGVzLmFkZChpZCwgdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbFByb21pc2UgPSB0aGlzLl9Qcm9taXNlLnJlc29sdmUodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190ZW1wbGF0ZUNvbnRyb2xDYWNoZS5wdXQoaWQsIGNvbnRyb2xQcm9taXNlKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFdhaXRzIGZvciB0aGUgdGVtcGxhdGUgcHJvbWlzZSB0byByZXNvbHZlLCB0aGVuIGluaXRpYWxpemVzXHJcbiAgICAgICAgICAgICAgICAgKiB0aGUgYmluZGluZyBvZiB0aGUgYmluZGFibGUgdGVtcGxhdGUgYW5kIHBsYWNlcyBpdCBpbnRvIHRoZVxyXG4gICAgICAgICAgICAgICAgICogRE9NLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LmFzeW5jLklUaGVuYWJsZTxwbGF0LnVpLmNvbnRyb2xzLlRlbXBsYXRlPn0gdGVtcGxhdGVQcm9taXNlIFRoZSBwcm9taXNlXHJcbiAgICAgICAgICAgICAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIGZpcnN0IGluc3RhbmNlIG9mIHRoZSBjb250cm9sIHdpdGggdGhpcyBJRC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgVGVtcGxhdGUucHJvdG90eXBlLl93YWl0Rm9yVGVtcGxhdGVDb250cm9sID0gZnVuY3Rpb24gKHRlbXBsYXRlUHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Byb21pc2UodGVtcGxhdGVQcm9taXNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlUHJvbWlzZS50aGVuKGZ1bmN0aW9uICh0ZW1wbGF0ZUNvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaXNOdWxsKF90aGlzLl91cmwpIHx8IChfdGhpcy5fdXJsID09PSB0ZW1wbGF0ZUNvbnRyb2wuX3VybCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLndhcm4oJ1RoZSBzcGVjaWZpZWQgdXJsOiAnICsgX3RoaXMuX3VybCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBkb2VzIG5vdCBtYXRjaCB0aGUgb3JpZ2luYWwgJyArIF90aGlzLnR5cGUgKyAnIHdpdGggaWQ6ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcIicgKyBfdGhpcy5faWQgKyAnXCIuIFRoZSBvcmlnaW5hbCB1cmwgd2lsbCBiZSBsb2FkZWQuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19tYXBCaW5kYWJsZVRlbXBsYXRlcyh0ZW1wbGF0ZUNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuYmluZGFibGVUZW1wbGF0ZXMuYmluZChfdGhpcy5faWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNsb25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmROb2RlID0gX3RoaXMuZW5kTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlKGVuZE5vZGUucGFyZW50Tm9kZSwgY2xvbmUsIGVuZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0cG9uZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLndhcm4oJ1Byb2JsZW0gcmVzb2x2aW5nICcgKyBfdGhpcy50eXBlICsgJyB1cmw6ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLnJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBNYXBzIHRoZSBiaW5kYWJsZSB0ZW1wbGF0ZXMgY2FjaGUgYW5kIGh0bWwgdGVtcGxhdGVzIG9mIHRoZSBmaXJzdFxyXG4gICAgICAgICAgICAgICAgICogY29udHJvbCB3aXRoIHRoZSBwcm9wZXIgSUQgdG8gdGhpcyBjb250cm9sJ3MgYmluZGFibGUgdGVtcGxhdGVzLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLmNvbnRyb2xzLlRlbXBsYXRlfSBjb250cm9sIFRoZSBmaXJzdCBvZiB0aGUgY29udHJvbHNcclxuICAgICAgICAgICAgICAgICAqIHdpdGggdGhpcyBjb3JyZXNwb25kaW5nIElEIHRoYXQgZGVmaW5lZCB0aGUgSFRNTCB0ZW1wbGF0ZSB0byByZXVzZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgVGVtcGxhdGUucHJvdG90eXBlLl9fbWFwQmluZGFibGVUZW1wbGF0ZXMgPSBmdW5jdGlvbiAoY29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiaW5kYWJsZVRlbXBsYXRlcyA9IHRoaXMuYmluZGFibGVUZW1wbGF0ZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgYmluZGFibGVUZW1wbGF0ZXMuY2FjaGUgPSBjb250cm9sLmJpbmRhYmxlVGVtcGxhdGVzLmNhY2hlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJpbmRhYmxlVGVtcGxhdGVzLnRlbXBsYXRlcyA9IGNvbnRyb2wuYmluZGFibGVUZW1wbGF0ZXMudGVtcGxhdGVzO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIFRlbXBsYXRlLl9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX1Byb21pc2U6IF9fUHJvbWlzZSxcclxuICAgICAgICAgICAgICAgICAgICBfdGVtcGxhdGVDYWNoZTogX19UZW1wbGF0ZUNhY2hlLFxyXG4gICAgICAgICAgICAgICAgICAgIF9kb2N1bWVudDogX19Eb2N1bWVudFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBUZW1wbGF0ZTtcclxuICAgICAgICAgICAgfShUZW1wbGF0ZUNvbnRyb2wpKTtcclxuICAgICAgICAgICAgY29udHJvbHNfMS5UZW1wbGF0ZSA9IFRlbXBsYXRlO1xyXG4gICAgICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fVGVtcGxhdGUsIFRlbXBsYXRlKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgVGVtcGxhdGVDb250cm9sIGZvciBpbm5lciBIVE1MIHRoYXQgY29udGFpbnMgY29udHJvbHNcclxuICAgICAgICAgICAgICogYW5kL29yIG1hcmt1cCBhbmQgbm90IGhhdmluZyBpdCBiaW5kIG9yIGV2YWx1YXRlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIElnbm9yZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgICAgICBfX2V4dGVuZHMoSWdub3JlLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gSWdub3JlKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZW1vdmVzIHRoZSBpbm5lckhUTUwgZnJvbSB0aGUgRE9NIGFuZCBzYXZlcyBpdC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgSWdub3JlLnByb3RvdHlwZS5zZXRUZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlubmVyVGVtcGxhdGUgPSBhcHBlbmRDaGlsZHJlbih0aGlzLmVsZW1lbnQuY2hpbGROb2Rlcyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBQbGFjZXMgdGhlIHNhdmVkIGlubmVySFRNTCBiYWNrIGludG8gdGhlIERPTS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgSWdub3JlLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuaW5uZXJUZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBJZ25vcmU7XHJcbiAgICAgICAgICAgIH0oVGVtcGxhdGVDb250cm9sKSk7XHJcbiAgICAgICAgICAgIGNvbnRyb2xzXzEuSWdub3JlID0gSWdub3JlO1xyXG4gICAgICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fSWdub3JlLCBJZ25vcmUpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBUZW1wbGF0ZUNvbnRyb2wgZm9yIHJlcGVhdGluZyBhIGJsb2NrIG9mXHJcbiAgICAgICAgICAgICAqIERPTSBub2RlcyBib3VuZCB0byBhbiBhcnJheS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBGb3JFYWNoID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgICAgIF9fZXh0ZW5kcyhGb3JFYWNoLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgY29uc3RydWN0b3IgZm9yIGEgRm9yRWFjaC4gQ3JlYXRlcyB0aGUgaXRlbXNMb2FkZWQgcHJvbWlzZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gRm9yRWFjaCgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFRoZSBsb2FkIHByaW9yaXR5IG9mIHRoZSBjb250cm9sIChuZWVkcyB0byBsb2FkIGJlZm9yZSBhIEJpbmQgY29udHJvbCkuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmlvcml0eSA9IDEyMDtcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBVc2VkIHRvIGhvbGQgdGhlIGFsaWFzIHRva2VucyBmb3IgdGhlIGJ1aWx0LWluIGZvcmVhY2ggYWxpYXNlcy4gWW91XHJcbiAgICAgICAgICAgICAgICAgICAgICogY2FuIG92ZXJ3cml0ZSB0aGVzZSB3aXRoIHRoZSBvcHRpb25zIGZvclxyXG4gICAgICAgICAgICAgICAgICAgICAqIHRoZSBGb3JFYWNoIGNvbnRyb2wuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWxpYXNlcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IF9fZm9yRWFjaEFsaWFzT3B0aW9ucy5pbmRleCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbjogX19mb3JFYWNoQWxpYXNPcHRpb25zLmV2ZW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9kZDogX19mb3JFYWNoQWxpYXNPcHRpb25zLm9kZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3Q6IF9fZm9yRWFjaEFsaWFzT3B0aW9ucy5maXJzdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdDogX19mb3JFYWNoQWxpYXNPcHRpb25zLmxhc3RcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFRoZSBub2RlIGxlbmd0aCBvZiBlYWNoIGl0ZW0ncyBjaGlsZE5vZGVzIChpbm5lckhUTUwpLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEZvciB0aGUgRm9yRWFjaCBpdCBzaG91bGQgYmUgYVxyXG4gICAgICAgICAgICAgICAgICAgICAqIHNpbmdsZSBjb25zdGFudCBudW1iZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmxvY2tMZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEEgcXVldWUgcmVwcmVzZW50aW5nIGFsbCBjdXJyZW50IGFkZCBvcGVyYXRpb25zLlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFF1ZXVlID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogVGhlIG51bWJlciBvZiBpdGVtcyBjdXJyZW50bHkgaW4gdGhlIGxpc3Qgb3IgaW4gdGhlIHByb2Nlc3Mgb2YgYmVpbmcgYWRkZWRcclxuICAgICAgICAgICAgICAgICAgICAgKiBvciByZW1vdmVkIGZyb20gdGhlIGxpc3QuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faXRlbUxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIEFycmF5IGxpc3RlbmVyIGhhcyBiZWVuIHNldC5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fbGlzdGVuZXJTZXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1zTG9hZGVkID0gbmV3IHRoaXMuX1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fX3Jlc29sdmVGbiA9IHJlc29sdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fcmVqZWN0Rm4gPSByZWplY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2gobm9vcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIENyZWF0ZXMgYSBiaW5kYWJsZSB0ZW1wbGF0ZSB3aXRoIHRoZSBjb250cm9sIGVsZW1lbnQncyBjaGlsZE5vZGVzIChpbm5lckhUTUwpLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBGb3JFYWNoLnByb3RvdHlwZS5zZXRUZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJpbmRhYmxlVGVtcGxhdGVzLmFkZCgnaXRlbScsIHRoaXMuZWxlbWVudC5jaGlsZE5vZGVzKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlLXN5bmNzIHRoZSBGb3JFYWNoIGNoaWxkIGNvbnRyb2xzIGFuZCBET00gd2l0aCB0aGUgbmV3XHJcbiAgICAgICAgICAgICAgICAgKiBhcnJheS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gbmV3VmFsdWUgVGhlIG5ldyBBcnJheVxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBvbGRWYWx1ZSBUaGUgb2xkIEFycmF5XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEZvckVhY2gucHJvdG90eXBlLmNvbnRleHRDaGFuZ2VkID0gZnVuY3Rpb24gKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KG5ld1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXhlY3V0ZUV2ZW50KFt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IG5ld1ZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3NwbGljZSdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfV0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogT2JzZXJ2ZXMgdGhlIEFycmF5IGNvbnRleHQgZm9yIGNoYW5nZXMgYW5kIGFkZHMgaW5pdGlhbCBpdGVtcyB0byB0aGUgRE9NLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBGb3JFYWNoLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsIGFuaW1hdGluZyA9IHRoaXMuX2FuaW1hdGUgPSAhaXNVbmRlZmluZWQob3B0aW9ucykgJiYgb3B0aW9ucy52YWx1ZS5hbmltYXRlID09PSB0cnVlLCBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IHRoaXMuZWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvblF1ZXVlID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldEFsaWFzZXMoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkoY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWRkUXVldWUgPSB0aGlzLl9hZGRRdWV1ZSwgaXRlbUNvdW50ID0gY29udGV4dC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFkZFByb21pc2UgPSB0aGlzLl9hZGRJdGVtcygwLCBpdGVtQ291bnQsIDApLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBhZGRRdWV1ZS5pbmRleE9mKGFkZFByb21pc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRRdWV1ZS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkUXVldWUucHVzaChhZGRQcm9taXNlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVtb3ZlcyBhbnkgcG90ZW50aWFsbHkgaGVsZCBtZW1vcnkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEZvckVhY2gucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudXRpbHMuaXNGdW5jdGlvbih0aGlzLl9fcmVqZWN0Rm4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19yZWplY3RGbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fcmVzb2x2ZUZuID0gdGhpcy5fX3JlamVjdEZuID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uUXVldWUgPSB0aGlzLl9hZGRRdWV1ZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTZXRzIHRoZSBhbGlhcyB0b2tlbnMgdG8gdXNlIGZvciBhbGwgdGhlIGl0ZW1zIGluIHRoZSBGb3JFYWNoIGNvbnRleHQgQXJyYXkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEZvckVhY2gucHJvdG90eXBlLl9zZXRBbGlhc2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChvcHRpb25zKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbGlhc2VzID0gb3B0aW9ucy52YWx1ZS5hbGlhc2VzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNPYmplY3QoYWxpYXNlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2FsaWFzZXMgPSB0aGlzLl9hbGlhc2VzLCBrZXlzID0gT2JqZWN0LmtleXMoX2FsaWFzZXMpLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwgdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGFsaWFzZXNba2V5c1tpXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hbGlhc2VzW2tleXNbaV1dID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBZGRzIG5ldyBpdGVtcyB0byB0aGUgY29udHJvbCdzIGVsZW1lbnQgd2hlbiBpdGVtcyBhcmUgYWRkZWQgdG9cclxuICAgICAgICAgICAgICAgICAqIHRoZSBhcnJheS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgcG9pbnQgaW4gdGhlIGFycmF5IHRvIHN0YXJ0IGFkZGluZyBpdGVtcy5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJPZkl0ZW1zIFRoZSBudW1iZXIgb2YgaXRlbXMgdG8gYWRkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGFuaW1hdGVJdGVtcyBUaGUgbnVtYmVyIG9mIGl0ZW1zIHRvIGFuaW1hdGUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEZvckVhY2gucHJvdG90eXBlLl9hZGRJdGVtcyA9IGZ1bmN0aW9uIChpbmRleCwgbnVtYmVyT2ZJdGVtcywgYW5pbWF0ZUl0ZW1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4ID0gKyhpbmRleCArIG51bWJlck9mSXRlbXMpLCBwcm9taXNlcyA9IFtdLCBpbml0aWFsSW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pdGVtTGVuZ3RoICs9IG51bWJlck9mSXRlbXM7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgbWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fYmluZEl0ZW0oaW5kZXgrKykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvbWlzZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1zTG9hZGVkID0gdGhpcy5fUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKHRlbXBsYXRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3NldEJsb2NrTGVuZ3RoKHRlbXBsYXRlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0ZUl0ZW1zID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGhfMTAgPSB0ZW1wbGF0ZXMubGVuZ3RoLCBjb250YWluZXIgPSBfdGhpcy5fY29udGFpbmVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoXzEwOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBhbmltYXRlSXRlbXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hcHBlbmRBbmltYXRlZEl0ZW0odGVtcGxhdGVzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUodGVtcGxhdGVzW2ldLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hcHBlbmRJdGVtcyh0ZW1wbGF0ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3VwZGF0ZVJlc291cmNlKGluaXRpYWxJbmRleCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oX3RoaXMuX19yZXNvbHZlRm4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19yZXNvbHZlRm4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fX3Jlc29sdmVGbiA9IF90aGlzLl9fcmVqZWN0Rm4gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3Rwb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcoZXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zTG9hZGVkO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQWRkcyBhbiBBcnJheSBvZiBpdGVtcyB0byB0aGUgZWxlbWVudCB3aXRob3V0IGFuaW1hdGluZy5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8Tm9kZT59IGl0ZW1zIFRoZSBBcnJheSBvZiBpdGVtcyB0byBhZGQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEZvckVhY2gucHJvdG90eXBlLl9hcHBlbmRJdGVtcyA9IGZ1bmN0aW9uIChpdGVtcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFwcGVuZENoaWxkcmVuKGl0ZW1zLCB0aGlzLl9jb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQWRkcyBhbiBpdGVtIHRvIHRoZSBjb250cm9sJ3MgZWxlbWVudCBhbmltYXRpbmcgaXRzIGVsZW1lbnRzLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSBpdGVtIFRoZSBIVE1MIGZyYWdtZW50IHJlcHJlc2VudGluZyBhIHNpbmdsZSBpdGVtLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBGb3JFYWNoLnByb3RvdHlwZS5fYXBwZW5kQW5pbWF0ZWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShpdGVtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25RdWV1ZSA9IHRoaXMuX2FuaW1hdGlvblF1ZXVlLCBhbmltYXRpb24gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogdGhpcy5fYW5pbWF0b3IuZW50ZXIoaXRlbSwgX19FbnRlciwgdGhpcy5fY29udGFpbmVyKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGFuaW1hdGlvblF1ZXVlLmluZGV4T2YoYW5pbWF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25RdWV1ZS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3A6IG51bGxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvblF1ZXVlLnB1c2goYW5pbWF0aW9uKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlbW92ZXMgaXRlbXMgZnJvbSB0aGUgY29udHJvbCdzIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IHRvIHN0YXJ0IGRpc3Bvc2luZyBmcm9tLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlck9mSXRlbXMgVGhlIG51bWJlciBvZiBpdGVtcyB0byByZW1vdmUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEZvckVhY2gucHJvdG90eXBlLl9yZW1vdmVJdGVtcyA9IGZ1bmN0aW9uIChpbmRleCwgbnVtYmVyT2ZJdGVtcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXNwb3NlID0gVGVtcGxhdGVDb250cm9sLmRpc3Bvc2UsIGNvbnRyb2xzID0gdGhpcy5jb250cm9scywgbGFzdCA9IGluZGV4ICsgbnVtYmVyT2ZJdGVtcztcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobGFzdC0tID4gaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcG9zZShjb250cm9sc1tsYXN0XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVJlc291cmNlKGNvbnRyb2xzLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQmluZHMgdGhlIGl0ZW0gdG8gYSB0ZW1wbGF0ZSBhdCB0aGF0IGluZGV4LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBGb3JFYWNoLnByb3RvdHlwZS5fYmluZEl0ZW0gPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5iaW5kYWJsZVRlbXBsYXRlcy5iaW5kKCdpdGVtJywgaW5kZXgsIHRoaXMuX2dldEFsaWFzZXMoaW5kZXgpKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNldHMgdGhlIGNvcnJlc3BvbmRpbmcgYmxvY2sgbGVuZ3RoIGZvciBhbmltYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEZvckVhY2gucHJvdG90eXBlLl9zZXRCbG9ja0xlbmd0aCA9IGZ1bmN0aW9uICh0ZW1wbGF0ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYmxvY2tMZW5ndGggPiAwIHx8IHRlbXBsYXRlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ibG9ja0xlbmd0aCA9IHRlbXBsYXRlc1swXS5jaGlsZE5vZGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFVwZGF0ZXMgYSBjaGlsZCByZXNvdXJjZSBvYmplY3Qgd2hlblxyXG4gICAgICAgICAgICAgICAgICogdGhlIGFycmF5IGNoYW5nZXMuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGNvbnRyb2wgd2hvc2UgcmVzb3VyY2VzIHdlIHdpbGwgdXBkYXRlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBGb3JFYWNoLnByb3RvdHlwZS5fdXBkYXRlUmVzb3VyY2UgPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbHMgPSB0aGlzLmNvbnRyb2xzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gY29udHJvbHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbHNbaW5kZXhdLnJlc291cmNlcy5hZGQodGhpcy5fZ2V0QWxpYXNlcyhpbmRleCkpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogU2V0cyBhIGxpc3RlbmVyIGZvciB0aGUgY2hhbmdlcyB0byB0aGUgYXJyYXkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEZvckVhY2gucHJvdG90eXBlLl9zZXRMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX19saXN0ZW5lclNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmVBcnJheSh0aGlzLl9leGVjdXRlRXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fbGlzdGVuZXJTZXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlY2VpdmVzIGFuIGV2ZW50IHdoZW4gYSBtZXRob2QgaGFzIGJlZW4gY2FsbGVkIG9uIGFuIGFycmF5IGFuZCBtYXBzIHRoZSBhcnJheVxyXG4gICAgICAgICAgICAgICAgICogbWV0aG9kIHRvIGl0cyBhc3NvY2lhdGVkIG1ldGhvZCBoYW5kbGVyLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxwbGF0Lm9ic2VydmFibGUuSUFycmF5Q2hhbmdlczxhbnk+Pn0gY2hhbmdlcyBUaGUgQXJyYXkgbXV0YXRpb24gZXZlbnQgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEZvckVhY2gucHJvdG90eXBlLl9leGVjdXRlRXZlbnQgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXRob2QgPSAnXycgKyBjaGFuZ2VzWzBdLnR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1ttZXRob2RdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW21ldGhvZF0oY2hhbmdlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyBhIHJlc291cmNlIGFsaWFzIG9iamVjdCBmb3IgYW4gaXRlbSBpbiB0aGUgYXJyYXkuIFRoZVxyXG4gICAgICAgICAgICAgICAgICogcmVzb3VyY2Ugb2JqZWN0IGNvbnRhaW5zIGluZGV4Om51bWJlciwgZXZlbjpib29sZWFuLCBvZGQ6Ym9vbGVhbixcclxuICAgICAgICAgICAgICAgICAqIGZpcnN0OmJvb2xlYW4sIGFuZCBsYXN0OmJvb2xlYW4uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IHVzZWQgdG8gY3JlYXRlIHRoZSByZXNvdXJjZSBhbGlhc2VzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBGb3JFYWNoLnByb3RvdHlwZS5fZ2V0QWxpYXNlcyA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0V2ZW4gPSAoaW5kZXggJiAxKSA9PT0gMCwgYWxpYXNlcyA9IHt9LCBfYWxpYXNlcyA9IHRoaXMuX2FsaWFzZXMsIHR5cGUgPSBfX0xJVEVSQUxfUkVTT1VSQ0U7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxpYXNlc1tfYWxpYXNlcy5pbmRleF0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpbmRleCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgYWxpYXNlc1tfYWxpYXNlcy5ldmVuXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGlzRXZlbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgYWxpYXNlc1tfYWxpYXNlcy5vZGRdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogIWlzRXZlbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgYWxpYXNlc1tfYWxpYXNlcy5maXJzdF0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpbmRleCA9PT0gMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgYWxpYXNlc1tfYWxpYXNlcy5sYXN0XSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGluZGV4ID09PSAodGhpcy5jb250ZXh0Lmxlbmd0aCAtIDEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxpYXNlcztcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEhhbmRsZXMgaXRlbXMgYmVpbmcgcHVzaGVkIGludG8gdGhlIGFycmF5LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxwbGF0Lm9ic2VydmFibGUuSUFycmF5Q2hhbmdlczxhbnk+Pn0gY2hhbmdlcyBUaGUgQXJyYXkgbXV0YXRpb24gZXZlbnQgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEZvckVhY2gucHJvdG90eXBlLl9wdXNoID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlID0gY2hhbmdlc1swXSwgYWRkUXVldWUgPSB0aGlzLl9hZGRRdWV1ZSwgaXRlbUNvdW50ID0gY2hhbmdlLmFkZGVkQ291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFkZFByb21pc2UgPSB0aGlzLl9hZGRJdGVtcyhjaGFuZ2UuaW5kZXgsIGl0ZW1Db3VudCwgdGhpcy5fYW5pbWF0ZSA/IGl0ZW1Db3VudCA6IDApLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBhZGRRdWV1ZS5pbmRleE9mKGFkZFByb21pc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRRdWV1ZS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkUXVldWUucHVzaChhZGRQcm9taXNlKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEhhbmRsZXMgaXRlbXMgYmVpbmcgcG9wcGVkIG9mZiB0aGUgYXJyYXkuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHBsYXQub2JzZXJ2YWJsZS5JQXJyYXlDaGFuZ2VzPGFueT4+fSBjaGFuZ2VzIFRoZSBBcnJheSBtdXRhdGlvbiBldmVudCBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgRm9yRWFjaC5wcm90b3R5cGUuX3BvcCA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlID0gY2hhbmdlc1swXSwgc3RhcnQgPSBjaGFuZ2Uub2JqZWN0Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnJlbW92ZWQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW92ZUluZGV4ID0gY2hhbmdlLm9iamVjdC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2l0ZW1MZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1MZW5ndGgtLTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fUHJvbWlzZS5hbGwodGhpcy5fYWRkUXVldWUpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2FuaW1hdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hbmltYXRlSXRlbXMoc3RhcnQsIDEsIF9fTGVhdmUsICdsZWF2ZScsIGZhbHNlKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVtb3ZlSXRlbXMocmVtb3ZlSW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlbW92ZUl0ZW1zKHJlbW92ZUluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEhhbmRsZXMgaXRlbXMgYmVpbmcgdW5zaGlmdGVkIGludG8gdGhlIGFycmF5LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxwbGF0Lm9ic2VydmFibGUuSUFycmF5Q2hhbmdlczxhbnk+Pn0gY2hhbmdlcyBUaGUgQXJyYXkgbXV0YXRpb24gZXZlbnQgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEZvckVhY2gucHJvdG90eXBlLl91bnNoaWZ0ID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlID0gY2hhbmdlc1swXSwgYWRkZWRDb3VudCA9IGNoYW5nZS5hZGRlZENvdW50LCBhZGRRdWV1ZSA9IHRoaXMuX2FkZFF1ZXVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hbmltYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25RdWV1ZSA9IHRoaXMuX2FuaW1hdGlvblF1ZXVlLCBhbmltYXRpb25MZW5ndGggPSBhbmltYXRpb25RdWV1ZS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGVJdGVtcygwLCBhZGRlZENvdW50LCBfX0VudGVyLCBudWxsLCBhbmltYXRpb25MZW5ndGggPiAwICYmIGFuaW1hdGlvblF1ZXVlW2FuaW1hdGlvbkxlbmd0aCAtIDFdLm9wID09PSAnY2xvbmUnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFkZFByb21pc2UgPSB0aGlzLl9hZGRJdGVtcyhjaGFuZ2Uub2JqZWN0Lmxlbmd0aCAtIGFkZGVkQ291bnQsIGFkZGVkQ291bnQsIDApLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBhZGRRdWV1ZS5pbmRleE9mKGFkZFByb21pc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRRdWV1ZS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkUXVldWUucHVzaChhZGRQcm9taXNlKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEhhbmRsZXMgaXRlbXMgYmVpbmcgc2hpZnRlZCBvZmYgdGhlIGFycmF5LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxwbGF0Lm9ic2VydmFibGUuSUFycmF5Q2hhbmdlczxhbnk+Pn0gY2hhbmdlcyBUaGUgQXJyYXkgbXV0YXRpb24gZXZlbnQgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEZvckVhY2gucHJvdG90eXBlLl9zaGlmdCA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWRkUXVldWUgPSB0aGlzLl9hZGRRdWV1ZSwgY2hhbmdlID0gY2hhbmdlc1swXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnJlbW92ZWQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fYW5pbWF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkUXVldWUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRRdWV1ZSA9IGFkZFF1ZXVlLmNvbmNhdChbdGhpcy5fYW5pbWF0ZUl0ZW1zKDAsIDEsIF9fTGVhdmUsICdjbG9uZScsIHRydWUpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW92ZUluZGV4ID0gY2hhbmdlLm9iamVjdC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2l0ZW1MZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1MZW5ndGgtLTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fUHJvbWlzZS5hbGwoYWRkUXVldWUpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVtb3ZlSXRlbXMocmVtb3ZlSW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogSGFuZGxlcyBhZGRpbmcvcmVtb3ZpbmcgaXRlbXMgd2hlbiBhbiBhcnJheSBpcyBzcGxpY2VkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxwbGF0Lm9ic2VydmFibGUuSUFycmF5Q2hhbmdlczxhbnk+Pn0gY2hhbmdlcyBUaGUgQXJyYXkgbXV0YXRpb24gZXZlbnQgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEZvckVhY2gucHJvdG90eXBlLl9zcGxpY2UgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbMF0sIGFkZENvdW50ID0gY2hhbmdlLmFkZGVkQ291bnQsIGFkZFF1ZXVlID0gdGhpcy5fYWRkUXVldWUsIGN1cnJlbnRMZW5ndGggPSB0aGlzLl9pdGVtTGVuZ3RoLCBhZGRQcm9taXNlLCBhbmltYXRpbmcgPSB0aGlzLl9hbmltYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwoYWRkQ291bnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbmNlbEN1cnJlbnRBbmltYXRpb25zKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0xlbmd0aCA9IGNoYW5nZS5vYmplY3QubGVuZ3RoLCBpdGVtQ291bnRfMSA9IGN1cnJlbnRMZW5ndGggLSBuZXdMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdMZW5ndGggPiBjdXJyZW50TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVtQ291bnQgd2lsbCBiZSBuZWdhdGl2ZSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFByb21pc2UgPSB0aGlzLl9hZGRJdGVtcyhjdXJyZW50TGVuZ3RoLCAtaXRlbUNvdW50XzEsIDApLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGFkZFF1ZXVlLmluZGV4T2YoYWRkUHJvbWlzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRRdWV1ZS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUXVldWUucHVzaChhZGRQcm9taXNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50TGVuZ3RoID4gbmV3TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudExlbmd0aCA+PSBpdGVtQ291bnRfMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1MZW5ndGggLT0gaXRlbUNvdW50XzE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pdGVtTGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX1Byb21pc2UuYWxsKGFkZFF1ZXVlKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVtb3ZlSXRlbXMoY3VycmVudExlbmd0aCAtIGl0ZW1Db3VudF8xLCBpdGVtQ291bnRfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZW1vdmVDb3VudCA9IGNoYW5nZS5yZW1vdmVkLmxlbmd0aCwgYW5pbWF0aW9uUXVldWUgPSB0aGlzLl9hbmltYXRpb25RdWV1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkQ291bnQgPiByZW1vdmVDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbUFkZENvdW50ID0gYWRkQ291bnQgLSByZW1vdmVDb3VudCwgYW5pbWF0aW9uQ291bnQgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkNvdW50ID0gYWRkQ291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uTGVuZ3RoID0gYW5pbWF0aW9uUXVldWUubGVuZ3RoLCBzdGFydEluZGV4ID0gY2hhbmdlLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRMZW5ndGggPCBhZGRDb3VudCAtIHN0YXJ0SW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25Db3VudCA9IGN1cnJlbnRMZW5ndGggLSBzdGFydEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZUl0ZW1zKHN0YXJ0SW5kZXgsIGFuaW1hdGlvbkNvdW50LCBfX0VudGVyLCBudWxsLCBhbmltYXRpb25MZW5ndGggPiAwICYmIGFuaW1hdGlvblF1ZXVlW2FuaW1hdGlvbkxlbmd0aCAtIDFdLm9wID09PSAnY2xvbmUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkNvdW50ID0gYWRkQ291bnQgLSBhbmltYXRpb25Db3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkNvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRQcm9taXNlID0gdGhpcy5fYWRkSXRlbXMoY2hhbmdlLm9iamVjdC5sZW5ndGggLSBpdGVtQWRkQ291bnQsIGl0ZW1BZGRDb3VudCwgYW5pbWF0aW9uQ291bnQpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYWRkUXVldWUuaW5kZXhPZihhZGRQcm9taXNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRRdWV1ZS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUXVldWUucHVzaChhZGRQcm9taXNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVtb3ZlQ291bnQgPiBhZGRDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWRkaW5nXzEgPSBhZGRDb3VudCA+IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRpbmcgJiYgIWFkZGluZ18xICYmIGFkZFF1ZXVlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUXVldWUgPSBhZGRRdWV1ZS5jb25jYXQoW3RoaXMuX2FuaW1hdGVJdGVtcyhjaGFuZ2UuaW5kZXgsIHJlbW92ZUNvdW50LCBfX0xlYXZlLCAnY2xvbmUnLCB0cnVlKV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWxldGVDb3VudF8xID0gcmVtb3ZlQ291bnQgLSBhZGRDb3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRMZW5ndGggPj0gZGVsZXRlQ291bnRfMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXRlbUxlbmd0aCAtPSBkZWxldGVDb3VudF8xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXRlbUxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fUHJvbWlzZS5hbGwoYWRkUXVldWUpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGluZyAmJiBhZGRpbmdfMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbmltTGVuZ3RoID0gYW5pbWF0aW9uUXVldWUubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hbmltYXRlSXRlbXMoY2hhbmdlLmluZGV4LCBhZGRDb3VudCwgX19FbnRlciwgbnVsbCwgYW5pbUxlbmd0aCA+IDAgJiYgYW5pbWF0aW9uUXVldWVbYW5pbUxlbmd0aCAtIDFdLm9wID09PSAnY2xvbmUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZW1vdmVJdGVtcyhjdXJyZW50TGVuZ3RoIC0gZGVsZXRlQ291bnRfMSwgZGVsZXRlQ291bnRfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdyYWJzIHRoZSB0b3RhbCBibG9ja2xlbmd0aCBvZiB0aGUgc3BlY2lmaWVkIGl0ZW1zLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggVGhlIHN0YXJ0aW5nIGluZGV4IG9mIGl0ZW1zLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlck9mSXRlbXMgVGhlIG51bWJlciBvZiBjb25zZWN1dGl2ZSBpdGVtcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgRm9yRWFjaC5wcm90b3R5cGUuX2NhbGN1bGF0ZUJsb2NrTGVuZ3RoID0gZnVuY3Rpb24gKHN0YXJ0SW5kZXgsIG51bWJlck9mSXRlbXMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYmxvY2tMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBbmltYXRlcyB0aGUgaW5kaWNhdGVkIGl0ZW1zLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggVGhlIHN0YXJ0aW5nIGluZGV4IG9mIGl0ZW1zIHRvIGFuaW1hdGUuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyT2ZJdGVtcyBUaGUgbnVtYmVyIG9mIGNvbnNlY3V0aXZlIGl0ZW1zIHRvIGFuaW1hdGUuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBhbmltYXRpb24ga2V5L3R5cGUuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uT3AgRGVub3RlcyBhbmltYXRpb24gb3BlcmF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBjYW5jZWwgV2hldGhlciBvciBub3QgdG8gY2FuY2VsIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBiZWZvcmUgYmVnaW5uaW5nIHRoaXMgb25lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBGb3JFYWNoLnByb3RvdHlwZS5fYW5pbWF0ZUl0ZW1zID0gZnVuY3Rpb24gKHN0YXJ0SW5kZXgsIG51bWJlck9mSXRlbXMsIGtleSwgYW5pbWF0aW9uT3AsIGNhbmNlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBibG9ja0xlbmd0aCA9IHRoaXMuX2NhbGN1bGF0ZUJsb2NrTGVuZ3RoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrTGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gc3RhcnRJbmRleCAqIGJsb2NrTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYW5pbWF0aW9uT3ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2xvbmUnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUNsb25lZENvbnRhaW5lckFuaW1hdGlvbihzdGFydCwgbnVtYmVyT2ZJdGVtcyAqIGJsb2NrTGVuZ3RoICsgc3RhcnQsIGtleSwgY2FuY2VsID09PSB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbGVhdmUnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUxlYXZlKHN0YXJ0LCBudW1iZXJPZkl0ZW1zICogYmxvY2tMZW5ndGggKyBzdGFydCwga2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVTaW1wbGVBbmltYXRpb24oc3RhcnQsIG51bWJlck9mSXRlbXMgKiBibG9ja0xlbmd0aCArIHN0YXJ0LCBrZXksIGNhbmNlbCA9PT0gdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogSGFuZGxlcyBhIHNpbXBsZSBhbmltYXRpb24gb2YgYSBibG9jayBvZiBlbGVtZW50cy5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydE5vZGUgVGhlIHN0YXJ0aW5nIGNoaWxkTm9kZSBvZiB0aGUgRm9yRWFjaCB0byBhbmltYXRlLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZE5vZGUgVGhlIGVuZGluZyBjaGlsZE5vZGUgb2YgdGhlIEZvckVhY2ggdG8gYW5pbWF0ZS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGFuaW1hdGlvbiBrZXkvdHlwZS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2FuY2VsIFdoZXRoZXIgb3Igbm90IHRvIGNhbmNlbCB0aGUgY3VycmVudCBhbmltYXRpb24gYmVmb3JlIGJlZ2lubmluZyB0aGlzIG9uZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgRm9yRWFjaC5wcm90b3R5cGUuX2hhbmRsZVNpbXBsZUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChzdGFydE5vZGUsIGVuZE5vZGUsIGtleSwgY2FuY2VsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciwgbm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjb250YWluZXIuY2hpbGROb2Rlcywgc3RhcnROb2RlLCBlbmROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvblF1ZXVlID0gdGhpcy5fYW5pbWF0aW9uUXVldWUsIGFuaW1hdGlvbkNyZWF0aW9uID0gdGhpcy5fYW5pbWF0b3IuY3JlYXRlKG5vZGVzLCBrZXkpLCBhbmltYXRpb25Qcm9taXNlID0gYW5pbWF0aW9uQ3JlYXRpb24uY3VycmVudC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYW5pbWF0aW9uUXVldWUuaW5kZXhPZihhbmltYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uUXVldWUuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9KSwgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkNyZWF0aW9uLnByZXZpb3VzLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uUHJvbWlzZS5zdGFydCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGlvblByb21pc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb246IGFuaW1hdGlvblByb21pc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wOiBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuY2VsICYmIGFuaW1hdGlvblF1ZXVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbmNlbFByb21pc2UgPSB0aGlzLl9jYW5jZWxDdXJyZW50QW5pbWF0aW9ucygpLnRoZW4oY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25RdWV1ZS5wdXNoKGFuaW1hdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYW5jZWxQcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25RdWV1ZS5wdXNoKGFuaW1hdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBIYW5kbGVzIGEgc2ltcGxlIGFuaW1hdGlvbiBvZiBhIGJsb2NrIG9mIGVsZW1lbnRzLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0Tm9kZSBUaGUgc3RhcnRpbmcgY2hpbGROb2RlIG9mIHRoZSBGb3JFYWNoIHRvIGFuaW1hdGUuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kTm9kZSBUaGUgZW5kaW5nIGNoaWxkTm9kZSBvZiB0aGUgRm9yRWFjaCB0byBhbmltYXRlLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgYW5pbWF0aW9uIGtleS90eXBlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBGb3JFYWNoLnByb3RvdHlwZS5faGFuZGxlTGVhdmUgPSBmdW5jdGlvbiAoc3RhcnROb2RlLCBlbmROb2RlLCBrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyLCBub2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNvbnRhaW5lci5jaGlsZE5vZGVzLCBzdGFydE5vZGUsIGVuZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uUXVldWUgPSB0aGlzLl9hbmltYXRpb25RdWV1ZSwgYW5pbWF0aW9uUHJvbWlzZSA9IHRoaXMuX2FuaW1hdG9yLmxlYXZlKG5vZGVzLCBrZXkpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBhbmltYXRpb25RdWV1ZS5pbmRleE9mKGFuaW1hdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25RdWV1ZS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb24gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogYW5pbWF0aW9uUHJvbWlzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3A6ICdsZWF2ZSdcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvblF1ZXVlLnB1c2goYW5pbWF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uUHJvbWlzZTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEhhbmRsZXMgYSBzaW1wbGUgYW5pbWF0aW9uIG9mIGEgYmxvY2sgb2YgZWxlbWVudHMuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnROb2RlIFRoZSBzdGFydGluZyBjaGlsZE5vZGUgb2YgdGhlIEZvckVhY2ggdG8gYW5pbWF0ZS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmROb2RlIFRoZSBlbmRpbmcgY2hpbGROb2RlIG9mIHRoZSBGb3JFYWNoIHRvIGFuaW1hdGUuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBhbmltYXRpb24ga2V5L3R5cGUuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNhbmNlbCBXaGV0aGVyIG9yIG5vdCB0byBjYW5jZWwgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGJlZm9yZSBiZWdpbm5pbmcgdGhpcyBvbmUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEZvckVhY2gucHJvdG90eXBlLl9oYW5kbGVDbG9uZWRDb250YWluZXJBbmltYXRpb24gPSBmdW5jdGlvbiAoc3RhcnROb2RlLCBlbmROb2RlLCBrZXksIGNhbmNlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIsIGNsb25lZENvbnRhaW5lciA9IGNvbnRhaW5lci5jbG9uZU5vZGUodHJ1ZSksIG5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY2xvbmVkQ29udGFpbmVyLmNoaWxkTm9kZXMsIHN0YXJ0Tm9kZSwgZW5kTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlLCBhbmltYXRpb25RdWV1ZSA9IHRoaXMuX2FuaW1hdGlvblF1ZXVlLCBhbmltYXRpb25DcmVhdGlvbiA9IHRoaXMuX2FuaW1hdG9yLmNyZWF0ZShub2Rlcywga2V5KSwgYW5pbWF0aW9uUHJvbWlzZSA9IGFuaW1hdGlvbkNyZWF0aW9uLmN1cnJlbnQudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGFuaW1hdGlvblF1ZXVlLmluZGV4T2YoYW5pbWF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvblF1ZXVlLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChwYXJlbnROb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGNvbnRhaW5lciwgY2xvbmVkQ29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9KSwgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBjb250YWluZXIucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChwYXJlbnROb2RlKSB8fCBhbmltYXRpb25Qcm9taXNlLmlzQ2FuY2VsZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGlvblByb21pc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoY2xvbmVkQ29udGFpbmVyLCBjb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25DcmVhdGlvbi5wcmV2aW91cy50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvblByb21pc2Uuc3RhcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhbmltYXRpb25Qcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uOiBhbmltYXRpb25Qcm9taXNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcDogJ2Nsb25lJ1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbmNlbCAmJiBhbmltYXRpb25RdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYW5jZWxQcm9taXNlID0gdGhpcy5fY2FuY2VsQ3VycmVudEFuaW1hdGlvbnMoKS50aGVuKGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uUXVldWUucHVzaChhbmltYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FuY2VsUHJvbWlzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uUXVldWUucHVzaChhbmltYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ2FuY2VscyBhbGwgY3VycmVudCBhbmltYXRpb25zLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBGb3JFYWNoLnByb3RvdHlwZS5fY2FuY2VsQ3VycmVudEFuaW1hdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvblF1ZXVlID0gdGhpcy5fYW5pbWF0aW9uUXVldWUsIGFuaW1hdGlvbnMgPSBbXSwgbGVuZ3RoID0gYW5pbWF0aW9uUXVldWUubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvblF1ZXVlW2ldLmFuaW1hdGlvbi5jYW5jZWwoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLmFsbChhbmltYXRpb25zKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBGb3JFYWNoLl9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2FuaW1hdG9yOiBfX0FuaW1hdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIF9Qcm9taXNlOiBfX1Byb21pc2VcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRm9yRWFjaDtcclxuICAgICAgICAgICAgfShUZW1wbGF0ZUNvbnRyb2wpKTtcclxuICAgICAgICAgICAgY29udHJvbHNfMS5Gb3JFYWNoID0gRm9yRWFjaDtcclxuICAgICAgICAgICAgcmVnaXN0ZXIuY29udHJvbChfX0ZvckVhY2gsIEZvckVhY2gpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBzcGVjaWFsIHR5cGUgb2YgVGVtcGxhdGVDb250cm9sIGZvciBtYW5hZ2luZyBtZXRhIHRhZ3MsIHVzZWZ1bCBmb3IgU0VPLiBUaGlzXHJcbiAgICAgICAgICAgICAqIGNvbnRyb2wgd2lsbCBub3QgZXhpc3QgdW5sZXNzIHlvdSByZWdpc3RlciBpdCBhcyBhIGNvbnRyb2wgd2l0aCB0aGUgbmFtZSAnaGVhZCcuIEl0IGlzIHN0YXRpYywgc28geW91IGNhbiBpbmplY3RcclxuICAgICAgICAgICAgICogaXQgaW50byBvdGhlciBjb21wb25lbnRzIGFuZCBnZXQgYWNjZXNzIHRvIGl0cyBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIEhlYWQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICAgICAgX19leHRlbmRzKEhlYWQsIF9zdXBlcik7XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBIZWFkKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFJhdGhlciB0aGFuIGJlIHJlcGxhY2VkIGJ5IGEgJ2RpdicsIHRoaXMgY29udHJvbCB3YW50cyB0byBiZSBhICdoZWFkJyBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZVdpdGggPSBfX0hlYWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQSByZWZlcmVuY2UgdG8gYWxsIHRoZSBzdHJ1Y3R1cmVkIGRhdGEgZWxlbWVudHMgYWRkZWQgdG8gdGhlIERPTSBmb3IgdGhpcyBwYWdlLlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0cnVjdHVyZWREYXRhRWxlbWVudHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVnaXN0ZXJzIGZvciB0aGUgbmF2aWdhdGluZyBldmVudCB0byBrbm93IHdoZW4gdG8gcmVtb3ZlIGFsbCB0aGUgZWxlbWVudHMgc28gdGhleVxyXG4gICAgICAgICAgICAgICAgICogZG9uJ3QgYmxlZWQgb250byB0aGUgbmV4dCBwYWdlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBIZWFkLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbihfX25hdmlnYXRpbmcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlbW92ZUFsbEVsZW1lbnRzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBNYWtlcyBzdXJlIGFsbCB0aGUgZWxlbWVudHMgZXhpc3QuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEhlYWQucHJvdG90eXBlLnNldFRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXRhID0gX19NZXRhLCB0aXRsZSA9IF9fVGl0bGUsIGxpbmsgPSBfX01ldGFMaW5rLCBhdXRob3IgPSBfX0F1dGhvciwgdHlwZSA9IF9fTWV0YVR5cGUsIGNyZWF0b3IgPSBfX0NyZWF0b3IsIGltYWdlID0gX19NZXRhSW1hZ2UsIHZpZGVvID0gX19NZXRhVmlkZW8sIGRlc2NyaXB0aW9uID0gX19EZXNjcmlwdGlvbiwgdXJsID0gX19VcmwsIG9nID0gX19PcGVuR3JhcGgsIGFydGljbGUgPSBfX0FydGljbGUsIHR3aXR0ZXIgPSBfX1R3aXR0ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGl0bGVFbGVtZW50ID0gdGhpcy5fY3JlYXRlRWxlbWVudCh0aXRsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2dUaXRsZUVsZW1lbnQgPSB0aGlzLl9jcmVhdGVFbGVtZW50KG1ldGEsIG9nICsgdGl0bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3R3aXR0ZXJUaXRsZUVsZW1lbnQgPSB0aGlzLl9jcmVhdGVFbGVtZW50KG1ldGEsIHR3aXR0ZXIgKyB0aXRsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVzY3JpcHRpb25FbGVtZW50ID0gdGhpcy5fY3JlYXRlRWxlbWVudChtZXRhLCBkZXNjcmlwdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2dEZXNjcmlwdGlvbkVsZW1lbnQgPSB0aGlzLl9jcmVhdGVFbGVtZW50KG1ldGEsIG9nICsgZGVzY3JpcHRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3R3aXR0ZXJEZXNjcmlwdGlvbkVsZW1lbnQgPSB0aGlzLl9jcmVhdGVFbGVtZW50KG1ldGEsIHR3aXR0ZXIgKyBkZXNjcmlwdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2dVcmxFbGVtZW50ID0gdGhpcy5fY3JlYXRlRWxlbWVudChtZXRhLCBvZyArIHVybCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHdpdHRlclVybEVsZW1lbnQgPSB0aGlzLl9jcmVhdGVFbGVtZW50KG1ldGEsIHR3aXR0ZXIgKyB1cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1dGhvckVsZW1lbnQgPSB0aGlzLl9jcmVhdGVFbGVtZW50KG1ldGEsIGF1dGhvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ29vZ2xlQXV0aG9yRWxlbWVudCA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQobGluaywgYXV0aG9yKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mYkF1dGhvckVsZW1lbnQgPSB0aGlzLl9jcmVhdGVFbGVtZW50KG1ldGEsIGFydGljbGUgKyBhdXRob3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3R3aXR0ZXJDcmVhdG9yRWxlbWVudCA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQobWV0YSwgdHdpdHRlciArIGNyZWF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29nVHlwZUVsZW1lbnQgPSB0aGlzLl9jcmVhdGVFbGVtZW50KG1ldGEsIG9nICsgdHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSB0aXRsZSBvciBzZXRzIHRoZSB0aXRsZSBlbGVtZW50cy5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZT8gSWYgc3VwcGxpZWQsIHRoZSB0aXRsZSBlbGVtZW50cyB3aWxsIGJlIHNldCB0byB0aGlzIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBIZWFkLnByb3RvdHlwZS50aXRsZSA9IGZ1bmN0aW9uICh0aXRsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNTdHJpbmcodGl0bGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRDb250ZW50KHRoaXMuX3RpdGxlRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpdGxlRWxlbWVudC5pbm5lclRleHQgPSB0aXRsZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRDb250ZW50KFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2dUaXRsZUVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3R3aXR0ZXJUaXRsZUVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICBdLCB0aXRsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpdGxlO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR2V0cyB0aGUgZGVzY3JpcHRpb24gb3Igc2V0cyB0aGUgZGVzY3JpcHRpb24gZWxlbWVudHMuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGVzY3JpcHRpb24/IElmIHN1cHBsaWVkLCB0aGUgZGVzY3JpcHRpb24gZWxlbWVudHMgd2lsbCBiZSBzZXQgdG8gdGhpcyB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgSGVhZC5wcm90b3R5cGUuZGVzY3JpcHRpb24gPSBmdW5jdGlvbiAoZGVzY3JpcHRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzU3RyaW5nKGRlc2NyaXB0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q29udGVudCh0aGlzLl9kZXNjcmlwdGlvbkVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRDb250ZW50KFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVzY3JpcHRpb25FbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vZ0Rlc2NyaXB0aW9uRWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHdpdHRlckRlc2NyaXB0aW9uRWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIF0sIGRlc2NyaXB0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRpb247XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSB1cmwgb3Igc2V0cyB0aGUgdXJsIGVsZW1lbnRzLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVybD8gSWYgc3VwcGxpZWQsIHRoZSB1cmwgZWxlbWVudHMgd2lsbCBiZSBzZXQgdG8gdGhpcyB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgSGVhZC5wcm90b3R5cGUudXJsID0gZnVuY3Rpb24gKHVybCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNTdHJpbmcodXJsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q29udGVudCh0aGlzLl9vZ1VybEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRDb250ZW50KFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2dVcmxFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90d2l0dGVyVXJsRWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIF0sIHVybCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVybDtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIGF1dGhvciBvciBzZXRzIHRoZSBhdXRob3IgZWxlbWVudHMuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXV0aG9yPyBJZiBzdXBwbGllZCwgdGhlIGF1dGhvciBlbGVtZW50cyB3aWxsIGJlIHNldCB0byB0aGlzIHZhbHVlLiBUaGUgdmFsdWUgc2hvdWxkIGJlIHRoZVxyXG4gICAgICAgICAgICAgICAgICogZGlzcGxheSBuYW1lIG9mIHRoZSBjb250ZW50IGF1dGhvci5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgSGVhZC5wcm90b3R5cGUuYXV0aG9yID0gZnVuY3Rpb24gKGF1dGhvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNTdHJpbmcoYXV0aG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q29udGVudCh0aGlzLl9hdXRob3JFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0Q29udGVudChbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1dGhvckVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgXSwgYXV0aG9yKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXV0aG9yO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR2V0cyB0aGUgYXV0aG9yIG9yIHNldHMgdGhlIGF1dGhvciBlbGVtZW50cy5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdXRob3I/IElmIHN1cHBsaWVkLCB0aGUgYXV0aG9yIGVsZW1lbnRzIHdpbGwgYmUgc2V0IHRvIHRoaXMgdmFsdWUuIFRoZSB2YWx1ZSBzaG91bGQgYmUgdGhlXHJcbiAgICAgICAgICAgICAgICAgKiBHb29nbGUrIHByb2ZpbGUgdXJsIGZvciB0aGUgYXV0aG9yLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBIZWFkLnByb3RvdHlwZS5nb29nbGVBdXRob3IgPSBmdW5jdGlvbiAoYXV0aG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1N0cmluZyhhdXRob3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRDb250ZW50KHRoaXMuX2dvb2dsZUF1dGhvckVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRDb250ZW50KFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ29vZ2xlQXV0aG9yRWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICBdLCBhdXRob3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdXRob3I7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSBhdXRob3Igb3Igc2V0cyB0aGUgYXV0aG9yIGVsZW1lbnRzLiBUaGlzIG1ldGhvZCBpcyBmb3IgdXNlIHdpdGggdGhlIEZhY2Vib29rIHByb2ZpbGUgYXV0aG9ycy5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdXRob3I/IElmIHN1cHBsaWVkLCB0aGUgYXV0aG9yIGVsZW1lbnRzIHdpbGwgYmUgc2V0IHRvIHRoaXMgdmFsdWUuIFRoZSB2YWx1ZSBzaG91bGQgYmVcclxuICAgICAgICAgICAgICAgICAqIHRoZSBgaHR0cHM6Ly93d3cuZmFjZWJvb2suY29tL3VzZXJuYW1lYCBhY2NvdW50LCBhbmQgbWFrZSBzdXJlIHRoZSB1c2VyIHN1cHBvcnRzIGZvbGxvd2Vycy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgSGVhZC5wcm90b3R5cGUuZmJBdXRob3IgPSBmdW5jdGlvbiAoYXV0aG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1N0cmluZyhhdXRob3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRDb250ZW50KHRoaXMuX2ZiQXV0aG9yRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldENvbnRlbnQoW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mYkF1dGhvckVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICBdLCBhdXRob3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdXRob3I7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSBjcmVhdG9yIG9yIHNldHMgdGhlIGNyZWF0b3IgZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjcmVhdG9yPyBJZiBzdXBwbGllZCwgdGhlIGNyZWF0b3IgZWxlbWVudHMgd2lsbCBiZSBzZXQgdG8gdGhpcyB2YWx1ZS4gVGhlXHJcbiAgICAgICAgICAgICAgICAgKiB2YWx1ZSBzaG91bGQgYmUgdGhlIHR3aXR0ZXIgYEB1c2VybmFtZWAgb2YgdGhlIGNyZWF0b3JcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgSGVhZC5wcm90b3R5cGUudHdpdHRlckNyZWF0b3IgPSBmdW5jdGlvbiAoY3JlYXRvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNTdHJpbmcoY3JlYXRvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENvbnRlbnQodGhpcy5fdHdpdHRlckNyZWF0b3JFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0Q29udGVudChbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3R3aXR0ZXJDcmVhdG9yRWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIF0sIGNyZWF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdG9yO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR2V0cyB0aGUgdHlwZSBvciBzZXRzIHRoZSB0eXBlIGVsZW1lbnRzLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGU/IElmIHN1cHBsaWVkLCB0aGUgaW1hZ2UgZWxlbWVudHMgd2lsbCBiZSBzZXQgdG8gdGhpcyB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgSGVhZC5wcm90b3R5cGUuZmJUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzU3RyaW5nKHR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRDb250ZW50KHRoaXMuX29nVHlwZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRDb250ZW50KFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2dUeXBlRWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIF0sIHR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogU2V0cyB0aGUgaW1hZ2UgZWxlbWVudHMuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGltYWdlcyBGb3IgZWFjaCBpbWFnZSwgYSB0YWcgd2lsbCBiZSBjcmVhdGVkXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEhlYWQucHJvdG90eXBlLmltYWdlcyA9IGZ1bmN0aW9uIChpbWFnZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNBcnJheShpbWFnZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGEgPSBfX01ldGEsIG9nID0gX19PcGVuR3JhcGgsIHR3aXR0ZXIgPSBfX1R3aXR0ZXIsIG9nRWxlbWVudCwgdHdpdHRlckVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yRWFjaChmdW5jdGlvbiAoaW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2dFbGVtZW50ID0gX3RoaXMuX2NyZWF0ZUVsZW1lbnQobWV0YSwgb2cgKyBfX01ldGFJbWFnZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR3aXR0ZXJFbGVtZW50ID0gX3RoaXMuX2NyZWF0ZUVsZW1lbnQobWV0YSwgdHdpdHRlciArIF9fTWV0YUltYWdlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UgPSBfdGhpcy5fYnJvd3Nlci51cmxVdGlscyhpbWFnZSkuaHJlZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3NldENvbnRlbnQoW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2dFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHdpdHRlckVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgXSwgaW1hZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIGltYWdlcyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTZXRzIHRoZSB2aWRlbyBlbGVtZW50cy5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gdmlkZW9zIEZvciBlYWNoIHZpZGVvLCBhIHRhZyB3aWxsIGJlIGNyZWF0ZWRcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgSGVhZC5wcm90b3R5cGUudmlkZW9zID0gZnVuY3Rpb24gKHZpZGVvcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KHZpZGVvcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0YSA9IF9fTWV0YSwgb2cgPSBfX09wZW5HcmFwaCwgbWV0YVZpZGVvID0gX19NZXRhVmlkZW8sIF9icm93c2VyID0gdGhpcy5fYnJvd3Nlciwgb2dFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGZvckVhY2goZnVuY3Rpb24gKHZpZGVvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9nRWxlbWVudCA9IF90aGlzLl9jcmVhdGVFbGVtZW50KG1ldGEsIG9nICsgbWV0YVZpZGVvLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW8gPSBfYnJvd3Nlci51cmxVdGlscyh2aWRlbykuaHJlZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3NldENvbnRlbnQoW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2dFbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sIHZpZGVvKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCB2aWRlb3MpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQWRkcyBhIHN0cnVjdHVyZWQgZGF0YSBsZCtqc29uIGVsZW1lbnQgdG8gdGhlIERPTS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBUaGUgb2JqZWN0LCBpdCB3aWxsIGJlIHN0cmluZ2lmaWVkIGFuZCBwdXQgaW4gdGhlIGxkK2pzb24gdGFnLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBIZWFkLnByb3RvdHlwZS5zdHJ1Y3R1cmVkRGF0YSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShvYmopKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JyksIHNpYmxpbmcgPSB0aGlzLl90aXRsZUVsZW1lbnQubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2FwcGxpY2F0aW9uL2xkK2pzb24nKTtcclxuICAgICAgICAgICAgICAgICAgICBlbC50ZXh0Q29udGVudCA9IEpTT04uc3RyaW5naWZ5KG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RydWN0dXJlZERhdGFFbGVtZW50cy5wdXNoKGVsKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5pbnNlcnRCZWZvcmUodGhpcy5lbGVtZW50LCBlbCwgc2libGluZyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUYWtlcyBpbiBvbmUgb3IgbW9yZSBCbG9nUG9zdGluZyA8aHR0cDovL3NjaGVtYS5vcmcvQmxvZ1Bvc3Rpbmc+IG9iamVjdHMgYW5kIHNldHMgdGhlbSBhcyBsZCtqc29uIHRhZ3MgaW4gdGhlIGhlYWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuY29udHJvbHMuSUJsb2dQb3N0aW5nfSBUaGUgcG9zdGluZyBvYmplY3QsIGl0IHdpbGwgYmUgc3RyaW5naWZpZWQgYW5kIHB1dCBpbiB0aGUgbGQranNvbiB0YWcuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEhlYWQucHJvdG90eXBlLmJsb2dQb3N0aW5ncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zdGluZ3MgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0aW5nc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF8xMSA9IHBvc3RpbmdzLmxlbmd0aDsgaSA8IGxlbmd0aF8xMTsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RydWN0dXJlZERhdGEocG9zdGluZ3NbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNldHMgdGhlIHVybCBlbGVtZW50cyBpbml0aWFsbHkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEhlYWQucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVybCh0aGlzLl9icm93c2VyLnVybCgpKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNldHMgdGhlIHVybCBlbGVtZW50cy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgSGVhZC5wcm90b3R5cGUubmF2aWdhdGVkID0gZnVuY3Rpb24gKHVybCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXJsKHVybCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSBpbm5lclRleHQvY29udGVudC9ocmVmIG9mIGFuIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IGZyb20gd2hpY2ggdG8gZ2V0IHRoZSBjb250ZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBIZWFkLnByb3RvdHlwZS5fZ2V0Q29udGVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlTmFtZSA9PT0gX19UaXRsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5pbm5lclRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGVOYW1lID09PSBfX01ldGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKF9fQ29udGVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGVOYW1lID09PSBfX01ldGFMaW5rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShfX01ldGFIcmVmKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTZXRzIHRoZSBpbm5lclRleHQvY29udGVudC9ocmVmIG9mIGEgbGlzdCBlbGVtZW50cy4gSWYgYW4gZWxlbWVudCBpcyBub3QgaW4gdGhlIERPTSwgaXRcclxuICAgICAgICAgICAgICAgICAqIGlzIGFkZGVkIHRvIHRoZSBkb20gcmlnaHQgYWZ0ZXIgdGhlIDx0aXRsZSAvPiBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxIVE1MRWxlbWVudD59IGVsZW1lbnRzIFRoZSBlbGVtZW50cyBmb3Igd2hpY2ggdG8gc2V0IHZhbHVlcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgSGVhZC5wcm90b3R5cGUuX3NldENvbnRlbnQgPSBmdW5jdGlvbiAoZWxlbWVudHMsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5lbGVtZW50LCBub2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGVsLmNoaWxkcmVuKSwgbGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoLCBjb250ZW50ID0gX19Db250ZW50LCBocmVmID0gX19NZXRhSHJlZiwgc2libGluZyA9IHRoaXMuX3RpdGxlRWxlbWVudC5uZXh0U2libGluZywgZG9tID0gdGhpcy5kb20sIG5vZGVOYW1lLCBlbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09PSBfX01ldGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGNvbnRlbnQsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGhyZWYsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZXMuaW5kZXhPZihlbGVtZW50KSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbS5pbnNlcnRCZWZvcmUoZWwsIGVsZW1lbnQsIHNpYmxpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ3JlYXRlcyBhbiBlbGVtZW50IHdpdGggdGhlIHNwZWNpZmllZCB0YWcgYW5kIG5hbWUuIFRoZSBuYW1lIGNvcnJlc3BvbmRzIHRvXHJcbiAgICAgICAgICAgICAgICAgKiB0aGUgdHlwZSBvZiB0aGUgbWV0YS9saW5rIHRhZyAoaS5lLiB0aXRsZS9kZXNjcmlwdGlvbi9hdXRob3IgZXRjKSwgYW5kIGlzIGFsc28gdGhlXHJcbiAgICAgICAgICAgICAgICAgKiB2YWx1ZSB0aGF0IHdpbGwgYmUgc2V0IGZvciB0aGUgcHJvcGVyIGF0dHJpYnV0ZS4gVGhlIGF0dHJpYnV0ZSBpcyBkZXRlcm1pbmVkIGJhc2VkIG9uXHJcbiAgICAgICAgICAgICAgICAgKiB0aGUgdGFnL25hbWUgY29tYmluYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSB0YWcgbmFtZSBmb3IgdGhlIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZT8gVGhlIG5hbWUgY29ycmVzcG9uZGluZyB0byB0aGUgdHlwZSBvZiBtZXRhL2xpbmsgdGFnLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBsZT8gV2hldGhlciBvciBub3QgdGhlcmUgY2FuIGJlIG11bHRpcGxlIG9mIHRoaXMgdGFnL25hbWUgaW4gdGhlIGRvbVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBIZWFkLnByb3RvdHlwZS5fY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICh0YWcsIG5hbWUsIG11bHRpcGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsLCBoYXNOYW1lID0gaXNTdHJpbmcobmFtZSksIGF0dHIgPSAoaGFzTmFtZSAmJiAobmFtZS5pbmRleE9mKF9fT3BlbkdyYXBoKSA9PT0gMCB8fCBuYW1lLmluZGV4T2YoX19BcnRpY2xlKSA9PT0gMCkpID8gX19NZXRhUHJvcGVydHkgOiBfX01ldGFOYW1lLCBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgPT09IF9fTWV0YUxpbmspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ciA9IF9fUmVsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW11bHRpcGxlICYmIGhhc05hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IodGFnICsgJ1snICsgYXR0ciArICc9XCInICsgbmFtZSArICdcIl0nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIW11bHRpcGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKHRhZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbCA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc05hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHIsIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWw7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZW1vdmVzIGFsbCB0aGUgdW5uZWNlc3NhcnkgZWxlbWVudHMgZnJvbSB0aGUgPGhlYWQgLz4gdG8gYXZvaWQgaGF2aW5nXHJcbiAgICAgICAgICAgICAgICAgKiBpbmNvcnJlY3QgdGFncyBvbiB0aGUgcGFnZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgSGVhZC5wcm90b3R5cGUuX3JlbW92ZUFsbEVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZSwgb2cgPSB0aGlzLl9kb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3JBbGwoJ21ldGFbJyArIF9fTWV0YVByb3BlcnR5ICsgJ149XCInICsgX19PcGVuR3JhcGggKyAnXCJdJyksIHR3aXR0ZXIgPSB0aGlzLl9kb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3JBbGwoJ21ldGFbJyArIF9fTWV0YU5hbWUgKyAnXj1cIicgKyBfX1R3aXR0ZXIgKyAnXCJdJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlRWxlbWVudHMuYXBwbHkodGhpcywgW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZXNjcmlwdGlvbkVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1dGhvckVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dvb2dsZUF1dGhvckVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICBdLmNvbmNhdChzbGljZS5jYWxsKG9nKSwgc2xpY2UuY2FsbCh0d2l0dGVyKSwgc2xpY2UuY2FsbCh0aGlzLl9zdHJ1Y3R1cmVkRGF0YUVsZW1lbnRzKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0cnVjdHVyZWREYXRhRWxlbWVudHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlbW92ZXMgZWxlbWVudHMgZnJvbSB0aGUgPGhlYWQgLz5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgSGVhZC5wcm90b3R5cGUuX3JlbW92ZUVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmVsZW1lbnQsIG5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZWwuY2hpbGRyZW4pLCBsZW5ndGggPSBlbGVtZW50cy5sZW5ndGgsIGVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2Rlcy5pbmRleE9mKGVsZW1lbnQpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgSGVhZC5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIF9kb2N1bWVudDogX19Eb2N1bWVudCxcclxuICAgICAgICAgICAgICAgICAgICBfYnJvd3NlcjogX19Ccm93c2VyXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEhlYWQ7XHJcbiAgICAgICAgICAgIH0odWkuVGVtcGxhdGVDb250cm9sKSk7XHJcbiAgICAgICAgICAgIGNvbnRyb2xzXzEuSGVhZCA9IEhlYWQ7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIFRlbXBsYXRlQ29udHJvbCBmb3IgYWRkaW5nIEhUTUwgdG8gdGhlXHJcbiAgICAgICAgICAgICAqIERPTSB0aHJvdWdoIGJvdW5kIGNvbnRleHQgc3RyaW5ncy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBJbm5lckh0bWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICAgICAgX19leHRlbmRzKElubmVySHRtbCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIElubmVySHRtbCgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ2xlYXJzIHRoZSBpbm5lciB0ZW1wbGF0ZSBpZiBvbmUgZXhpc3RzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBJbm5lckh0bWwucHJvdG90eXBlLnNldFRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNsZWFyTm9kZSh0aGlzLmVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ2hlY2tzIG9wdGlvbnMgYW5kIGluaXRpYWxpemVzIGJpbmRpbmdzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBJbm5lckh0bWwucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzT2JqZWN0KG9wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25PcHRpb25zQ2hhbmdlZChvcHRpb25zLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9ic2VydmUodGhpcy5fb25PcHRpb25zQ2hhbmdlZCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgZnVuY3Rpb24gY2FsbGVkIHdoZW4gYW55IG9mIHRoZSBvcHRpb25zIGZvciB0aGlzIGNvbnRyb2wgY2hhbmdlcy5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7SUlubmVySHRtbE9wdGlvbnN9IG5ld1ZhbHVlIFRoZSBuZXcgdmFsdWUgb2YgdGhlIG9wdGlvbnMgcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0lJbm5lckh0bWxPcHRpb25zfSBvbGRWYWx1ZT8gVGhlIG9sZCB2YWx1ZSBvZiB0aGUgb3B0aW9ucyBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgSW5uZXJIdG1sLnByb3RvdHlwZS5fb25PcHRpb25zQ2hhbmdlZCA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNPYmplY3QobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZygncGxhdC1vcHRpb25zIGZvciAnICsgdGhpcy50eXBlICsgJyBtdXN0IGJlIGFuIG9iamVjdC4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaHRtbCA9IG5ld1ZhbHVlLmh0bWw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGh0bWwgPT09IHRoaXMuX2h0bWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9odG1sID0gaHRtbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaHRtbElzU3RyaW5nID0gaXNTdHJpbmcoaHRtbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChodG1sKSB8fCAoaHRtbElzU3RyaW5nICYmIGh0bWwudHJpbSgpID09PSAnJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fVGVtcGxhdGVDb250cm9sRmFjdG9yeS5kaXNwb3NlKHRoaXMuY29udHJvbHNbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uY2xlYXJOb2RlKHRoaXMuZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghaHRtbElzU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZygnVHJ5aW5nIHRvIGJpbmQgYSBub24tc3RyaW5nIHZhbHVlIHRvICcgKyB0aGlzLnR5cGUgKyAnLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5ld1ZhbHVlLmNvbXBpbGUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhc0NvbnRyb2xfMSA9IHRoaXMuY29udHJvbHMubGVuZ3RoID4gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iaW5kYWJsZVRlbXBsYXRlcy5vbmNlKGh0bWwpLnRoZW4oZnVuY3Rpb24gKHRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzQ29udHJvbF8xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX1RlbXBsYXRlQ29udHJvbEZhY3RvcnkuZGlzcG9zZShfdGhpcy5jb250cm9sc1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kb20uY2xlYXJOb2RlKF90aGlzLmVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZWxlbWVudC5pbnNlcnRCZWZvcmUodGVtcGxhdGUsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzZXRJbm5lckh0bWwodGhpcy5lbGVtZW50LCBodG1sKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBJbm5lckh0bWwuX2luamVjdCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBfVGVtcGxhdGVDb250cm9sRmFjdG9yeTogX19UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIElubmVySHRtbDtcclxuICAgICAgICAgICAgfShUZW1wbGF0ZUNvbnRyb2wpKTtcclxuICAgICAgICAgICAgY29udHJvbHNfMS5Jbm5lckh0bWwgPSBJbm5lckh0bWw7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19IdG1sLCBJbm5lckh0bWwpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBCaW5kQ29udHJvbCBmb3IgYmluZGluZyBhbiBIVE1MIHNlbGVjdCBlbGVtZW50XHJcbiAgICAgICAgICAgICAqIHRvIGFuIEFycmF5IGNvbnRleHQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgU2VsZWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgICAgIF9fZXh0ZW5kcyhTZWxlY3QsIF9zdXBlcik7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBjb25zdHJ1Y3RvciBmb3IgYSBTZWxlY3QuIENyZWF0ZXMgdGhlIGl0ZW1zTG9hZGVkIHByb21pc2UuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFNlbGVjdCgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFJlcGxhY2VzIHRoZSBgPHBsYXQtc2VsZWN0PmAgbm9kZSB3aXRoXHJcbiAgICAgICAgICAgICAgICAgICAgICogYSA8c2VsZWN0PiBub2RlLlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZVdpdGggPSAnc2VsZWN0JztcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBUaGUgbG9hZCBwcmlvcml0eSBvZiB0aGUgY29udHJvbCAobmVlZHMgdG8gbG9hZCBiZWZvcmUgYSBCaW5kIGNvbnRyb2wpLlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJpb3JpdHkgPSAxMjA7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQW4gb2JqZWN0IHRoYXQga2VlcHMgdHJhY2sgb2YgdW5pcXVlXHJcbiAgICAgICAgICAgICAgICAgICAgICogb3B0Z3JvdXBzLlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtc0xvYWRlZCA9IG5ldyB0aGlzLl9Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19yZXNvbHZlRm4gPSByZXNvbHZlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fX3JlamVjdEZuID0gcmVqZWN0O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKG5vb3ApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDcmVhdGVzIHRoZSBiaW5kYWJsZSBvcHRpb24gdGVtcGxhdGUgYW5kIGdyb3VwaW5nXHJcbiAgICAgICAgICAgICAgICAgKiB0ZW1wbGF0ZSBpZiBuZWNlc3NhcnkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFNlbGVjdC5wcm90b3R5cGUuc2V0VGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iaW5kYWJsZVRlbXBsYXRlcy5hZGQoJ29wdGlvbicsIHRoaXMuZWxlbWVudC5jaGlsZE5vZGVzKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyB8fCB7fSwgcGxhdE9wdGlvbnMgPSBvcHRpb25zLnZhbHVlIHx8IHt9LCBkZWZhdWx0T3B0aW9uVmFsdWVzID0gcGxhdE9wdGlvbnMuZGVmYXVsdDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QoZGVmYXVsdE9wdGlvblZhbHVlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRPcHRpb24gPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKSwgZGVmYXVsdFZhbHVlID0gZGVmYXVsdE9wdGlvblZhbHVlcy52YWx1ZSwgZGVmYXVsdFRleHRDb250ZW50ID0gZGVmYXVsdE9wdGlvblZhbHVlcy50ZXh0Q29udGVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdE9wdGlvbi52YWx1ZSA9IGlzVW5kZWZpbmVkKGRlZmF1bHRWYWx1ZSkgPyBkZWZhdWx0VGV4dENvbnRlbnQgOiBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb24udGV4dENvbnRlbnQgPSBpc1VuZGVmaW5lZChkZWZhdWx0VGV4dENvbnRlbnQpID8gZGVmYXVsdFZhbHVlIDogZGVmYXVsdFRleHRDb250ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuaW5zZXJ0QmVmb3JlKGRlZmF1bHRPcHRpb24sIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChwbGF0T3B0aW9ucy5ncm91cCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5fZ3JvdXAgPSBwbGF0T3B0aW9ucy5ncm91cCwgb3B0aW9uR3JvdXAgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRncm91cCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25Hcm91cC5sYWJlbCA9IF9fc3RhcnRTeW1ib2wgKyBncm91cCArIF9fZW5kU3ltYm9sO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJpbmRhYmxlVGVtcGxhdGVzLmFkZCgnZ3JvdXAnLCBvcHRpb25Hcm91cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzR3JvdXBlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc0dyb3VwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZS1vYnNlcnZlcyB0aGUgbmV3IGFycmF5IGNvbnRleHQgYW5kIG1vZGlmaWVzXHJcbiAgICAgICAgICAgICAgICAgKiB0aGUgb3B0aW9ucyBhY2NvcmRpbmdseS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gbmV3VmFsdWUgVGhlIG5ldyBhcnJheSBjb250ZXh0LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBvbGRWYWx1ZSBUaGUgb2xkIGFycmF5IGNvbnRleHQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFNlbGVjdC5wcm90b3R5cGUuY29udGV4dENoYW5nZWQgPSBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0VtcHR5KG9sZFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtc0xvYWRlZC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVtb3ZlSXRlbXMoX3RoaXMuY29udHJvbHMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzQXJyYXkobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0xlbmd0aCA9IGlzQXJyYXkobmV3VmFsdWUpID8gbmV3VmFsdWUubGVuZ3RoIDogMCwgb2xkTGVuZ3RoID0gaXNBcnJheShvbGRWYWx1ZSkgPyBvbGRWYWx1ZS5sZW5ndGggOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldExpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0xlbmd0aCA+IG9sZExlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRJdGVtcyhuZXdMZW5ndGggLSBvbGRMZW5ndGgsIG9sZExlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5ld0xlbmd0aCA8IG9sZExlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVJdGVtcyhvbGRMZW5ndGggLSBuZXdMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIE9ic2VydmVzIHRoZSBuZXcgYXJyYXkgY29udGV4dCBhbmQgYWRkc1xyXG4gICAgICAgICAgICAgICAgICogdGhlIG9wdGlvbnMgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFNlbGVjdC5wcm90b3R5cGUubG9hZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh0aGlzLl9pc0dyb3VwZWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zIHx8IHt9LCBwbGF0T3B0aW9ucyA9IG9wdGlvbnMudmFsdWUgfHwge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzR3JvdXBlZCA9ICFpc051bGwoKHRoaXMuX2dyb3VwID0gcGxhdE9wdGlvbnMuZ3JvdXApKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVmYXVsdE9wdGlvbiA9IHRoaXMuZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkoY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRJdGVtcyhjb250ZXh0Lmxlbmd0aCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0TGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlbW92ZXMgYW55IHBvdGVudGlhbGx5IGhlbGQgbWVtb3J5LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBTZWxlY3QucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudXRpbHMuaXNGdW5jdGlvbih0aGlzLl9fcmVqZWN0Rm4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19yZWplY3RGbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fcmVzb2x2ZUZuID0gdGhpcy5fX3JlamVjdEZuID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVmYXVsdE9wdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHRoaXMgY29udHJvbCB0byBvYnNlcnZlIGJvdGggdGhlIGJvdW5kIHByb3BlcnR5IGl0c2VsZiBhcyB3ZWxsIGFzXHJcbiAgICAgICAgICAgICAgICAgKiBwb3RlbnRpYWwgY2hpbGQgcHJvcGVydGllcyBpZiBiZWluZyBib3VuZCB0byBhbiBvYmplY3QuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQub2JzZXJ2YWJsZS5JSW1wbGVtZW50VHdvV2F5QmluZGluZ30gYmluZGVyIFRoZSBjb250cm9sIHRoYXQgZmFjaWxpdGF0ZXMgdGhlXHJcbiAgICAgICAgICAgICAgICAgKiBkYXRhYmluZGluZy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgU2VsZWN0LnByb3RvdHlwZS5vYnNlcnZlUHJvcGVydGllcyA9IGZ1bmN0aW9uIChiaW5kZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRlciA9IGJpbmRlcjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5tdWx0aXBsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGJpbmRlci5ldmFsdWF0ZSgpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dENoYW5nZWQoW10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRlci5vYnNlcnZlUHJvcGVydHkodGhpcy5fc2V0U2VsZWN0ZWRJbmRpY2VzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmluZGVyLm9ic2VydmVBcnJheUNoYW5nZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2V0U2VsZWN0ZWRJbmRpY2VzKGJpbmRlci5ldmFsdWF0ZSgpLCBudWxsLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5kZXIub2JzZXJ2ZVByb3BlcnR5KHRoaXMuX3NldFNlbGVjdGVkSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgJ2NoYW5nZScsIHRoaXMuX29ic2VydmVDaGFuZ2UsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFVwZGF0ZXMgdGhlIHNlbGVjdGVkIGluZGV4IGlmIGJvdW5kIHRvIGEgcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3VmFsdWUgVGhlIG5ldyB2YWx1ZSBvZiB0aGUgYm91bmQgcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBvZiB0aGUgYm91bmQgcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmllciBUaGUgY2hpbGQgaWRlbnRpZmllciBvZiB0aGUgYm91bmQgcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpcnN0VGltZT8gV2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSBiZWluZyBjYWxsZWQgYXMgYSBzZXR0ZXIuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFNlbGVjdC5wcm90b3R5cGUuX3NldFNlbGVjdGVkSW5kZXggPSBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlLCBpZGVudGlmaWVyLCBmaXJzdFRpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LCB2YWx1ZSA9IGVsZW1lbnQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0VGltZSA9PT0gdHJ1ZSB8fCAhdGhpcy5fZG9jdW1lbnQuYm9keS5jb250YWlucyhlbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtc0xvYWRlZC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKF90aGlzLl9iaW5kZXIuZXZhbHVhdGUoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW5wdXRDaGFuZ2VkKGVsZW1lbnQudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2VsZWN0ZWRJbmRleCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc1N0cmluZyhuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKG5ld1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvcGVydHlUeXBlID0gJ251bWJlcic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNCb29sZWFuKG5ld1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvcGVydHlUeXBlID0gJ2Jvb2xlYW4nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24obmV3VmFsdWUudG9TdHJpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmluZm8oJ1RyeWluZyB0byBiaW5kIHRoZSBpbnZhbGlkIHZhbHVlIFwiJyArIG5ld1ZhbHVlICsgJ1wiIHRvIGEgJyArIHRoaXMudHlwZSArICcuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbXNMb2FkZWQudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX2RvY3VtZW50LmJvZHkuY29udGFpbnMoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQudmFsdWUgPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnZhbHVlICE9PSBuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbnB1dENoYW5nZWQoX3RoaXMuX2Nhc3RWYWx1ZShlbGVtZW50LnZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC52YWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayB0byBtYWtlIHN1cmUgdGhlIHVzZXIgY2hhbmdlZCB0byBhIHZhbGlkIHZhbHVlIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWNvbmQgYm9vbGVhbiBhcmd1bWVudCBpcyBhbiBpZSBmaXggZm9yIGluY29uc2lzdGVuY3kgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnZhbHVlICE9PSBuZXdWYWx1ZSB8fCBlbGVtZW50LnNlbGVjdGVkSW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnNlbGVjdGVkSW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVXBkYXRlcyB0aGUgc2VsZWN0ZWQgaW5kZXggaWYgYm91bmQgdG8gYSBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gbmV3VmFsdWUgVGhlIG5ldyB2YWx1ZSBBcnJheSBvZiB0aGUgYm91bmQgcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgQXJyYXkgb2YgdGhlIGJvdW5kIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aWZpZXIgVGhlIGNoaWxkIGlkZW50aWZpZXIgb2YgdGhlIGJvdW5kIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmaXJzdFRpbWU/IFdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgYmVpbmcgY2FsbGVkIGFzIGEgc2V0dGVyLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBTZWxlY3QucHJvdG90eXBlLl9zZXRTZWxlY3RlZEluZGljZXMgPSBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlLCBpZGVudGlmaWVyLCBmaXJzdFRpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbXNMb2FkZWQudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gX3RoaXMuZWxlbWVudCwgb3B0aW9ucyA9IGVsZW1lbnQub3B0aW9ucywgbGVuZ3RoID0gaXNOdWxsKG9wdGlvbnMpID8gMCA6IG9wdGlvbnMubGVuZ3RoLCBvcHRpb24sIG51bGxWYWx1ZSA9IGlzTnVsbChuZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsVmFsdWUgfHwgIWlzQXJyYXkobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RUaW1lID09PSB0cnVlICYmIGlzTnVsbChfdGhpcy5fYmluZGVyLmV2YWx1YXRlKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW5wdXRDaGFuZ2VkKF90aGlzLl9nZXRTZWxlY3RlZFZhbHVlcygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVuc2VsZWN0cyB0aGUgb3B0aW9ucyB1bmxlc3MgYSBtYXRjaCBpcyBmb3VuZCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChsZW5ndGgtLSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24gPSBvcHRpb25zW2xlbmd0aF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFudWxsVmFsdWUgJiYgb3B0aW9uLnZhbHVlID09PSAnJyArIG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlLCBudW1iZXJWYWx1ZSwgaW5kZXgsIGhpZ2hlc3RJbmRleCA9IEluZmluaXR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobGVuZ3RoLS0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24gPSBvcHRpb25zW2xlbmd0aF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG9wdGlvbi52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZS5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyVmFsdWUgPSBOdW1iZXIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKG51bWJlclZhbHVlKSAmJiAoaW5kZXggPSBuZXdWYWx1ZS5pbmRleE9mKG51bWJlclZhbHVlKSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgaGlnaGVzdEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9wcm9wZXJ0eVR5cGUgPSAnbnVtYmVyJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaGVzdEluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgodmFsdWUgPT09ICd0cnVlJyAmJiAoaW5kZXggPSBuZXdWYWx1ZS5pbmRleE9mKHRydWUpKSAhPT0gLTEpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPT09ICdmYWxzZScgJiYgKGluZGV4ID0gbmV3VmFsdWUuaW5kZXhPZihmYWxzZSkpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGhpZ2hlc3RJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcHJvcGVydHlUeXBlID0gJ2Jvb2xlYW4nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdoZXN0SW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBGaXJlcyB0aGUgaW5wdXRDaGFuZ2VkIGV2ZW50IHdoZW4gdGhlIHNlbGVjdCdzIHZhbHVlIGNoYW5nZXMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFNlbGVjdC5wcm90b3R5cGUuX29ic2VydmVDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dENoYW5nZWQoZWxlbWVudC5tdWx0aXBsZSA/IHRoaXMuX2dldFNlbGVjdGVkVmFsdWVzKCkgOiB0aGlzLl9jYXN0VmFsdWUoZWxlbWVudC52YWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR2V0dGVyIGZvciBzZWxlY3QtbXVsdGlwbGUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFNlbGVjdC5wcm90b3R5cGUuX2dldFNlbGVjdGVkVmFsdWVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5lbGVtZW50Lm9wdGlvbnMsIGxlbmd0aCA9IG9wdGlvbnMubGVuZ3RoLCBvcHRpb24sIHNlbGVjdGVkVmFsdWVzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24gPSBvcHRpb25zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uLnNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFZhbHVlcy5wdXNoKHRoaXMuX2Nhc3RWYWx1ZShvcHRpb24udmFsdWUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWRWYWx1ZXM7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDYXN0cyBhIHZhbHVlIHRvIHRoZSBkZXRlcm1pbmVkIGluaXRpYWwgcHJvcGVydHkgdHlwZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgU2VsZWN0LnByb3RvdHlwZS5fY2FzdFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLl9wcm9wZXJ0eVR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbCh0eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjYXN0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXN0VmFsdWUgPSBpc0VtcHR5KHZhbHVlKSA/IHVuZGVmaW5lZCA6IE51bWJlcih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndHJ1ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc3RWYWx1ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZhbHNlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcwJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdudWxsJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXN0VmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzdFZhbHVlID0gISF2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc3RWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYXN0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTZXRzIGEgbGlzdGVuZXIgZm9yIHRoZSBjaGFuZ2VzIHRvIHRoZSBhcnJheS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgU2VsZWN0LnByb3RvdHlwZS5fc2V0TGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9fbGlzdGVuZXJTZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlQXJyYXkodGhpcy5fZXhlY3V0ZUV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2xpc3RlbmVyU2V0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZWNlaXZlcyBhbiBldmVudCB3aGVuIGEgbWV0aG9kIGhhcyBiZWVuIGNhbGxlZCBvbiBhbiBhcnJheSBhbmQgbWFwcyB0aGUgYXJyYXlcclxuICAgICAgICAgICAgICAgICAqIG1ldGhvZCB0byBpdHMgYXNzb2NpYXRlZCBtZXRob2QgaGFuZGxlci5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8cGxhdC5vYnNlcnZhYmxlLklBcnJheUNoYW5nZXM8YW55Pj59IGNoYW5nZXMgVGhlIEFycmF5IG11dGF0aW9uIGV2ZW50IGluZm9ybWF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBTZWxlY3QucHJvdG90eXBlLl9leGVjdXRlRXZlbnQgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXRob2QgPSAnXycgKyBjaGFuZ2VzWzBdLnR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1ttZXRob2RdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW21ldGhvZF0oY2hhbmdlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQWRkcyB0aGUgb3B0aW9ucyB0byB0aGUgc2VsZWN0IGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyT2ZJdGVtcyBUaGUgbnVtYmVyIG9mIGl0ZW1zIHRvIGFkZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgc3RhcnRpbmcgaW5kZXggb2YgdGhlIG5leHRcclxuICAgICAgICAgICAgICAgICAqIHNldCBvZiBpdGVtcyB0byBhZGQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFNlbGVjdC5wcm90b3R5cGUuX2FkZEl0ZW1zID0gZnVuY3Rpb24gKG51bWJlck9mSXRlbXMsIGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYmluZGFibGVUZW1wbGF0ZXMgPSB0aGlzLmJpbmRhYmxlVGVtcGxhdGVzLCBwcm9taXNlcyA9IFtdLCBpbnNlcnRPcHRpb24gPSB0aGlzLl9pbnNlcnRPcHRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG51bWJlck9mSXRlbXMtLSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChiaW5kYWJsZVRlbXBsYXRlcy5iaW5kKCdvcHRpb24nLCBpbmRleCkudGhlbihpbnNlcnRPcHRpb24uYmluZCh0aGlzLCBpbmRleCsrKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvbWlzZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1zTG9hZGVkID0gdGhpcy5fUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oX3RoaXMuX19yZXNvbHZlRm4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19yZXNvbHZlRm4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fX3Jlc29sdmVGbiA9IF90aGlzLl9fcmVqZWN0Rm4gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3Rwb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcoZXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zTG9hZGVkO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGNhbGxiYWNrIHVzZWQgdG8gYWRkIGFuIG9wdGlvbiBhZnRlclxyXG4gICAgICAgICAgICAgICAgICogaXRzIHRlbXBsYXRlIGhhcyBiZWVuIGJvdW5kLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBpdGVtIGJlaW5nIGFkZGVkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSBvcHRpb24gVGhlIGJvdW5kIERvY3VtZW50RnJhZ21lbnQgdG8gYmVcclxuICAgICAgICAgICAgICAgICAqIGluc2VydGVkIGludG8gdGhlIERPTS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgU2VsZWN0LnByb3RvdHlwZS5faW5zZXJ0T3B0aW9uID0gZnVuY3Rpb24gKGluZGV4LCBvcHRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNHcm91cGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncm91cHNfMSA9IHRoaXMuZ3JvdXBzLCBuZXdHcm91cF8xID0gKHRoaXMuY29udGV4dFtpbmRleF0gfHwge30pW3RoaXMuX2dyb3VwXSwgb3B0Z3JvdXBfMSA9IGdyb3Vwc18xW25ld0dyb3VwXzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKG9wdGdyb3VwXzEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGdyb3Vwc18xW25ld0dyb3VwXzFdID0gdGhpcy5iaW5kYWJsZVRlbXBsYXRlcy5iaW5kKCdncm91cCcsIGluZGV4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChncm91cEZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0Z3JvdXBfMSA9IGdyb3Vwc18xW25ld0dyb3VwXzFdID0gZ3JvdXBGcmFnbWVudC5jaGlsZE5vZGVzWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGdyb3VwXzEuaW5zZXJ0QmVmb3JlKG9wdGlvbiwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5pbnNlcnRCZWZvcmUoZ3JvdXBGcmFnbWVudCwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGdyb3VwXzE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNQcm9taXNlKG9wdGdyb3VwXzEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0Z3JvdXBfMS50aGVuKGZ1bmN0aW9uIChncm91cCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwLmluc2VydEJlZm9yZShvcHRpb24sIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0Z3JvdXBfMS5pbnNlcnRCZWZvcmUob3B0aW9uLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lmluc2VydEJlZm9yZShvcHRpb24sIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlbW92ZXMgYSBzcGVjaWZpZWQgbnVtYmVyIG9mIGVsZW1lbnRzLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlck9mSXRlbXMgVGhlIG51bWJlciBvZiBpdGVtc1xyXG4gICAgICAgICAgICAgICAgICogdG8gcmVtb3ZlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBTZWxlY3QucHJvdG90eXBlLl9yZW1vdmVJdGVtcyA9IGZ1bmN0aW9uIChudW1iZXJPZkl0ZW1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3Bvc2UgPSBUZW1wbGF0ZUNvbnRyb2wuZGlzcG9zZSwgY29udHJvbHMgPSB0aGlzLmNvbnRyb2xzO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChudW1iZXJPZkl0ZW1zLS0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3Bvc2UoY29udHJvbHMucG9wKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbiBjYWxsZWQgd2hlbiBhbiBpdGVtIGhhcyBiZWVuIHJlbW92ZWRcclxuICAgICAgICAgICAgICAgICAqIGZyb20gdGhlIEFycmF5IGNvbnRleHQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFNlbGVjdC5wcm90b3R5cGUuX3JlbW92ZUl0ZW0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzR3JvdXBlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNldFNlbGVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUl0ZW1zKDEpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVzZXRzIHRoZSBzZWxlY3QgZWxlbWVudCBieSByZW1vdmluZyBhbGwgaXRzXHJcbiAgICAgICAgICAgICAgICAgKiBpdGVtcyBhbmQgYWRkaW5nIHRoZW0gYmFjay5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgU2VsZWN0LnByb3RvdHlwZS5fcmVzZXRTZWxlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlSXRlbXModGhpcy5jb250cm9scy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc051bGwodGhpcy5fZGVmYXVsdE9wdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLl9kZWZhdWx0T3B0aW9uLmNsb25lTm9kZSh0cnVlKSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEl0ZW1zKHRoaXMuY29udGV4dC5sZW5ndGgsIDApO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIGFuIGVsZW1lbnQgaXMgcHVzaGVkIHRvXHJcbiAgICAgICAgICAgICAgICAgKiB0aGUgYXJyYXkgY29udGV4dC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8cGxhdC5vYnNlcnZhYmxlLklBcnJheUNoYW5nZXM8YW55Pj59IGNoYW5nZXMgVGhlIEFycmF5IG11dGF0aW9uIGV2ZW50IGluZm9ybWF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBTZWxlY3QucHJvdG90eXBlLl9wdXNoID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlID0gY2hhbmdlc1swXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRJdGVtcyhjaGFuZ2UuYWRkZWRDb3VudCwgY2hhbmdlLmluZGV4KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbiBjYWxsZWQgd2hlbiBhbiBpdGVtIGlzIHBvcHBlZFxyXG4gICAgICAgICAgICAgICAgICogZnJvbSB0aGUgYXJyYXkgY29udGV4dC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8cGxhdC5vYnNlcnZhYmxlLklBcnJheUNoYW5nZXM8YW55Pj59IGNoYW5nZXMgVGhlIEFycmF5IG11dGF0aW9uIGV2ZW50IGluZm9ybWF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBTZWxlY3QucHJvdG90eXBlLl9wb3AgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZXNbMF0ucmVtb3ZlZC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1zTG9hZGVkLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVtb3ZlSXRlbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIGFuIGl0ZW0gaXMgdW5zaGlmdGVkXHJcbiAgICAgICAgICAgICAgICAgKiBvbnRvIHRoZSBhcnJheSBjb250ZXh0LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxwbGF0Lm9ic2VydmFibGUuSUFycmF5Q2hhbmdlczxhbnk+Pn0gY2hhbmdlcyBUaGUgQXJyYXkgbXV0YXRpb24gZXZlbnQgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFNlbGVjdC5wcm90b3R5cGUuX3Vuc2hpZnQgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0dyb3VwZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzZXRTZWxlY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlID0gY2hhbmdlc1swXSwgYWRkZWRDb3VudCA9IGNoYW5nZS5hZGRlZENvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEl0ZW1zKGFkZGVkQ291bnQsIGNoYW5nZS5vYmplY3QubGVuZ3RoIC0gYWRkZWRDb3VudCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIGFuIGl0ZW0gaXMgc2hpZnRlZFxyXG4gICAgICAgICAgICAgICAgICogZnJvbSB0aGUgYXJyYXkgY29udGV4dC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8cGxhdC5vYnNlcnZhYmxlLklBcnJheUNoYW5nZXM8YW55Pj59IGNoYW5nZXMgVGhlIEFycmF5IG11dGF0aW9uIGV2ZW50IGluZm9ybWF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBTZWxlY3QucHJvdG90eXBlLl9zaGlmdCA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlc1swXS5yZW1vdmVkLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbXNMb2FkZWQudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZW1vdmVJdGVtKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgZnVuY3Rpb24gY2FsbGVkIHdoZW4gaXRlbXMgYXJlIHNwbGljZWRcclxuICAgICAgICAgICAgICAgICAqIGZyb20gdGhlIGFycmF5IGNvbnRleHQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHBsYXQub2JzZXJ2YWJsZS5JQXJyYXlDaGFuZ2VzPGFueT4+fSBjaGFuZ2VzIFRoZSBBcnJheSBtdXRhdGlvbiBldmVudCBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgU2VsZWN0LnByb3RvdHlwZS5fc3BsaWNlID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0dyb3VwZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzZXRTZWxlY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlID0gY2hhbmdlc1swXSwgYWRkQ291bnQgPSBjaGFuZ2UuYWRkZWRDb3VudCwgcmVtb3ZlQ291bnQgPSBjaGFuZ2UucmVtb3ZlZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZENvdW50ID4gcmVtb3ZlQ291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkSXRlbXMoYWRkQ291bnQgLSByZW1vdmVDb3VudCwgY2hhbmdlLm9iamVjdC5sZW5ndGggLSBhZGRDb3VudCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZW1vdmVDb3VudCA+IGFkZENvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbXNMb2FkZWQudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVtb3ZlSXRlbXMocmVtb3ZlQ291bnQgLSBhZGRDb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgYXJyYXkgY29udGV4dFxyXG4gICAgICAgICAgICAgICAgICogaXMgc29ydGVkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxwbGF0Lm9ic2VydmFibGUuSUFycmF5Q2hhbmdlczxhbnk+Pn0gY2hhbmdlcyBUaGUgQXJyYXkgbXV0YXRpb24gZXZlbnQgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFNlbGVjdC5wcm90b3R5cGUuX3NvcnQgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0dyb3VwZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzZXRTZWxlY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgZnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIGFycmF5IGNvbnRleHRcclxuICAgICAgICAgICAgICAgICAqIGlzIHJldmVyc2VkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxwbGF0Lm9ic2VydmFibGUuSUFycmF5Q2hhbmdlczxhbnk+Pn0gY2hhbmdlcyBUaGUgQXJyYXkgbXV0YXRpb24gZXZlbnQgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFNlbGVjdC5wcm90b3R5cGUuX3JldmVyc2UgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0dyb3VwZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzZXRTZWxlY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgU2VsZWN0Ll9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX1Byb21pc2U6IF9fUHJvbWlzZSxcclxuICAgICAgICAgICAgICAgICAgICBfZG9jdW1lbnQ6IF9fRG9jdW1lbnRcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU2VsZWN0O1xyXG4gICAgICAgICAgICB9KEJpbmRDb250cm9sKSk7XHJcbiAgICAgICAgICAgIGNvbnRyb2xzXzEuU2VsZWN0ID0gU2VsZWN0O1xyXG4gICAgICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fU2VsZWN0LCBTZWxlY3QpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBUZW1wbGF0ZUNvbnRyb2wgY29uZGl0aW9uYWxseSBhZGRpbmcgb3IgcmVtb3ZpbmdcclxuICAgICAgICAgICAgICogYSBibG9jayBvZiBub2RlcyB0byBvciBmcm9tIHRoZSBET00uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgSWYgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICAgICAgX19leHRlbmRzKElmLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgY29uc3RydWN0b3IgZm9yIGEgSWYuIENyZWF0ZXMgdGhlIGNvbW1lbnQgbm9kZSBhbmQgZG9jdW1lbnQgZnJhZ21lbnQgc3RvcmFnZVxyXG4gICAgICAgICAgICAgICAgICogdXNlZCBieSB0aGlzIGNvbnRyb2wuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIElmKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFRoZSBjdXJyZW50IGV2YWx1YXRlZCBjb25kaXRpb24gKHdoZXRoZXIgb3Igbm90IHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAqIGNvbnRyb2wgaXMgdmlzaWJsZSkgb2YgdGhlIGNvbnRyb2wuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2NvbmRpdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQSBib29sZWFuIHZhbHVlIHN0YXRpbmcgd2hldGhlciBvciBub3QgdGhlIGNvbmRpdGlvbiBoYXMgYWxyZWFkeVxyXG4gICAgICAgICAgICAgICAgICAgICAqIGJlZW4gZXZhbHVhdGVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19maXJzdFRpbWUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfZG9jdW1lbnQgPSB0aGlzLl9kb2N1bWVudDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1lbnROb2RlID0gX2RvY3VtZW50LmNyZWF0ZUNvbW1lbnQoX19JZiArIF9fQk9VTkRfUFJFRklYICsgJ3BsYWNlaG9sZGVyJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFnbWVudFN0b3JlID0gX2RvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ2hlY2tzIHRoZSBvcHRpb25zIGFuZCBpbml0aWFsaXplcyB0aGVcclxuICAgICAgICAgICAgICAgICAqIGV2YWx1YXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIElmLnByb3RvdHlwZS5jb250ZXh0Q2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShvcHRpb25zKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXR0ZXIob3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDcmVhdGVzIGEgYmluZGFibGUgdGVtcGxhdGUgd2l0aCB0aGUgY29udHJvbCBlbGVtZW50J3MgY2hpbGROb2RlcyAoaW5uZXJIVE1MKS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgSWYucHJvdG90eXBlLnNldFRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmluZGFibGVUZW1wbGF0ZXMuYWRkKCd0ZW1wbGF0ZScsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuZWxlbWVudC5jaGlsZE5vZGVzKSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTZXRzIHRoZSB2aXNpYmlsaXR5IHRvIHRydWUgaWYgbm8gb3B0aW9ucyBhcmVcclxuICAgICAgICAgICAgICAgICAqIGRlZmluZWQsIGtpY2tzIG9mZiB0aGUgZXZhbHVhdGlvbiwgYW5kIG9ic2VydmVzXHJcbiAgICAgICAgICAgICAgICAgKiB0aGUgb3B0aW9ucyBmb3IgY2hhbmdlcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgSWYucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHRoaXMub3B0aW9ucykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oJ05vIGNvbmRpdGlvbiBzcGVjaWZpZWQgaW4gJyArIF9fT3B0aW9ucyArICcgZm9yICcgKyB0aGlzLnR5cGUgKyAnLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbjogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmU6IG5vb3BcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLmNvbnRleHRDaGFuZ2VkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3JlbW92ZUxpc3RlbmVyID0gdGhpcy5vcHRpb25zLm9ic2VydmUodGhpcy5fc2V0dGVyKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFN0b3BzIGxpc3RlbmluZyB0byB0aGUgb3B0aW9ucyBmb3IgY2hhbmdlcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgSWYucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpcy5fX3JlbW92ZUxpc3RlbmVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fcmVtb3ZlTGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3JlbW92ZUxpc3RlbmVyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21tZW50Tm9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFnbWVudFN0b3JlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIENoZWNrcyB0aGUgY29uZGl0aW9uIGFuZCBkZWNpZGVzXHJcbiAgICAgICAgICAgICAgICAgKiB3aGV0aGVyIG9yIG5vdCB0byBhZGQgb3IgcmVtb3ZlXHJcbiAgICAgICAgICAgICAgICAgKiB0aGUgbm9kZSBmcm9tIHRoZSBET00uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIElmLnByb3RvdHlwZS5fc2V0dGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICEhb3B0aW9ucy5jb25kaXRpb24sIHByb21pc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB0aGlzLl9fY29uZGl0aW9uICYmICF0aGlzLl9fZmlyc3RUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLnJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbCh0aGlzLl9fbGVhdmVBbmltYXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gdGhpcy5fX2xlYXZlQW5pbWF0aW9uLmNhbmNlbCgpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fbGVhdmVBbmltYXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fYWRkSXRlbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gdGhpcy5fYWRkSXRlbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbCh0aGlzLl9fZW50ZXJBbmltYXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gdGhpcy5fX2VudGVyQW5pbWF0aW9uLmNhbmNlbCgpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fZW50ZXJBbmltYXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVtb3ZlSXRlbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVJdGVtKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gdGhpcy5fUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19jb25kaXRpb24gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFkZHMgdGhlIGNvbmRpdGlvbmFsIG5vZGVzIHRvIHRoZSBET00uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIElmLnByb3RvdHlwZS5fYWRkSXRlbSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKHRoaXMuY29tbWVudE5vZGUucGFyZW50Tm9kZSkgJiYgIXRoaXMuX19maXJzdFRpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UucmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX19maXJzdFRpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2ZpcnN0VGltZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9faW5pdGlhbEJpbmQgPSB0aGlzLmJpbmRhYmxlVGVtcGxhdGVzLmJpbmQoJ3RlbXBsYXRlJykudGhlbihmdW5jdGlvbiAodGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gX3RoaXMuZWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9faW5pdGlhbEJpbmQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQucGFyZW50Tm9kZSA9PT0gX3RoaXMuZnJhZ21lbnRTdG9yZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRlbXBsYXRlLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2FuaW1hdGVFbnRyYW5jZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19lbnRlckFuaW1hdGlvbiA9IF90aGlzLl9hbmltYXRvci5hbmltYXRlKGVsZW1lbnQsIF9fRW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5pbnNlcnRCZWZvcmUodGVtcGxhdGUsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9fZW50ZXJBbmltYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19lbnRlckFuaW1hdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX2luaXRpYWxCaW5kO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcm9taXNlKHRoaXMuX19pbml0aWFsQmluZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19pbml0aWFsQmluZC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fYW5pbWF0ZUVudHJhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYW5pbWF0ZUVudHJhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBbmltYXRlcyB0aGUgdGVtcGxhdGUgYXMgaXQgZW50ZXJzIHRoZSBET00uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIElmLnByb3RvdHlwZS5fYW5pbWF0ZUVudHJhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnROb2RlID0gdGhpcy5jb21tZW50Tm9kZSwgcGFyZW50Tm9kZSA9IGNvbW1lbnROb2RlLnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05vZGUocGFyZW50Tm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FuaW1hdG9yLnJlc29sdmUoKS50aGVuKG5vb3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX2VudGVyQW5pbWF0aW9uID0gdGhpcy5fYW5pbWF0b3IuZW50ZXIodGhpcy5lbGVtZW50LCBfX0VudGVyLCBwYXJlbnROb2RlLCBjb21tZW50Tm9kZSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fZW50ZXJBbmltYXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVtb3ZlcyB0aGUgY29uZGl0aW9uYWwgbm9kZXMgZnJvbSB0aGUgRE9NLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBJZi5wcm90b3R5cGUuX3JlbW92ZUl0ZW0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcm9taXNlKHRoaXMuX19pbml0aWFsQmluZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19pbml0aWFsQmluZC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fYW5pbWF0ZUxlYXZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYW5pbWF0ZUxlYXZlKCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBbmltYXRlcyB0aGUgdGVtcGxhdGUgYXMgaXQgbGVhdmVzIHRoZSBET00uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIElmLnByb3RvdHlwZS5fYW5pbWF0ZUxlYXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsIHBhcmVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudCwgbmV4dFNpYmxpbmcgPSBlbGVtZW50Lm5leHRTaWJsaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKHBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FuaW1hdG9yLnJlc29sdmUoKS50aGVuKG5vb3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX2xlYXZlQW5pbWF0aW9uID0gdGhpcy5fYW5pbWF0b3IubGVhdmUoZWxlbWVudCwgX19MZWF2ZSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fbGVhdmVBbmltYXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKF90aGlzLmNvbW1lbnROb2RlLCBuZXh0U2libGluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmZyYWdtZW50U3RvcmUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIElmLl9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2FuaW1hdG9yOiBfX0FuaW1hdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIF9Qcm9taXNlOiBfX1Byb21pc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgX2RvY3VtZW50OiBfX0RvY3VtZW50XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIElmO1xyXG4gICAgICAgICAgICB9KFRlbXBsYXRlQ29udHJvbCkpO1xyXG4gICAgICAgICAgICBjb250cm9sc18xLklmID0gSWY7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19JZiwgSWYpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBUZW1wbGF0ZUNvbnRyb2wgZm9yIGFkZGluZyBhZGRpdG9uYWxcclxuICAgICAgICAgICAgICogZnVuY3Rpb25hbGl0eSB0byBhIG5hdGl2ZSBIVE1MIGFuY2hvciB0YWcuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgTGluayA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgICAgICBfX2V4dGVuZHMoTGluaywgX3N1cGVyKTtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIExpbmsoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogUmVwbGFjZXMgdGhlIExpbmsncyBlbGVtZW50IHdpdGggYSBuYXRpdmUgYW5jaG9yIHRhZy5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VXaXRoID0gJ2EnO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFRoZSByb3V0ZXIgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbGluay5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yb3V0ZXIgPSB0aGlzLl9Sb3V0ZXIuY3VycmVudFJvdXRlcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBJbml0aWFsaXplcyBjbGljayBldmVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTGluay5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVDbGlja0xpc3RlbmVyID0gdGhpcy5kb20uYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmVsZW1lbnQsICdjbGljaycsIHRoaXMuX2hhbmRsZUNsaWNrLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDYWxscyB0byBub3JtYWxpemUgdGhlIGhyZWYgZm9yIGludGVybmFsIGxpbmtzIGFuZCBpbml0aWFsaXplcyB0aGUgdGFwIGV2ZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBMaW5rLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsIHNldEhyZWYgPSB0aGlzLnNldEhyZWYuYmluZCh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzT2JqZWN0KG9wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKCdObyBvcHRpb25zIHNwZWNpZmllZCBmb3IgJyArIHRoaXMudHlwZSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLiBQbGVhc2Ugc2VuZCBpbiBvcHRpb25zIG9mIHR5cGUgcGxhdC51aS5jb250cm9scy5JTGlua09wdGlvbnMuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy52YWx1ZSA9IHsgdmlldzogJycgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRIcmVmKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0KG9wdGlvbnMudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudmFsdWUgPSB7IHZpZXc6ICcnIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmVsZW1lbnQsIF9fdGFwLCB0aGlzLl9oYW5kbGVUYXAsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRIcmVmKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vYnNlcnZlKHNldEhyZWYpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogU2V0cyB0aGUgZWxlbWVudCBocmVmIHRvIHRoZSBvbmUgZm9ybWVkIHVzaW5nIHRoZSBhc3NvY2lhdGVkIG9wdGlvbnMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIExpbmsucHJvdG90eXBlLnNldEhyZWYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhyZWYgPSB0aGlzLmdldEhyZWYoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRW1wdHkoaHJlZikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaHJlZiA9IGhyZWY7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRGV0ZXJtaW5lcyB0aGUgaHJlZiBiYXNlZCBvbiB0aGUgaW5wdXQgb3B0aW9ucy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTGluay5wcm90b3R5cGUuZ2V0SHJlZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHRoaXMuX3JvdXRlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLm9wdGlvbnMudmFsdWUsIGhyZWYgPSB2YWx1ZS52aWV3O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5pc1VybCAhPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1ldGVycyA9IHZhbHVlLnBhcmFtZXRlcnMsIHF1ZXJ5ID0gdmFsdWUucXVlcnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KGhyZWYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaHJlZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmID0gdGhpcy5fcm91dGVyLmdlbmVyYXRlKGhyZWYsIHBhcmFtZXRlcnMsIHF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Jyb3dzZXIuZm9ybWF0VXJsKGhyZWYpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRGV0ZXJtaW5lcyBXaGV0aGVyIG9yIG5vdCB0aGUgZGVmYXVsdCBjbGljayBiZWhhdmlvciBzaG91bGQgYmUgcHJldmVudGVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBMaW5rLnByb3RvdHlwZS5faGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9ucztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIoZXYuYnV0dG9ucykgJiYgZXYuYnV0dG9ucyAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b25zID0gZXYuYnV0dG9ucztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNOdW1iZXIoZXYud2hpY2gpICYmIGV2LndoaWNoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b25zID0gZXYud2hpY2g7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGV2LmJ1dHRvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAtMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25zID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25zID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25zID0gNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25zID0gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25zID0gODtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25zID0gMTY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnMgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChidXR0b25zID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRGV0ZXJtaW5lcyB0aGUgcHJvcGVyIGxpbmsgdXBvbiAkdGFwLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBMaW5rLnByb3RvdHlwZS5faGFuZGxlVGFwID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXYuYnV0dG9ucyAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBocmVmID0gdGhpcy5nZXRIcmVmKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGhyZWYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWVHbG9iYWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYnJvd3Nlci51cmwoaHJlZik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDYWxscyB0byByZW1vdmUgdGhlIGNsaWNrIGVhdGVyIGFmdGVyIGEgZGVsYXkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIExpbmsucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmZXIodGhpcy5fcmVtb3ZlQ2xpY2tMaXN0ZW5lciwgMzAwMCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgTGluay5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIF9Sb3V0ZXI6IF9fUm91dGVyU3RhdGljLFxyXG4gICAgICAgICAgICAgICAgICAgIF9JbmplY3RvcjogX19JbmplY3RvclN0YXRpYyxcclxuICAgICAgICAgICAgICAgICAgICBfYnJvd3NlcjogX19Ccm93c2VyXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIExpbms7XHJcbiAgICAgICAgICAgIH0oVGVtcGxhdGVDb250cm9sKSk7XHJcbiAgICAgICAgICAgIGNvbnRyb2xzXzEuTGluayA9IExpbms7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19MaW5rLCBMaW5rKTtcclxuICAgICAgICB9KShjb250cm9scyA9IHVpLmNvbnRyb2xzIHx8ICh1aS5jb250cm9scyA9IHt9KSk7XHJcbiAgICB9KSh1aSA9IHBsYXRfMS51aSB8fCAocGxhdF8xLnVpID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogSG9sZHMgY2xhc3NlcyBhbmQgaW50ZXJmYWNlcyByZWxhdGVkIHRvIERvY3VtZW50IHByb2Nlc3NpbmcgaW4gcGxhdHlwdXMuXHJcbiAgICAgKi9cclxuICAgIHZhciBwcm9jZXNzaW5nO1xyXG4gICAgKGZ1bmN0aW9uIChwcm9jZXNzaW5nKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVzcG9uc2libGUgZm9yIGl0ZXJhdGluZyB0aHJvdWdoIHRoZSBET00gYW5kIGNvbGxlY3RpbmcgY29udHJvbHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIENvbXBpbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gQ29tcGlsZXIoKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbiAobm9kZSwgY29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBub2RlLmNoaWxkTm9kZXMsIGxlbmd0aCwgbmV3TGVuZ3RoLCBjaGlsZE5vZGUsIGhhc0NvbnRyb2wgPSAhaXNOdWxsKGNvbnRyb2wpLCBtYW5hZ2VyID0gKGhhc0NvbnRyb2wgPyB0aGlzLl9tYW5hZ2VyQ2FjaGUucmVhZChjb250cm9sLnVpZCkgOiBudWxsKSwgY3JlYXRlID0gdGhpcy5fRWxlbWVudE1hbmFnZXJGYWN0b3J5LmNyZWF0ZTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoY2hpbGROb2RlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY2hpbGROb2Rlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKG5vZGUucHVzaCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwobWFuYWdlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBjaGlsZE5vZGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChjcmVhdGUoY2hpbGROb2RlKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBpbGUoY2hpbGROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdMZW5ndGggPSBjaGlsZE5vZGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSBuZXdMZW5ndGggLSBsZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IG5ld0xlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb21waWxlTm9kZXMoY2hpbGROb2RlcywgbWFuYWdlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJdGVyYXRlcyB0aHJvdWdoIHRoZSBhcnJheSBvZiBub2RlcyBjcmVhdGluZyBFbGVtZW50TWFuYWdlcnMgb24gRWxlbWVudFxyXG4gICAgICAgICAgICAgKiBub2RlcywgVGV4dE1hbmFnZXJzIG9uIHRleHQgbm9kZXMsIGFuZFxyXG4gICAgICAgICAgICAgKiBDb21tZW50TWFuYWdlcnMgb24gY29tbWVudCBub2Rlcy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxOb2RlPn0gbm9kZXMgVGhlIGFycmF5IG9mIG5vZGVzIHRvIGJlIGNvbXBpbGVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucHJvY2Vzc2luZy5FbGVtZW50TWFuYWdlcn0gbWFuYWdlciBUaGUgcGFyZW50IEVsZW1lbnRNYW5hZ2Vyc1xyXG4gICAgICAgICAgICAgKiBmb3IgdGhlIGdpdmVuIGFycmF5IG9mIG5vZGVzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBub2RlcyBUaGUgTm9kZUxpc3QgdG8gYmUgY29tcGlsZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBtYW5hZ2VyIFRoZSBwYXJlbnQgRWxlbWVudCBNYW5hZ2VyIGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2Ygbm9kZXMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVOb2RlcyA9IGZ1bmN0aW9uIChub2RlcywgbWFuYWdlcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IG5vZGVzLmxlbmd0aCwgbm9kZSwgbmV3TWFuYWdlciwgbmV3TGVuZ3RoLCBjcmVhdGUgPSB0aGlzLl9FbGVtZW50TWFuYWdlckZhY3RvcnkuY3JlYXRlLCBjb21tZW50Q3JlYXRlID0gdGhpcy5fQ29tbWVudE1hbmFnZXJGYWN0b3J5LmNyZWF0ZSwgdGV4dENyZWF0ZSA9IHRoaXMuX1RleHRNYW5hZ2VyRmFjdG9yeS5jcmVhdGU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE5vZGUuRUxFTUVOVF9OT0RFOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TWFuYWdlciA9IGNyZWF0ZShub2RlLCBtYW5hZ2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKG5ld01hbmFnZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29tcGlsZU5vZGVzKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG5vZGUuY2hpbGROb2RlcyksIG5ld01hbmFnZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTm9kZS5URVhUX05PREU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Q3JlYXRlKG5vZGUsIG1hbmFnZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTm9kZS5DT01NRU5UX05PREU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50Q3JlYXRlKG5vZGUsIG1hbmFnZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBpICs9IG5ld0xlbmd0aCAtIGxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBuZXdMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIENvbXBpbGVyLl9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgICAgICBfRWxlbWVudE1hbmFnZXJGYWN0b3J5OiBfX0VsZW1lbnRNYW5hZ2VyRmFjdG9yeSxcclxuICAgICAgICAgICAgICAgIF9UZXh0TWFuYWdlckZhY3Rvcnk6IF9fVGV4dE1hbmFnZXJGYWN0b3J5LFxyXG4gICAgICAgICAgICAgICAgX0NvbW1lbnRNYW5hZ2VyRmFjdG9yeTogX19Db21tZW50TWFuYWdlckZhY3RvcnksXHJcbiAgICAgICAgICAgICAgICBfbWFuYWdlckNhY2hlOiBfX01hbmFnZXJDYWNoZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gQ29tcGlsZXI7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBwcm9jZXNzaW5nLkNvbXBpbGVyID0gQ29tcGlsZXI7XHJcbiAgICAgICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX0NvbXBpbGVyLCBDb21waWxlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVzcG9uc2libGUgZm9yIGRhdGEgYmluZGluZyBhIGRhdGEgY29udGV4dCB0byBhIE5vZGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIE5vZGVNYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gTm9kZU1hbmFnZXIoKSB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoaXMgTm9kZU1hbmFnZXIgaXMgYSBjbG9uZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0Nsb25lID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERldGVybWluZXMgaWYgYSBzdHJpbmcgaGFzIHRoZSBtYXJrdXAgbm90YXRpb24uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHN0cmluZyBpbiB3aGljaCB0byBzZWFyY2ggZm9yIG1hcmt1cC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE5vZGVNYW5hZ2VyLmhhc01hcmt1cCA9IGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTm9kZU1hbmFnZXIuX21hcmt1cFJlZ2V4LnRlc3QodGV4dCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHaXZlbiBhIHN0cmluZywgZmluZHMgbWFya3VwIGluIHRoZSBzdHJpbmcgYW5kIGNyZWF0ZXMgYW4gYXJyYXkgb2ZcclxuICAgICAgICAgICAgICogSVBhcnNlZEV4cHJlc3Npb24uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHN0cmluZyBpbiB3aGljaCB0byBzZWFyY2ggZm9yIG1hcmt1cC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE5vZGVNYW5hZ2VyLmZpbmRNYXJrdXAgPSBmdW5jdGlvbiAodGV4dCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0LCBlbmQsIHBhcnNlZEV4cHJlc3Npb25zID0gW10sIHdyYXBFeHByZXNzaW9uID0gTm9kZU1hbmFnZXIuX3dyYXBFeHByZXNzaW9uLCBzdWJzdHJpbmcsIGV4cHJlc3Npb24sIF9wYXJzZXIgPSBOb2RlTWFuYWdlci5fcGFyc2VyO1xyXG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShOb2RlTWFuYWdlci5fbmV3TGluZVJlZ2V4LCAnJyk7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoKHN0YXJ0ID0gdGV4dC5pbmRleE9mKF9fc3RhcnRTeW1ib2wpKSAhPT0gLTEgJiYgKGVuZCA9IHRleHQuaW5kZXhPZihfX2VuZFN5bWJvbCkpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRFeHByZXNzaW9ucy5wdXNoKHdyYXBFeHByZXNzaW9uKHRleHQuc2xpY2UoMCwgc3RhcnQpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVtZW50IHdpdGggd2hpbGUgbG9vcCBpbnN0ZWFkIG9mIGp1c3QgKz0gMiBmb3IgbmVzdGVkIG9iamVjdCBsaXRlcmFsIGNhc2UuIFxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0ZXh0WysrZW5kXSA9PT0gJ30nKSB7IH1cclxuICAgICAgICAgICAgICAgICAgICBzdWJzdHJpbmcgPSB0ZXh0LnNsaWNlKHN0YXJ0ICsgMiwgZW5kIC0gMik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIG9uZS10aW1lIGRhdGFiaW5kaW5nIFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJzdHJpbmdbMF0gPT09ICc9Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gX3BhcnNlci5wYXJzZShzdWJzdHJpbmcuc2xpY2UoMSkudHJpbSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5vbmVUaW1lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkRXhwcmVzc2lvbnMucHVzaChleHByZXNzaW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZEV4cHJlc3Npb25zLnB1c2goX3BhcnNlci5wYXJzZShzdWJzdHJpbmcudHJpbSgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKGVuZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPiAtMSAmJiBlbmQgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEV4cHJlc3Npb25zLnB1c2god3JhcEV4cHJlc3Npb24odGV4dC5zbGljZShlbmQpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0ZXh0ICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEV4cHJlc3Npb25zLnB1c2god3JhcEV4cHJlc3Npb24odGV4dCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZEV4cHJlc3Npb25zO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGFrZXMgaW4gYSBjb250cm9sIHdpdGggYSBkYXRhIGNvbnRleHQgYW5kIGFuIGFycmF5IG9mIElQYXJzZWRFeHByZXNzaW9uXHJcbiAgICAgICAgICAgICAqIGFuZCBvdXRwdXRzIGEgc3RyaW5nIG9mIHRoZSBldmFsdWF0ZWQgZXhwcmVzc2lvbnMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8cGxhdC5leHByZXNzaW9ucy5JUGFyc2VkRXhwcmVzc2lvbj59IGV4cHJlc3Npb25zIFRoZSBjb21wb3NpdGlvbiBhcnJheSB0byBldmFsdWF0ZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlRlbXBsYXRlQ29udHJvbH0gY29udHJvbD8gVGhlIFRlbXBsYXRlQ29udHJvbCB1c2VkIHRvIHBhcnNlXHJcbiAgICAgICAgICAgICAqIHRoZSBleHByZXNzaW9ucy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE5vZGVNYW5hZ2VyLmJ1aWxkID0gZnVuY3Rpb24gKGV4cHJlc3Npb25zLCBjb250cm9sKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9ICcnLCBsZW5ndGggPSBleHByZXNzaW9ucy5sZW5ndGgsIHJlc291cmNlcyA9IHt9LCBleHByZXNzaW9uLCB2YWx1ZSwgZXZhbHVhdGVFeHByZXNzaW9uID0gTm9kZU1hbmFnZXIuX1RlbXBsYXRlQ29udHJvbEZhY3RvcnkuZXZhbHVhdGVFeHByZXNzaW9uO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGV2YWx1YXRlRXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250cm9sLCByZXNvdXJjZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgKz0gSlNPTi5zdHJpbmdpZnkodmFsdWUsIG51bGwsIDQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChlLmRlc2NyaXB0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuZGVzY3JpcHRpb24gPSAnQ2Fubm90IHN0cmluZ2lmeSBvYmplY3Q6ICcgKyBlLmRlc2NyaXB0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5tZXNzYWdlID0gJ0Nhbm5vdCBzdHJpbmdpZnkgb2JqZWN0OiAnICsgZS5tZXNzYWdlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTm9kZU1hbmFnZXIuX2xvZy53YXJuKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc051bGwodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgKz0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciB0byBiZSBub3RpZmllZCBvZiBhIGNoYW5nZSBpbiBhbnkgYXNzb2NpYXRlZCBpZGVudGlmaWVyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHBsYXQuZXhwcmVzc2lvbnMuSVBhcnNlZEV4cHJlc3Npb24+fSBleHByZXNzaW9ucyBBbiBBcnJheSBvZlxyXG4gICAgICAgICAgICAgKiBJUGFyc2VkRXhwcmVzc2lvbnMgdG8gb2JzZXJ2ZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlRlbXBsYXRlQ29udHJvbH0gY29udHJvbCBUaGUgVGVtcGxhdGVDb250cm9sIGFzc29jaWF0ZWRcclxuICAgICAgICAgICAgICogdG8gdGhlIGlkZW50aWZpZXJzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geyguLi5hcmdzOiBBcnJheTxhbnk+KSA9PiB2b2lkfSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gY2FsbCB3aGVuIGFueSBpZGVudGlmaWVyIHByb3BlcnR5IGNoYW5nZXMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBOb2RlTWFuYWdlci5vYnNlcnZlRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbnMsIGNvbnRyb2wsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdW5pcXVlSWRlbnRpZmllcnMgPSBOb2RlTWFuYWdlci5fX2ZpbmRVbmlxdWVJZGVudGlmaWVycyhleHByZXNzaW9ucyksIGlkZW50aWZpZXJzID0gdW5pcXVlSWRlbnRpZmllcnMuaWRlbnRpZmllcnMsIG9uZVRpbWVJZGVudGlmaWVycyA9IHVuaXF1ZUlkZW50aWZpZXJzLm9uZVRpbWVJZGVudGlmaWVycywgb25lVGltZUlkZW50aWZpZXIsIG9ic2VydmFibGVDYWxsYmFjayA9IHtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgdWlkOiBjb250cm9sLnVpZFxyXG4gICAgICAgICAgICAgICAgfSwgb2JzZXJ2YXRpb25EZXRhaWxzLCBtYW5hZ2VyLCBhYnNvbHV0ZUlkZW50aWZpZXI7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaWRlbnRpZmllcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmF0aW9uRGV0YWlscyA9IE5vZGVNYW5hZ2VyLl9fZ2V0T2JzZXJ2YXRpb25EZXRhaWxzKGlkZW50aWZpZXJzLnBvcCgpLCBjb250cm9sKTtcclxuICAgICAgICAgICAgICAgICAgICBtYW5hZ2VyID0gb2JzZXJ2YXRpb25EZXRhaWxzLm1hbmFnZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc051bGwobWFuYWdlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFuYWdlci5vYnNlcnZlKG9ic2VydmF0aW9uRGV0YWlscy5hYnNvbHV0ZUlkZW50aWZpZXIsIG9ic2VydmFibGVDYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKG9uZVRpbWVJZGVudGlmaWVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25lVGltZUlkZW50aWZpZXIgPSBvbmVUaW1lSWRlbnRpZmllcnMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2YXRpb25EZXRhaWxzID0gTm9kZU1hbmFnZXIuX19nZXRPYnNlcnZhdGlvbkRldGFpbHMob25lVGltZUlkZW50aWZpZXIsIGNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hbmFnZXIgPSBvYnNlcnZhdGlvbkRldGFpbHMubWFuYWdlcjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShpc051bGwobWFuYWdlcikgfHwgb2JzZXJ2YXRpb25EZXRhaWxzLmlzRGVmaW5lZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVJZGVudGlmaWVyID0gb2JzZXJ2YXRpb25EZXRhaWxzLmFic29sdXRlSWRlbnRpZmllcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3BPYnNlcnZpbmcgPSBtYW5hZ2VyLm9ic2VydmUoYWJzb2x1dGVJZGVudGlmaWVyLCBvYnNlcnZhYmxlQ2FsbGJhY2spLCBzdG9wTGlzdGVuaW5nID0gbWFuYWdlci5vYnNlcnZlKGFic29sdXRlSWRlbnRpZmllciwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWlkOiBjb250cm9sLnVpZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcE9ic2VydmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BMaXN0ZW5pbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV3JhcHMgY29uc3RhbnQgdGV4dCBhcyBhIHN0YXRpYyBJUGFyc2VkRXhwcmVzc2lvbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHRleHQgVGhlIHRleHQgdG8gd3JhcCBpbnRvIGEgc3RhdGljIGV4cHJlc3Npb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBOb2RlTWFuYWdlci5fd3JhcEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodGV4dCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBldmFsdWF0ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGV4dDsgfSxcclxuICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgYWxpYXNlczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogdGV4dFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdpdmVuIGFuIElQYXJzZWRFeHByZXNzaW9uIGFycmF5LCBjcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSBpZGVudGlmZXJzXHJcbiAgICAgICAgICAgICAqIHRvIHVzZSB3aXRoIGJpbmRpbmcuIFRoaXMgYWxsb3dzIHVzIHRvIGF2b2lkIGNyZWF0aW5nIG11bHRpcGxlIGxpc3RlbmVycyBmb3IgdGhlIGlkZW50aWZpZXIgYW5kIG5vZGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8cGxhdC5leHByZXNzaW9ucy5JUGFyc2VkRXhwcmVzc2lvbj59IGV4cHJlc3Npb25zIEFuIGFycmF5IG9mIHBhcnNlZCBleHByZXNzaW9ucyB0byBzZWFyY2ggZm9yIGlkZW50aWZpZXJzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTm9kZU1hbmFnZXIuX19maW5kVW5pcXVlSWRlbnRpZmllcnMgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbnMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBleHByZXNzaW9ucy5sZW5ndGgsIGV4cHJlc3Npb247XHJcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb25zWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uLm9uZVRpbWUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXJzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZVRpbWVJZGVudGlmaWVyczogZXhwcmVzc2lvbi5pZGVudGlmaWVycy5zbGljZSgwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyczogZXhwcmVzc2lvbi5pZGVudGlmaWVycy5zbGljZSgwKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25lVGltZUlkZW50aWZpZXJzOiBbXVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdW5pcXVlSWRlbnRpZmllck9iamVjdCA9IHt9LCBvbmVUaW1lSWRlbnRpZmllck9iamVjdCA9IHt9LCB1bmlxdWVJZGVudGlmaWVycyA9IFtdLCBvbmVUaW1lSWRlbnRpZmllcnMgPSBbXSwgaWRlbnRpZmllcnMsIGlkZW50aWZpZXIsIGosIGpMZW5ndGgsIG9uZVRpbWU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb25zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIG9uZVRpbWUgPSBleHByZXNzaW9uLm9uZVRpbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcnMgPSBleHByZXNzaW9uLmlkZW50aWZpZXJzO1xyXG4gICAgICAgICAgICAgICAgICAgIGpMZW5ndGggPSBpZGVudGlmaWVycy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW5ndGg7ICsraikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyID0gaWRlbnRpZmllcnNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbmVUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5pcXVlSWRlbnRpZmllck9iamVjdFtpZGVudGlmaWVyXSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvbmVUaW1lSWRlbnRpZmllck9iamVjdFtpZGVudGlmaWVyXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZVRpbWVJZGVudGlmaWVyT2JqZWN0W2lkZW50aWZpZXJdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmVUaW1lSWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdW5pcXVlSWRlbnRpZmllck9iamVjdFtpZGVudGlmaWVyXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUlkZW50aWZpZXJPYmplY3RbaWRlbnRpZmllcl0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob25lVGltZUlkZW50aWZpZXJPYmplY3RbaWRlbnRpZmllcl0gPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmVUaW1lSWRlbnRpZmllck9iamVjdFtpZGVudGlmaWVyXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZVRpbWVJZGVudGlmaWVycy5zcGxpY2Uob25lVGltZUlkZW50aWZpZXJzLmluZGV4T2YoaWRlbnRpZmllciksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyczogdW5pcXVlSWRlbnRpZmllcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgb25lVGltZUlkZW50aWZpZXJzOiBvbmVUaW1lSWRlbnRpZmllcnNcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUYWtlcyBpbiBhbiBpZGVudGlmaWVyIGFuZCByZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIGJvdGggaXRzIGNvbnZlcnRlZCBhYnNvbHV0ZSBwYXRoIGFuZCB0aGVcclxuICAgICAgICAgICAgICogQ29udGV4dE1hbmFnZXIgbmVlZGVkIHRvIG9ic2VydmUgaXQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGlmaWVyIFRoZSBpZGVudGlmaWVyIGxvb2tpbmcgdG8gYmUgb2JzZXJ2ZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5UZW1wbGF0ZUNvbnRyb2x9IGNvbnRyb2wgVGhlIFRlbXBsYXRlQ29udHJvbCBhc3NvY2lhdGVkXHJcbiAgICAgICAgICAgICAqIHRvIHRoZSBpZGVudGlmaWVycy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE5vZGVNYW5hZ2VyLl9fZ2V0T2JzZXJ2YXRpb25EZXRhaWxzID0gZnVuY3Rpb24gKGlkZW50aWZpZXIsIGNvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfQ29udGV4dE1hbmFnZXIgPSBOb2RlTWFuYWdlci5fQ29udGV4dE1hbmFnZXIsIG1hbmFnZXIsIHNwbGl0ID0gaWRlbnRpZmllci5zcGxpdCgnLicpLCBhYnNvbHV0ZUlkZW50aWZpZXIgPSAnJywgaXNEZWZpbmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoaWRlbnRpZmllclswXSA9PT0gJ0AnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgZm91bmQgYW4gYWxpYXMgXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc291cmNlT2JqID0gdm9pZCAwLCByZXNvdXJjZXMgPSB7fSwgdG9wSWRlbnRpZmllciA9IHNwbGl0LnNoaWZ0KCksIGFsaWFzID0gdG9wSWRlbnRpZmllci5zbGljZSgxKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3BsaXQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZUlkZW50aWZpZXIgPSAnLicgKyBzcGxpdC5qb2luKCcuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlT2JqID0gcmVzb3VyY2VzW2FsaWFzXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHJlc291cmNlT2JqKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZU9iaiA9IHJlc291cmNlc1thbGlhc10gPSBjb250cm9sLmZpbmRSZXNvdXJjZShhbGlhcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKHJlc291cmNlT2JqKSAmJiAhaXNOdWxsKHJlc291cmNlT2JqLnJlc291cmNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHJlc291cmNlT2JqLnJlc291cmNlLnR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbGlhcyA9PT0gX19DT05URVhUX1JFU09VUkNFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYW5hZ2VyID0gX0NvbnRleHRNYW5hZ2VyLmdldE1hbmFnZXIoQ29udHJvbC5nZXRSb290Q29udHJvbChjb250cm9sKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZUlkZW50aWZpZXIgPSBjb250cm9sLmFic29sdXRlQ29udGV4dFBhdGggKyBhYnNvbHV0ZUlkZW50aWZpZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYWxpYXMgPT09IF9fUk9PVF9DT05URVhUX1JFU09VUkNFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYW5hZ2VyID0gX0NvbnRleHRNYW5hZ2VyLmdldE1hbmFnZXIocmVzb3VyY2VzW2FsaWFzXS5jb250cm9sKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFic29sdXRlSWRlbnRpZmllciA9ICdjb250ZXh0JyArIGFic29sdXRlSWRlbnRpZmllcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBfX09CU0VSVkFCTEVfUkVTT1VSQ0UgfHwgdHlwZSA9PT0gX19MSVRFUkFMX1JFU09VUkNFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYW5hZ2VyID0gX0NvbnRleHRNYW5hZ2VyLmdldE1hbmFnZXIocmVzb3VyY2VzW2FsaWFzXS5jb250cm9sKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFic29sdXRlSWRlbnRpZmllciA9ICdyZXNvdXJjZXMuJyArIGFsaWFzICsgJy52YWx1ZScgKyBhYnNvbHV0ZUlkZW50aWZpZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBsb29rIG9uIHRoZSBjb250cm9sLmNvbnRleHQgXHJcbiAgICAgICAgICAgICAgICAgICAgaXNEZWZpbmVkID0gIWlzVW5kZWZpbmVkKF9Db250ZXh0TWFuYWdlci5nZXRDb250ZXh0KGNvbnRyb2wuY29udGV4dCwgc3BsaXQpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkIHx8IGlzVW5kZWZpbmVkKF9Db250ZXh0TWFuYWdlci5nZXRDb250ZXh0KGNvbnRyb2wsIHNwbGl0KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFuYWdlciA9IF9Db250ZXh0TWFuYWdlci5nZXRNYW5hZ2VyKENvbnRyb2wuZ2V0Um9vdENvbnRyb2woY29udHJvbCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZUlkZW50aWZpZXIgPSBjb250cm9sLmFic29sdXRlQ29udGV4dFBhdGggKyAnLicgKyBpZGVudGlmaWVyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFuYWdlciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZUlkZW50aWZpZXI6IGFic29sdXRlSWRlbnRpZmllcixcclxuICAgICAgICAgICAgICAgICAgICBtYW5hZ2VyOiBtYW5hZ2VyLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzRGVmaW5lZDogaXNEZWZpbmVkXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIG1hbmFnZXIncyBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucHJvY2Vzc2luZy5JTm9kZU1hcH0gbm9kZU1hcCBUaGUgbWFwcGluZyBhc3NvY2lhdGVkIHdpdGggdGhpcyBtYW5hZ2VyLiBXZSBoYXZlIHRvIHVzZSBhblxyXG4gICAgICAgICAgICAgKiBVc2VkIHRvIHRyZWF0IGFsbCBOb2RlTWFuYWdlcnMgdGhlIHNhbWUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5wcm9jZXNzaW5nLkVsZW1lbnRNYW5hZ2VyfSBwYXJlbnQgVGhlIHBhcmVudCBFbGVtZW50TWFuYWdlci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE5vZGVNYW5hZ2VyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG5vZGVNYXAsIHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlTWFwID0gbm9kZU1hcDtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGwocGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNDbG9uZSA9IHBhcmVudC5pc0Nsb25lO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0cmlldmVzIHRoZSBwYXJlbnQgY29udHJvbCBhc3NvY2lhdGVkIHdpdGggdGhlIHBhcmVudCBtYW5hZ2VyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTm9kZU1hbmFnZXIucHJvdG90eXBlLmdldFBhcmVudENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQsIGNvbnRyb2w7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaXNOdWxsKGNvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChwYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sID0gcGFyZW50LmdldFVpQ29udHJvbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENsb25lcyB0aGlzIE5vZGVNYW5hZ2VyIHdpdGggdGhlIG5ldyBub2RlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge05vZGV9IG5ld05vZGUgVGhlIG5ldyBub2RlIGFzc29jaWF0ZWQgd2l0aCB0aGUgbmV3IG1hbmFnZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5wcm9jZXNzaW5nLkVsZW1lbnRNYW5hZ2VyfSBwYXJlbnRNYW5hZ2VyIFRoZSBwYXJlbnRcclxuICAgICAgICAgICAgICogRWxlbWVudE1hbmFnZXIgZm9yIHRoZSBjbG9uZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE5vZGVNYW5hZ2VyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIChuZXdOb2RlLCBwYXJlbnRNYW5hZ2VyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbiB1c2VkIGZvciBkYXRhLWJpbmRpbmcgYSBkYXRhIGNvbnRleHQgdG8gdGhlIERPTS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE5vZGVNYW5hZ2VyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgICAgICAgICByZXR1cm4gTm9kZU1hbmFnZXI7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBwcm9jZXNzaW5nLk5vZGVNYW5hZ2VyID0gTm9kZU1hbmFnZXI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gSU5vZGVNYW5hZ2VyU3RhdGljKF9yZWdleCwgX0NvbnRleHRNYW5hZ2VyLCBfcGFyc2VyLCBfVGVtcGxhdGVDb250cm9sRmFjdG9yeSwgX2xvZykge1xyXG4gICAgICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIG5vdCBhZHZpc2VkIGJ5IFR5cGVTY3JpcHQsIGJ1dCB3ZSB3YW50IHRvIGRvIHRoaXMuIFxyXG4gICAgICAgICAgICBOb2RlTWFuYWdlci5fbWFya3VwUmVnZXggPSBfcmVnZXgubWFya3VwUmVnZXg7XHJcbiAgICAgICAgICAgIE5vZGVNYW5hZ2VyLl9uZXdMaW5lUmVnZXggPSBfcmVnZXgubmV3TGluZVJlZ2V4O1xyXG4gICAgICAgICAgICBOb2RlTWFuYWdlci5fQ29udGV4dE1hbmFnZXIgPSBfQ29udGV4dE1hbmFnZXI7XHJcbiAgICAgICAgICAgIE5vZGVNYW5hZ2VyLl9wYXJzZXIgPSBfcGFyc2VyO1xyXG4gICAgICAgICAgICBOb2RlTWFuYWdlci5fVGVtcGxhdGVDb250cm9sRmFjdG9yeSA9IF9UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5O1xyXG4gICAgICAgICAgICBOb2RlTWFuYWdlci5fbG9nID0gX2xvZztcclxuICAgICAgICAgICAgcmV0dXJuIE5vZGVNYW5hZ2VyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcm9jZXNzaW5nLklOb2RlTWFuYWdlclN0YXRpYyA9IElOb2RlTWFuYWdlclN0YXRpYztcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fTm9kZU1hbmFnZXJTdGF0aWMsIElOb2RlTWFuYWdlclN0YXRpYywgW1xyXG4gICAgICAgICAgICBfX1JlZ2V4LFxyXG4gICAgICAgICAgICBfX0NvbnRleHRNYW5hZ2VyU3RhdGljLFxyXG4gICAgICAgICAgICBfX1BhcnNlcixcclxuICAgICAgICAgICAgX19UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5LFxyXG4gICAgICAgICAgICBfX0xvZ1xyXG4gICAgICAgIF0sIF9fU1RBVElDKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGNsYXNzIHVzZWQgdG8gbWFuYWdlIGVsZW1lbnQgbm9kZXMuIFByb3ZpZGVzIGEgd2F5IGZvciBjb21waWxpbmcgYW5kIGJpbmRpbmcgdGhlXHJcbiAgICAgICAgICogZWxlbWVudC90ZW1wbGF0ZS4gQWxzbyBwcm92aWRlcyBtZXRob2RzIGZvciBjbG9uaW5nIGFuXHJcbiAgICAgICAgICogRWxlbWVudE1hbmFnZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEVsZW1lbnRNYW5hZ2VyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKEVsZW1lbnRNYW5hZ2VyLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBFbGVtZW50TWFuYWdlcigpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgY2hpbGQgbWFuYWdlcnMgZm9yIHRoaXMgbWFuYWdlci5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIHR5cGUgZm9yIHRoaXMgTm9kZU1hbmFnZXIuXHJcbiAgICAgICAgICAgICAgICAgKiBJdCdzIHZhbHVlIGlzIFwiZWxlbWVudFwiLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSAnZWxlbWVudCc7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIG1hbmFnZXIgaGFzIGEgVGVtcGxhdGVDb250cm9sIHdoaWNoIGhhcyBhXHJcbiAgICAgICAgICAgICAgICAgKiByZXBsYWNlV2l0aCBwcm9wZXJ0eSBzZXQgdG8gbnVsbCBvciBlbXB0eSBzdHJpbmcuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgVGVtcGxhdGVDb250cm9sIGZvciB0aGlzIG1hbmFnZXIgaGFzIGl0cyBvd24gY29udGV4dFxyXG4gICAgICAgICAgICAgICAgICogb3IgaW5oZXJpdHMgaXQgZnJvbSBhIHBhcmVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYXNPd25Db250ZXh0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERldGVybWluZXMgaWYgdGhlIGFzc29jaWF0ZWQgRWxlbWVudCBoYXMgY29udHJvbHMgdGhhdCBuZWVkIHRvIGJlIGluc3RhbnRpYXRlZCBvciBBdHRyIG5vZGVzXHJcbiAgICAgICAgICAgICAqIGNvbnRhaW5pbmcgdGV4dCBtYXJrdXAuIElmIGNvbnRyb2xzIGV4aXN0IG9yIG1hcmt1cCBpcyBmb3VuZCBhIG5ld1xyXG4gICAgICAgICAgICAgKiBFbGVtZW50TWFuYWdlciB3aWxsIGJlIGNyZWF0ZWQsXHJcbiAgICAgICAgICAgICAqIGVsc2UgYW4gZW1wdHkgTm9kZU1hbmFnZXIgd2lsbCBiZSBhZGRlZCB0byB0aGUgQXJyYXkgb2ZcclxuICAgICAgICAgICAgICogTm9kZU1hbmFnZXJzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIEVsZW1lbnQgdG8gdXNlIHRvIGlkZW50aWZpZXIgbWFya3VwIGFuZCBjb250cm9scy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnByb2Nlc3NpbmcuRWxlbWVudE1hbmFnZXJ9IHBhcmVudD8gVGhlIHBhcmVudCBFbGVtZW50TWFuYWdlclxyXG4gICAgICAgICAgICAgKiB1c2VkIGZvciBjb250ZXh0IGluaGVyaXRhbmNlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRWxlbWVudE1hbmFnZXIuY3JlYXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIG5vZGVOYW1lID0gbmFtZSwgaW5qZWN0b3IgPSBjb250cm9sSW5qZWN0b3JzW25hbWVdIHx8IHZpZXdDb250cm9sSW5qZWN0b3JzW25hbWVdLCBub0NvbnRyb2xBdHRyaWJ1dGUgPSB0cnVlLCBoYXNVaUNvbnRyb2wgPSBmYWxzZSwgdWlDb250cm9sTm9kZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoaW5qZWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKF9fQ29udHJvbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKF9fQ29udHJvbCkudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5qZWN0b3IgPSBjb250cm9sSW5qZWN0b3JzW25hbWVdIHx8IHZpZXdDb250cm9sSW5qZWN0b3JzW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub0NvbnRyb2xBdHRyaWJ1dGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoX19BdHRyaWJ1dGVQcmVmaXggKyBfX0NvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShfX0F0dHJpYnV0ZVByZWZpeCArIF9fQ29udHJvbCkudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5qZWN0b3IgPSBjb250cm9sSW5qZWN0b3JzW25hbWVdIHx8IHZpZXdDb250cm9sSW5qZWN0b3JzW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub0NvbnRyb2xBdHRyaWJ1dGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChpbmplY3RvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdWlDb250cm9sID0gaW5qZWN0b3IuaW5qZWN0KCksIHJlc291cmNlRWxlbWVudCA9IEVsZW1lbnRNYW5hZ2VyLmxvY2F0ZVJlc291cmNlcyhlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB1aUNvbnRyb2xOb2RlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sOiB1aUNvbnRyb2wsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlRWxlbWVudDogcmVzb3VyY2VFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlTmFtZTogbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmplY3RvcjogaW5qZWN0b3JcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc1VpQ29udHJvbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vQ29udHJvbEF0dHJpYnV0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShfX0NvbnRyb2wsIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZW1lbnRUeXBlID0gdWlDb250cm9sLnJlcGxhY2VXaXRoLCByZXBsYWNlV2l0aERpdiA9IHJlcGxhY2VtZW50VHlwZSA9PT0gJ2FueScgJiYgbm9Db250cm9sQXR0cmlidXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNFbXB0eShyZXBsYWNlbWVudFR5cGUpICYmIChyZXBsYWNlbWVudFR5cGUgIT09ICdhbnknIHx8IHJlcGxhY2VXaXRoRGl2KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudFR5cGUudG9Mb3dlckNhc2UoKSAhPT0gbm9kZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VXaXRoRGl2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudFR5cGUgPSAnZGl2JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBFbGVtZW50TWFuYWdlci5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChyZXBsYWNlbWVudFR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwbGFjZW1lbnQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gcmVwbGFjZVdpdGgoZWxlbWVudCwgcmVwbGFjZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRNYXAgPSBFbGVtZW50TWFuYWdlci5fY29sbGVjdEF0dHJpYnV0ZXMoZWxlbWVudC5hdHRyaWJ1dGVzKSwgbWFuYWdlciA9IEVsZW1lbnRNYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50TWFwLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoYXNVaUNvbnRyb2wgJiYgaXNTdHJpbmcoZWxlbWVudE1hcC5jaGlsZENvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0b3IgPSBpbmplY3RhYmxlSW5qZWN0b3JzW19fVGVtcGxhdGVDb250cm9sSW5zdGFuY2VdO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc1VpQ29udHJvbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudE1hcC51aUNvbnRyb2xOb2RlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sOiBpbmplY3Rvci5pbmplY3QoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VFbGVtZW50OiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlTmFtZTogX19UZW1wbGF0ZUNvbnRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5qZWN0b3I6IGluamVjdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRNYXAudWlDb250cm9sTm9kZSA9IHVpQ29udHJvbE5vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBtYW5hZ2VyLmluaXRpYWxpemUoZWxlbWVudE1hcCwgcGFyZW50KTtcclxuICAgICAgICAgICAgICAgIGlmICghKGVsZW1lbnRNYXAuaGFzQ29udHJvbCB8fCBoYXNVaUNvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFuYWdlci5iaW5kID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBtYW5hZ2VyLnNldFVpQ29udHJvbFRlbXBsYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc1VpQ29udHJvbCA/IG51bGwgOiBtYW5hZ2VyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hbmFnZXI7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBMb29rcyB0aHJvdWdoIHRoZSBOb2RlJ3MgY2hpbGQgbm9kZXMgdG8gdHJ5IGFuZCBmaW5kIGFueVxyXG4gICAgICAgICAgICAgKiBkZWZpbmVkIFJlc291cmNlcyBpbiBhIDxwbGF0LXJlc291cmNlcz4gdGFncy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHdob3NlIGNoaWxkIG5vZGVzIG1heSBjb250YWluIFJlc291cmNlcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEVsZW1lbnRNYW5hZ2VyLmxvY2F0ZVJlc291cmNlcyA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG5vZGUuY2hpbGROb2RlcyksIGNoaWxkTm9kZSwgbm9kZU5hbWU7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlcy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVOYW1lID0gY2hpbGROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09PSBfX1Jlc291cmNlcyB8fCBub2RlTmFtZSA9PT0gJ3gtJyArIF9fUmVzb3VyY2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDbG9uZXMgYW4gRWxlbWVudE1hbmFnZXIgd2l0aCBhIG5ldyBlbGVtZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucHJvY2Vzc2luZy5FbGVtZW50TWFuYWdlcn0gc291cmNlTWFuYWdlciBUaGUgb3JpZ2luYWwgRWxlbWVudE1hbmFnZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5wcm9jZXNzaW5nLkVsZW1lbnRNYW5hZ2VyfSBwYXJlbnQgVGhlIHBhcmVudCBFbGVtZW50TWFuYWdlclxyXG4gICAgICAgICAgICAgKiBmb3IgdGhlIG5ldyBjbG9uZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBuZXcgZWxlbWVudCB0byBhc3NvY2lhdGUgd2l0aCB0aGUgY2xvbmUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5UZW1wbGF0ZUNvbnRyb2x9IG5ld0NvbnRyb2w/IEFuIG9wdGlvbmFsIGNvbnRyb2wgdG8gYXNzb2NpYXRlIHdpdGggdGhlIGNsb25lLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucHJvY2Vzc2luZy5JTm9kZU1hcH0gbm9kZU1hcD8gVGhlIHtAbGluayBwbGF0LnByb2Nlc3NpbmcuSU5vZGVNYXB9IHVzZWQgdG8gY2xvbmUgdGhpc1xyXG4gICAgICAgICAgICAgKiBFbGVtZW50TWFuYWdlci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEVsZW1lbnRNYW5hZ2VyLmNsb25lID0gZnVuY3Rpb24gKHNvdXJjZU1hbmFnZXIsIHBhcmVudCwgZWxlbWVudCwgbmV3Q29udHJvbCwgbm9kZU1hcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChub2RlTWFwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVNYXAgPSBFbGVtZW50TWFuYWdlci5fY2xvbmVOb2RlTWFwKHNvdXJjZU1hbmFnZXIubm9kZU1hcCwgZWxlbWVudCwgcGFyZW50LmdldFVpQ29udHJvbCgpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5nZXRQYXJlbnRDb250cm9sKCksIG5ld0NvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIG1hbmFnZXIgPSBFbGVtZW50TWFuYWdlci5nZXRJbnN0YW5jZSgpLCBoYXNOZXdDb250cm9sID0gIWlzTnVsbChuZXdDb250cm9sKTtcclxuICAgICAgICAgICAgICAgIG1hbmFnZXIubm9kZU1hcCA9IG5vZGVNYXA7XHJcbiAgICAgICAgICAgICAgICBtYW5hZ2VyLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKHBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaChtYW5hZ2VyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1hbmFnZXIucmVwbGFjZSA9IHNvdXJjZU1hbmFnZXIucmVwbGFjZTtcclxuICAgICAgICAgICAgICAgIG1hbmFnZXIucmVwbGFjZU5vZGVMZW5ndGggPSBzb3VyY2VNYW5hZ2VyLnJlcGxhY2VOb2RlTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgbWFuYWdlci5oYXNPd25Db250ZXh0ID0gc291cmNlTWFuYWdlci5oYXNPd25Db250ZXh0O1xyXG4gICAgICAgICAgICAgICAgbWFuYWdlci5pc0Nsb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmICghKG5vZGVNYXAuaGFzQ29udHJvbCB8fCBoYXNOZXdDb250cm9sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hbmFnZXIuYmluZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGhhc05ld0NvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICBFbGVtZW50TWFuYWdlci5fbWFuYWdlckNhY2hlLnB1dChuZXdDb250cm9sLnVpZCwgbWFuYWdlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFuYWdlcjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENsb25lcyBhbiBUZW1wbGF0ZUNvbnRyb2wgd2l0aCBhIG5ldyBJTm9kZU1hcC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnByb2Nlc3NpbmcuSU5vZGVNYXB9IHNvdXJjZU1hcCBUaGUgc291cmNlIElOb2RlTWFwIHVzZWQgdG8gY2xvbmUgdGhlXHJcbiAgICAgICAgICAgICAqIFRlbXBsYXRlQ29udHJvbC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlRlbXBsYXRlQ29udHJvbH0gcGFyZW50IFRoZSBwYXJlbnQgY29udHJvbCBvZiB0aGUgY2xvbmUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFbGVtZW50TWFuYWdlci5jbG9uZVVpQ29udHJvbCA9IGZ1bmN0aW9uIChzb3VyY2VNYXAsIHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHVpQ29udHJvbE5vZGUgPSBzb3VyY2VNYXAudWlDb250cm9sTm9kZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwodWlDb250cm9sTm9kZSkgfHwgaXNOdWxsKHVpQ29udHJvbE5vZGUuaW5qZWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHVpQ29udHJvbCA9IHVpQ29udHJvbE5vZGUuY29udHJvbCwgbmV3VWlDb250cm9sID0gdWlDb250cm9sTm9kZS5pbmplY3Rvci5pbmplY3QoKSwgcmVzb3VyY2VzID0gRWxlbWVudE1hbmFnZXIuX1Jlc291cmNlc0ZhY3RvcnkuZ2V0SW5zdGFuY2UoKSwgYXR0cmlidXRlcyA9IEVsZW1lbnRNYW5hZ2VyLl9BdHRyaWJ1dGVzRmFjdG9yeS5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICAgICAgbmV3VWlDb250cm9sLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgIHBhcmVudC5jb250cm9scy5wdXNoKG5ld1VpQ29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICBuZXdVaUNvbnRyb2wuY29udHJvbHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuaW5pdGlhbGl6ZShuZXdVaUNvbnRyb2wsIHNvdXJjZU1hcC5hdHRyaWJ1dGVzKTtcclxuICAgICAgICAgICAgICAgIG5ld1VpQ29udHJvbC5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcclxuICAgICAgICAgICAgICAgIHJlc291cmNlcy5pbml0aWFsaXplKG5ld1VpQ29udHJvbCwgdWlDb250cm9sLnJlc291cmNlcyk7XHJcbiAgICAgICAgICAgICAgICBuZXdVaUNvbnRyb2wucmVzb3VyY2VzID0gcmVzb3VyY2VzO1xyXG4gICAgICAgICAgICAgICAgRWxlbWVudE1hbmFnZXIuX1Jlc291cmNlc0ZhY3RvcnkuYWRkQ29udHJvbFJlc291cmNlcyhuZXdVaUNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGwodWlDb250cm9sLmlubmVyVGVtcGxhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VWlDb250cm9sLmlubmVyVGVtcGxhdGUgPSB1aUNvbnRyb2wuaW5uZXJUZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuZXdVaUNvbnRyb2wudHlwZSA9IHVpQ29udHJvbC50eXBlO1xyXG4gICAgICAgICAgICAgICAgbmV3VWlDb250cm9sLmJpbmRhYmxlVGVtcGxhdGVzID0gRWxlbWVudE1hbmFnZXIuX0JpbmRhYmxlVGVtcGxhdGVzRmFjdG9yeS5jcmVhdGUobmV3VWlDb250cm9sLCB1aUNvbnRyb2wuYmluZGFibGVUZW1wbGF0ZXMpO1xyXG4gICAgICAgICAgICAgICAgbmV3VWlDb250cm9sLnJlcGxhY2VXaXRoID0gdWlDb250cm9sLnJlcGxhY2VXaXRoO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1VpQ29udHJvbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENyZWF0ZXMgbmV3IElOb2RlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBlbGVtZW50XHJcbiAgICAgICAgICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgSU5vZGVNYXAgb3IgdGhlIHBhc3NlZC1pbiBlbGVtZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucHJvY2Vzc2luZy5JTm9kZU1hcH0gbm9kZU1hcCBUaGUgSU5vZGVNYXAgdGhhdCBjb250YWluc1xyXG4gICAgICAgICAgICAgKiB0aGUgYXR0cmlidXRlIG5vZGVzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVGVtcGxhdGVDb250cm9sfSBwYXJlbnQgVGhlIHBhcmVudCBUZW1wbGF0ZUNvbnRyb2wgZm9yXHJcbiAgICAgICAgICAgICAqIHRoZSBuZXdseSBjcmVhdGVkIGNvbnRyb2xzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVGVtcGxhdGVDb250cm9sfSB0ZW1wbGF0ZUNvbnRyb2w/IFRoZSBUZW1wbGF0ZUNvbnRyb2xcclxuICAgICAgICAgICAgICogbGlua2VkIHRvIHRoZXNlIGNyZWF0ZWQgY29udHJvbHMgaWYgb25lIGV4aXN0cy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBuZXdFbGVtZW50PyBBbiBvcHRpb25hbCBlbGVtZW50IHRvIHVzZSBmb3IgYXR0cmlidXRlcyAodXNlZCBpbiBjbG9uaW5nKS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBpc0Nsb25lPyBXaGV0aGVyIG9yIG5vdCB0aGVzZSBjb250cm9scyBhcmUgY2xvbmVzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRWxlbWVudE1hbmFnZXIuY3JlYXRlQXR0cmlidXRlQ29udHJvbHMgPSBmdW5jdGlvbiAobm9kZU1hcCwgcGFyZW50LCB0ZW1wbGF0ZUNvbnRyb2wsIG5ld0VsZW1lbnQsIGlzQ2xvbmUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IG5vZGVNYXAubm9kZXMsIGVsZW1lbnQgPSBpc0Nsb25lID09PSB0cnVlID8gbmV3RWxlbWVudCA6IG5vZGVNYXAuZWxlbWVudCwgYXR0cmlidXRlcztcclxuICAgICAgICAgICAgICAgIGlmIChpc05vZGUoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0Nsb25lID09PSB0cnVlID8gRWxlbWVudE1hbmFnZXIuX2NvcHlBdHRyaWJ1dGVOb2Rlcyhub2RlcykgOiBbXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcyA9IGVsZW1lbnQuYXR0cmlidXRlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IG5vZGVNYXAuYXR0cmlidXRlcywgbmV3QXR0cmlidXRlcywgbm9kZSwgaW5qZWN0b3IsIGNvbnRyb2wsIG5ld05vZGVzID0gW10sIGxlbmd0aCA9IG5vZGVzLmxlbmd0aCwgbm9kZU5hbWUsIGk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZU5hbWUgPSBub2RlLm5vZGVOYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIGluamVjdG9yID0gbm9kZS5pbmplY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChpbmplY3RvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbCA9IGluamVjdG9yLmluamVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNvbnRyb2wgPSBjb250cm9sO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbC5lbGVtZW50ID0gZWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3QXR0cmlidXRlcyA9IEVsZW1lbnRNYW5hZ2VyLl9BdHRyaWJ1dGVzRmFjdG9yeS5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdBdHRyaWJ1dGVzLmluaXRpYWxpemUoY29udHJvbCwgYXR0cnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sLmF0dHJpYnV0ZXMgPSBuZXdBdHRyaWJ1dGVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sLnR5cGUgPSBub2RlTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1N0cmluZyhjb250cm9sLnVpZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2wudWlkID0gdW5pcXVlSWQoX19QbGF0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sLnRlbXBsYXRlQ29udHJvbCA9IHRlbXBsYXRlQ29udHJvbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2xvbmUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sOiBjb250cm9sLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnM6IG5vZGUuZXhwcmVzc2lvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlOiAhYXR0cmlidXRlcyA/IG51bGwgOiAoYXR0cmlidXRlcy5nZXROYW1lZEl0ZW0obm9kZU5hbWUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oX19BdHRyaWJ1dGVQcmVmaXggKyBub2RlTmFtZSkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZU5hbWU6IG5vZGVOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5qZWN0b3I6IGluamVjdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChjb250cm9sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc051bGwocGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5jb250cm9scy5wdXNoKGNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oY29udHJvbC5pbml0aWFsaXplKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2wuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0Nsb25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYUNvbnRyb2wgPSBhLmNvbnRyb2wsIGJDb250cm9sID0gYi5jb250cm9sO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGFDb250cm9sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNOdWxsKGJDb250cm9sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhUHJpb3JpdHkgPSBpc051bWJlcihhQ29udHJvbC5wcmlvcml0eSkgPyBhQ29udHJvbC5wcmlvcml0eSA6IDAsIGJQcmlvcml0eSA9IGlzTnVtYmVyKGJDb250cm9sLnByaW9yaXR5KSA/IGJDb250cm9sLnByaW9yaXR5IDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJQcmlvcml0eSAtIGFQcmlvcml0eTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sID0gbm9kZS5jb250cm9sO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChjb250cm9sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc051bGwocGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5jb250cm9scy5wdXNoKGNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oY29udHJvbC5pbml0aWFsaXplKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2wuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld05vZGVzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiBhbiBFbGVtZW50TWFuYWdlci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEVsZW1lbnRNYW5hZ2VyLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hbmFnZXIgPSBuZXcgRWxlbWVudE1hbmFnZXIoKTtcclxuICAgICAgICAgICAgICAgIG1hbmFnZXIuX1Byb21pc2UgPSBhY3F1aXJlKF9fUHJvbWlzZSk7XHJcbiAgICAgICAgICAgICAgICBtYW5hZ2VyLl9Db250ZXh0TWFuYWdlciA9IE5vZGVNYW5hZ2VyLl9Db250ZXh0TWFuYWdlcjtcclxuICAgICAgICAgICAgICAgIG1hbmFnZXIuX2NvbXBpbGVyID0gYWNxdWlyZShfX0NvbXBpbGVyKTtcclxuICAgICAgICAgICAgICAgIG1hbmFnZXIuX0NvbW1lbnRNYW5hZ2VyRmFjdG9yeSA9IGFjcXVpcmUoX19Db21tZW50TWFuYWdlckZhY3RvcnkpO1xyXG4gICAgICAgICAgICAgICAgbWFuYWdlci5fQ29udHJvbEZhY3RvcnkgPSBhY3F1aXJlKF9fQ29udHJvbEZhY3RvcnkpO1xyXG4gICAgICAgICAgICAgICAgbWFuYWdlci5fVGVtcGxhdGVDb250cm9sRmFjdG9yeSA9IE5vZGVNYW5hZ2VyLl9UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5O1xyXG4gICAgICAgICAgICAgICAgbWFuYWdlci5fQmluZGFibGVUZW1wbGF0ZXNGYWN0b3J5ID0gRWxlbWVudE1hbmFnZXIuX0JpbmRhYmxlVGVtcGxhdGVzRmFjdG9yeTtcclxuICAgICAgICAgICAgICAgIG1hbmFnZXIuX2xvZyA9IEVsZW1lbnRNYW5hZ2VyLl9sb2c7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFuYWdlcjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEl0ZXJhdGVzIG92ZXIgdGhlIGF0dHJpYnV0ZXMgKE5hbWVkTm9kZU1hcCksIGNyZWF0aW5nIGFuIElOb2RlTWFwLlxyXG4gICAgICAgICAgICAgKiBUaGlzIG1hcCB3aWxsIGNvbnRhaW4gaW5qZWN0b3JzIGZvciBhbGwgdGhlIENvbnRyb2xzIGFzIHdlbGwgYXMgcGFyc2VkIGV4cHJlc3Npb25zXHJcbiAgICAgICAgICAgICAqIGFuZCBpZGVudGlmaWVycyBmb3VuZCBmb3IgZWFjaCBBdHRyaWJ1dGUgKHVzZWZ1bCBmb3IgZGF0YSBiaW5kaW5nKS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtOYW1lZE5vZGVNYXB9IGF0dHJpYnV0ZXMgVGhlIGF0dHJpYnV0ZXMgdXNlZCB0byBjcmVhdGUgdGhlIElOb2RlTWFwLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRWxlbWVudE1hbmFnZXIuX2NvbGxlY3RBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGF0dHJpYnV0ZXMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IFtdLCBhdHRyaWJ1dGUsIG5hbWUsIHZhbHVlLCBjaGlsZENvbnRleHQsIGNoaWxkSWRlbnRpZmllciwgaGFzTWFya3VwLCBoYXNNYXJrdXBGbiA9IE5vZGVNYW5hZ2VyLmhhc01hcmt1cCwgZmluZE1hcmt1cCA9IE5vZGVNYW5hZ2VyLmZpbmRNYXJrdXAsIF9wYXJzZXIgPSBOb2RlTWFuYWdlci5fcGFyc2VyLCBleHByZXNzaW9ucywgaGFzQ29udHJvbCA9IGZhbHNlLCBpbmplY3RvciwgbGVuZ3RoID0gYXR0cmlidXRlcy5sZW5ndGgsIGNvbnRyb2xBdHRyaWJ1dGVzID0ge307XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlID0gYXR0cmlidXRlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGF0dHJpYnV0ZS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gYXR0cmlidXRlLm5hbWUucmVwbGFjZSgvXmRhdGEtL2ksICcnKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGluamVjdG9yID0gY29udHJvbEluamVjdG9yc1tuYW1lXSB8fCB2aWV3Q29udHJvbEluamVjdG9yc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gX19Db250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkQ29udGV4dCA9IF9wYXJzZXIucGFyc2UodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkQ29udGV4dC5pZGVudGlmaWVycy5sZW5ndGggIT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFbGVtZW50TWFuYWdlci5fbG9nLndhcm4oJ0luY29ycmVjdCAnICsgX19Db250ZXh0ICsgJzogJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICsgJywgbXVzdCBjb250YWluIGEgc2luZ2xlIGlkZW50aWZpZXIuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZElkZW50aWZpZXIgPSBjaGlsZENvbnRleHQuaWRlbnRpZmllcnNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmFtZSAhPT0gX19Db250cm9sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc01hcmt1cCA9IGhhc01hcmt1cEZuKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMgPSBoYXNNYXJrdXAgPyBmaW5kTWFya3VwKHZhbHVlKSA6IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc0NvbnRyb2wgJiYgKGhhc01hcmt1cCB8fCAhaXNOdWxsKGluamVjdG9yKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NvbnRyb2wgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IGF0dHJpYnV0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVOYW1lOiBuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnM6IGV4cHJlc3Npb25zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5qZWN0b3I6IGluamVjdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sQXR0cmlidXRlc1tjYW1lbENhc2UobmFtZSldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogY29udHJvbEF0dHJpYnV0ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZXM6IG5vZGVzLFxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkQ29udGV4dDogY2hpbGRJZGVudGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgICAgIGhhc0NvbnRyb2w6IGhhc0NvbnRyb2xcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBVc2VkIHRvIGNvcHkgdGhlIGF0dHJpYnV0ZSBub2RlcyBkdXJpbmcgdGhlIGNsb25pbmcgcHJvY2Vzcy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxwbGF0LnByb2Nlc3NpbmcuSU5vZGU+fSBub2RlcyBUaGUgY29tcGlsZWQgSU5vZGVzXHJcbiAgICAgICAgICAgICAqIHRvIGJlIGNsb25lZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEVsZW1lbnRNYW5hZ2VyLl9jb3B5QXR0cmlidXRlTm9kZXMgPSBmdW5jdGlvbiAobm9kZXMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdOb2RlcyA9IFtdLCBsZW5ndGggPSBub2Rlcy5sZW5ndGgsIG5vZGU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld05vZGVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uczogbm9kZS5leHByZXNzaW9ucyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZU5hbWU6IG5vZGUubm9kZU5hbWVcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdOb2RlcztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENsb25lcyBhbiBJTm9kZSB3aXRoIGEgbmV3IG5vZGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5wcm9jZXNzaW5nLklOb2RlfSBzb3VyY2VOb2RlIFRoZSBvcmlnaW5hbCBJTm9kZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBuZXcgbm9kZSB1c2VkIGZvciBjbG9uaW5nLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVGVtcGxhdGVDb250cm9sfSBuZXdDb250cm9sPyBBbiBvcHRpb25hbCBuZXcgY29udHJvbCB0byBhc3NvY2lhdGUgd2l0aCB0aGUgY2xvbmVkIG5vZGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFbGVtZW50TWFuYWdlci5fY2xvbmVOb2RlID0gZnVuY3Rpb24gKHNvdXJjZU5vZGUsIG5vZGUsIG5ld0NvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbDogbmV3Q29udHJvbCxcclxuICAgICAgICAgICAgICAgICAgICBpbmplY3Rvcjogc291cmNlTm9kZS5pbmplY3RvcixcclxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uczogc291cmNlTm9kZS5leHByZXNzaW9ucyxcclxuICAgICAgICAgICAgICAgICAgICBub2RlOiBub2RlLFxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVOYW1lOiBzb3VyY2VOb2RlLm5vZGVOYW1lXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2xvbmVzIGFuIElOb2RlTWFwIHdpdGggYSBuZXcgZWxlbWVudC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnByb2Nlc3NpbmcuSU5vZGVNYXB9IHNvdXJjZU1hcCBUaGUgb3JpZ2luYWwgSU5vZGVNYXAuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgbmV3IEVsZW1lbnQgdXNlZCBmb3IgY2xvbmluZy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlRlbXBsYXRlQ29udHJvbH0gcGFyZW50IFRoZSBUZW1wbGF0ZUNvbnRyb2wgYXNzb2NpYXRlZFxyXG4gICAgICAgICAgICAgKiB3aXRoIHRoZSBwYXJlbnQgRWxlbWVudE1hbmFnZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5UZW1wbGF0ZUNvbnRyb2x9IG5ld0NvbnRyb2w/IEFuIG9wdGlvbmFsIG5ldyBUZW1wbGF0ZUNvbnRyb2xcclxuICAgICAgICAgICAgICogdG8gYXNzb2NpYXRlIHdpdGggdGhlIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFbGVtZW50TWFuYWdlci5fY2xvbmVOb2RlTWFwID0gZnVuY3Rpb24gKHNvdXJjZU1hcCwgZWxlbWVudCwgcGFyZW50LCBuZXdDb250cm9sKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGFzQ29udHJvbCA9IHNvdXJjZU1hcC5oYXNDb250cm9sLCBub2RlTWFwID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNvdXJjZU1hcC5hdHRyaWJ1dGVzLFxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkQ29udGV4dDogc291cmNlTWFwLmNoaWxkQ29udGV4dCxcclxuICAgICAgICAgICAgICAgICAgICBub2RlczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICB1aUNvbnRyb2xOb2RlOiAhaXNOdWxsKHNvdXJjZU1hcC51aUNvbnRyb2xOb2RlKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEVsZW1lbnRNYW5hZ2VyLl9jbG9uZU5vZGUoc291cmNlTWFwLnVpQ29udHJvbE5vZGUsIGVsZW1lbnQsIG5ld0NvbnRyb2wpIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBoYXNDb250cm9sOiBoYXNDb250cm9sXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc0NvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlTWFwLm5vZGVzID0gRWxlbWVudE1hbmFnZXIuY3JlYXRlQXR0cmlidXRlQ29udHJvbHMoc291cmNlTWFwLCBwYXJlbnQsIG5ld0NvbnRyb2wsIGVsZW1lbnQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVNYXA7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDbG9uZXMgdGhlIEVsZW1lbnRNYW5hZ2VyIHdpdGggYSBuZXcgbm9kZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtOb2RlfSBuZXdOb2RlIFRoZSBuZXcgZWxlbWVudCB1c2VkIHRvIGNsb25lIHRoZSBFbGVtZW50TWFuYWdlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnByb2Nlc3NpbmcuRWxlbWVudE1hbmFnZXJ9IHBhcmVudE1hbmFnZXIgVGhlIHBhcmVudCBtYW5hZ2VyIGZvciB0aGUgY2xvbmUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5wcm9jZXNzaW5nLklOb2RlTWFwfSBub2RlTWFwPyBBbiBvcHRpb25hbCBJTm9kZU1hcCB0byBjbG9uZSBhIHVpIGNvbnRyb2wgaWYgbmVlZGVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRWxlbWVudE1hbmFnZXIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKG5ld05vZGUsIHBhcmVudE1hbmFnZXIsIG5vZGVNYXApIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZE5vZGVzLCBjbG9uZWRNYW5hZ2VyLCByZXBsYWNlID0gdGhpcy5yZXBsYWNlLCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4sIG5ld0NvbnRyb2wgPSAhaXNOdWxsKG5vZGVNYXApID8gbm9kZU1hcC51aUNvbnRyb2xOb2RlLmNvbnRyb2wgOiBudWxsLCBuZXdDb250cm9sRXhpc3RzID0gIWlzTnVsbChuZXdDb250cm9sKSwgc3RhcnROb2RlTWFuYWdlciwgZW5kTm9kZU1hbmFnZXI7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW5ld0NvbnRyb2xFeGlzdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgbmV3IGNvbnRyb2wgXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udHJvbCA9IEVsZW1lbnRNYW5hZ2VyLmNsb25lVWlDb250cm9sKHRoaXMubm9kZU1hcCwgKHBhcmVudE1hbmFnZXIuZ2V0VWlDb250cm9sKCkgfHwgcGFyZW50TWFuYWdlci5nZXRQYXJlbnRDb250cm9sKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdDb250cm9sRXhpc3RzID0gIWlzTnVsbChuZXdDb250cm9sKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVmaW5pdGVseSBoYXZlIG5ld0NvbnRyb2wgXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gbmV3Tm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXMsIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsIHN0YXJ0SW5kZXggPSBhcnJheVByb3RvLmluZGV4T2YuY2FsbChub2RlcywgbmV3Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlcyA9IGFycmF5UHJvdG8uc2xpY2UuY2FsbChub2Rlcywgc3RhcnRJbmRleCArIDEsIHN0YXJ0SW5kZXggKyB0aGlzLnJlcGxhY2VOb2RlTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICBjbG9uZWRNYW5hZ2VyID0gRWxlbWVudE1hbmFnZXIuY2xvbmUodGhpcywgcGFyZW50TWFuYWdlciwgbnVsbCwgbmV3Q29udHJvbCwgbm9kZU1hcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udHJvbC5lbGVtZW50Tm9kZXMgPSBjaGlsZE5vZGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRyb2wuc3RhcnROb2RlID0gbmV3Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdDb250cm9sLmVuZE5vZGUgPSBjaGlsZE5vZGVzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZU1hbmFnZXIgPSBjaGlsZHJlbi5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZE5vZGVNYW5hZ2VyID0gY2hpbGRyZW4uc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydE5vZGVNYW5hZ2VyLmNsb25lKG5ld0NvbnRyb2wuc3RhcnROb2RlLCBjbG9uZWRNYW5hZ2VyKTtcclxuICAgICAgICAgICAgICAgICAgICBlbmROb2RlTWFuYWdlci5jbG9uZShuZXdDb250cm9sLmVuZE5vZGUsIGNsb25lZE1hbmFnZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKG5ld0NvbnRyb2wuaW5pdGlhbGl6ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29udHJvbC5pbml0aWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG5ld05vZGUuY2hpbGROb2Rlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkTWFuYWdlciA9IEVsZW1lbnRNYW5hZ2VyLmNsb25lKHRoaXMsIHBhcmVudE1hbmFnZXIsIG5ld05vZGUsIG5ld0NvbnRyb2wsIG5vZGVNYXApO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVNYXAgPSBjbG9uZWRNYW5hZ2VyLm5vZGVNYXA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0NvbnRyb2xFeGlzdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29udHJvbC5lbGVtZW50ID0gbmV3Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24obmV3Q29udHJvbC5pbml0aWFsaXplKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29udHJvbC5pbml0aWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoLCBjaGlsZE5vZGVPZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNsb25lIGNoaWxkcmVuIFxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZU9mZnNldCArPSBjaGlsZHJlbltpXS5jbG9uZShjaGlsZE5vZGVzW2NoaWxkTm9kZU9mZnNldF0sIGNsb25lZE1hbmFnZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi51bnNoaWZ0KGVuZE5vZGVNYW5hZ2VyKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi51bnNoaWZ0KHN0YXJ0Tm9kZU1hbmFnZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZE5vZGVPZmZzZXQgKyAyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbml0aWFsaXplcyBib3RoIHRoZSBtYW5hZ2VyIGl0c2VsZiBhbmQgYWxsIHRoZSBjb250cm9scyBhc3NvY2lhdGVkIHRvIHRoZSBtYW5hZ2VyJ3NcclxuICAgICAgICAgICAgICogSU5vZGVNYXAuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5wcm9jZXNzaW5nLklOb2RlTWFwfSBub2RlTWFwIEEgbWFwIG9mIHRoZSBub2RlcyAoZWxlbWVudCBhbmQgYXR0cmlidXRlcylcclxuICAgICAgICAgICAgICogYXNzb2NpYXRlZCB3aXRoIHRoaXMgRWxlbWVudE1hbmFnZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5wcm9jZXNzaW5nLkVsZW1lbnRNYW5hZ2VyfSBwYXJlbnQgVGhlIHBhcmVudFxyXG4gICAgICAgICAgICAgKiBFbGVtZW50TWFuYWdlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBkb250SW5pdGlhbGl6ZT8gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoZSBpbml0aWFsaXplIG1ldGhvZCBzaG91bGRcclxuICAgICAgICAgICAgICogYmUgY2FsbGVkIGZvciBhIFRlbXBsYXRlQ29udHJvbCBpZiBvbmUgaXMgYXR0YWNoZWRcclxuICAgICAgICAgICAgICogdG8gdGhpcyBFbGVtZW50TWFuYWdlci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEVsZW1lbnRNYW5hZ2VyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG5vZGVNYXAsIHBhcmVudCwgZG9udEluaXRpYWxpemUpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG5vZGVNYXAsIHBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbE5vZGUgPSBub2RlTWFwLnVpQ29udHJvbE5vZGUsIGhhc1VpQ29udHJvbCA9ICFpc051bGwoY29udHJvbE5vZGUpLCBjb250cm9sO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc1VpQ29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvcHVsYXRlVWlDb250cm9sKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbCA9IGNvbnRyb2xOb2RlLmNvbnRyb2w7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNPd25Db250ZXh0ID0gY29udHJvbC5oYXNPd25Db250ZXh0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVNYXAuaGFzQ29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIEVsZW1lbnRNYW5hZ2VyLmNyZWF0ZUF0dHJpYnV0ZUNvbnRyb2xzKG5vZGVNYXAsIHRoaXMuZ2V0UGFyZW50Q29udHJvbCgpLCBjb250cm9sKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghZG9udEluaXRpYWxpemUgJiYgaGFzVWlDb250cm9sICYmIGlzRnVuY3Rpb24oY29udHJvbC5pbml0aWFsaXplKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTGlua3MgdGhlIGRhdGEgY29udGV4dCB0byB0aGUgRE9NIChkYXRhLWJpbmRpbmcpLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRWxlbWVudE1hbmFnZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGVNYXAgPSB0aGlzLm5vZGVNYXAsIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50Q29udHJvbCgpLCBjb250cm9sTm9kZSA9IG5vZGVNYXAudWlDb250cm9sTm9kZSwgY29udHJvbHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKGNvbnRyb2xOb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1aUNvbnRyb2xfMSA9IGNvbnRyb2xOb2RlLmNvbnRyb2wsIGNoaWxkQ29udGV4dCA9IG5vZGVNYXAuY2hpbGRDb250ZXh0LCBnZXRNYW5hZ2VyID0gdGhpcy5fQ29udGV4dE1hbmFnZXIuZ2V0TWFuYWdlciwgY29udGV4dE1hbmFnZXJfMSwgYWJzb2x1dGVDb250ZXh0UGF0aF8xID0gaXNOdWxsKHBhcmVudCkgPyBfX0NPTlRFWFQgOiBwYXJlbnQuYWJzb2x1dGVDb250ZXh0UGF0aCwgX1RlbXBsYXRlQ29udHJvbEZhY3RvcnkgPSB0aGlzLl9UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5LCBpbmhlcml0c0NvbnRleHQgPSAhdWlDb250cm9sXzEuaGFzT3duQ29udGV4dDtcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9scy5wdXNoKHVpQ29udHJvbF8xKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5oZXJpdHNDb250ZXh0ICYmICFpc051bGwoY2hpbGRDb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRDb250ZXh0WzBdID09PSAnQCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcGxpdCA9IGNoaWxkQ29udGV4dC5zcGxpdCgnLicpLCB0b3BJZGVudGlmaWVyID0gc3BsaXQuc2hpZnQoKSwgYWxpYXMgPSB0b3BJZGVudGlmaWVyLnNsaWNlKDEpLCByZXNvdXJjZU9iaiA9IF9UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5LmZpbmRSZXNvdXJjZSh1aUNvbnRyb2xfMSwgYWxpYXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHJlc291cmNlT2JqKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNvdXJjZSA9IHJlc291cmNlT2JqLnJlc291cmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkQ29udGV4dCA9IChzcGxpdC5sZW5ndGggPiAwID8gKCcuJyArIHNwbGl0LmpvaW4oJy4nKSkgOiAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFsaWFzID09PSBfX0NPTlRFWFRfUkVTT1VSQ0UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVDb250ZXh0UGF0aF8xICs9IGNoaWxkQ29udGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYWxpYXMgPT09IF9fUk9PVF9DT05URVhUX1JFU09VUkNFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFic29sdXRlQ29udGV4dFBhdGhfMSA9IF9fQ09OVEVYVCArIGNoaWxkQ29udGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzb3VyY2UudHlwZSA9PT0gX19PQlNFUlZBQkxFX1JFU09VUkNFIHx8IHJlc291cmNlLnR5cGUgPT09IF9fTElURVJBTF9SRVNPVVJDRSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZUNvbnRleHRQYXRoXzEgPSAncmVzb3VyY2VzLicgKyBhbGlhcyArICcudmFsdWUnICsgY2hpbGRDb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aUNvbnRyb2xfMS5yb290ID0gcmVzb3VyY2VPYmouY29udHJvbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKCdPbmx5IHJlc291cmNlcyBvZiB0eXBlIFwib2JzZXJ2YWJsZVwiIGNhbiBiZSBzZXQgYXMgY29udGV4dC4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cud2FybignQ291bGQgbm90IHNldCB0aGUgY29udGV4dCBvZiAnICsgdWlDb250cm9sXzEudHlwZSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgd2l0aCB0aGUgcmVzb3VyY2Ugc3BlY2lmaWVkIGFzIFwiJyArIGNoaWxkQ29udGV4dCArICdcIi4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFic29sdXRlQ29udGV4dFBhdGhfMSArPSAnLicgKyBjaGlsZENvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc09iamVjdCh1aUNvbnRyb2xfMS5yb290KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1aUNvbnRyb2xfMS5yb290ID0gdGhpcy5fQ29udHJvbEZhY3RvcnkuZ2V0Um9vdENvbnRyb2wodWlDb250cm9sXzEpIHx8IHVpQ29udHJvbF8xO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0TWFuYWdlcl8xID0gZ2V0TWFuYWdlcih1aUNvbnRyb2xfMS5yb290KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXdhaXRDb250ZXh0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluaGVyaXRzQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1aUNvbnRyb2xfMS5jb250ZXh0ID0gY29udGV4dE1hbmFnZXJfMS5nZXRDb250ZXh0KGFic29sdXRlQ29udGV4dFBhdGhfMS5zcGxpdCgnLicpLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0Q29udGV4dCA9IGlzVW5kZWZpbmVkKHVpQ29udHJvbF8xLmNvbnRleHQpICYmICF0aGlzLl9CaW5kYWJsZVRlbXBsYXRlc0ZhY3RvcnkuaXNCb3VuZENvbnRyb2wodWlDb250cm9sXzEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVDb250ZXh0UGF0aF8xID0gX19DT05URVhUO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXdhaXRDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dFByb21pc2UgPSBuZXcgdGhpcy5fUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlTGlzdGVuZXIgPSBjb250ZXh0TWFuYWdlcl8xLm9ic2VydmUoYWJzb2x1dGVDb250ZXh0UGF0aF8xLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWlkOiB1aUNvbnRyb2xfMS51aWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXI6IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKG5ld1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpQ29udHJvbF8xLmNvbnRleHQgPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2JlZm9yZUxvYWQodWlDb250cm9sXzEsIGFic29sdXRlQ29udGV4dFBhdGhfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9iZWZvcmVMb2FkKHVpQ29udHJvbF8xLCBhYnNvbHV0ZUNvbnRleHRQYXRoXzEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX29ic2VydmVDb250cm9sSWRlbnRpZmllcnMobm9kZU1hcC5ub2RlcywgcGFyZW50LCBjb250cm9scywgbm9kZU1hcC5lbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9scztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIHRlbXBsYXRlIGZvciBhbiBtYW5hZ2VyIGJ5IG9idGFpbmluZyBhbnkgbmVlZGVkIEhUTUwgdGVtcGxhdGVzIGFuZFxyXG4gICAgICAgICAgICAgKiBjYWxsaW5nIGl0cyBhc3NvY2lhdGVkIFRlbXBsYXRlQ29udHJvbCdzXHJcbiAgICAgICAgICAgICAqIHNldFRlbXBsYXRlIG1ldGhvZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlVXJsPyBUaGUgVVJMIGZvciB0aGUgYXNzb2NpYXRlZCBUZW1wbGF0ZUNvbnRyb2wnc1xyXG4gICAgICAgICAgICAgKiBIVE1MIHRlbXBsYXRlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRWxlbWVudE1hbmFnZXIucHJvdG90eXBlLnNldFVpQ29udHJvbFRlbXBsYXRlID0gZnVuY3Rpb24gKHRlbXBsYXRlVXJsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xOb2RlID0gdGhpcy5ub2RlTWFwLnVpQ29udHJvbE5vZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChjb250cm9sTm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbF8xID0gY29udHJvbE5vZGUuY29udHJvbDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRlbXBsYXRlUHJvbWlzZSA9IHRoaXMuX1RlbXBsYXRlQ29udHJvbEZhY3RvcnkuZGV0ZXJtaW5lVGVtcGxhdGUoY29udHJvbF8xLCB0ZW1wbGF0ZVVybCkudGhlbihmdW5jdGlvbiAodGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudGVtcGxhdGVQcm9taXNlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2luaXRpYWxpemVDb250cm9sKGNvbnRyb2xfMSwgdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudGVtcGxhdGVQcm9taXNlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChlcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9CaW5kYWJsZVRlbXBsYXRlc0ZhY3RvcnkuaXNCb3VuZENvbnRyb2woY29udHJvbF8xKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlID0gYXBwZW5kQ2hpbGRyZW4oY29udHJvbF8xLmVsZW1lbnQuY2hpbGROb2Rlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5faW5pdGlhbGl6ZUNvbnRyb2woY29udHJvbF8xLCB0ZW1wbGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3N0cG9uZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGVycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbCh0aGlzLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRBbmRMb2FkKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXRyaWV2ZXMgdGhlIFRlbXBsYXRlQ29udHJvbCBpbnN0YW5jZVxyXG4gICAgICAgICAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhpcyBFbGVtZW50TWFuYWdlci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEVsZW1lbnRNYW5hZ2VyLnByb3RvdHlwZS5nZXRVaUNvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdWlDb250cm9sTm9kZSA9IHRoaXMubm9kZU1hcC51aUNvbnRyb2xOb2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbCh1aUNvbnRyb2xOb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB1aUNvbnRyb2xOb2RlLmNvbnRyb2w7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGdWxsZmlsbHMgYW55IHRlbXBsYXRlIHByb21pc2VzIGFuZCBmaW5pc2hlcyB0aGUgY29tcGlsZSBwaGFzZSBmb3IgdGhlIEhUTUwgdGVtcGxhdGUgYXNzb2NpYXRlZFxyXG4gICAgICAgICAgICAgKiB3aXRoIHRoaXMgRWxlbWVudE1hbmFnZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFbGVtZW50TWFuYWdlci5wcm90b3R5cGUuZnVsZmlsbFRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKHRoaXMudGVtcGxhdGVQcm9taXNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRlbXBsYXRlUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9mdWxmaWxsQ2hpbGRUZW1wbGF0ZXMoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9mdWxmaWxsQ2hpbGRUZW1wbGF0ZXMoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEZ1bGZpbGxzIHRoZSB0ZW1wbGF0ZSBwcm9taXNlIHByaW9yIHRvIGJpbmRpbmcgYW5kIGxvYWRpbmcgdGhlIGNvbnRyb2wuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFbGVtZW50TWFuYWdlci5wcm90b3R5cGUuZnVsZmlsbEFuZExvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnVsZmlsbFRlbXBsYXRlKCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmJpbmRBbmRMb2FkKCk7XHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3N0cG9uZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhlcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQmluZHMgY29udGV4dCB0byB0aGUgRE9NIGFuZCBsb2FkcyBjb250cm9scy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEVsZW1lbnRNYW5hZ2VyLnByb3RvdHlwZS5iaW5kQW5kTG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbHMgPSB0aGlzLmJpbmQoKSwgcHJvbWlzZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1Byb21pc2UodGhpcy5jb250ZXh0UHJvbWlzZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gdGhpcy5jb250ZXh0UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9iaW5kQ2hpbGRyZW4oKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSB0aGlzLl9iaW5kQ2hpbGRyZW4oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fbG9hZENvbnRyb2xzKGNvbnRyb2xzLCBfdGhpcy5nZXRVaUNvbnRyb2woKSk7XHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3N0cG9uZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhlcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogT2JzZXJ2ZXMgdGhlIHJvb3QgY29udGV4dCBmb3IgY29udHJvbHMgdGhhdCBzcGVjaWZ5IHRoZWlyIG93biBjb250ZXh0LCBhbmQgaW5pdGlhdGVzXHJcbiAgICAgICAgICAgICAqIGEgbG9hZCB1cG9uIGEgc3VjY2Vzc2Z1bCBzZXQgb2YgdGhlIGNvbnRleHQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5UZW1wbGF0ZUNvbnRyb2x9IHJvb3QgVGhlIFRlbXBsYXRlQ29udHJvbCBzcGVjaWZ5aW5nIGl0cyBvd24gY29udGV4dC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHsoKSA9PiBhc3luYy5JVGhlbmFibGU8dm9pZD59IGxvYWRNZXRob2QgVGhlIGZ1bmN0aW9uIHRvIGluaXRpYXRlIHRoZSBsb2FkaW5nIG9mIHRoZSByb290IGNvbnRyb2wgYW5kIGl0c1xyXG4gICAgICAgICAgICAgKiBjaGlsZHJlbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEVsZW1lbnRNYW5hZ2VyLnByb3RvdHlwZS5vYnNlcnZlUm9vdENvbnRleHQgPSBmdW5jdGlvbiAocm9vdCwgbG9hZE1ldGhvZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIGxvYWRNZXRob2QgPSBsb2FkTWV0aG9kLmJpbmQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChyb290LmNvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRNZXRob2QoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5fUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZW1vdmVMaXN0ZW5lciA9IF90aGlzLl9Db250ZXh0TWFuYWdlci5nZXRNYW5hZ2VyKHJvb3QpLm9ic2VydmUoX19DT05URVhULCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZE1ldGhvZCgpLnRoZW4ocmVzb2x2ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpZDogcm9vdC51aWRcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc3Rwb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGVycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGaW5hbGl6ZXMgYWxsIHRoZSBwcm9wZXJ0aWVzIG9uIGFuIFRlbXBsYXRlQ29udHJvbFxyXG4gICAgICAgICAgICAgKiBiZWZvcmUgbG9hZGluZy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlRlbXBsYXRlQ29udHJvbH0gdWlDb250cm9sIFRoZSBjb250cm9sIHRvIGZpbmFsaXplLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWJzb2x1dGVDb250ZXh0UGF0aCBUaGUgYWJzb2x1dGVDb250ZXh0UGF0aCBvZiB0aGUgdWlDb250cm9sLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRWxlbWVudE1hbmFnZXIucHJvdG90eXBlLl9iZWZvcmVMb2FkID0gZnVuY3Rpb24gKHVpQ29udHJvbCwgYWJzb2x1dGVDb250ZXh0UGF0aCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHRNYW5hZ2VyID0gdGhpcy5fQ29udGV4dE1hbmFnZXIuZ2V0TWFuYWdlcih1aUNvbnRyb2wucm9vdCksIF9UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5ID0gdGhpcy5fVGVtcGxhdGVDb250cm9sRmFjdG9yeTtcclxuICAgICAgICAgICAgICAgIHVpQ29udHJvbC56Q0NfX3BsYXQgPSBjb250ZXh0TWFuYWdlci5vYnNlcnZlKGFic29sdXRlQ29udGV4dFBhdGgsIHtcclxuICAgICAgICAgICAgICAgICAgICB1aWQ6IHVpQ29udHJvbC51aWQsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IF9fQ09OVEVYVF9DSEFOR0VEX1BSSU9SSVRZLFxyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyOiBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpQ29udHJvbC5jb250ZXh0ID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBfVGVtcGxhdGVDb250cm9sRmFjdG9yeS5zZXRBYnNvbHV0ZUNvbnRleHRQYXRoKHVpQ29udHJvbCwgYWJzb2x1dGVDb250ZXh0UGF0aCk7XHJcbiAgICAgICAgICAgICAgICBfVGVtcGxhdGVDb250cm9sRmFjdG9yeS5zZXRDb250ZXh0UmVzb3VyY2VzKHVpQ29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICBFbGVtZW50TWFuYWdlci5fUmVzb3VyY2VzRmFjdG9yeS5iaW5kUmVzb3VyY2VzKHVpQ29udHJvbC5yZXNvdXJjZXMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQmluZHMgY29udGV4dCB0byB0aGUgRE9NIGFuZCBjYWxscyBiaW5kQW5kTG9hZCBvbiBhbGwgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFbGVtZW50TWFuYWdlci5wcm90b3R5cGUuX2JpbmRDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4sIGxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aCwgY2hpbGQsIHByb21pc2VzID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuaGFzT3duQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0Nsb25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGNoaWxkLm9ic2VydmVSb290Q29udGV4dChjaGlsZC5nZXRVaUNvbnRyb2woKSwgY2hpbGQuYmluZEFuZExvYWQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goY2hpbGQub2JzZXJ2ZVJvb3RDb250ZXh0KGNoaWxkLmdldFVpQ29udHJvbCgpLCBjaGlsZC5mdWxmaWxsQW5kTG9hZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc1VuZGVmaW5lZChjaGlsZC5jaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChjaGlsZC5iaW5kQW5kTG9hZCgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmJpbmQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTG9hZHMgdGhlIHBvdGVudGlhbCBhdHRyaWJ1dGUgYmFzZWQgY29udHJvbHMgYXNzb2NpYXRlZCB3aXRoIHRoaXNcclxuICAgICAgICAgICAgICogRWxlbWVudE1hbmFnZXIgYW5kXHJcbiAgICAgICAgICAgICAqIGF0dGFjaGVzIHRoZSBjb3JyZXNwb25kaW5nIFRlbXBsYXRlQ29udHJvbCBpZiBhdmFpbGFibGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8cGxhdC5BdHRyaWJ1dGVDb250cm9sPn0gY29udHJvbHMgVGhlIGFycmF5IG9mIGF0dHJpYnV0ZSBiYXNlZCBjb250cm9scyB0byBsb2FkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVGVtcGxhdGVDb250cm9sfSB0ZW1wbGF0ZUNvbnRyb2wgVGhlIFRlbXBsYXRlQ29udHJvbFxyXG4gICAgICAgICAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhpcyBtYW5hZ2VyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRWxlbWVudE1hbmFnZXIucHJvdG90eXBlLl9sb2FkQ29udHJvbHMgPSBmdW5jdGlvbiAoY29udHJvbHMsIHRlbXBsYXRlQ29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGNvbnRyb2xzLmxlbmd0aCwgY29udHJvbCwgbG9hZCA9IHRoaXMuX0NvbnRyb2xGYWN0b3J5LmxvYWQsIHRlbXBsYXRlQ29udHJvbExvYWRlZCA9IGlzTnVsbCh0ZW1wbGF0ZUNvbnRyb2wpLCBwcm9taXNlLCB0ZW1wbGF0ZUNvbnRyb2xQcmlvcml0eSwgaTtcclxuICAgICAgICAgICAgICAgIGlmICh0ZW1wbGF0ZUNvbnRyb2xMb2FkZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBuZWVkIHRvIHNldCB0ZW1wbGF0ZUNvbnRyb2xQcmlvcml0eSBiZWNhdXNlIGl0IHdpbGwgbmV2ZXIgYmUgY2hlY2tlZC4gXHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJpb3JpdHkgPSB0ZW1wbGF0ZUNvbnRyb2wucHJpb3JpdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVDb250cm9sUHJpb3JpdHkgPSBpc051bWJlcihwcmlvcml0eSkgPyBwcmlvcml0eSA6IDEwMDtcclxuICAgICAgICAgICAgICAgICAgICBpID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sID0gY29udHJvbHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbC50ZW1wbGF0ZUNvbnRyb2wgPSB0ZW1wbGF0ZUNvbnRyb2w7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZW1wbGF0ZUNvbnRyb2xMb2FkZWQgJiYgdGVtcGxhdGVDb250cm9sUHJpb3JpdHkgPiBjb250cm9sLnByaW9yaXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlQ29udHJvbExvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBsb2FkKHRlbXBsYXRlQ29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxvYWQoY29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRlbXBsYXRlQ29udHJvbExvYWRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBsb2FkKHRlbXBsYXRlQ29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBvcHVsYXRlcyB0aGUgVGVtcGxhdGVDb250cm9sIHByb3BlcnRpZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbWFuYWdlclxyXG4gICAgICAgICAgICAgKiBpZiBvbmUgZXhpc3RzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRWxlbWVudE1hbmFnZXIucHJvdG90eXBlLl9wb3B1bGF0ZVVpQ29udHJvbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBub2RlTWFwID0gdGhpcy5ub2RlTWFwLCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudENvbnRyb2woKSwgY29udHJvbE5vZGUgPSBub2RlTWFwLnVpQ29udHJvbE5vZGUsIHVpQ29udHJvbCA9IGNvbnRyb2xOb2RlLmNvbnRyb2wsIHVpZCA9IHVpQ29udHJvbC51aWQsIHJlc291cmNlcyA9IHVpQ29udHJvbC5yZXNvdXJjZXMsIGVsZW1lbnQgPSBub2RlTWFwLmVsZW1lbnQsIGNoaWxkTm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlbGVtZW50LmNoaWxkTm9kZXMpLCBuZXdBdHRyaWJ1dGVzID0gRWxlbWVudE1hbmFnZXIuX0F0dHJpYnV0ZXNGYWN0b3J5LmdldEluc3RhbmNlKCksIHJlcGxhY2UgPSB0aGlzLnJlcGxhY2UgPSAodWlDb250cm9sLnJlcGxhY2VXaXRoID09PSBudWxsIHx8IHVpQ29udHJvbC5yZXBsYWNlV2l0aCA9PT0gJycpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1N0cmluZyh1aWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdWlkID0gdWlDb250cm9sLnVpZCA9IHVuaXF1ZUlkKF9fUGxhdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBFbGVtZW50TWFuYWdlci5fbWFuYWdlckNhY2hlLnB1dCh1aWQsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGwocGFyZW50KSAmJiB1aUNvbnRyb2wucGFyZW50ICE9PSBwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuY29udHJvbHMucHVzaCh1aUNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIHVpQ29udHJvbC5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihlbGVtZW50LnNldEF0dHJpYnV0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShfX0hpZGUsICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHVpQ29udHJvbC5lbGVtZW50ID0gZWxlbWVudDtcclxuICAgICAgICAgICAgICAgIHVpQ29udHJvbC5jb250cm9scyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgbmV3QXR0cmlidXRlcy5pbml0aWFsaXplKHVpQ29udHJvbCwgbm9kZU1hcC5hdHRyaWJ1dGVzKTtcclxuICAgICAgICAgICAgICAgIHVpQ29udHJvbC5hdHRyaWJ1dGVzID0gbmV3QXR0cmlidXRlcztcclxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChyZXNvdXJjZXMpICYmIGlzRnVuY3Rpb24ocmVzb3VyY2VzLmFkZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZXMuYWRkKGNvbnRyb2xOb2RlLnJlc291cmNlRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZXMgPSBFbGVtZW50TWFuYWdlci5fUmVzb3VyY2VzRmFjdG9yeS5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlcy5pbml0aWFsaXplKHVpQ29udHJvbCwgY29udHJvbE5vZGUucmVzb3VyY2VFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB1aUNvbnRyb2wucmVzb3VyY2VzID0gcmVzb3VyY2VzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgRWxlbWVudE1hbmFnZXIuX1Jlc291cmNlc0ZhY3RvcnkuYWRkQ29udHJvbFJlc291cmNlcyh1aUNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgdWlDb250cm9sLnR5cGUgPSBjb250cm9sTm9kZS5ub2RlTmFtZTtcclxuICAgICAgICAgICAgICAgIHVpQ29udHJvbC5iaW5kYWJsZVRlbXBsYXRlcyA9IHVpQ29udHJvbC5iaW5kYWJsZVRlbXBsYXRlcyB8fCB0aGlzLl9CaW5kYWJsZVRlbXBsYXRlc0ZhY3RvcnkuY3JlYXRlKHVpQ29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGggPiAwICYmICghaXNFbXB0eSh1aUNvbnRyb2wudGVtcGxhdGVTdHJpbmcpIHx8ICFpc0VtcHR5KHVpQ29udHJvbC50ZW1wbGF0ZVVybCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdWlDb250cm9sLmlubmVyVGVtcGxhdGUgPSBhcHBlbmRDaGlsZHJlbihjaGlsZE5vZGVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwbGFjZUVsZW1lbnQodWlDb250cm9sLCBub2RlTWFwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlbW92ZXMgdGhlIFRlbXBsYXRlQ29udHJvbCdzIGVsZW1lbnQuIENhbGxlZCBpZiBpdHMgcmVwbGFjZVdpdGggcHJvcGVydHkgaXNcclxuICAgICAgICAgICAgICogbnVsbCBvciBlbXB0eSBzdHJpbmcuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5UZW1wbGF0ZUNvbnRyb2x9IGNvbnRyb2wgVGhlIFRlbXBsYXRlQ29udHJvbCB3aG9zZSBlbGVtZW50XHJcbiAgICAgICAgICAgICAqIHdpbGwgYmUgcmVtb3ZlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnByb2Nlc3NpbmcuSU5vZGVNYXB9IG5vZGVNYXAgVGhlIElOb2RlTWFwIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1hbmFnZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFbGVtZW50TWFuYWdlci5wcm90b3R5cGUuX3JlcGxhY2VFbGVtZW50ID0gZnVuY3Rpb24gKGNvbnRyb2wsIG5vZGVNYXApIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gbm9kZU1hcC5lbGVtZW50LCBwYXJlbnROb2RlID0gZWxlbWVudC5wYXJlbnROb2RlLCBfZG9jdW1lbnQgPSBFbGVtZW50TWFuYWdlci5fZG9jdW1lbnQsIGNvbnRyb2xUeXBlID0gY29udHJvbC50eXBlLCBjb250cm9sVWlkID0gY29udHJvbC51aWQsIHN0YXJ0Tm9kZSA9IGNvbnRyb2wuc3RhcnROb2RlID0gX2RvY3VtZW50LmNyZWF0ZUNvbW1lbnQoY29udHJvbFR5cGUgKyAnICcgKyBjb250cm9sVWlkICsgX19TVEFSVF9OT0RFKSwgZW5kTm9kZSA9IGNvbnRyb2wuZW5kTm9kZSA9IF9kb2N1bWVudC5jcmVhdGVDb21tZW50KGNvbnRyb2xUeXBlICsgJyAnICsgY29udHJvbFVpZCArIF9fRU5EX05PREUpLCBjcmVhdGUgPSB0aGlzLl9Db21tZW50TWFuYWdlckZhY3RvcnkuY3JlYXRlO1xyXG4gICAgICAgICAgICAgICAgY3JlYXRlKHN0YXJ0Tm9kZSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICBjcmVhdGUoZW5kTm9kZSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShzdGFydE5vZGUsIGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZW5kTm9kZSwgZWxlbWVudC5uZXh0U2libGluZyk7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sLmVsZW1lbnROb2RlcyA9IHJlcGxhY2UoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sLmVsZW1lbnQgPSBub2RlTWFwLmVsZW1lbnQgPSBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBjb250cm9sJ3MgdGVtcGxhdGUgYW5kIGNvbXBpbGVzIHRoZSBjb250cm9sLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVGVtcGxhdGVDb250cm9sfSB1aUNvbnRyb2wgVGhlIFRlbXBsYXRlQ29udHJvbFxyXG4gICAgICAgICAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhpcyBtYW5hZ2VyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IHRlbXBsYXRlIFRoZSBhc3NvY2lhdGVkIFRlbXBsYXRlQ29udHJvbCdzXHJcbiAgICAgICAgICAgICAqIHRlbXBsYXRlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRWxlbWVudE1hbmFnZXIucHJvdG90eXBlLl9pbml0aWFsaXplQ29udHJvbCA9IGZ1bmN0aW9uICh1aUNvbnRyb2wsIHRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMubm9kZU1hcC5lbGVtZW50LCBcclxuICAgICAgICAgICAgICAgIC8vIGhhdmUgdG8gY2hlY2sgaWYgbnVsbCBzaW5jZSBpc051bGwgY2hlY2tzIGZvciB1bmRlZmluZWQgY2FzZSBcclxuICAgICAgICAgICAgICAgIHJlcGxhY2VFbGVtZW50ID0gdGhpcy5yZXBsYWNlLCBlbmROb2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGwodGVtcGxhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc291cmNlRWxlbWVudCA9IEVsZW1lbnRNYW5hZ2VyLmxvY2F0ZVJlc291cmNlcyh0ZW1wbGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc051bGwocmVzb3VyY2VFbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1aUNvbnRyb2wucmVzb3VyY2VzLmFkZChFbGVtZW50TWFuYWdlci5fUmVzb3VyY2VzRmFjdG9yeS5wYXJzZUVsZW1lbnQocmVzb3VyY2VFbGVtZW50KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmROb2RlID0gdWlDb250cm9sLmVuZE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpQ29udHJvbC5lbGVtZW50Tm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0ZW1wbGF0ZS5jaGlsZE5vZGVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlKGVuZE5vZGUucGFyZW50Tm9kZSwgdGVtcGxhdGUsIGVuZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIHRlbXBsYXRlLCBlbGVtZW50Lmxhc3RDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odWlDb250cm9sLnNldFRlbXBsYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVpQ29udHJvbC5zZXRUZW1wbGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29tcGlsZXIuY29tcGlsZSh1aUNvbnRyb2wuZWxlbWVudE5vZGVzLCB1aUNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydE5vZGUgPSB1aUNvbnRyb2wuc3RhcnROb2RlLCBwYXJlbnROb2RlID0gc3RhcnROb2RlLnBhcmVudE5vZGUsIGNoaWxkTm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChwYXJlbnROb2RlLmNoaWxkTm9kZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZE5vZGUgPSB1aUNvbnRyb2wuZW5kTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICB1aUNvbnRyb2wuZWxlbWVudE5vZGVzID0gY2hpbGROb2Rlcy5zbGljZShjaGlsZE5vZGVzLmluZGV4T2Yoc3RhcnROb2RlKSArIDEsIGNoaWxkTm9kZXMuaW5kZXhPZihlbmROb2RlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlTm9kZUxlbmd0aCA9IHVpQ29udHJvbC5lbGVtZW50Tm9kZXMubGVuZ3RoICsgMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVyLmNvbXBpbGUoZWxlbWVudCwgdWlDb250cm9sKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwodWlDb250cm9sLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZ1bGZpbGxBbmRMb2FkKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBPYnNlcnZlcyB0aGUgaWRlbnRpZmllcnMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbWFuYWdlcidzIElOb2Rlcy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxwbGF0LnByb2Nlc3NpbmcuSU5vZGU+fSBub2RlcyBUaGUgYXJyYXkgb2YgSU5vZGVzIHRvIGl0ZXJhdGUgdGhyb3VnaC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlRlbXBsYXRlQ29udHJvbH0gcGFyZW50IFRoZSBwYXJlbnQgVGVtcGxhdGVDb250cm9sIGZvciBjb250ZXh0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHBsYXQuQ29udHJvbD59IGNvbnRyb2xzIFRoZSBhcnJheSBvZiBjb250cm9scyB3aG9zZSBhdHRyaWJ1dGVzIHdpbGwgbmVlZCB0byBiZSB1cGRhdGVkXHJcbiAgICAgICAgICAgICAqIHVwb24gdGhlIGNvbnRleHQgY2hhbmdpbmcuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFbGVtZW50TWFuYWdlci5wcm90b3R5cGUuX29ic2VydmVDb250cm9sSWRlbnRpZmllcnMgPSBmdW5jdGlvbiAobm9kZXMsIHBhcmVudCwgY29udHJvbHMsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBub2Rlcy5sZW5ndGgsIGhhc1BhcmVudCA9ICFpc051bGwocGFyZW50KSwgbm9kZSwgY29udHJvbCwgaSA9IDAsIHJlcGxhY2UgPSB0aGlzLnJlcGxhY2UsIG1hbmFnZXJzID0gW10sIG1hbmFnZXI7XHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wgPSBub2RlLmNvbnRyb2w7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1BhcmVudCAmJiBub2RlLmV4cHJlc3Npb25zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFuYWdlciA9IEF0dHJpYnV0ZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFuYWdlcnMucHVzaChtYW5hZ2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFuYWdlci5pbml0aWFsaXplKGVsZW1lbnQsIG5vZGUsIHBhcmVudCwgY29udHJvbHMsIHJlcGxhY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBOb2RlTWFuYWdlci5vYnNlcnZlRXhwcmVzc2lvbnMobm9kZS5leHByZXNzaW9ucywgcGFyZW50LCBtYW5hZ2VyLmF0dHJpYnV0ZUNoYW5nZWQuYmluZChtYW5hZ2VyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKGNvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xzLnB1c2goY29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gbWFuYWdlcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFuYWdlcnNbaV0uYXR0cmlidXRlQ2hhbmdlZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUnVucyB0aHJvdWdoIGFsbCB0aGUgY2hpbGRyZW4gb2YgdGhpcyBtYW5hZ2VyIGFuZCBjYWxscyBmdWxmaWxsVGVtcGxhdGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFbGVtZW50TWFuYWdlci5wcm90b3R5cGUuX2Z1bGZpbGxDaGlsZFRlbXBsYXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLCBjaGlsZCwgbGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoLCBwcm9taXNlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChjaGlsZC5jaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChjaGlsZC5mdWxmaWxsVGVtcGxhdGUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UuYWxsKHByb21pc2VzKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3N0cG9uZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhlcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBFbGVtZW50TWFuYWdlci5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICAgICAgX1Byb21pc2U6IF9fUHJvbWlzZSxcclxuICAgICAgICAgICAgICAgIF9Db250ZXh0TWFuYWdlcjogX19Db250ZXh0TWFuYWdlclN0YXRpYyxcclxuICAgICAgICAgICAgICAgIF9jb21waWxlcjogX19Db21waWxlcixcclxuICAgICAgICAgICAgICAgIF9Db21tZW50TWFuYWdlckZhY3Rvcnk6IF9fQ29tbWVudE1hbmFnZXJGYWN0b3J5LFxyXG4gICAgICAgICAgICAgICAgX0NvbnRyb2xGYWN0b3J5OiBfX0NvbnRyb2xGYWN0b3J5LFxyXG4gICAgICAgICAgICAgICAgX1RlbXBsYXRlQ29udHJvbEZhY3Rvcnk6IF9fVGVtcGxhdGVDb250cm9sRmFjdG9yeSxcclxuICAgICAgICAgICAgICAgIF9CaW5kYWJsZVRlbXBsYXRlc0ZhY3Rvcnk6IF9fQmluZGFibGVUZW1wbGF0ZXNGYWN0b3J5LFxyXG4gICAgICAgICAgICAgICAgX2xvZzogX19Mb2dcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIEVsZW1lbnRNYW5hZ2VyO1xyXG4gICAgICAgIH0oTm9kZU1hbmFnZXIpKTtcclxuICAgICAgICBwcm9jZXNzaW5nLkVsZW1lbnRNYW5hZ2VyID0gRWxlbWVudE1hbmFnZXI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gSUVsZW1lbnRNYW5hZ2VyRmFjdG9yeShfZG9jdW1lbnQsIF9tYW5hZ2VyQ2FjaGUsIF9SZXNvdXJjZXNGYWN0b3J5LCBfQXR0cmlidXRlc0ZhY3RvcnksIF9CaW5kYWJsZVRlbXBsYXRlc0ZhY3RvcnksIF9sb2cpIHtcclxuICAgICAgICAgICAgRWxlbWVudE1hbmFnZXIuX2RvY3VtZW50ID0gX2RvY3VtZW50O1xyXG4gICAgICAgICAgICBFbGVtZW50TWFuYWdlci5fbWFuYWdlckNhY2hlID0gX21hbmFnZXJDYWNoZTtcclxuICAgICAgICAgICAgRWxlbWVudE1hbmFnZXIuX1Jlc291cmNlc0ZhY3RvcnkgPSBfUmVzb3VyY2VzRmFjdG9yeTtcclxuICAgICAgICAgICAgRWxlbWVudE1hbmFnZXIuX0F0dHJpYnV0ZXNGYWN0b3J5ID0gX0F0dHJpYnV0ZXNGYWN0b3J5O1xyXG4gICAgICAgICAgICBFbGVtZW50TWFuYWdlci5fQmluZGFibGVUZW1wbGF0ZXNGYWN0b3J5ID0gX0JpbmRhYmxlVGVtcGxhdGVzRmFjdG9yeTtcclxuICAgICAgICAgICAgRWxlbWVudE1hbmFnZXIuX2xvZyA9IF9sb2c7XHJcbiAgICAgICAgICAgIHJldHVybiBFbGVtZW50TWFuYWdlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvY2Vzc2luZy5JRWxlbWVudE1hbmFnZXJGYWN0b3J5ID0gSUVsZW1lbnRNYW5hZ2VyRmFjdG9yeTtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fRWxlbWVudE1hbmFnZXJGYWN0b3J5LCBJRWxlbWVudE1hbmFnZXJGYWN0b3J5LCBbXHJcbiAgICAgICAgICAgIF9fRG9jdW1lbnQsXHJcbiAgICAgICAgICAgIF9fTWFuYWdlckNhY2hlLFxyXG4gICAgICAgICAgICBfX1Jlc291cmNlc0ZhY3RvcnksXHJcbiAgICAgICAgICAgIF9fQXR0cmlidXRlc0ZhY3RvcnksXHJcbiAgICAgICAgICAgIF9fQmluZGFibGVUZW1wbGF0ZXNGYWN0b3J5LFxyXG4gICAgICAgICAgICBfX0xvZ1xyXG4gICAgICAgIF0sIF9fRkFDVE9SWSk7XHJcbiAgICAgICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX0VsZW1lbnRNYW5hZ2VySW5zdGFuY2UsIEVsZW1lbnRNYW5hZ2VyLCBudWxsLCBfX0lOU1RBTkNFKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY2xhc3MgcmVzcG9uc2libGUgZm9yIGluaXRpYWxpemluZyBhbmQgZGF0YS1iaW5kaW5nIHZhbHVlcyB0byB0ZXh0IG5vZGVzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBUZXh0TWFuYWdlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhUZXh0TWFuYWdlciwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gVGV4dE1hbmFnZXIoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogU3BlY2lmaWVzIHRoZSB0eXBlIGZvciB0aGlzIE5vZGVNYW5hZ2VyLlxyXG4gICAgICAgICAgICAgICAgICogSXQncyB2YWx1ZSBpcyBcInRleHRcIi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gJ3RleHQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEZXRlcm1pbmVzIGlmIGEgdGV4dCBub2RlIGhhcyBtYXJrdXAsIGFuZCBjcmVhdGVzIGEgVGV4dE1hbmFnZXIgaWYgaXQgZG9lcy5cclxuICAgICAgICAgICAgICogQW4gVGV4dE1hbmFnZXIgcmVzcG9uc2libGUgZm9yIG1hcmt1cCBpbiB0aGUgcGFzc2VkIGluIG5vZGUgb3IgYW4gZW1wdHlcclxuICAgICAgICAgICAgICogVGV4dE1hbmFnZXIgaWYgbm90IG1hcmt1cCBpcyBmb3VuZCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBtYW5hZ2VycyBhcnJheS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBOb2RlIHVzZWQgdG8gZmluZCBtYXJrdXAuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5wcm9jZXNzaW5nLkVsZW1lbnRNYW5hZ2VyfSBwYXJlbnQgVGhlIHBhcmVudCBFbGVtZW50TWFuYWdlclxyXG4gICAgICAgICAgICAgKiBmb3IgdGhlIG5vZGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUZXh0TWFuYWdlci5jcmVhdGUgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBub2RlLm5vZGVWYWx1ZSwgbWFuYWdlciA9IG5ldyBUZXh0TWFuYWdlcigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKE5vZGVNYW5hZ2VyLmhhc01hcmt1cCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbnNfMSA9IE5vZGVNYW5hZ2VyLmZpbmRNYXJrdXAodmFsdWUpLCBtYXBfMSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXM6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogbm9kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uczogZXhwcmVzc2lvbnNfMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIG1hbmFnZXIuaW5pdGlhbGl6ZShtYXBfMSwgcGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFuYWdlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1hbmFnZXIuaW5pdGlhbGl6ZShudWxsLCBwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgbWFuYWdlci5iaW5kID0gbm9vcDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYW5hZ2VyO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2xvbmVzIGFuIElOb2RlTWFwIHdpdGggYSBuZXcgdGV4dCBub2RlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucHJvY2Vzc2luZy5JTm9kZU1hcH0gc291cmNlTWFwIFRoZSBvcmlnaW5hbCBJTm9kZU1hcC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtOb2RlfSBuZXdOb2RlIFRoZSBuZXcgdGV4dCBub2RlIHVzZWQgZm9yIGNsb25pbmcuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUZXh0TWFuYWdlci5fY2xvbmVOb2RlTWFwID0gZnVuY3Rpb24gKHNvdXJjZU1hcCwgbmV3Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBzb3VyY2VNYXAubm9kZXNbMF0sIG5vZGVNYXAgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZXM6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uczogbm9kZS5leHByZXNzaW9ucyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVOYW1lOiBub2RlLm5vZGVOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogbmV3Tm9kZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlTWFwO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2xvbmVzIGEgVGV4dE1hbmFnZXIgd2l0aCBhIG5ldyB0ZXh0IG5vZGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5wcm9jZXNzaW5nLk5vZGVNYW5hZ2VyfSBzb3VyY2VNYW5hZ2VyIFRoZSBvcmlnaW5hbCBOb2RlTWFuYWdlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBuZXcgdGV4dCBub2RlIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBjbG9uZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnByb2Nlc3NpbmcuRWxlbWVudE1hbmFnZXJ9IHBhcmVudCBUaGUgcGFyZW50IEVsZW1lbnRNYW5hZ2VyXHJcbiAgICAgICAgICAgICAqIGZvciB0aGUgbmV3IGNsb25lLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVGV4dE1hbmFnZXIuX2Nsb25lID0gZnVuY3Rpb24gKHNvdXJjZU1hbmFnZXIsIG5vZGUsIHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hcCA9IHNvdXJjZU1hbmFnZXIubm9kZU1hcCwgbWFuYWdlciA9IG5ldyBUZXh0TWFuYWdlcigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGwobWFwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hbmFnZXIuaW5pdGlhbGl6ZShUZXh0TWFuYWdlci5fY2xvbmVOb2RlTWFwKG1hcCwgbm9kZSksIHBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBtYW5hZ2VyLmluaXRpYWxpemUobnVsbCwgcGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBtYW5hZ2VyLmJpbmQgPSBub29wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hbmFnZXI7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDbG9uZXMgdGhpcyBUZXh0TWFuYWdlciB3aXRoIGEgbmV3IG5vZGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbmV3Tm9kZSBUaGUgbmV3IG5vZGUgYXR0YWNoZWQgdG8gdGhlIGNsb25lZCBUZXh0TWFuYWdlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnByb2Nlc3NpbmcuRWxlbWVudE1hbmFnZXJ9IHBhcmVudE1hbmFnZXIgVGhlIHBhcmVudCBFbGVtZW50TWFuYWdlclxyXG4gICAgICAgICAgICAgKiBmb3IgdGhlIGNsb25lLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVGV4dE1hbmFnZXIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKG5ld05vZGUsIHBhcmVudE1hbmFnZXIpIHtcclxuICAgICAgICAgICAgICAgIFRleHRNYW5hZ2VyLl9jbG9uZSh0aGlzLCBuZXdOb2RlLCBwYXJlbnRNYW5hZ2VyKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGZ1bmN0aW9uIHVzZWQgZm9yIGRhdGEtYmluZGluZyBhIGRhdGEgY29udGV4dCB0byB0aGUgRE9NLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVGV4dE1hbmFnZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnRDb250cm9sKCksIG5vZGUgPSB0aGlzLm5vZGVNYXAubm9kZXNbMF0sIHRleHROb2RlID0gbm9kZS5ub2RlLCBleHByZXNzaW9ucyA9IG5vZGUuZXhwcmVzc2lvbnM7XHJcbiAgICAgICAgICAgICAgICBOb2RlTWFuYWdlci5vYnNlcnZlRXhwcmVzc2lvbnMobm9kZS5leHByZXNzaW9ucywgcGFyZW50LCB0aGlzLl9zZXRUZXh0LmJpbmQodGhpcywgdGV4dE5vZGUsIHBhcmVudCwgZXhwcmVzc2lvbnMpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFRleHQodGV4dE5vZGUsIHBhcmVudCwgZXhwcmVzc2lvbnMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQnVpbGRzIHRoZSBub2RlIGV4cHJlc3Npb24gYW5kIHNldHMgdGhlIHZhbHVlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge05vZGV9IE5vZGUgVGhlIGFzc29jaWF0ZWQgbm9kZSB3aG9zZSB2YWx1ZSB3aWxsIGJlIHNldC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlRlbXBsYXRlQ29udHJvbH0gY29udHJvbCBUaGUgY29udHJvbCB3aG9zZSBjb250ZXh0IHdpbGwgYmUgdXNlZCB0byBiaW5kXHJcbiAgICAgICAgICAgICAqIHRoZSBkYXRhLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHBsYXQuZXhwcmVzc2lvbnMuSVBhcnNlZEV4cHJlc3Npb24+fSBleHByZXNzaW9ucyBBbiBhcnJheSBvZiBwYXJzZWQgZXhwcmVzc2lvbnMgdXNlZCB0byBidWlsZFxyXG4gICAgICAgICAgICAgKiB0aGUgbm9kZSB2YWx1ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRleHRNYW5hZ2VyLnByb3RvdHlwZS5fc2V0VGV4dCA9IGZ1bmN0aW9uIChub2RlLCBjb250cm9sLCBleHByZXNzaW9ucykge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5ub2RlVmFsdWUgPSBOb2RlTWFuYWdlci5idWlsZChleHByZXNzaW9ucywgKGNvbnRyb2wgfHwge30pKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFRleHRNYW5hZ2VyO1xyXG4gICAgICAgIH0oTm9kZU1hbmFnZXIpKTtcclxuICAgICAgICBwcm9jZXNzaW5nLlRleHRNYW5hZ2VyID0gVGV4dE1hbmFnZXI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gSVRleHRNYW5hZ2VyRmFjdG9yeSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFRleHRNYW5hZ2VyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcm9jZXNzaW5nLklUZXh0TWFuYWdlckZhY3RvcnkgPSBJVGV4dE1hbmFnZXJGYWN0b3J5O1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19UZXh0TWFuYWdlckZhY3RvcnksIElUZXh0TWFuYWdlckZhY3RvcnksIG51bGwsIF9fRkFDVE9SWSk7XHJcbiAgICAgICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX1RleHRNYW5hZ2VySW5zdGFuY2UsIFRleHRNYW5hZ2VyLCBudWxsLCBfX0lOU1RBTkNFKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGNsYXNzIHVzZWQgdG8gbWFuYWdlIENvbW1lbnQgbm9kZXMuIFByb3ZpZGVzIGEgd2F5IHRvXHJcbiAgICAgICAgICogY2xvbmUgYSBDb21tZW50IG5vZGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIENvbW1lbnRNYW5hZ2VyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKENvbW1lbnRNYW5hZ2VyLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBDb21tZW50TWFuYWdlcigpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIHR5cGUgZm9yIHRoaXMgTm9kZU1hbmFnZXIuXHJcbiAgICAgICAgICAgICAgICAgKiBJdCdzIHZhbHVlIGlzIFwiY29tbWVudFwiLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSAnY29tbWVudCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENyZWF0ZXMgYSBuZXcgQ29tbWVudE1hbmFnZXIgZm9yIHRoZSBnaXZlbiBDb21tZW50IG5vZGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgQ29tbWVudCB0byBhc3NvY2lhdGUgd2l0aCB0aGUgbmV3IG1hbmFnZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5wcm9jZXNzaW5nLkVsZW1lbnRNYW5hZ2VyfSBwYXJlbnQgVGhlIHBhcmVudFxyXG4gICAgICAgICAgICAgKiBFbGVtZW50TWFuYWdlci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENvbW1lbnRNYW5hZ2VyLmNyZWF0ZSA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtYW5hZ2VyID0gbmV3IENvbW1lbnRNYW5hZ2VyKCk7XHJcbiAgICAgICAgICAgICAgICBtYW5hZ2VyLmluaXRpYWxpemUoe1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzOiBbe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogbm9kZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XVxyXG4gICAgICAgICAgICAgICAgfSwgcGFyZW50KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYW5hZ2VyO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBtZXRob2QgZm9yIGNsb25pbmcgdGhpcyBtYW5hZ2VyIHdpdGggYSBuZXcgQ29tbWVudC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtOb2RlfSBuZXdOb2RlIFRoZSBuZXcgQ29tbWVudCBub2RlIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBjbG9uZWRcclxuICAgICAgICAgICAgICogbWFuYWdlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnByb2Nlc3NpbmcuRWxlbWVudE1hbmFnZXJ9IHBhcmVudE1hbmFnZXIgVGhlIHBhcmVudCBFbGVtZW50TWFuYWdlclxyXG4gICAgICAgICAgICAgKiBmb3IgdGhlIGNsb25lLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29tbWVudE1hbmFnZXIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKG5ld05vZGUsIHBhcmVudE1hbmFnZXIpIHtcclxuICAgICAgICAgICAgICAgIENvbW1lbnRNYW5hZ2VyLmNyZWF0ZShuZXdOb2RlLCBwYXJlbnRNYW5hZ2VyKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gQ29tbWVudE1hbmFnZXI7XHJcbiAgICAgICAgfShOb2RlTWFuYWdlcikpO1xyXG4gICAgICAgIHByb2Nlc3NpbmcuQ29tbWVudE1hbmFnZXIgPSBDb21tZW50TWFuYWdlcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBJQ29tbWVudE1hbmFnZXJGYWN0b3J5KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gQ29tbWVudE1hbmFnZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb2Nlc3NpbmcuSUNvbW1lbnRNYW5hZ2VyRmFjdG9yeSA9IElDb21tZW50TWFuYWdlckZhY3Rvcnk7XHJcbiAgICAgICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX0NvbW1lbnRNYW5hZ2VyRmFjdG9yeSwgSUNvbW1lbnRNYW5hZ2VyRmFjdG9yeSwgbnVsbCwgX19GQUNUT1JZKTtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fQ29tbWVudE1hbmFnZXJJbnN0YW5jZSwgQ29tbWVudE1hbmFnZXIsIG51bGwsIF9fSU5TVEFOQ0UpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVzZWQgdG8gZmFjaWxpdGF0ZSBvYnNlcnZpbmcgZXhwcmVzc2lvbnMgb24gYXR0cmlidXRlcy4gSGFzIHRoZSBhYmlsaXR5IHRvIGFsZXJ0IEF0dHJpYnV0ZXNcclxuICAgICAgICAgKiB3aXRoIGNoYW5nZXMuIEhhbmRsZXMgZHluYW1pYyBhbmQgc3RhdGljIGF0dHJpYnV0ZXMgKGR5bmFtaWMgbWVhbmluZyBcImNsYXNzXCItbGlrZSBhdHRyaWJ1dGVzKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgQXR0cmlidXRlTWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEF0dHJpYnV0ZU1hbmFnZXIoKSB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgcmVndWxhciBleHByZXNzaW9uIGZvciBmaW5kaW5nIG1hcmt1cCBpbiBhIHN0cmluZy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFya3VwUmVnZXggPSBuZXcgUmVnRXhwKFwiXlwiICsgX19zdGFydFN5bWJvbCArIFwiW1xcXFxTXFxcXHNdKj9cIiArIF9fZW5kU3ltYm9sICsgXCJcXFxcUypcXFxccyp8XFxcXHMqXFxcXFMqXCIgKyBfX3N0YXJ0U3ltYm9sICsgXCJbXFxcXFNcXFxcc10qP1wiICsgX19lbmRTeW1ib2wgKyBcIlxcXFxTKlwiLCAnZycpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgcHJldmlvdXMgYm91bmQgdmFsdWVzIG9mIGEgXCJkeW5hbWljXCIgYXR0cmlidXRlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0VmFsdWVzID0ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgYSBuZXcgaW5zdGFuY2Ugb2YgYW4gQXR0cmlidXRlTWFuYWdlci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEF0dHJpYnV0ZU1hbmFnZXIuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWFuYWdlciA9IG5ldyBBdHRyaWJ1dGVNYW5hZ2VyKCk7XHJcbiAgICAgICAgICAgICAgICBtYW5hZ2VyLl9Ob2RlTWFuYWdlciA9IGFjcXVpcmUoX19Ob2RlTWFuYWdlclN0YXRpYyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFuYWdlcjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluaXRpYWxpemVzIHRoZSBtYW5hZ2VyIGFuZCBkZXRlcm1pbmVzIHdoYXQgbWV0aG9kIHNob3VsZCBiZSB1c2VkIHRvIGhhbmRsZSBhdHRyaWJ1dGUgY2hhbmdlcy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoaXMgYXR0cmlidXRlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucHJvY2Vzc2luZy5JTm9kZX0gbm9kZSBUaGUgSU5vZGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgYXR0cmlidXRlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVGVtcGxhdGVDb250cm9sfSBwYXJlbnQgVGhlIHBhcmVudCBjb250cm9sIGZvciBhbGwgdGhlIGNvbnRyb2xzIGFzc29jaWF0ZWQgd2l0aFxyXG4gICAgICAgICAgICAgKiB0aGUgZWxlbWVudC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxwbGF0LkNvbnRyb2w+fSBjb250cm9scyBUaGUgY29udHJvbHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBlbGVtZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcGxhY2U/IFdoZXRoZXIgb3Igbm90IHRoZSBlbGVtZW50IGlzIHJlcGxhY2VkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQXR0cmlidXRlTWFuYWdlci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBub2RlLCBwYXJlbnQsIGNvbnRyb2xzLCByZXBsYWNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29udHJvbHMgPSBjb250cm9scztcclxuICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZSA9IHJlcGxhY2U7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSAhPT0gJ2NsYXNzJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZCA9IHRoaXMuX3N0YXRpY0F0dHJpYnV0ZUNoYW5nZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWQgPSB0aGlzLl9keW5hbWljQXR0cmlidXRlQ2hhbmdlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEhhbmRsZXMgY2hhbmdlcyB0byBkeW5hbWljIGF0dHJpYnV0ZXMuIFRha2VzIGludG8gYWNjb3VudCB0aGF0IHRoZSBhdHRyaWJ1dGUgbWF5IGhhdmUgYmVlbiBjaGFuZ2VkIHByb2dyYW1tYXRpY2FsbHksIGFuZFxyXG4gICAgICAgICAgICAgKiB3ZSBuZWVkIHRvIG9ubHkgbXV0YXRlIHRoZSBwaWVjZSBvZiB0aGUgYXR0cmlidXRlIGNvcnJlc3BvbmRpbmcgdG8gZXhwcmVzc2lvbnMgd2l0aCBtYXJrdXAuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBBdHRyaWJ1dGVNYW5hZ2VyLnByb3RvdHlwZS5fZHluYW1pY0F0dHJpYnV0ZUNoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZSwgYXR0ciA9IG5vZGUubm9kZSwgbm9kZVZhbHVlID0gYXR0ci52YWx1ZSwgY2xhc3NlcyA9IHRoaXMuX05vZGVNYW5hZ2VyLmJ1aWxkKG5vZGUuZXhwcmVzc2lvbnMsIHRoaXMucGFyZW50KS50cmltKCkuc3BsaXQoL1xccy8pLCBsYXN0ID0gdGhpcy5fbGFzdFZhbHVlcywgZWxlbWVudCA9IHRoaXMuZWxlbWVudCwgYywgbGVuZ3RoID0gY2xhc3Nlcy5sZW5ndGgsIGk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fTm9kZU1hbmFnZXIuaGFzTWFya3VwKG5vZGVWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBhdHRyLnZhbHVlID0gbm9kZVZhbHVlLnJlcGxhY2UodGhpcy5fbWFya3VwUmVnZXgsICcnKS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0W2NsYXNzZXNbaV1dID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNsYXNzZXMgPSBPYmplY3Qua2V5cyhsYXN0KTtcclxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IGNsYXNzZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IGNsYXNzZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RbY10pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RbY10gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KGxhc3QsIGMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCBjKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ub3RpZnlBdHRyaWJ1dGVzKG5vZGUubm9kZU5hbWUsIGF0dHIudmFsdWUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSGFuZGxlcyBjaGFuZ2VzIHRvIHN0YXRpYyBhdHRyaWJ1dGVzLiBCdWlsZHMgYSBzdHJpbmcgZnJvbSB0aGUgbm9kZSBleHByZXNzaW9ucywgdGhlbiBzZXRzIHRoZSBhdHRyaWJ1dGUgdmFsdWVcclxuICAgICAgICAgICAgICogYW5kIG5vdGlmaWVzIHRoZSBhc3NvY2lhdGVkIEF0dHJpYnV0ZXMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBBdHRyaWJ1dGVNYW5hZ2VyLnByb3RvdHlwZS5fc3RhdGljQXR0cmlidXRlQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb250cm9scyA9IHRoaXMuX2NvbnRyb2xzLCBub2RlID0gdGhpcy5ub2RlLCBrZXkgPSBjYW1lbENhc2Uobm9kZS5ub2RlTmFtZSksIHZhbHVlID0gdGhpcy5fTm9kZU1hbmFnZXIuYnVpbGQobm9kZS5leHByZXNzaW9ucywgdGhpcy5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbm90aWZ5QXR0cmlidXRlcyhrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5yZXBsYWNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5ub2RlLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBOb3RpZmllcyB0aGUgbmVjZXNzYXJ5IEF0dHJpYnV0ZXMgb2YgY2hhbmdlcyB0byBhbiBhdHRyaWJ1dGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBBdHRyaWJ1dGVNYW5hZ2VyLnByb3RvdHlwZS5fbm90aWZ5QXR0cmlidXRlcyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbHMgPSB0aGlzLl9jb250cm9scywgbGVuZ3RoID0gY29udHJvbHMubGVuZ3RoLCBhdHRyaWJ1dGVzLCBvbGRWYWx1ZTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzID0gY29udHJvbHNbaV0uYXR0cmlidXRlcztcclxuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IGF0dHJpYnV0ZXNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLl9hdHRyaWJ1dGVDaGFuZ2VkKGtleSwgdmFsdWUsIG9sZFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIEF0dHJpYnV0ZU1hbmFnZXI7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBwcm9jZXNzaW5nLkF0dHJpYnV0ZU1hbmFnZXIgPSBBdHRyaWJ1dGVNYW5hZ2VyO1xyXG4gICAgfSkocHJvY2Vzc2luZyA9IHBsYXRfMS5wcm9jZXNzaW5nIHx8IChwbGF0XzEucHJvY2Vzc2luZyA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIEhvbGRzIGFsbCBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIHJlbGF0ZWQgdG8gcm91dGluZyBjb21wb25lbnRzIGluIHBsYXR5cHVzLlxyXG4gICAgICovXHJcbiAgICB2YXIgcm91dGluZztcclxuICAgIChmdW5jdGlvbiAocm91dGluZykge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRpZXMgdGhlIGJyb3dzZXIgYW5kIHJvdXRlcnMgdG9nZXRoZXIsIGZhY2lsaXRhdGluZyBhcHAgbmF2aWdhdGlvbiBhdCBldmVyeSByb3V0ZXIgbGV2ZWwuXHJcbiAgICAgICAgICogTGlzdGVucyBmb3IgdXJsIGNoYW5nZXMgYW5kIHJlc3BvbmRzIGFjY29yZGluZ2x5LiBBbHNvIGNvbnRhaW5zIGZ1bmN0aW9uYWxpdHkgZm9yIGdlbmVyYXRpbmdcclxuICAgICAgICAgKiBhbmQgY2hhbmdpbmcgdGhlIHVybC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgTmF2aWdhdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gTmF2aWdhdG9yKCkge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIHVuaXF1ZSBpZCwgY3JlYXRlZCBkdXJpbmcgaW5zdGFudGlhdGlvbiBhbmQgZm91bmQgb24gZXZlcnkgTmF2aWdhdG9yLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnVpZCA9IHVuaXF1ZUlkKF9fUGxhdCk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFN0YXRlcyB3aGV0aGVyIG9yIG5vdCB0aGUgTmF2aWdhdG9yIGlzIHRoZSByb290IE5hdmlnYXRvci5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1Jvb3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBtZXRob2QgdG8gY2FsbCB0byBzdG9wIGxpc3RlbmluZyBmb3IgdXJsIGNoYW5nZXMsIG9ubHkgd29ya3Mgb24gdGhlIHJvb3QgbmF2aWdhdG9yLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVVcmxMaXN0ZW5lciA9IG5vb3A7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgbWV0aG9kIHRvIGNhbGwgdG8gc3RvcCBsaXN0ZW5pbmcgZm9yIHVybCBjaGFuZ2VzLCBvbmx5IHdvcmtzIG9uIHRoZSByb290IG5hdmlnYXRvci5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faWdub3JlT25jZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgY3VycmVudCBuYXZpZ2F0aW9uIGlzIGEgYmFja3dhcmQgbmF2aWdhdGlvblxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9iYWNrTmF2aWdhdGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhpcyBOYXZpZ2F0b3Igd2l0aCBhIHJvdXRlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnJvdXRpbmcuUm91dGVyfSByb3V0ZXIgVGhlIHJvdXRlciB0aGF0IHRoZSBuYXZpZ2F0b3Igc2hvdWxkIHVzZSB0byBtYXRjaC9nZW5lcmF0ZSByb3V0ZXMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBOYXZpZ2F0b3IucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAocm91dGVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yb3V0ZXIgPSByb3V0ZXI7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3Qocm91dGVyKSAmJiByb3V0ZXIuaXNSb290ICYmICFpc09iamVjdChOYXZpZ2F0b3IuX3Jvb3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1Jvb3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIE5hdmlnYXRvci5fcm9vdCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2JzZXJ2ZVVybCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGVsbHMgdGhlIG5hdmlnYXRvciB0byBuYXZpZ2F0ZSB0byB0aGUgdXJsIHJlZ2lzdGVyZWQgZm9yIGEgcGFydGljdWxhciB2aWV3LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gdmlldyBUaGUgdmlldyB0byB3aGljaCB0aGUgTmF2aWdhdG9yIHNob3VsZCBuYXZpZ2F0ZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnJvdXRpbmcuSU5hdmlnYXRlT3B0aW9uc30gb3B0aW9ucyB1c2VkIHRvIGdlbmVyYXRlIHRoZSB1cmwgYW5kIHBlcmZvcm0gbmF2aWdhdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE5hdmlnYXRvci5wcm90b3R5cGUubmF2aWdhdGUgPSBmdW5jdGlvbiAodmlldywgb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBpc09iamVjdChvcHRpb25zKSA/IG9wdGlvbnMgOiB7fTtcclxuICAgICAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOYXZpZ2F0aW5nKCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaXNVcmwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gdmlldztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IF90aGlzLl9nZW5lcmF0ZSh2aWV3LCBvcHRpb25zLnBhcmFtZXRlcnMsIG9wdGlvbnMucXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzU3RyaW5nKHVybCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3Qgc2VyaWFsaXplIHVybCBmcm9tIGlucHV0IHBhcmFtZXRlcnMsIGNoZWNrIHlvdXIgdmlldyByZWZlcmVuY2UuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX25hdmlnYXRlKHVybCwgb3B0aW9ucy5yZXBsYWNlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGFsbCBuYXZpZ2F0aW9uIGhhcyBmaW5pc2hlZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE5hdmlnYXRvci5wcm90b3R5cGUuZmluaXNoTmF2aWdhdGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciByb3V0ZXIgPSBOYXZpZ2F0b3IuX3Jvb3QuX3JvdXRlcjtcclxuICAgICAgICAgICAgICAgIGlmIChyb3V0ZXIubmF2aWdhdGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb3V0ZXIuZmluaXNoTmF2aWdhdGluZy5jYXRjaChub29wKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRlbGxzIHRoZSByb3V0ZXIgdG8gZ28gYmFjayB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTmF2aWdhdG9yLnByb3RvdHlwZS5nb0JhY2sgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBpc09iamVjdChvcHRpb25zKSA/IG9wdGlvbnMgOiB7fTtcclxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBOdW1iZXIob3B0aW9ucy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bWJlcihsZW5ndGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc1Jvb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmF2aWdhdG9yLl9yb290LmdvQmFjayhvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5hdmlnYXRpbmcoKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYmFja05hdmlnYXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2dvQmFjayhsZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhlIGN1cnJlbnQgbmF2aWdhdGlvbiBpcyBhIGJhY2t3YXJkIG5hdmlnYXRpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBOYXZpZ2F0b3IucHJvdG90eXBlLmlzQmFja05hdmlnYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNSb290KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5hdmlnYXRvci5fcm9vdC5pc0JhY2tOYXZpZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYmFja05hdmlnYXRlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTGV0cyB0aGUgcm91dGVyIGRpc3Bvc2Ugb2YgYWxsIG9mIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE5hdmlnYXRvci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVVybExpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eSh0aGlzLCAncm91dGVyJyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbnRlcm5hbCBtZXRob2QgZm9yIG5hdmlnYXRpbmcgdG8gdGhlIHNwZWNpZmllZCB1cmwuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBOYXZpZ2F0b3IucHJvdG90eXBlLl9uYXZpZ2F0ZSA9IGZ1bmN0aW9uICh1cmwsIHJlcGxhY2UpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNSb290KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5hdmlnYXRvci5fcm9vdC5fbmF2aWdhdGUodXJsLCByZXBsYWNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5fUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Jlc29sdmVOYXZpZ2F0ZSA9IHJlc29sdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlamVjdE5hdmlnYXRlID0gcmVqZWN0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gX3RoaXMuX2Jyb3dzZXIudXJsKCksIG5leHQgPSBfdGhpcy5fYnJvd3Nlci51cmwodXJsLCByZXBsYWNlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gbmV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVzb2x2ZU5hdmlnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbnRlcm5hbCBtZXRob2QgZm9yIGdvaW5nIGJhY2sgYSBjZXJ0YWluIGxlbmd0aCBpbiBoaXN0b3J5XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBOYXZpZ2F0b3IucHJvdG90eXBlLl9nb0JhY2sgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLl9Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVzb2x2ZU5hdmlnYXRlID0gcmVzb2x2ZTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVqZWN0TmF2aWdhdGUgPSByZWplY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Jyb3dzZXIuYmFjayhsZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgcm9vdCBuYXZpZ2F0b3Igd2lsbCBhbHdheXMgb2JzZXJ2ZSBmb3IgdXJsIGNoYW5nZXMgYW5kIGhhbmRsZSB0aGVtIGFjY29yZGluZ2x5LiBUaGlzIG1lYW5zIGluc3RydWN0aW5nIHRoZVxyXG4gICAgICAgICAgICAgKiByb3V0ZXIgdG8gbmF2aWdhdGUsIGFuZCBkZXRlcm1pbmluZyB3aGF0IHRvIGRvIGluIHRoZSBldmVudCB0aGF0IG5hdmlnYXRpb24gaXMgcHJldmVudGVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTmF2aWdhdG9yLnByb3RvdHlwZS5fb2JzZXJ2ZVVybCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzT2JqZWN0KHRoaXMuX3JvdXRlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgRXZlbnRNYW5hZ2VyID0gdGhpcy5fRXZlbnRNYW5hZ2VyLCBwcmV2aW91c1VybCwgaGVhZENvbnRyb2wgPSBhY3F1aXJlKF9fSGVhZCksIGhlYWRFeGlzdHMgPSBpc09iamVjdChoZWFkQ29udHJvbCkgJiYgaXNGdW5jdGlvbihoZWFkQ29udHJvbC5uYXZpZ2F0ZWQpLCBvbkZhaWxlZE5hdmlnYXRvbiA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3ByZXZpb3VzVXJsID0gcHJldmlvdXNVcmw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9oaXN0b3J5ID0gX3RoaXMuX2hpc3RvcnksIHN0YXRlID0gX2hpc3Rvcnkuc3RhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2lnbm9yZU9uY2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwoc3RhdGUucHJldmlvdXNMb2NhdGlvbikgfHwgc3RhdGUucHJldmlvdXNMb2NhdGlvbiA9PT0gcHJldmlvdXNVcmwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2hpc3RvcnkuZ28oLTEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2hpc3RvcnkuZ28oMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9iYWNrTmF2aWdhdGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihfdGhpcy5fcmVqZWN0TmF2aWdhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZWplY3ROYXZpZ2F0ZShlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0VtcHR5KGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cud2FybihlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNVcmwgPSB0aGlzLl9icm93c2VyLnVybCgpO1xyXG4gICAgICAgICAgICAgICAgLy8gUHJvdGVjdCBhZ2FpbnN0IGFjY2lkZW50YWxseSBjYWxsaW5nIHRoaXMgbWV0aG9kIHR3aWNlLiBcclxuICAgICAgICAgICAgICAgIEV2ZW50TWFuYWdlci5kaXNwb3NlKHRoaXMudWlkKTtcclxuICAgICAgICAgICAgICAgIEV2ZW50TWFuYWdlci5vbih0aGlzLnVpZCwgX19iYWNrQnV0dG9uLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ID0gRXZlbnRNYW5hZ2VyLmRpc3BhdGNoKF9fYmFja0J1dHRvblByZXNzZWQsIF90aGlzLCBFdmVudE1hbmFnZXIuRElSRUNUKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXYuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmdvQmFjaygpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBFdmVudE1hbmFnZXIub24odGhpcy51aWQsIF9fdXJsQ2hhbmdlZCwgZnVuY3Rpb24gKGV2LCB1dGlscykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5faWdub3JlT25jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5faWdub3JlT25jZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihfdGhpcy5fcmVzb2x2ZU5hdmlnYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2JhY2tOYXZpZ2F0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Jlc29sdmVOYXZpZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNVcmwgPSBfdGhpcy5fcHJldmlvdXNVcmw7XHJcbiAgICAgICAgICAgICAgICAgICAgZXYgPSBFdmVudE1hbmFnZXIuZGlzcGF0Y2goX19iZWZvcmVOYXZpZ2F0ZSwgX3RoaXMsIEV2ZW50TWFuYWdlci5ESVJFQ1QsIFt1dGlsc10pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldi5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRmFpbGVkTmF2aWdhdG9uKG5ldyBFcnJvcignTmF2aWdhdGlvbiBwcmV2ZW50ZWQgZHVyaW5nICcgKyBfX2JlZm9yZU5hdmlnYXRlICsgJyBldmVudCcpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5maW5pc2hOYXZpZ2F0aW5nKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBFdmVudE1hbmFnZXIuZGlzcGF0Y2goX19uYXZpZ2F0aW5nLCBfdGhpcywgRXZlbnRNYW5hZ2VyLkRJUkVDVCwgW3V0aWxzXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcm91dGVyLm5hdmlnYXRlKHV0aWxzLnBhdGhuYW1lLCB1dGlscy5xdWVyeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9wcmV2aW91c1VybCA9IHV0aWxzLnBhdGhuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihfdGhpcy5fcmVzb2x2ZU5hdmlnYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2JhY2tOYXZpZ2F0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Jlc29sdmVOYXZpZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoZWFkRXhpc3RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkQ29udHJvbC5uYXZpZ2F0ZWQodXRpbHMuaHJlZik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgRXZlbnRNYW5hZ2VyLmRpc3BhdGNoKF9fbmF2aWdhdGVkLCBfdGhpcywgRXZlbnRNYW5hZ2VyLkRJUkVDVCwgW3V0aWxzXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgb25GYWlsZWROYXZpZ2F0b24pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZW5lcmF0ZXMgYSB1cmwgd2l0aCB0aGUgZ2l2ZW4gdmlldywgcGFyYW1ldGVycywgYW5kIHF1ZXJ5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTmF2aWdhdG9yLnByb3RvdHlwZS5fZ2VuZXJhdGUgPSBmdW5jdGlvbiAodmlldywgcGFyYW1ldGVycywgcXVlcnkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwodGhpcy5fcm91dGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KHZpZXcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpZXc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcm91dGVyLmdlbmVyYXRlKHZpZXcsIHBhcmFtZXRlcnMsIHF1ZXJ5KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgTmF2aWdhdG9yLl9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgICAgICBfUHJvbWlzZTogX19Qcm9taXNlLFxyXG4gICAgICAgICAgICAgICAgX0luamVjdG9yOiBfX0luamVjdG9yU3RhdGljLFxyXG4gICAgICAgICAgICAgICAgX2Jyb3dzZXJDb25maWc6IF9fQnJvd3NlckNvbmZpZyxcclxuICAgICAgICAgICAgICAgIF9icm93c2VyOiBfX0Jyb3dzZXIsXHJcbiAgICAgICAgICAgICAgICBfRXZlbnRNYW5hZ2VyOiBfX0V2ZW50TWFuYWdlclN0YXRpYyxcclxuICAgICAgICAgICAgICAgIF93aW5kb3c6IF9fV2luZG93LFxyXG4gICAgICAgICAgICAgICAgX2xvZzogX19Mb2csXHJcbiAgICAgICAgICAgICAgICBfaGlzdG9yeTogX19IaXN0b3J5XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBOYXZpZ2F0b3I7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICByb3V0aW5nLk5hdmlnYXRvciA9IE5hdmlnYXRvcjtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fTmF2aWdhdG9ySW5zdGFuY2UsIE5hdmlnYXRvciwgbnVsbCwgX19JTlNUQU5DRSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gSGlzdG9yeShfd2luZG93KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfd2luZG93Lmhpc3Rvcnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJvdXRpbmcuSGlzdG9yeSA9IEhpc3Rvcnk7XHJcbiAgICAgICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX0hpc3RvcnksIEhpc3RvcnksIFtfX1dpbmRvd10pO1xyXG4gICAgICAgIHZhciBzcGVjaWFsQ2hhcmFjdGVycyA9IFtcclxuICAgICAgICAgICAgJy8nLCAnLicsICcqJywgJysnLCAnPycsICd8JyxcclxuICAgICAgICAgICAgJygnLCAnKScsICdbJywgJ10nLCAneycsICd9JywgJ1xcXFwnXHJcbiAgICAgICAgXSwgZXNjYXBlUmVnZXggPSBuZXcgUmVnRXhwKCcoXFxcXCcgKyBzcGVjaWFsQ2hhcmFjdGVycy5qb2luKCd8XFxcXCcpICsgJyknLCAnZycpO1xyXG4gICAgICAgIHZhciBiYXNlU2VnbWVudCwgZHluYW1pY1NlZ21lbnRzID0ge30sIHNwbGF0U2VnbWVudHMgPSB7fSwgc3RhdGljU2VnbWVudHMgPSB7fTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgYSBzZWdtZW50LCBwdWJsaXNoZXMgYSByZWdleCBmb3IgbWF0Y2hpbmcgdGhlIHNlZ21lbnQgYXMgd2VsbCBhc1xyXG4gICAgICAgICAqIG1ldGhvZHMgZm9yIGdlbmVyYXRpbmcgdGhlIHNlZ21lbnQgYW5kIGl0ZXJhdGluZyBvdmVyIHRoZSBjaGFyYWN0ZXJzIGluIHRoZSBzZWdtZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBCYXNlU2VnbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEJhc2VTZWdtZW50KCkge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEZW5vdGVzIHRoZSB0eXBlIG9mIHNlZ21lbnQgZm9yIHRoaXMgaW5zdGFuY2UuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IF9fQkFTRV9TRUdNRU5UX1RZUEU7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBzZWdtZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSAnJztcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nIHdoaWNoIGNhbiBiZSB1c2VkIHRvIG1hdGNoIHRoZSBzZWdtZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2V4ID0gJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBhcnNlcyBhIHJvdXRlIGludG8gc2VnbWVudHMsIHBvcHVsYXRpbmcgYW4gYXJyYXkgb2YgbmFtZXMgKGZvciBkeW5hbWljIGFuZCBzcGxhdCBzZWdtZW50cykgYXMgd2VsbCBhc1xyXG4gICAgICAgICAgICAgKiBhbiBJU2VnbWVudFR5cGVDb3VudCBvYmplY3QuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSByb3V0ZSBUaGUgcm91dGUgdG8gcGFyc2UuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gbmFtZXMgQW4gYXJyYXkgdG8gcG9wdWxhdGUgd2l0aCBkeW5hbWljL3NwbGF0IHNlZ21lbnQgbmFtZXNcclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnJvdXRpbmcuSVNlZ21lbnRUeXBlQ291bnR9IHR5cGVzIEFuIG9iamVjdCB0byB1c2UgZm9yIGNvdW50aW5nIHNlZ21lbnQgdHlwZXMgaW4gdGhlIHJvdXRlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmFzZVNlZ21lbnQucGFyc2UgPSBmdW5jdGlvbiAocm91dGUsIG5hbWVzLCB0eXBlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1N0cmluZyhyb3V0ZSkgfHwgIWlzQXJyYXkobmFtZXMpIHx8ICFpc09iamVjdCh0eXBlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyb3V0ZVswXSA9PT0gJy8nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm91dGUgPSByb3V0ZS5zbGljZSgxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBzZWdtZW50cyA9IHJvdXRlLnNwbGl0KCcvJyksIGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aCwgZmluZFNlZ21lbnQgPSBCYXNlU2VnbWVudC5fX2ZpbmRTZWdtZW50LCByZXN1bHRzID0gW10sIHNlZ21lbnQsIG5hbWUsIG1hdGNoLCBfcmVnZXggPSBCYXNlU2VnbWVudC5fcmVnZXg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWdtZW50ID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzT2JqZWN0KGJhc2VTZWdtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVNlZ21lbnQgPSBhY3F1aXJlKF9fQmFzZVNlZ21lbnRJbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGJhc2VTZWdtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2ggPSBzZWdtZW50Lm1hdGNoKF9yZWdleC5keW5hbWljU2VnbWVudHNSZWdleCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG1hdGNoWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZmluZFNlZ21lbnQobmFtZSwgX19EeW5hbWljU2VnbWVudEluc3RhbmNlLCBkeW5hbWljU2VnbWVudHMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXMucHVzaChuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXMuZHluYW1pY3MrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2ggPSBzZWdtZW50Lm1hdGNoKF9yZWdleC5zcGxhdFNlZ21lbnRSZWdleCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG1hdGNoWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZmluZFNlZ21lbnQobmFtZSwgX19TcGxhdFNlZ21lbnRJbnN0YW5jZSwgc3BsYXRTZWdtZW50cykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lcy5wdXNoKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlcy5zcGxhdHMrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChmaW5kU2VnbWVudChzZWdtZW50LCBfX1N0YXRpY1NlZ21lbnRJbnN0YW5jZSwgc3RhdGljU2VnbWVudHMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXMuc3RhdGljcysrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGFyc2VzIGEgcm91dGUgaW50byBzZWdtZW50cywgcG9wdWxhdGluZyBhbiBhcnJheSBvZiBuYW1lcyAoZm9yIGR5bmFtaWMgYW5kIHNwbGF0IHNlZ21lbnRzKSBhcyB3ZWxsIGFzXHJcbiAgICAgICAgICAgICAqIGFuIElTZWdtZW50VHlwZUNvdW50IG9iamVjdC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHNlZ21lbnQgdG8gbG9vayBmb3IuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBUaGUgdG9rZW4gdXNlZCB0byBhY3F1aXJlIGEgbmV3IHNlZ21lbnQgaWYgbmVjZXNzYXJ5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuSU9iamVjdDxwbGF0LnJvdXRpbmcuQmFzZVNlZ21lbnQ+fSBjYWNoZSBUaGUgY2FjaGUgaW4gd2hpY2ggdG8gbG9vayBmb3Ivc3RvcmUgdGhlIHNlZ21lbnQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCYXNlU2VnbWVudC5fX2ZpbmRTZWdtZW50ID0gZnVuY3Rpb24gKG5hbWUsIHRva2VuLCBjYWNoZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBjYWNoZVtuYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNPYmplY3Qoc2VnbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50ID0gY2FjaGVbbmFtZV0gPSBhY3F1aXJlKHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50LmluaXRpYWxpemUobmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VnbWVudDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluaXRpYWxpemVzIHRoZSBzZWdtZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZT8gVGhlIG5hbWUgZm9yIHRoZSBuZXcgc2VnbWVudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJhc2VTZWdtZW50LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJdGVyYXRlcyBvdmVyIHRoZSBjaGFyYWN0ZXJzIGluIHRoZSBzZWdtZW50LCBjYWxsaW5nIGFuIGl0ZXJhdG9yIG1ldGhvZCBhbmQgYWNjdW11bGF0aW5nIHRoZSByZXN1bHQgb2YgZWFjaCBjYWxsIGluXHJcbiAgICAgICAgICAgICAqIGEgZGVmaW5lZCBvYmplY3QuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7KHByZXZpb3VzVmFsdWU6IFQsIHNwZWM6IHBsYXQucm91dGluZy5JQ2hhcmFjdGVyU3BlY2lmaWNhdGlvbikgPT4gVH0gaXRlcmF0b3IgVGhlIGl0ZXJhdG9yIHRvIGNhbGwgd2l0aCBlYWNoIGNoYXJhY3Rlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtUfSBpbml0aWFsVmFsdWU/IEFuIG9wdGlvbmFsIGluaXRpYWwgdmFsdWUgd2l0aCB3aGljaCB0byBzdGFydCB0aGUgYWNjdW11bGF0aW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmFzZVNlZ21lbnQucHJvdG90eXBlLnJlZHVjZUNoYXJhY3RlcnMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGluaXRpYWxWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHRoaXMuX3NwZWNpZmljYXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFZhbHVlID0gaXRlcmF0b3IoaW5pdGlhbFZhbHVlLCB0aGlzLl9zcGVjaWZpY2F0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBpbml0aWFsVmFsdWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZW5lcmF0ZXMgYSBuZXcgc2VnbWVudCwgdXNpbmcgdGhlIGlucHV0IHBhcmFtZXRlcnMgaWYgbmVjZXNzYXJ5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuSU9iamVjdDxzdHJpbmc+fSBwYXJhbWV0ZXJzPyBUaGUgaW5wdXQgcGFyYW1ldGVycyBmb3IgdGhlIHNlZ21lbnQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCYXNlU2VnbWVudC5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiAocGFyYW1ldGVycykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIEJhc2VTZWdtZW50O1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgcm91dGluZy5CYXNlU2VnbWVudCA9IEJhc2VTZWdtZW50O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIElCYXNlU2VnbWVudEZhY3RvcnkoX3JlZ2V4KSB7XHJcbiAgICAgICAgICAgIEJhc2VTZWdtZW50Ll9yZWdleCA9IF9yZWdleDtcclxuICAgICAgICAgICAgcmV0dXJuIEJhc2VTZWdtZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICByb3V0aW5nLklCYXNlU2VnbWVudEZhY3RvcnkgPSBJQmFzZVNlZ21lbnRGYWN0b3J5O1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19CYXNlU2VnbWVudEZhY3RvcnksIElCYXNlU2VnbWVudEZhY3RvcnksIFtfX1JlZ2V4XSwgX19GQUNUT1JZKTtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fQmFzZVNlZ21lbnRJbnN0YW5jZSwgQmFzZVNlZ21lbnQsIG51bGwsIF9fSU5TVEFOQ0UpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCBhIHN0YXRpYyBzZWdtZW50LCBwdWJsaXNoZXMgYSByZWdleCBmb3IgbWF0Y2hpbmcgdGhlIHNlZ21lbnQgYXMgd2VsbCBhc1xyXG4gICAgICAgICAqIG1ldGhvZHMgZm9yIGdlbmVyYXRpbmcgdGhlIHNlZ21lbnQgYW5kIGl0ZXJhdGluZyBvdmVyIHRoZSBjaGFyYWN0ZXJzIGluIHRoZSBzZWdtZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBTdGF0aWNTZWdtZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFN0YXRpY1NlZ21lbnQsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFN0YXRpY1NlZ21lbnQoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRGVub3RlcyB0aGF0IHRoaXMgaXMgYSBzdGF0aWMgc2VnbWVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gX19TVEFUSUNfU0VHTUVOVF9UWVBFO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbml0aWFsaXplcyB0aGUgc2VnbWVudC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWU/IFRoZSBuYW1lIGZvciB0aGUgbmV3IHNlZ21lbnQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBTdGF0aWNTZWdtZW50LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWdleCA9IHRoaXMubmFtZS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCAnXFxcXCQxJyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJdGVyYXRlcyBvdmVyIHRoZSBjaGFyYWN0ZXJzIGluIHRoZSBzZWdtZW50LCBjYWxsaW5nIGFuIGl0ZXJhdG9yIG1ldGhvZCBhbmQgYWNjdW11bGF0aW5nIHRoZSByZXN1bHQgb2YgZWFjaCBjYWxsIGluXHJcbiAgICAgICAgICAgICAqIGEgZGVmaW5lZCBvYmplY3QuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7KHByZXZpb3VzVmFsdWU6IFQsIHNwZWM6IHBsYXQucm91dGluZy5JQ2hhcmFjdGVyU3BlY2lmaWNhdGlvbikgPT4gVH0gaXRlcmF0b3IgVGhlIGl0ZXJhdG9yIHRvIGNhbGwgd2l0aCBlYWNoIGNoYXJhY3Rlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtUfSBpbml0aWFsVmFsdWU/IEFuIG9wdGlvbmFsIGluaXRpYWwgdmFsdWUgd2l0aCB3aGljaCB0byBzdGFydCB0aGUgYWNjdW11bGF0aW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgU3RhdGljU2VnbWVudC5wcm90b3R5cGUucmVkdWNlQ2hhcmFjdGVycyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgaW5pdGlhbFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMubmFtZSwgbGVuZ3RoID0gbmFtZS5sZW5ndGgsIHZhbHVlID0gaW5pdGlhbFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaXRlcmF0b3IodmFsdWUsIHsgdmFsaWRDaGFyYWN0ZXJzOiBuYW1lW2ldIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gU3RhdGljU2VnbWVudDtcclxuICAgICAgICB9KEJhc2VTZWdtZW50KSk7XHJcbiAgICAgICAgcm91dGluZy5TdGF0aWNTZWdtZW50ID0gU3RhdGljU2VnbWVudDtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fU3RhdGljU2VnbWVudEluc3RhbmNlLCBTdGF0aWNTZWdtZW50LCBudWxsLCBfX0lOU1RBTkNFKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgYSB2YXJpYWJsZSBzZWdtZW50IChlaXRoZXIgZHluYW1pYyBvciBzcGxhdCksIHB1Ymxpc2hlcyBhIHJlZ2V4IGZvciBtYXRjaGluZyB0aGUgc2VnbWVudCBhcyB3ZWxsIGFzXHJcbiAgICAgICAgICogbWV0aG9kcyBmb3IgZ2VuZXJhdGluZyB0aGUgc2VnbWVudCBhbmQgaXRlcmF0aW5nIG92ZXIgdGhlIGNoYXJhY3RlcnMgaW4gdGhlIHNlZ21lbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFZhcmlhYmxlU2VnbWVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhWYXJpYWJsZVNlZ21lbnQsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFZhcmlhYmxlU2VnbWVudCgpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEZW5vdGVzIHRoYXQgdGhpcyBpcyBhIHZhcmlhYmxlIHNlZ21lbnQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IF9fVkFSSUFCTEVfU0VHTUVOVF9UWVBFO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZW5lcmF0ZXMgYSBuZXcgc2VnbWVudCwgdXNpbmcgdGhlIGlucHV0IHBhcmFtZXRlcnMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5JT2JqZWN0PHN0cmluZz59IHBhcmFtZXRlcnM/IFRoZSBpbnB1dCBwYXJhbWV0ZXJzIGZvciB0aGUgc2VnbWVudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFZhcmlhYmxlU2VnbWVudC5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiAocGFyYW1ldGVycykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHBhcmFtZXRlcnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnNbdGhpcy5uYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFZhcmlhYmxlU2VnbWVudDtcclxuICAgICAgICB9KEJhc2VTZWdtZW50KSk7XHJcbiAgICAgICAgcm91dGluZy5WYXJpYWJsZVNlZ21lbnQgPSBWYXJpYWJsZVNlZ21lbnQ7XHJcbiAgICAgICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX1ZhcmlhYmxlU2VnbWVudEluc3RhbmNlLCBWYXJpYWJsZVNlZ21lbnQsIG51bGwsIF9fSU5TVEFOQ0UpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCBhIHNwbGF0IHNlZ21lbnQsIHB1Ymxpc2hlcyBhIHJlZ2V4IGZvciBtYXRjaGluZyB0aGUgc2VnbWVudCBhcyB3ZWxsIGFzXHJcbiAgICAgICAgICogbWV0aG9kcyBmb3IgZ2VuZXJhdGluZyB0aGUgc2VnbWVudCBhbmQgaXRlcmF0aW5nIG92ZXIgdGhlIGNoYXJhY3RlcnMgaW4gdGhlIHNlZ21lbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFNwbGF0U2VnbWVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhTcGxhdFNlZ21lbnQsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFNwbGF0U2VnbWVudCgpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEZW5vdGVzIHRoYXQgdGhpcyBpcyBhIHNwbGF0IHNlZ21lbnQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IF9fU1BMQVRfU0VHTUVOVF9UWVBFO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbWF0Y2ggdGhlIHNlZ21lbnQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMucmVnZXggPSAnKC4rKSc7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgcmVndWxhciBleHByZXNzaW9uIHN0cmluZyB3aGljaCBjYW4gYmUgdXNlZCB0byBtYXRjaCB0aGUgc2VnbWVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BlY2lmaWNhdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkQ2hhcmFjdGVyczogJycsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0OiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBTcGxhdFNlZ21lbnQ7XHJcbiAgICAgICAgfShWYXJpYWJsZVNlZ21lbnQpKTtcclxuICAgICAgICByb3V0aW5nLlNwbGF0U2VnbWVudCA9IFNwbGF0U2VnbWVudDtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fU3BsYXRTZWdtZW50SW5zdGFuY2UsIFNwbGF0U2VnbWVudCwgbnVsbCwgX19JTlNUQU5DRSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3RvcmVzIGluZm9ybWF0aW9uIGFib3V0IGEgZHluYW1pYyBzZWdtZW50LCBwdWJsaXNoZXMgYSByZWdleCBmb3IgbWF0Y2hpbmcgdGhlIHNlZ21lbnQgYXMgd2VsbCBhc1xyXG4gICAgICAgICAqIG1ldGhvZHMgZm9yIGdlbmVyYXRpbmcgdGhlIHNlZ21lbnQgYW5kIGl0ZXJhdGluZyBvdmVyIHRoZSBjaGFyYWN0ZXJzIGluIHRoZSBzZWdtZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBEeW5hbWljU2VnbWVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhEeW5hbWljU2VnbWVudCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gRHluYW1pY1NlZ21lbnQoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRGVub3RlcyB0aGF0IHRoaXMgaXMgYSBkeW5hbWljIHNlZ21lbnQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IF9fRFlOQU1JQ19TRUdNRU5UX1RZUEU7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgcmVndWxhciBleHByZXNzaW9uIHN0cmluZyB3aGljaCBjYW4gYmUgdXNlZCB0byBtYXRjaCB0aGUgc2VnbWVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWdleCA9ICcoW14vXSspJztcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nIHdoaWNoIGNhbiBiZSB1c2VkIHRvIG1hdGNoIHRoZSBzZWdtZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGVjaWZpY2F0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRDaGFyYWN0ZXJzOiAnLycsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0OiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBEeW5hbWljU2VnbWVudDtcclxuICAgICAgICB9KFZhcmlhYmxlU2VnbWVudCkpO1xyXG4gICAgICAgIHJvdXRpbmcuRHluYW1pY1NlZ21lbnQgPSBEeW5hbWljU2VnbWVudDtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fRHluYW1pY1NlZ21lbnRJbnN0YW5jZSwgRHluYW1pY1NlZ21lbnQsIG51bGwsIF9fSU5TVEFOQ0UpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJvdXRlIHNlZ21lbnQgbWF0Y2hpbmcgaXMgZG9uZSB1c2luZyBhIHN0YXRlIG1hY2hpbmUuIEVhY2ggc3RhdGUgY29udGFpbnNcclxuICAgICAgICAgKiBhIHNwZWNpZmljYXRpb24gaW5kaWNhdGluZyB2YWxpZCBhbmQgaW52YWxpZCBjaGFyYWN0ZXJzLiBFYWNoIFN0YXRlIGhhcyBhXHJcbiAgICAgICAgICogbGlzdCBvZiBwb3RlbnRpYWwgbmV4dCBzdGF0ZXMuIFdoZW4gbWF0Y2hpbmcgYSByb3V0ZSBzZWdtZW50IHlvdSBzdGFydCB3aXRoXHJcbiAgICAgICAgICogYSByb290IHN0YXRlIGFuZCB0aGVuIGl0ZXJhdGl2ZWx5IG1hdGNoIG5leHQgc3RhdGVzIHVudGlsIHlvdSBjb21wbGV0ZSB0aGVcclxuICAgICAgICAgKiBzZWdtZW50IG9yIGludmFsaWRhdGUgdGhlIHNlZ21lbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFN0YXRlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBjb25zdHJ1Y3RvciBmb3IgYSBTdGF0ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFN0YXRlKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENvbXBpbGVzIGEgc2VnbWVudCBpbnRvIGEgc3RhdGUgdHJlZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnJvdXRpbmcuQmFzZVNlZ21lbnR9IHNlZ21lbnQgVGhlIHNlZ21lbnQgdG8gY29tcGlsZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnJvdXRpbmcuU3RhdGV9IHN0YXRlIFRoZSBpbml0aWFsIHN0YXRlIHdpdGggd2hpY2ggdG8gc3RhcnQgY29tcGlsYXRpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBTdGF0ZS5jb21waWxlID0gZnVuY3Rpb24gKHNlZ21lbnQsIHN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VnbWVudC5yZWR1Y2VDaGFyYWN0ZXJzKGZ1bmN0aW9uIChzLCBjaGFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMuYWRkKGNoYXIpO1xyXG4gICAgICAgICAgICAgICAgfSwgc3RhdGUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTGlua3MgYSBwYXRoIHRvIGEgY29tcGlsZWQgc3RhdGUsIGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5yb3V0aW5nLlN0YXRlfSBzdGF0ZSBUaGUgc3RhdGUgd2l0aCB3aGljaCB0byBsaW5rIHRoZSByZXN1bHQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGxpbmsgdG8gdGhlIGdpdmVuIHN0YXRlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgU3RhdGUubGluayA9IGZ1bmN0aW9uIChzdGF0ZSwgcGF0aCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlbGVnYXRlcyA9IHN0YXRlLmRlbGVnYXRlcywgcmVnZXggPSBzdGF0ZS5yZWdleCwgbGVuZ3RoID0gZGVsZWdhdGVzLmxlbmd0aCwgbWF0Y2hlcyA9IHBhdGgubWF0Y2gocmVnZXgpLCBtYXRjaEluZGV4ID0gMSwgcmVzdWx0ID0gW10sIG5hbWVzLCBwYXJhbWV0ZXJzLCBqLCBqTGVuZ3RoLCBkZWxlZ2F0ZTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZSA9IGRlbGVnYXRlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lcyA9IGRlbGVnYXRlLm5hbWVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBqTGVuZ3RoID0gbmFtZXMubGVuZ3RoOyBqIDwgakxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNbbmFtZXNbal1dID0gbWF0Y2hlc1ttYXRjaEluZGV4KytdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlOiBkZWxlZ2F0ZS5kZWxlZ2F0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyczogcGFyYW1ldGVycyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNEeW5hbWljOiBqTGVuZ3RoID4gMFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEZpbmRzIGFsbCB0aGUgbmV4dCBzdGF0ZXMgZm9yIGEgZ2l2ZW4gY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhciBUaGUgY2hhcmFjdGVyIHVzZWQgdG8gbWF0Y2ggbmV4dCBzdGF0ZXMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8cGxhdC5yb3V0aW5nLlN0YXRlPn0gc3RhdGVzIFRoZSBzdGF0ZXMgd2l0aCB3aGljaCB0byBtYXRjaCB0aGUgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgU3RhdGUucmVjb2duaXplID0gZnVuY3Rpb24gKGNoYXIsIHN0YXRlcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5leHRTdGF0ZXMgPSBbXSwgbGVuZ3RoID0gc3RhdGVzLmxlbmd0aCwgc3RhdGU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlcyA9IG5leHRTdGF0ZXMuY29uY2F0KHN0YXRlLm1hdGNoKGNoYXIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0U3RhdGVzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU29ydHMgc3RhdGVzIGJ5IHN0YXRpY3MvZHluYW1pY3Mvc3BsYXRzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHBsYXQucm91dGluZy5TdGF0ZT59IHN0YXRlcyBUaGUgc3RhdGVzIHRvIHNvcnQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBTdGF0ZS5zb3J0ID0gZnVuY3Rpb24gKHN0YXRlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KHN0YXRlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGFUeXBlcywgYVNwbGF0cywgYVN0YXRpY3MsIGFEeW5hbWljcywgYlR5cGVzLCBiU3BsYXRzLCBiU3RhdGljcywgYkR5bmFtaWNzO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYVR5cGVzID0gYS50eXBlcztcclxuICAgICAgICAgICAgICAgICAgICBiVHlwZXMgPSBiLnR5cGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGFTcGxhdHMgPSBhVHlwZXMuc3BsYXRzO1xyXG4gICAgICAgICAgICAgICAgICAgIGJTcGxhdHMgPSBiVHlwZXMuc3BsYXRzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhU3BsYXRzICE9PSBiU3BsYXRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhU3BsYXRzIC0gYlNwbGF0cztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYVN0YXRpY3MgPSBhVHlwZXMuc3RhdGljcztcclxuICAgICAgICAgICAgICAgICAgICBhRHluYW1pY3MgPSBhVHlwZXMuZHluYW1pY3M7XHJcbiAgICAgICAgICAgICAgICAgICAgYlN0YXRpY3MgPSBiVHlwZXMuc3RhdGljcztcclxuICAgICAgICAgICAgICAgICAgICBiRHluYW1pY3MgPSBiVHlwZXMuZHluYW1pY3M7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFTcGxhdHMgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhU3RhdGljcyAhPT0gYlN0YXRpY3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiU3RhdGljcyAtIGFTdGF0aWNzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhRHluYW1pY3MgIT09IGJEeW5hbWljcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJEeW5hbWljcyAtIGFEeW5hbWljcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYUR5bmFtaWNzICE9PSBiRHluYW1pY3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFEeW5hbWljcyAtIGJEeW5hbWljcztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFTdGF0aWNzICE9PSBiU3RhdGljcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYlN0YXRpY3MgPSBhU3RhdGljcztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluaXRpYWxpemVzIHRoZSBzdGF0ZSB3aXRoIHRoZSBnaXZlbiBzcGVjaWZpY2F0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucm91dGluZy5JQ2hhcmFjdGVyU3BlY2lmaWNhdGlvbn0gc3BlY2lmaWNhdGlvbj8gVGhlIGNoYXJhY3RlciBzcGVjaWZpY2F0aW9uIGZvciB0aGUgc3RhdGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBTdGF0ZS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChzcGVjaWZpY2F0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWNpZmljYXRpb24gPSBzcGVjaWZpY2F0aW9uO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0U3RhdGVzID0gW107XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBZGRzIGEgbmV3IHNwZWNpZmljYXRpb24gdG8gdGhlIG5leHQgc3RhdGVzLiBJZiB0aGUgc3BlY2lmaWNhdGlvblxyXG4gICAgICAgICAgICAgKiBhbHJlYWR5IGV4aXN0cyBhcyBhIG5leHQgc3RhdGUgYSBuZXcgb25lIHdvbid0IGJlIHVzZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5yb3V0aW5nLklDaGFyYWN0ZXJTcGVjaWZpY2F0aW9ufSBzcGVjaWZpY2F0aW9uPyBUaGUgY2hhcmFjdGVyIHNwZWNpZmljYXRpb24gdXNlZCB0byBjcmVhdGVcclxuICAgICAgICAgICAgICogdGhlIG5leHQgc3RhdGUgaWYgbmVjZXNzYXJ5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgU3RhdGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChzcGVjaWZpY2F0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9maW5kKHNwZWNpZmljYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHN0YXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN0YXRlID0gYWNxdWlyZShTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5pbml0aWFsaXplKHNwZWNpZmljYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0U3RhdGVzLnB1c2goc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNwZWNpZmljYXRpb24ucmVwZWF0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUubmV4dFN0YXRlcy5wdXNoKHN0YXRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEZpbmRzIG5leHQgc3RhdGVzIHRoYXQgbWF0Y2ggdGhlIGlucHV0IGNoYXJhY3Rlci4gSWYgdGhlIGNoYXJhY3RlciBleGlzdHNcclxuICAgICAgICAgICAgICogaW4gdGhlIHN0YXRlJ3Mgc3BlY2lmaWNhdGlvbiBmb3IgdmFsaWQgY2hhcmFjdGVycywgb3IgaWYgaXQgZG9lcyBub3RcclxuICAgICAgICAgICAgICogZXhpc3QgaW4gdGhlIHNwZWNpZmljYXRpb24gZm9yIGludmFsaWQgY2hhcmFjdGVycywgdGhlbiB0aGUgc3RhdGUgaXMgY29uc2lkZXJlZFxyXG4gICAgICAgICAgICAgKiBhIG1hdGNoLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhciBUaGUgY2hhcmFjdGVyIHdpdGggd2hpY2ggdG8gbWF0Y2ggbmV4dCBzdGF0ZXMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBTdGF0ZS5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAoY2hhcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBbXSwgc3BlYywgY2hhcnM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zb21lQ2hpbGRyZW4oZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3BlYyA9IGNoaWxkLnNwZWNpZmljYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHZhbGlkIGNoYXJhY3RlcnMgZmlyc3QgXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnMgPSBzcGVjLnZhbGlkQ2hhcmFjdGVycztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcoY2hhcnMpICYmIGNoYXJzLmluZGV4T2YoY2hhcikgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBubyBpbnZhbGlkIGNoYXJhY3RlcnMgXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnMgPSBzcGVjLmludmFsaWRDaGFyYWN0ZXJzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhjaGFycykgJiYgY2hhcnMuaW5kZXhPZihjaGFyKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRmluZHMgdGhlIG5leHQgc3RhdGUgdGhhdCBzaGFyZXMgdGhlIHNhbWUgc3BlY2lmaWNhdGlvblxyXG4gICAgICAgICAgICAgKiBhcyB0aGUgaW5wdXQgc3BlYy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnJvdXRpbmcuSUNoYXJhY3RlclNwZWNpZmljYXRpb259IHNwZWMgVGhlIGNoYXJhY3RlciBzcGVjaWZpY2F0aW9uIHVzZWQgdG8gZmluZFxyXG4gICAgICAgICAgICAgKiB0aGUgbmV4dCBzdGF0ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFN0YXRlLnByb3RvdHlwZS5fZmluZCA9IGZ1bmN0aW9uIChzcGVjKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsaWRDaGFycyA9IHNwZWMudmFsaWRDaGFyYWN0ZXJzLCBpbnZhbGlkQ2hhcnMgPSBzcGVjLmludmFsaWRDaGFyYWN0ZXJzLCBzLCBmb3VuZDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NvbWVDaGlsZHJlbihmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzID0gY2hpbGQuc3BlY2lmaWNhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocy52YWxpZENoYXJhY3RlcnMgPT09IHZhbGlkQ2hhcnMgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgcy5pbnZhbGlkQ2hhcmFjdGVycyA9PT0gaW52YWxpZENoYXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gY2hpbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTdGF0ZS5wcm90b3R5cGUuX3NvbWVDaGlsZHJlbiA9IGZ1bmN0aW9uIChpdGVyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5leHRTdGF0ZXMgPSB0aGlzLm5leHRTdGF0ZXMsIGxlbmd0aCA9IG5leHRTdGF0ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVyYXRvcihuZXh0U3RhdGVzW2ldKSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBTdGF0ZTtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIHJvdXRpbmcuU3RhdGUgPSBTdGF0ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBJU3RhdGVTdGF0aWMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdGF0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcm91dGluZy5JU3RhdGVTdGF0aWMgPSBJU3RhdGVTdGF0aWM7XHJcbiAgICAgICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX1N0YXRlU3RhdGljLCBJU3RhdGVTdGF0aWMsIG51bGwsIF9fU1RBVElDKTtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fU3RhdGVJbnN0YW5jZSwgU3RhdGUsIG51bGwsIF9fSU5TVEFOQ0UpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFzc2lzdHMgaW4gY29tcGlsaW5nIGFuZCBsaW5raW5nIHJvdXRlIHN0cmluZ3MuIFlvdSBjYW4gcmVnaXN0ZXIgcm91dGUgc3RyaW5ncyB1c2luZ1xyXG4gICAgICAgICAqIGEgZGVmaW5lZCBzY2hlbWUsIGFuZCBpdCB3aWxsIGNvbXBpbGUgdGhlIHJvdXRlcy4gV2hlbiB5b3Ugd2FudCB0byBtYXRjaCBhIHJvdXRlLCBpdCB3aWxsXHJcbiAgICAgICAgICogZmluZCB0aGUgYXNzb2NpYXRlZCBjb21waWxlZCByb3V0ZSBhbmQgbGluayBpdCB0byB0aGUgZGF0YSBnaXZlbiB3aXRoIHRoZSBwYXNzZWQtaW4gcm91dGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFJvdXRlUmVjb2duaXplciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFJvdXRlUmVjb2duaXplcigpIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQWxsIHRoZSBuYW1lZCByb3V0ZXMgZm9yIHRoaXMgcmVjb2duaXplci5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbmFtZWRSb3V0ZXMgPSB7fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBtZXRob2QgZm9yIHJlZ2lzdGVyaW5nIHJvdXRlcyB0byBiZSBpZGVudGlmaWVkIGxhdGVyLiBJbnRlcm5hbGx5IHRoZVxyXG4gICAgICAgICAgICAgKiByb3V0ZXMgd2lsbCBiZSBjb21waWxlZCBpbnRvIGEgc2VyaWVzIG9mIHN0YXRlc1xyXG4gICAgICAgICAgICAgKiB3aGljaCB3aWxsIGJlIHVzZWQgdG8gcmVjb2duaXplIHRoZSByb3V0ZSBsYXRlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxwbGF0LnJvdXRpbmcuSVJvdXRlRGVsZWdhdGU+fSByb3V0ZXMgVGhlIHJvdXRlcyB0byByZWdpc3Rlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnJvdXRpbmcuSVJlZ2lzdGVyT3B0aW9uc30gb3B0aW9ucz8gQW4gb2JqZWN0IGNvbnRhaW5pbmcgb3B0aW9ucyBmb3IgdGhlXHJcbiAgICAgICAgICAgICAqIHJlZ2lzdGVyZWQgcm91dGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSb3V0ZVJlY29nbml6ZXIucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHJvdXRlcywgb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KHJvdXRlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZmluYWxTdGF0ZSA9IHRoaXMuX3Jvb3RTdGF0ZSwgbGVuZ3RoID0gcm91dGVzLmxlbmd0aCwgcmVnZXggPSBbJ14nXSwgdHlwZXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljczogMCxcclxuICAgICAgICAgICAgICAgICAgICBkeW5hbWljczogMCxcclxuICAgICAgICAgICAgICAgICAgICBzcGxhdHM6IDBcclxuICAgICAgICAgICAgICAgIH0sIGRlbGVnYXRlcyA9IFtdLCBhbGxTZWdtZW50cyA9IFtdLCBzZWdtZW50cztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50cyA9IHRoaXMuX3BhcnNlKHJvdXRlc1tpXSwgZGVsZWdhdGVzLCB0eXBlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxsU2VnbWVudHMgPSBhbGxTZWdtZW50cy5jb25jYXQoc2VnbWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsU3RhdGUgPSB0aGlzLl9jb21waWxlKHNlZ21lbnRzLCBmaW5hbFN0YXRlLCByZWdleCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaW5hbFN0YXRlID0gdGhpcy5fZmluYWxpemUoZmluYWxTdGF0ZSwgcmVnZXgpO1xyXG4gICAgICAgICAgICAgICAgZmluYWxTdGF0ZS5kZWxlZ2F0ZXMgPSBkZWxlZ2F0ZXM7XHJcbiAgICAgICAgICAgICAgICBmaW5hbFN0YXRlLnJlZ2V4ID0gbmV3IFJlZ0V4cChyZWdleC5qb2luKCcnKSArICckJyk7XHJcbiAgICAgICAgICAgICAgICBmaW5hbFN0YXRlLnR5cGVzID0gdHlwZXM7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykgJiYgaXNTdHJpbmcob3B0aW9ucy5uYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25hbWVkUm91dGVzW3RoaXMuX3RvTG93ZXJDYXNlKG9wdGlvbnMubmFtZSldID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50czogYWxsU2VnbWVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlczogZGVsZWdhdGVzXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNlYXJjaGVzIGZvciBhIG1hdGNoIHRvIHRoZSBwcm92aWRlZCBwYXRoLiBJZiBhIG1hdGNoIGlzIGZvdW5kLCB0aGUgcGF0aCBpcyBkZWNvbnN0cnVjdGVkXHJcbiAgICAgICAgICAgICAqIHRvIHBvcHVsYXRlIGEgcGFyYW1ldGVycyBvYmplY3QgKGlmIHRoZSByZWdpc3RlcmVkIHJvdXRlIHdhcyBhIGR5bmFtaWMvc3BsYXQgcm91dGUpLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCB0byByZWNvZ25pemUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSb3V0ZVJlY29nbml6ZXIucHJvdG90eXBlLnJlY29nbml6ZSA9IGZ1bmN0aW9uIChwYXRoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNUcmFpbGluZ1NsYXNoRHJvcHBlZCA9IGZhbHNlLCBzb2x1dGlvbnMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHBhdGggPSB0aGlzLl9hZGRMZWFkaW5nU2xhc2gocGF0aCk7XHJcbiAgICAgICAgICAgICAgICBpc1RyYWlsaW5nU2xhc2hEcm9wcGVkID0gdGhpcy5faGFzVHJhaWxpbmdTbGFzaChwYXRoKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1RyYWlsaW5nU2xhc2hEcm9wcGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDAsIHBhdGgubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzb2x1dGlvbnMgPSB0aGlzLl9maWx0ZXIodGhpcy5fZmluZFN0YXRlcyhwYXRoKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGluayhzb2x1dGlvbnNbMF0sIHBhdGgsIGlzVHJhaWxpbmdTbGFzaERyb3BwZWQpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRmluZHMgYSBJTmFtZWRSb3V0ZSBhbmQgZ2VuZXJhdGVzIGEgc3RyaW5nXHJcbiAgICAgICAgICAgICAqIGlmIGl0IGV4aXN0cy4gVXNlcyB0aGUgcGFyYW1ldGVycyBvYmplY3QgdG8gZ2VuZXJhdGUgZHluYW1pYyByb3V0ZXMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lZCByb3V0ZSB3aXRoIHdoaWNoIHRvIGdlbmVyYXRlIHRoZSByb3V0ZSBzdHJpbmcuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5JT2JqZWN0PHN0cmluZz59IHBhcmFtZXRlcnMgVGhlIHJvdXRlIHBhcmFtZXRlcnMsIGluIHRoZSBjYXNlIHRoYXQgdGhlXHJcbiAgICAgICAgICAgICAqIG5hbWVkIHJvdXRlIGlzIGR5bmFtaWMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSb3V0ZVJlY29nbml6ZXIucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gKG5hbWUsIHBhcmFtZXRlcnMpIHtcclxuICAgICAgICAgICAgICAgIG5hbWUgPSB0aGlzLl90b0xvd2VyQ2FzZShuYW1lKTtcclxuICAgICAgICAgICAgICAgIHZhciByb3V0ZSA9IHRoaXMuX25hbWVkUm91dGVzW25hbWVdLCBvdXRwdXQgPSAnJywgc2VnbWVudHMsIGxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmICghaXNPYmplY3Qocm91dGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2VnbWVudHMgPSByb3V0ZS5zZWdtZW50cztcclxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWdtZW50LnR5cGUgPT09IF9fQkFTRV9TRUdNRU5UX1RZUEUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSAnLyc7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IHNlZ21lbnQuZ2VuZXJhdGUocGFyYW1ldGVycyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzLl9hZGRMZWFkaW5nU2xhc2gob3V0cHV0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGaW5kcyB0aGUgZGVsZWdhdGVzIGZvciBhbiBJTmFtZWRSb3V0ZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZWQgcm91dGUgZnJvbSB3aGljaCB0byBnZXQgdGhlIGRlbGVnYXRlcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJvdXRlUmVjb2duaXplci5wcm90b3R5cGUuZGVsZWdhdGVzRm9yID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIG5hbWUgPSB0aGlzLl90b0xvd2VyQ2FzZShuYW1lKTtcclxuICAgICAgICAgICAgICAgIHZhciBuYW1lZFJvdXRlID0gdGhpcy5fbmFtZWRSb3V0ZXNbbmFtZV0sIGRlbGVnYXRlcztcclxuICAgICAgICAgICAgICAgIGlmICghaXNPYmplY3QobmFtZWRSb3V0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZWxlZ2F0ZXMgPSBuYW1lZFJvdXRlLmRlbGVnYXRlcztcclxuICAgICAgICAgICAgICAgIGlmICghaXNBcnJheShkZWxlZ2F0ZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlcy5zbGljZSgwKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgYW4gSU5hbWVkUm91dGUgaXMgcmVnaXN0ZXJlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWVkIHJvdXRlIHRvIHNlYXJjaCBmb3IuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSb3V0ZVJlY29nbml6ZXIucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNPYmplY3QodGhpcy5fbmFtZWRSb3V0ZXNbdGhpcy5fdG9Mb3dlckNhc2UobmFtZSldKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNhZmVseSBjb252ZXJ0cyBhIHN0cmluZyB0byBsb3dlciBjYXNlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gY29udmVydCB0byBsb3dlciBjYXNlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5fdG9Mb3dlckNhc2UgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzU3RyaW5nKHN0cikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRmluYWxpemVzIGEgY29tcGlsZWQgcm91dGUsIGFkZGluZyBhIGZpbmFsIHN0YXRlIGlmIG5lY2Vzc2FyeS4gSWYgdGhlIHN0YXRlIGlzIGVxdWFsIHRvIHRoZVxyXG4gICAgICAgICAgICAgKiByb290IHN0YXRlIGZvciB0aGUgcmVjb2duaXplciwgYSBuZXcgc3RhdGUgd2lsbCBiZSBjcmVhdGVkLiBUaGlzIGlzIGJlY2F1c2UgdGhlIHJvb3Qgc3RhdGUgZG9lcyBub3RcclxuICAgICAgICAgICAgICogcmVwcmVzZW50IGFueSByb3V0ZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnJvdXRpbmcuU3RhdGV9IHN0YXRlIFRoZSBzdGF0ZSB0byBmaW5hbGl6ZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2V4IFRoZSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nIGJ1aWx0IGZvciB0aGUgY29tcGlsZWQgcm91dGVzLiBVc2VkIHRvIHJlY29nbml6ZVxyXG4gICAgICAgICAgICAgKiByb3V0ZXMgYW5kIGFzc29jaWF0ZSB0aGVtIHdpdGggdGhlIGNvbXBpbGVkIHJvdXRlcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJvdXRlUmVjb2duaXplci5wcm90b3R5cGUuX2ZpbmFsaXplID0gZnVuY3Rpb24gKHN0YXRlLCByZWdleCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSB0aGlzLl9yb290U3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLmFkZCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkQ2hhcmFjdGVyczogJy8nXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVnZXgucHVzaCgnLycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGFyc2VzIGEgcm91dGUgaW50byBkaWZmZXJlbnQgc2VnbWVudHM7XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5yb3V0aW5nLklSb3V0ZURlbGVnYXRlfSByb3V0ZSBUaGUgcm91dGUgb3B0aW9ucyB0byBiZSBwYXJzZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8cGxhdC5yb3V0aW5nLklEZWxlZ2F0ZVBhcmFtZXRlck5hbWVzPn0gZGVsZWdhdGVzIFRoZSBkZWxlZ2F0ZXMgYW5kIGFzc29jaWF0ZWQgbmFtZXMgZm9yIG1hcHBpbmcgcGFyYW1ldGVycy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnJvdXRpbmcuSVNlZ21lbnRUeXBlQ291bnR9IHR5cGVzIEEgY291bnQgb2YgYWxsIHRoZSBzZWdtZW50IHR5cGVzIGluIHRoZSByb3V0ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJvdXRlUmVjb2duaXplci5wcm90b3R5cGUuX3BhcnNlID0gZnVuY3Rpb24gKHJvdXRlLCBkZWxlZ2F0ZXMsIHR5cGVzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmFtZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGRlbGVnYXRlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZTogcm91dGUuZGVsZWdhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZXM6IG5hbWVzXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9CYXNlU2VnbWVudEZhY3RvcnkucGFyc2Uocm91dGUucGF0dGVybiwgbmFtZXMsIHR5cGVzKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENvbXBpbGVzIGEgbGlzdCBvZiBzZWdtZW50cyBpbnRvIGEgc2VyaWVzIG9mIHN0YXRlcy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxwbGF0LnJvdXRpbmcuQmFzZVNlZ21lbnQ+fSBzZWdtZW50cyBUaGUgc2VnbWVudHMgdG8gY29tcGlsZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnJvdXRpbmcuU3RhdGV9IHN0YXRlIFRoZSBpbml0aWFsIHN0YXRlIHVzZWQgdG8gY29tcGlsZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSByZWdleCBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcgdG8gYnVpbGQgaW4gb3JkZXIgdG8gbWF0Y2ggdGhlIHNlZ21lbnRzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5fY29tcGlsZSA9IGZ1bmN0aW9uIChzZWdtZW50cywgc3RhdGUsIHJlZ2V4KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoLCBjb21waWxlID0gdGhpcy5fU3RhdGUuY29tcGlsZSwgc2VnbWVudDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50ID0gc2VnbWVudHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZ21lbnQudHlwZSA9PT0gX19CQVNFX1NFR01FTlRfVFlQRSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS5hZGQoeyB2YWxpZENoYXJhY3RlcnM6ICcvJyB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IGNvbXBpbGUoc2VnbWVudCwgc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlZ2V4LnB1c2goJy8nICsgc2VnbWVudC5yZWdleCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBZGRzIGEgbGVhZGluZyBzbGFzaCB0byB0aGUgcGFzc2VkLWluIHN0cmluZyBpZiBuZWNlc3NhcnkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIHdoaWNoIHRvIGFkZCB0aGUgc2xhc2guXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSb3V0ZVJlY29nbml6ZXIucHJvdG90eXBlLl9hZGRMZWFkaW5nU2xhc2ggPSBmdW5jdGlvbiAocGF0aCkge1xyXG4gICAgICAgICAgICAgICAgcGF0aCA9IGRlY29kZVVSSShwYXRoKTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXRoWzBdICE9PSAnLycpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoID0gJy8nICsgcGF0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2hlY2tzIGZvciBhIHRyYWlsaW5nIHNsYXNoIG9uIGEgZ2l2ZW4gc3RyaW5nLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvbiB3aGljaCB0byBsb29rIGZvciBhIHRyYWlsaW5nIHNsYXNoLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5faGFzVHJhaWxpbmdTbGFzaCA9IGZ1bmN0aW9uIChwYXRoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoID4gMSAmJiBwYXRoW2xlbmd0aCAtIDFdID09PSAnLyc7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGaW5kcyB0aGUgY29tcGlsZWQgc3RhdGVzIGZvciBhIGdpdmVuIHBhdGguXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHdpdGggd2hpY2ggdG8gbG9vayBmb3IgY29tcGlsZWQgc3RhdGVzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5fZmluZFN0YXRlcyA9IGZ1bmN0aW9uIChwYXRoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGVzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3RTdGF0ZVxyXG4gICAgICAgICAgICAgICAgXSwgcmVjb2duaXplID0gdGhpcy5fU3RhdGUucmVjb2duaXplLCBsZW5ndGggPSBwYXRoLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZXMgPSByZWNvZ25pemUocGF0aFtpXSwgc3RhdGVzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGVzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRmlsdGVycyBvdXQgc3RhdGVzIHdpdGggbm8gZGVsZWdhdGVzLCBhbmQgc29ydHMgdGhlIHN0YXRlcy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxwbGF0LnJvdXRpbmcuU3RhdGU+fSBzdGF0ZXMgVGhlIHN0YXRlcyB0byBmaWx0ZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSb3V0ZVJlY29nbml6ZXIucHJvdG90eXBlLl9maWx0ZXIgPSBmdW5jdGlvbiAoc3RhdGVzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gc3RhdGVzLmxlbmd0aCwgc29sdXRpb25zID0gW10sIHN0YXRlO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gc3RhdGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHN0YXRlLmRlbGVnYXRlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9TdGF0ZS5zb3J0KHNvbHV0aW9ucyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBMaW5rcyBhIHN0YXRlIHRvIGEgcGF0aCwgcHJvZHVjaW5nIGFuIElSZWNvZ25pemVSZXN1bHQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5yb3V0aW5nLlN0YXRlfSBzdGF0ZXMgVGhlIHN0YXRlIHRvIGxpbmsuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGxpbmsuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNUcmFpbGluZ1NsYXNoRHJvcHBlZCBXaGV0aGVyIG9yIG5vdCB0aGUgdHJhaWxpbmcgc2xhc2ggaXMgZHJvcHBlZCBmcm9tIHRoZSBwYXRoLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5fbGluayA9IGZ1bmN0aW9uIChzdGF0ZSwgcGF0aCwgaXNUcmFpbGluZ1NsYXNoRHJvcHBlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHN0YXRlKSAmJiBpc0FycmF5KHN0YXRlLmRlbGVnYXRlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNUcmFpbGluZ1NsYXNoRHJvcHBlZCAmJiB0aGlzLl9pc0R5bmFtaWMoc3RhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoICsgJy8nO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fU3RhdGUubGluayhzdGF0ZSwgcGF0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRoZSBzdGF0ZSBpcyBkeW5hbWljLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucm91dGluZy5TdGF0ZX0gc3RhdGVzIFRoZSBzdGF0ZSB1c2VkIHRvIGRldGVybWluZSBpZiBpdCBpcyBkeW5hbWljIG9yIG5vdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJvdXRlUmVjb2duaXplci5wcm90b3R5cGUuX2lzRHluYW1pYyA9IGZ1bmN0aW9uIChzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnJlZ2V4LnNvdXJjZS5zbGljZSgtNSkgPT09ICcoLispJCc7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFJvdXRlUmVjb2duaXplci5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICAgICAgX0Jhc2VTZWdtZW50RmFjdG9yeTogX19CYXNlU2VnbWVudEZhY3RvcnksXHJcbiAgICAgICAgICAgICAgICBfU3RhdGU6IF9fU3RhdGVTdGF0aWMsXHJcbiAgICAgICAgICAgICAgICBfcm9vdFN0YXRlOiBfX1N0YXRlSW5zdGFuY2VcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFJvdXRlUmVjb2duaXplcjtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIHJvdXRpbmcuUm91dGVSZWNvZ25pemVyID0gUm91dGVSZWNvZ25pemVyO1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19Sb3V0ZVJlY29nbml6ZXJJbnN0YW5jZSwgUm91dGVSZWNvZ25pemVyLCBudWxsLCBfX0lOU1RBTkNFKTtcclxuICAgICAgICA7XHJcbiAgICAgICAgdmFyIF9fQ0hJTERfUk9VVEUgPSAnLypjaGlsZFJvdXRlJywgX19DSElMRF9ST1VURV9MRU5HVEggPSBfX0NISUxEX1JPVVRFLmxlbmd0aDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNYXRjaGVzIFVSTHMgdG8gcmVnaXN0ZXJlZCB2aWV3cy4gQWxsb3dzIGZvciByZWplY3RpbmcgbmF2aWdhdGlvbiwgYXMgd2VsbCBhc1xyXG4gICAgICAgICAqIHByb2Nlc3Npbmcgcm91dGUgYW5kIHF1ZXJ5IHBhcmFtZXRlcnMuIFdoZW4gYSByb3V0ZSBpcyBtYXRjaGVzLCB0aGUgY3VycmVudCB2aWV3XHJcbiAgICAgICAgICogaGFzIHRoZSBvcHBvcnR1bml0eSB0byByZWplY3QvZGVsYXkgbmF2aWdhdGlvbi4gVGhlIG5leHQgdmlldyBjYW4gYWxzbyByZWplY3QgbmF2aWdhdGlvbixcclxuICAgICAgICAgKiBvciByZWRpcmVjdC5cclxuICAgICAgICAgKiBUaGlzIGlzIGRvbmUgYXN5bmNocm9ub3VzbHksIGdpdmluZyB0aGUgYXBwbGljYXRpb24gdGhlIGFiaWxpdHkgdG8gbWFrZSB3ZWIgc2VydmljZSBjYWxsc1xyXG4gICAgICAgICAqIHRvIGRldGVybWluZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBSb3V0ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5zdGFudGlhdGVzIGEgbmV3IHJvdXRlciBhbmQgc2V0cyBpdCBhcyB0aGUgY3VycmVudCByb3V0ZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBSb3V0ZXIoKSB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSByb3V0ZXIgaXMgY3VycmVudGx5IG5hdmlnYXRpbmcuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMubmF2aWdhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBbGwgdGhlIHJlZ2lzdGVyZWQgY2hpbGRyZW4gZm9yIHRoaXMgcm91dGVyLiBVc2VmdWwgZm9yIGdlbmVyYXRpbmcgYW5kIG1hdGNoaW5nIHJvdXRlcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGlzIHJvdXRlciBpcyB0aGUgcm9vdCByb3V0ZXIgKGhhcyBubyBwYXJlbnQpLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzUm9vdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBbiBvYmplY3QgY29udGFpbmluZyB0cmFuc2Zvcm0gbWV0aG9kcyBmb3Igcm91dGUgcGFyYW1ldGVycy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyYW1UcmFuc2Zvcm1zID0ge307XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFuIG9iamVjdCBjb250YWluaW5nIHRyYW5zZm9ybSBtZXRob2RzIGZvciBxdWVyeSBwYXJhbWV0ZXJzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWVyeVRyYW5zZm9ybXMgPSB7fTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgaW50ZXJjZXB0b3IgbWV0aG9kcyBmb3IgcGFydGljdWxhciByb3V0ZXMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVyY2VwdG9ycyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBbGwgdGhlIHJlZ2lzdGVyZWQgVmlld3BvcnRzIGZvciB0aGUgcm91dGVyLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3J0cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIHNob3J0Y3V0IHRvIHRoZSBQcm9taXNlLnJlc29sdmUgZnVuY3Rpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUgPSB0aGlzLl9Qcm9taXNlLnJlc29sdmUuYmluZCh0aGlzLl9Qcm9taXNlKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBzaG9ydGN1dCB0byB0aGUgUHJvbWlzZS5yZWplY3QgZnVuY3Rpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdCA9IHRoaXMuX1Byb21pc2UucmVqZWN0LmJpbmQodGhpcy5fUHJvbWlzZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVpZCA9IHVuaXF1ZUlkKF9fUGxhdCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzUm9vdCA9IGlzTnVsbChSb3V0ZXIuY3VycmVudFJvdXRlcigpKTtcclxuICAgICAgICAgICAgICAgIFJvdXRlci5jdXJyZW50Um91dGVyKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEV4cG9zZXMgdGhlIGN1cnJlbnQgcm91dGVyIHByb3BlcnR5LiBBbHNvIHByb3ZpZGVzIHRoZVxyXG4gICAgICAgICAgICAgKiBhYmlsaXR5IHRvIHNldCB0aGUgY3VycmVudCByb3V0ZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5yb3V0aW5nLlJvdXRlcn0gcm91dGVyIFdpbGwgc2V0IHRoZSBjdXJyZW50IHJvdXRlci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJvdXRlci5jdXJyZW50Um91dGVyID0gZnVuY3Rpb24gKHJvdXRlcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGwocm91dGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIFJvdXRlci5fX2N1cnJlbnRSb3V0ZXIgPSByb3V0ZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUm91dGVyLl9fY3VycmVudFJvdXRlcjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluaXRpYWxpemVzIGEgcm91dGVyLCBnaXZpbmcgaXQgYSBwYXJlbnQgcm91dGVyIHRvIGxpbmsgdG8gaWYgbmVjZXNzYXJ5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucm91dGluZy5Sb3V0ZXJ9IHBhcmVudD8gVGhlIHBhcmVudCByb3V0ZXIgdG8gbGluay5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJvdXRlci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVnaXN0ZXJzIGEgY2hpbGQgcm91dGVyIHdpdGggdGhlIGN1cnJlbnQgcm91dGVyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucm91dGluZy5Sb3V0ZXJ9IGNoaWxkIEEgY2hpbGQgcm91dGVyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUm91dGVyLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChjaGlsZCkgfHwgdGhpcy5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2hpbGQuaW5pdGlhbGl6ZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZW1vdmVzIGEgY2hpbGQgZnJvbSB0aGUgcm91dGVyJ3MgY2hpbGRyZW4sIGlmIGl0IGV4aXN0cy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnJvdXRpbmcuUm91dGVyfSBjaGlsZCBUaGUgY2hpbGQgcm91dGVyIHRvIHJlbW92ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJvdXRlci5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4sIGluZGV4ID0gY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gUm91dGVyLmN1cnJlbnRSb3V0ZXIoKTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIFJvdXRlci5jdXJyZW50Um91dGVyKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVnaXN0ZXJzIGEgVmlld3BvcnQgKG9yIHNpbWlsYXIgb2JqZWN0KSB3aXRoIHRoZVxyXG4gICAgICAgICAgICAgKiByb3V0ZXIsIGFuZCB0cmlnZ2VycyBhIG5hdmlnYXRpb24gaWYgcG9zc2libGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5yb3V0aW5nLklTdXBwb3J0Um91dGVOYXZpZ2F0aW9ufSBwb3J0IEFuIG9iamVjdCB0aGF0IHN1cHBvcnRzIGFsbCB0aGUgbmF2aWdhdGlvbiBldmVudHMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSb3V0ZXIucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHBvcnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9ydHMgPSB0aGlzLl9wb3J0cztcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwocG9ydCkgfHwgcG9ydHMuaW5kZXhPZihwb3J0KSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBvcnRzLnB1c2gocG9ydCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzT2JqZWN0KHRoaXMuY3VycmVudFJvdXRlSW5mbykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHRoaXMuZmluaXNoTmF2aWdhdGluZylcclxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2gobm9vcClcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvdXRlSW5mbyA9IF9jbG9uZShfdGhpcy5jdXJyZW50Um91dGVJbmZvLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZmluaXNoTmF2aWdhdGluZyA9IF90aGlzLl9jYW5OYXZpZ2F0ZVRvKHJvdXRlSW5mbylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNhbk5hdmlnYXRlVG8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5OYXZpZ2F0ZVRvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3VycmVudFJvdXRlSW5mbyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9wZXJmb3JtTmF2aWdhdGlvbihyb3V0ZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5uYXZpZ2F0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmN1cnJlbnRSb3V0ZUluZm8gPSByb3V0ZUluZm87XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5uYXZpZ2F0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFVucmVnaXN0ZXJzIGEgVmlld3BvcnQgKG9yIHNpbWlsYXIgb2JqZWN0KSB3aXRoIHRoZVxyXG4gICAgICAgICAgICAgKiByb3V0ZXIgaW4gb3JkZXIgdG8gc3RvcCByZWNlaXZpbmcgbmF2aWdhdGlvbiBldmVudHMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5yb3V0aW5nLklTdXBwb3J0Um91dGVOYXZpZ2F0aW9ufSBwb3J0IEFuIG9iamVjdCB0aGF0IHN1cHBvcnRzIGFsbCB0aGUgbmF2aWdhdGlvbiBldmVudHMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSb3V0ZXIucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiAocG9ydCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvcnRzID0gdGhpcy5fcG9ydHMsIGluZGV4ID0gcG9ydHMuaW5kZXhPZihwb3J0KTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwb3J0cy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvcnRzLmxlbmd0aCA9PT0gMCAmJiAhaXNOdWxsKHRoaXMucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBSb3V0ZXIucHJvdG90eXBlLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uIChyb3V0ZXMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShyb3V0ZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yRWFjaChmdW5jdGlvbiAocm91dGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NvbmZpZ3VyZVJvdXRlKHJvdXRlKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCByb3V0ZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uZmlndXJlUm91dGUocm91dGVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb3JjZU5hdmlnYXRlKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBbGxvd3MgZm9yIGR5bmFtaWMgcm91dGluZy4gQ2FsbCB0aGlzIG1ldGhvZCBpbiBvcmRlciB0byByZWdpc3RlciBhIGhhbmRsZXIgZm9yIGR5bmFtaWNhbGx5IGRldGVybWluaW5nIHdoYXQgdmlldyB0b1xyXG4gICAgICAgICAgICAgKiB1c2Ugd2hlbiBhIHJlZ2lzdGVyZWQgcm91dGUgaXMgbm90IGZvdW5kLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geyhpbmZvOiBJVW5rbm93blJvdXRlSW5mbykgPT4gYW55fSBoYW5kbGVyIEEgbWV0aG9kIGNhbGxlZCB0byBkZXRlcm1pbmUgd2hhdCB2aWV3IGlzIGFzc29jaWF0ZWQgd2l0aCBhIHJvdXRlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUm91dGVyLnByb3RvdHlwZS51bmtub3duID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Vua25vd25IYW5kbGVyID0gaGFuZGxlcjtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBSb3V0ZXIucHJvdG90eXBlLnBhcmFtID0gZnVuY3Rpb24gKGhhbmRsZXIsIHBhcmFtZXRlciwgdmlldykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZEhhbmRsZXIoaGFuZGxlciwgcGFyYW1ldGVyLCB2aWV3LCB0aGlzLl9wYXJhbVRyYW5zZm9ybXMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBSb3V0ZXIucHJvdG90eXBlLnF1ZXJ5UGFyYW0gPSBmdW5jdGlvbiAoaGFuZGxlciwgcGFyYW1ldGVyLCB2aWV3KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkSGFuZGxlcihoYW5kbGVyLCBwYXJhbWV0ZXIsIHZpZXcsIHRoaXMuX3F1ZXJ5VHJhbnNmb3Jtcyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFJvdXRlci5wcm90b3R5cGUuaW50ZXJjZXB0ID0gZnVuY3Rpb24gKGludGVyY2VwdG9yLCB2aWV3KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodmlldykpIHtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3ID0gJyonO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGFsaWFzID0gdmlldztcclxuICAgICAgICAgICAgICAgIGlmICh2aWV3ICE9PSAnKicpIHtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3ID0gdGhpcy5fSW5qZWN0b3IuY29udmVydERlcGVuZGVuY3kodmlldyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodmlldyA9PT0gX19OT09QX0lOSkVDVE9SKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlldyA9IGFsaWFzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGludGVyY2VwdG9ycyA9IHRoaXMuX2ludGVyY2VwdG9yc1t2aWV3XTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNBcnJheShpbnRlcmNlcHRvcnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJjZXB0b3JzID0gdGhpcy5faW50ZXJjZXB0b3JzW3ZpZXddID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnRlcmNlcHRvcnMucHVzaChpbnRlcmNlcHRvcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRlbGxzIHRoZSByb3V0ZXIgdG8gbWF0Y2ggYSBuZXcgcm91dGUuIFRoZSByb3V0ZXIgd2lsbCBhdHRlbXB0IHRvIGZpbmQgdGhlIHJvdXRlIGFuZCBpZiBpdCBzdWNjZWVkcyBpdCB3aWxsXHJcbiAgICAgICAgICAgICAqIGF0dGVtcHQgdG8gbmF2aWdhdGUgdG8gaXQuIElmIGl0IGZhaWxzLCBpdCB3aWxsIHJldHVybiBhIFByb21pc2UgdGhhdCByZWplY3RzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBuZXcgcm91dGUgdG8gbWF0Y2guXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5JT2JqZWN0PGFueT59IHF1ZXJ5IFRoZSBxdWVyeSBwYXJhbWV0ZXJzIGZvciB0aGUgcm91dGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2UgV2hldGhlciBvciBub3QgdG8gZm9yY2UgbmF2aWdhdGlvbiwgZXZlbiBpZiB0aGUgc2FtZSB1cmwgaGFzIGFscmVhZHkgYmVlbiBtYXRjaGVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUm91dGVyLnByb3RvdHlwZS5uYXZpZ2F0ZSA9IGZ1bmN0aW9uICh1cmwsIHF1ZXJ5LCBmb3JjZSwgcG9sbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIGlmIChwb2xsID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvbGwgPSAhaXNPYmplY3QodGhpcy5jdXJyZW50Um91dGVJbmZvKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghaXNPYmplY3QocXVlcnkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVlcnkgPSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciByZXNvbHZlID0gdGhpcy5fcmVzb2x2ZSwgcXVlcnlTdHJpbmcgPSBzZXJpYWxpemVRdWVyeShxdWVyeSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodXJsID09PSAnLycpIHtcclxuICAgICAgICAgICAgICAgICAgICB1cmwgPSAnJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvcmNlID0gZm9yY2UgPT09IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzU3RyaW5nKHVybCkgfHwgdGhpcy5uYXZpZ2F0aW5nIHx8ICghZm9yY2UgJiYgdXJsID09PSB0aGlzLl9wcmV2aW91c1VybCAmJiBxdWVyeVN0cmluZyA9PT0gdGhpcy5fcHJldmlvdXNRdWVyeSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5uYXZpZ2F0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5hdmlnYXRpbmcudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubmF2aWdhdGUodXJsLCBxdWVyeSwgZm9yY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciByZWNvZ25pemVyID0gdGhpcy5fcmVjb2duaXplciwgcmVzdWx0ID0gcmVjb2duaXplci5yZWNvZ25pemUodXJsKSwgcm91dGVJbmZvLCBlbXB0eVJlc3VsdCA9IGlzRW1wdHkocmVzdWx0KSwgcGF0dGVybiwgc2VnbWVudDtcclxuICAgICAgICAgICAgICAgIGlmICghZW1wdHlSZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8gPSByZXN1bHRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLnF1ZXJ5ID0gcXVlcnk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgc2FtZVJvdXRlID0gdGhpcy5faXNTYW1lUm91dGUocm91dGVJbmZvKTtcclxuICAgICAgICAgICAgICAgIGlmIChlbXB0eVJlc3VsdCB8fCBzYW1lUm91dGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRVcmxfMSA9IHVybDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2FtZVJvdXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnQgPSByZWNvZ25pemVyLmdlbmVyYXRlKHJvdXRlSW5mby5kZWxlZ2F0ZS5hbGlhcyB8fCByb3V0ZUluZm8uZGVsZWdhdGUudmlldywgcm91dGVJbmZvLnBhcmFtZXRlcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZFVybF8xID0gY2hpbGRVcmxfMS5yZXBsYWNlKHNlZ21lbnQsICcnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkVXJsXzEgPT09ICcvJyB8fCBjaGlsZFVybF8xID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZFVybF8xID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvbWUoZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBjaGlsZC5fcmVjb2duaXplci5yZWNvZ25pemUoY2hpbGRVcmxfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWlzRW1wdHkocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9jaGlsZFJlY29nbml6ZXIucmVjb2duaXplKGNoaWxkVXJsXzEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZW1wdHlSZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlY29nbml6ZXIucmVjb2duaXplKHVybCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8gPSByZXN1bHRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8ucXVlcnkgPSBxdWVyeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSByb3V0ZUluZm8uZGVsZWdhdGUucGF0dGVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJvdXRlIGhhcyBub3QgYmVlbiBtYXRjaGVkIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNVcmwgPSBjaGlsZFVybF8xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNRdWVyeSA9IHF1ZXJ5U3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Um91dGVJbmZvID0gcm91dGVJbmZvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpcy5fdW5rbm93bkhhbmRsZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVua25vd25Sb3V0ZUNvbmZpZ18xID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50OiB1cmwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXc6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodGhpcy5fdW5rbm93bkhhbmRsZXIodW5rbm93blJvdXRlQ29uZmlnXzEpKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZpZXcgPSB1bmtub3duUm91dGVDb25maWdfMS52aWV3O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodmlldykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY29uZmlndXJlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IHVybCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXc6IHZpZXdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8gPSByZXN1bHRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5xdWVyeSA9IHF1ZXJ5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gcm91dGVJbmZvLmRlbGVnYXRlLnBhdHRlcm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnNsaWNlKDAsIHBhdHRlcm4ubGVuZ3RoIC0gX19DSElMRF9ST1VURV9MRU5HVEgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVtcHR5UmVzdWx0IHx8IHRoaXMuX2lzU2FtZVJvdXRlKHJvdXRlSW5mbykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwYXR0ZXJuIGZvciB0aGlzIHJvdXRlciBpcyB0aGUgc2FtZSBhcyB0aGUgbGFzdCBwYXR0ZXJuIHNvIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBuYXZpZ2F0ZSBjaGlsZCByb3V0ZXJzLiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmF2aWdhdGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOYXZpZ2F0aW5nID0gdGhpcy5fbmF2aWdhdGVDaGlsZHJlbihyb3V0ZUluZm8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9wcmV2aW91c1VybCA9IHVybDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcHJldmlvdXNRdWVyeSA9IHF1ZXJ5U3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm5hdmlnYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubmF2aWdhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSByb3V0ZUluZm8uZGVsZWdhdGUucGF0dGVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNlZ21lbnQgPSByZWNvZ25pemVyLmdlbmVyYXRlKHJvdXRlSW5mby5kZWxlZ2F0ZS5hbGlhcyB8fCByb3V0ZUluZm8uZGVsZWdhdGUudmlldywgcm91dGVJbmZvLnBhcmFtZXRlcnMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzU2VnbWVudCA9IHRoaXMuX3ByZXZpb3VzU2VnbWVudDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzU2VnbWVudCA9IHNlZ21lbnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hdmlnYXRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvdXRlSW5mb0NvcHkgPSB0aGlzLl9uZXh0Um91dGVJbmZvID0gX2Nsb25lKHJvdXRlSW5mbywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOYXZpZ2F0aW5nID0gdGhpcy5fY2FuTmF2aWdhdGUocm91dGVJbmZvLCBwb2xsKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjYW5OYXZpZ2F0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FuTmF2aWdhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubmF2aWdhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBjbGVhcmVkIHRvIG5hdmlnYXRlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9wcmV2aW91c1VybCA9IHVybDtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcHJldmlvdXNRdWVyeSA9IHF1ZXJ5U3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcGVyZm9ybU5hdmlnYXRpb24ocm91dGVJbmZvKTtcclxuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9wcmV2aW91c1BhdHRlcm4gPSBwYXR0ZXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9wcmV2aW91c1NlZ21lbnQgPSBzZWdtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmN1cnJlbnRSb3V0ZUluZm8gPSByb3V0ZUluZm9Db3B5O1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm5hdmlnYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3ByZXZpb3VzU2VnbWVudCA9IHByZXZpb3VzU2VnbWVudDtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5uYXZpZ2F0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBSb3V0ZXIucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gKG5hbWUsIHBhcmFtZXRlcnMsIHF1ZXJ5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWxpYXMgPSBuYW1lO1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IHRoaXMuX0luamVjdG9yLmNvbnZlcnREZXBlbmRlbmN5KG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IF9fTk9PUF9JTkpFQ1RPUikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBhbGlhcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciByb3V0ZXIgPSB0aGlzLCBwcmVmaXggPSAnJztcclxuICAgICAgICAgICAgICAgIHdoaWxlICghKGlzTnVsbChyb3V0ZXIpIHx8IHJvdXRlci5fcmVjb2duaXplci5leGlzdHMobmFtZSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm91dGVyID0gcm91dGVyLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwocm91dGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUm91dGUgZm9yICcgKyBuYW1lICsgJyBkb2VzIG5vdCBleGlzdC4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBwYXRoID0gcm91dGVyLl9yZWNvZ25pemVyLmdlbmVyYXRlKG5hbWUsIHBhcmFtZXRlcnMpLCBwcmV2aW91cztcclxuICAgICAgICAgICAgICAgIHdoaWxlICghaXNOdWxsKHJvdXRlciA9IHJvdXRlci5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMgPSByb3V0ZXIuX3ByZXZpb3VzU2VnbWVudDtcclxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyA9ICghaXNOdWxsKHByZXZpb3VzKSAmJiBwcmV2aW91cyAhPT0gJy8nKSA/IHByZXZpb3VzIDogJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gcHJldmlvdXMgKyBwcmVmaXg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgcGF0aCArIHNlcmlhbGl6ZVF1ZXJ5KHF1ZXJ5KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENvbmZpZ3VyZXMgYSByb3V0ZSBtYXBwaW5nIGFuZCByZWdpc3RlcnMgaXQgd2l0aCB0aGUgUm91dGVSZWNvZ25pemVyIGFuZCB0aGUgY2hpbGRcclxuICAgICAgICAgICAgICogUm91dGVSZWNvZ25pemVyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucm91dGluZy5JUm91dGVNYXBwaW5nfSByb3V0ZSBUaGUgbWFwcGluZyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGUgcm91dGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSb3V0ZXIucHJvdG90eXBlLl9jb25maWd1cmVSb3V0ZSA9IGZ1bmN0aW9uIChyb3V0ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl9JbmplY3Rvci5jb252ZXJ0RGVwZW5kZW5jeShyb3V0ZS52aWV3KSwgYWxpYXMgPSByb3V0ZS5hbGlhcyB8fCB2aWV3O1xyXG4gICAgICAgICAgICAgICAgaWYgKHZpZXcgPT09IF9fTk9PUF9JTkpFQ1RPUikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJvdXRlLnZpZXcgPSB2aWV3O1xyXG4gICAgICAgICAgICAgICAgcm91dGUuYWxpYXMgPSBhbGlhcyB8fCB2aWV3O1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvdXRlRGVsZWdhdGUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybjogcm91dGUucGF0dGVybixcclxuICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZTogcm91dGVcclxuICAgICAgICAgICAgICAgIH0sIGNoaWxkUGF0dGVybiA9IHJvdXRlLnBhdHRlcm4gKyBfX0NISUxEX1JPVVRFLCBjaGlsZERlbGVnYXRlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IGNoaWxkUGF0dGVybixcclxuICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuOiBjaGlsZFBhdHRlcm4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXc6IHZpZXcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWFzOiBhbGlhc1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWNvZ25pemVyLnJlZ2lzdGVyKFtyb3V0ZURlbGVnYXRlXSwgeyBuYW1lOiBhbGlhcyB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NoaWxkUmVjb2duaXplci5yZWdpc3RlcihbY2hpbGREZWxlZ2F0ZV0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2VuZXJpYyBtZXRob2QgZm9yIGFkZGluZyBhIHBhcmFtL3F1ZXJ5UGFyYW0gaGFuZGxlciB0byB0aGUgcmVnaXN0ZXJlZCBoYW5kbGVycyBvYmplY3QuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7KHZhbHVlOiBhbnksIHF1ZXJ5OiBhbnkpID0+IGFueX0gaGFuZGxlciBBIG1ldGhvZCB0aGF0IHdpbGwgbWFuaXB1bGF0ZSB0aGUgcmVnaXN0ZXJlZCBwYXJhbWV0ZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXIgVGhlIHBhcmFtZXRlciB0aGF0IHRoZSByZWdpc3RlcmVkIGhhbmRsZXIgd2lsbCBtb2RpZnkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSB2aWV3IFRoZSB2aWV3IHVzZWQgdG8gbWF0Y2ggdGhlIHJvdXRlLiBJZiB1bmRlZmluZWQsIGFsbCByb3V0ZXMgd2lsbCBiZSBtYXRjaGVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuSU9iamVjdDxwbGF0LnJvdXRpbmcuSVJvdXRlVHJhbnNmb3Jtcz59IGhhbmRsZXJzIFRoZSBvYmplY3QgdG8gd2hpY2ggdG8gYWRkIHRoZSBoYW5kbGVyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUm91dGVyLnByb3RvdHlwZS5fYWRkSGFuZGxlciA9IGZ1bmN0aW9uIChoYW5kbGVyLCBwYXJhbWV0ZXIsIHZpZXcsIGhhbmRsZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodmlldykpIHtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3ID0gJyonO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGFsaWFzID0gdmlldztcclxuICAgICAgICAgICAgICAgIGlmICh2aWV3ICE9PSAnKicpIHtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3ID0gdGhpcy5fSW5qZWN0b3IuY29udmVydERlcGVuZGVuY3kodmlldyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodmlldyA9PT0gX19OT09QX0lOSkVDVE9SKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlldyA9IGFsaWFzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkodmlldykgfHwgaXNFbXB0eShwYXJhbWV0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdmlld0hhbmRsZXJzID0gaGFuZGxlcnNbdmlld107XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzT2JqZWN0KHZpZXdIYW5kbGVycykpIHtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3SGFuZGxlcnMgPSBoYW5kbGVyc1t2aWV3XSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybXMgPSB2aWV3SGFuZGxlcnNbcGFyYW1ldGVyXTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNBcnJheSh0cmFuc2Zvcm1zKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybXMgPSB2aWV3SGFuZGxlcnNbcGFyYW1ldGVyXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3Jtcy5wdXNoKGhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGb3JjZXMgYSBuYXZpZ2F0aW9uIGlmIHBvc3NpYmxlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUm91dGVyLnByb3RvdHlwZS5fZm9yY2VOYXZpZ2F0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZSA9IHRoaXMuX3Jlc29sdmUsIHF1ZXJ5O1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubmF2aWdhdGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5hdmlnYXRpbmcudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZm9yY2VOYXZpZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNSb290ICYmIGlzRW1wdHkodGhpcy5fcHJldmlvdXNVcmwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHV0aWxzID0gdGhpcy5fYnJvd3Nlci51cmxVdGlscygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzVXJsID0gdXRpbHMucGF0aG5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVlcnkgPSB1dGlscy5xdWVyeTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghaXNFbXB0eSh0aGlzLl9wcmV2aW91c1F1ZXJ5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0gZGVzZXJpYWxpemVRdWVyeSh0aGlzLl9wcmV2aW91c1F1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghaXNFbXB0eSh0aGlzLl9wcmV2aW91c1VybCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uYXZpZ2F0ZSh0aGlzLl9wcmV2aW91c1VybCwgcXVlcnksIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE5hdmlnYXRlcyB0aGUgY2hpbGQgcm91dGVycy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnJvdXRpbmcuSVJvdXRlSW5mb30gaW5mbyBUaGUgaW5mb3JtYXRpb24gbmVjZXNzYXJ5IHRvIGJ1aWxkIHRoZSBjaGlsZFJvdXRlIGZvciB0aGUgY2hpbGQgcm91dGVycy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJvdXRlci5wcm90b3R5cGUuX25hdmlnYXRlQ2hpbGRyZW4gPSBmdW5jdGlvbiAoaW5mbywgcG9sbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvbGwgPT09IHZvaWQgMCkgeyBwb2xsID0gdHJ1ZTsgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkUm91dGUgPSB0aGlzLl9nZXRDaGlsZFJvdXRlKGluZm8pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChjaGlsZFJvdXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwQXN5bmMoZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLm5hdmlnYXRlKGNoaWxkUm91dGUsIGluZm8ucXVlcnksIHVuZGVmaW5lZCwgcG9sbCk7XHJcbiAgICAgICAgICAgICAgICB9LCB0aGlzLmNoaWxkcmVuKS50aGVuKG5vb3ApO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGFyc2VzIG91dCB0aGUgY2hpbGQgcm91dGUgZnJvbSByb3V0ZSBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnJvdXRpbmcuSVJvdXRlSW5mb30gaW5mbyBUaGUgaW5mb3JtYXRpb24gbmVjZXNzYXJ5IHRvIGdldCB0aGUgY2hpbGQgcm91dGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSb3V0ZXIucHJvdG90eXBlLl9nZXRDaGlsZFJvdXRlID0gZnVuY3Rpb24gKGluZm8pIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoaW5mbykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRSb3V0ZSA9IGluZm8ucGFyYW1ldGVycy5jaGlsZFJvdXRlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1N0cmluZyhjaGlsZFJvdXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkUm91dGUgPSAnJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAnLycgKyBjaGlsZFJvdXRlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSXQgaXMgc2FmZSB0byBuYXZpZ2F0ZSwgc28gcGVyZm9ybSB0aGUgbmF2aWdhdGlvbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnJvdXRpbmcuSVJvdXRlSW5mb30gaW5mbyBUaGUgcm91dGUgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSb3V0ZXIucHJvdG90eXBlLl9wZXJmb3JtTmF2aWdhdGlvbiA9IGZ1bmN0aW9uIChpbmZvKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNhbWVSb3V0ZSA9IHRoaXMuX2lzU2FtZVJvdXRlKHRoaXMuX25leHRSb3V0ZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BlcmZvcm1OYXZpZ2F0ZUZyb20oc2FtZVJvdXRlKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2FtZVJvdXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcEFzeW5jKGZ1bmN0aW9uIChwb3J0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3J0Lm5hdmlnYXRlVG8oaW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgX3RoaXMuX3BvcnRzKTtcclxuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fbmF2aWdhdGVDaGlsZHJlbihpbmZvLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEl0IGlzIHNhZmUgdG8gbmF2aWdhdGUsIHNvIGZpcmUgdGhlIG5hdmlnYXRlRnJvbSBldmVudHMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaWdub3JlUG9ydHM/IElnbm9yZXMgdGhlIHBvcnRzIGlmIG5lY2Vzc2FyeS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJvdXRlci5wcm90b3R5cGUuX3BlcmZvcm1OYXZpZ2F0ZUZyb20gPSBmdW5jdGlvbiAoaWdub3JlUG9ydHMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwQXN5bmMoZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLl9wZXJmb3JtTmF2aWdhdGVGcm9tKCk7XHJcbiAgICAgICAgICAgICAgICB9LCB0aGlzLmNoaWxkcmVuKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlUG9ydHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFwQXN5bmMoZnVuY3Rpb24gKHBvcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvcnQubmF2aWdhdGVGcm9tKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgX3RoaXMuX3BvcnRzKTtcclxuICAgICAgICAgICAgICAgIH0pLnRoZW4obm9vcCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEZXRlcm1pbmVzIGlmIHdlIGNhbiBuYXZpZ2F0ZSBmcm9tIHRoZSBjdXJyZW50IHN0YXRlIGFuZCBuYXZpZ2F0ZSB0byB0aGUgbmV4dCBzdGF0ZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnJvdXRpbmcuSVJvdXRlSW5mb30gaW5mbyBUaGUgcm91dGUgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSb3V0ZXIucHJvdG90eXBlLl9jYW5OYXZpZ2F0ZSA9IGZ1bmN0aW9uIChpbmZvLCBwb2xsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvbGwgPT09IHZvaWQgMCkgeyBwb2xsID0gdHJ1ZTsgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHNhbWVSb3V0ZSA9IHRoaXMuX2lzU2FtZVJvdXRlKHRoaXMuX25leHRSb3V0ZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwb2xsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxBbGxIYW5kbGVycyhpbmZvLmRlbGVnYXRlLmFsaWFzLCBpbmZvLnBhcmFtZXRlcnMsIGluZm8ucXVlcnkpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2NhbGxJbnRlcmNlcHRvcnMoaW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FuTmF2aWdhdGVGcm9tKHNhbWVSb3V0ZSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY2FuTmF2aWdhdGVGcm9tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbk5hdmlnYXRlRnJvbSAmJiBfdGhpcy5fY2FuTmF2aWdhdGVUbyhpbmZvLCBzYW1lUm91dGUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEZXRlcm1pbmVzIGlmIHdlIGNhbiBuYXZpZ2F0ZSBmcm9tIHRoZSBjdXJyZW50IHN0YXRlIGFuZCBuYXZpZ2F0ZSB0byB0aGUgbmV4dCBzdGF0ZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBpZ25vcmVQb3J0cyBJZ25vcmVzIHRoZSBwb3J0cyBpZiBuZWNlc3NhcnkuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSb3V0ZXIucHJvdG90eXBlLl9jYW5OYXZpZ2F0ZUZyb20gPSBmdW5jdGlvbiAoaWdub3JlUG9ydHMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5hbGwodGhpcy5jaGlsZHJlbi5yZWR1Y2UoZnVuY3Rpb24gKHByb21pc2VzLCBjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlcy5jb25jYXQoY2hpbGQuX2Nhbk5hdmlnYXRlRnJvbSgpKTtcclxuICAgICAgICAgICAgICAgIH0sIFtdKSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihib29sZWFuUmVkdWNlKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjYW5OYXZpZ2F0ZUZyb20pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbk5hdmlnYXRlRnJvbSB8fCBpZ25vcmVQb3J0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2Nhbk5hdmlnYXRlRnJvbV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXBBc3luYyhmdW5jdGlvbiAocG9ydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9ydC5jYW5OYXZpZ2F0ZUZyb20oKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBfdGhpcy5fcG9ydHMpO1xyXG4gICAgICAgICAgICAgICAgfSkudGhlbihib29sZWFuUmVkdWNlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERldGVybWluZXMgaWYgd2UgY2FuIG5hdmlnYXRlIHRvIHRoZSBuZXh0IHN0YXRlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucm91dGluZy5JUm91dGVJbmZvfSBpbmZvIFRoZSByb3V0ZSBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBpZ25vcmVQb3J0cyBJZ25vcmVzIHRoZSBwb3J0cyBpZiBuZWNlc3NhcnkuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSb3V0ZXIucHJvdG90eXBlLl9jYW5OYXZpZ2F0ZVRvID0gZnVuY3Rpb24gKGluZm8sIGlnbm9yZVBvcnRzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkodGhpcy5fcG9ydHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsbEFsbEhhbmRsZXJzKGluZm8uZGVsZWdhdGUuYWxpYXMsIGluZm8ucGFyYW1ldGVycywgaW5mby5xdWVyeSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jYWxsSW50ZXJjZXB0b3JzKGluZm8pO1xyXG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoY2FuTmF2aWdhdGVUbykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW5OYXZpZ2F0ZVRvID09PSBmYWxzZSB8fCBpZ25vcmVQb3J0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2Nhbk5hdmlnYXRlVG9dO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFwQXN5bmMoZnVuY3Rpb24gKHBvcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvcnQuY2FuTmF2aWdhdGVUbyhpbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBfdGhpcy5fcG9ydHMpO1xyXG4gICAgICAgICAgICAgICAgfSkudGhlbihib29sZWFuUmVkdWNlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENhbGxzIGFsbCB0aGUgcmVnaXN0ZXJlZCBxdWVyeSBhbmQgcGFyYW0gdHJhbnNmb3JtcyBmb3IgYSByb3V0ZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZpZXcgVGhlIGFzc29jaWF0ZWQgdmlldyBmb3IgdGhlIHJvdXRlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gcGFyYW1ldGVycyBUaGUgcm91dGUgcGFyYW1ldGVycy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IHF1ZXJ5PyBUaGUgcXVlcnkgcGFyYW1ldGVycy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJvdXRlci5wcm90b3R5cGUuX2NhbGxBbGxIYW5kbGVycyA9IGZ1bmN0aW9uICh2aWV3LCBwYXJhbWV0ZXJzLCBxdWVyeSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxsSGFuZGxlcnModGhpcy5fcXVlcnlUcmFuc2Zvcm1zWycqJ10sIHF1ZXJ5KVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9jYWxsSGFuZGxlcnMoX3RoaXMuX3F1ZXJ5VHJhbnNmb3Jtc1t2aWV3XSwgcXVlcnkpOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9jYWxsSGFuZGxlcnMoX3RoaXMuX3BhcmFtVHJhbnNmb3Jtc1snKiddLCBwYXJhbWV0ZXJzLCBxdWVyeSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2NhbGxIYW5kbGVycyhfdGhpcy5fcGFyYW1UcmFuc2Zvcm1zW3ZpZXddLCBwYXJhbWV0ZXJzLCBxdWVyeSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4obm9vcCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDYWxscyB0aGUgYXNzb2NpYXRlZCB0cmFuc2Zvcm0gZnVuY3Rpb25zLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucm91dGluZy5JUm91dGVUcmFuc2Zvcm1zfSBhbGxIYW5kbGVycyBUaGUgdHJhbnNmb3JtIGZ1bmN0aW9uc1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2JqIFRoZSBwYXJhbWV0ZXJzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gcXVlcnk/IFRoZSBxdWVyeSBwYXJhbWV0ZXJzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUm91dGVyLnByb3RvdHlwZS5fY2FsbEhhbmRsZXJzID0gZnVuY3Rpb24gKGFsbEhhbmRsZXJzLCBvYmosIHF1ZXJ5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZSA9IHRoaXMuX3Jlc29sdmU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzT2JqZWN0KG9iaikpIHtcclxuICAgICAgICAgICAgICAgICAgICBvYmogPSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBtYXBBc3luYyhmdW5jdGlvbiAoaGFuZGxlcnMsIGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXBBc3luY0luT3JkZXIoZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoaGFuZGxlcihvYmpba2V5XSwgb2JqLCBxdWVyeSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIGhhbmRsZXJzKTtcclxuICAgICAgICAgICAgICAgIH0sIGFsbEhhbmRsZXJzKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKG5vb3ApO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2FsbHMgdGhlIGludGVyY2VwdG9ycyBmb3IgYSBwYXJ0aWN1bGFyIHJvdXRlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucm91dGluZy5JUm91dGVJbmZvfSBpbmZvIFRoZSByb3V0ZSBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJvdXRlci5wcm90b3R5cGUuX2NhbGxJbnRlcmNlcHRvcnMgPSBmdW5jdGlvbiAoaW5mbykge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciByZXNvbHZlID0gdGhpcy5fcmVzb2x2ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYXBBc3luY0luT3JkZXIoZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShoYW5kbGVyKGluZm8pKTtcclxuICAgICAgICAgICAgICAgIH0sIHRoaXMuX2ludGVyY2VwdG9yc1snKiddKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGJvb2xlYW5SZWR1Y2UpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNhbk5hdmlnYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5OYXZpZ2F0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2Nhbk5hdmlnYXRlXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcEFzeW5jKGZ1bmN0aW9uIChoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGhhbmRsZXIoaW5mbykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIF90aGlzLl9pbnRlcmNlcHRvcnNbaW5mby5kZWxlZ2F0ZS5hbGlhc10pO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihib29sZWFuUmVkdWNlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENoZWNrcyBhIHBhc3NlZC1pbiByb3V0ZSBhZ2FpbnN0IHRoZSBjdXJyZW50IHJvdXRlIHRvIGRldGVybWluZSBpZiBpdCBpcyB0aGUgc2FtZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnJvdXRpbmcuSVJvdXRlSW5mb30gaW5mbyBUaGUgcm91dGUgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSb3V0ZXIucHJvdG90eXBlLl9pc1NhbWVSb3V0ZSA9IGZ1bmN0aW9uIChpbmZvKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFJvdXRlSW5mbyA9IF9jbG9uZSh0aGlzLmN1cnJlbnRSb3V0ZUluZm8sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgaW5mbyA9IF9jbG9uZShpbmZvLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Nhbml0aXplUm91dGVJbmZvKGN1cnJlbnRSb3V0ZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2FuaXRpemVSb3V0ZUluZm8oaW5mbyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShpc09iamVjdChjdXJyZW50Um91dGVJbmZvKSAmJiBpc09iamVjdChpbmZvKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudERlbGVnYXRlID0gY3VycmVudFJvdXRlSW5mby5kZWxlZ2F0ZSwgZGVsZWdhdGUgPSBpbmZvLmRlbGVnYXRlLCBjdXJyZW50UGFyYW1ldGVycyA9IHNlcmlhbGl6ZVF1ZXJ5KGN1cnJlbnRSb3V0ZUluZm8ucGFyYW1ldGVycyksIHBhcmFtZXRlcnMgPSBzZXJpYWxpemVRdWVyeShpbmZvLnBhcmFtZXRlcnMpLCBjdXJyZW50UXVlcnkgPSBzZXJpYWxpemVRdWVyeShjdXJyZW50Um91dGVJbmZvLnF1ZXJ5KSwgcXVlcnkgPSBzZXJpYWxpemVRdWVyeShpbmZvLnF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGVsZWdhdGUudmlldyA9PT0gZGVsZWdhdGUudmlldyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZWxlZ2F0ZS5hbGlhcyA9PT0gZGVsZWdhdGUuYWxpYXMgJiZcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGVsZWdhdGUucGF0dGVybiA9PT0gZGVsZWdhdGUucGF0dGVybiAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJhbWV0ZXJzID09PSBwYXJhbWV0ZXJzICYmXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFF1ZXJ5ID09PSBxdWVyeTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlbW92ZXMgY2hpbGRSb3V0ZSBmcm9tIHJvdXRlSW5mb1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucm91dGluZy5JUm91dGVJbmZvfSBpbmZvIFRoZSByb3V0ZSBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJvdXRlci5wcm90b3R5cGUuX3Nhbml0aXplUm91dGVJbmZvID0gZnVuY3Rpb24gKGluZm8pIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChpbmZvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmZvLnBhcmFtZXRlcnMuaGFzT3duUHJvcGVydHkoJ2NoaWxkUm91dGUnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsZWdhdGUgPSBpbmZvLmRlbGVnYXRlLCBwYXR0ZXJuID0gZGVsZWdhdGUucGF0dGVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGUucGF0dGVybiA9IHBhdHRlcm4uc2xpY2UoMCwgcGF0dGVybi5sZW5ndGggLSBfX0NISUxEX1JPVVRFX0xFTkdUSCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KGluZm8ucGFyYW1ldGVycywgJ2NoaWxkUm91dGUnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDbGVhcnMgYWxsIHRoZSByb3V0ZXIgaW5mb3JtYXRpb24sIGVzc2VudGlhbGx5IHNldHRpbmcgdGhlIHJvdXRlciBiYWNrIHRvIGl0cyBpbml0aWFsaXplZCBzdGF0ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJvdXRlci5wcm90b3R5cGUuX2NsZWFySW5mbyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzU2VnbWVudCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzUGF0dGVybiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzVXJsID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNRdWVyeSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFJvdXRlSW5mbyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIHRoaXMubmF2aWdhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5fY2xlYXJJbmZvKCk7XHJcbiAgICAgICAgICAgICAgICB9LCB0aGlzLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUm91dGVyLl9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgICAgICBfUHJvbWlzZTogX19Qcm9taXNlLFxyXG4gICAgICAgICAgICAgICAgX0luamVjdG9yOiBfX0luamVjdG9yU3RhdGljLFxyXG4gICAgICAgICAgICAgICAgX0V2ZW50TWFuYWdlcjogX19FdmVudE1hbmFnZXJTdGF0aWMsXHJcbiAgICAgICAgICAgICAgICBfYnJvd3NlcjogX19Ccm93c2VyLFxyXG4gICAgICAgICAgICAgICAgX2Jyb3dzZXJDb25maWc6IF9fQnJvd3NlckNvbmZpZyxcclxuICAgICAgICAgICAgICAgIF9yZWNvZ25pemVyOiBfX1JvdXRlUmVjb2duaXplckluc3RhbmNlLFxyXG4gICAgICAgICAgICAgICAgX2NoaWxkUmVjb2duaXplcjogX19Sb3V0ZVJlY29nbml6ZXJJbnN0YW5jZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gUm91dGVyO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgcm91dGluZy5Sb3V0ZXIgPSBSb3V0ZXI7XHJcbiAgICAgICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX1JvdXRlciwgUm91dGVyLCBudWxsLCBfX0lOU1RBTkNFKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBJUm91dGVyU3RhdGljKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUm91dGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByb3V0aW5nLklSb3V0ZXJTdGF0aWMgPSBJUm91dGVyU3RhdGljO1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19Sb3V0ZXJTdGF0aWMsIElSb3V0ZXJTdGF0aWMpO1xyXG4gICAgfSkocm91dGluZyA9IHBsYXRfMS5yb3V0aW5nIHx8IChwbGF0XzEucm91dGluZyA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIEhvbGRzIGFsbCBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIHJlbGF0ZWQgdG8gYXR0cmlidXRlIGNvbnRyb2wgY29tcG9uZW50cyBpbiBwbGF0eXB1cy5cclxuICAgICAqL1xyXG4gICAgdmFyIGNvbnRyb2xzO1xyXG4gICAgKGZ1bmN0aW9uIChjb250cm9scykge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFsbG93cyBmb3IgYXNzaWduaW5nIGEgbmFtZSB0byBhbiBFbGVtZW50IG9yIFRlbXBsYXRlQ29udHJvbCBhbmQgcmVmZXJlbmNpbmcgaXRcclxuICAgICAgICAgKiBmcm9tIHBhcmVudCBjb250cm9scy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgTmFtZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhOYW1lLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBOYW1lKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERlZmluZXMgdGhlIHByb3BlcnR5IHNwZWNpZmllZCBieSB0aGUgYXR0cmlidXRlIHZhbHVlIGFzIHRoZSBJTmFtZWRFbGVtZW50XHJcbiAgICAgICAgICAgICAqIG9uIGFsbCB0aGUgYW5jZXN0b3IgY29udHJvbHMsIGlnbm9yaW5nIHRob3NlIHRoYXQgYWxyZWFkeSBoYXZlIHRoZSBwcm9wZXJ0eSBkZWZpbmVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTmFtZS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhdHRyID0gY2FtZWxDYXNlKHRoaXMudHlwZSksIG5hbWUgPSB0aGlzLmF0dHJpYnV0ZXNbYXR0cl07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShuYW1lKSB8fCB0aGlzLl9pc1ByZWNvbXBpbGVkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbCA9IG5hbWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWZpbmUobmFtZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZW1vdmVzIHRoZSBJTmFtZWRFbGVtZW50IGZyb20gdGhlIGFuY2VzdG9yIGNvbnRyb2xzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTmFtZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gdGhpcy5fbGFiZWwsIGNvbnRyb2wgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIHdoaWxlICghaXNVbmRlZmluZWQobmFtZSkgJiYgaXNPYmplY3QoY29udHJvbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QoY29udHJvbFtuYW1lXSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNOb2RlKGNvbnRyb2xbbmFtZV0uZWxlbWVudCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbFtuYW1lXS5lbGVtZW50ID09PSB0aGlzLmVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkoY29udHJvbCwgbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wgPSBjb250cm9sLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERlZmluZXMgdGhlIHByb3BlcnR5IHNwZWNpZmllZCBieSB0aGUgYXR0cmlidXRlIHZhbHVlIGFzIHRoZSBJTmFtZWRFbGVtZW50XHJcbiAgICAgICAgICAgICAqIG9uIGFsbCB0aGUgYW5jZXN0b3IgY29udHJvbHMsIGlnbm9yaW5nIHRob3NlIHRoYXQgYWxyZWFkeSBoYXZlIHRoZSBwcm9wZXJ0eSBkZWZpbmVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSB0byBkZWZpbmUgb24gYWxsIHRoZSBhbmNlc3RvciBjb250cm9scy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE5hbWUucHJvdG90eXBlLl9kZWZpbmUgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlQ29udHJvbCA9IHRoaXMudGVtcGxhdGVDb250cm9sO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGwodGVtcGxhdGVDb250cm9sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlQ29udHJvbC5uYW1lID0gbmFtZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBjb250cm9sID0gdGhpcy5wYXJlbnQsIG5hbWVkRWxlbWVudCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiB0aGlzLmVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbDogdGVtcGxhdGVDb250cm9sXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGlzT2JqZWN0KGNvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IGNvbnRyb2xbbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc09iamVjdChvYmopKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xbbmFtZV0gPSBuYW1lZEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wgPSBjb250cm9sLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdGhpcyBjb250cm9sIGlzIHBhcnQgb2YgYSBwcmUtY29tcGlsZWQgY29udHJvbCB0cmVlLiBJbiB0aGUgZXZlbnRcclxuICAgICAgICAgICAgICogdGhhdCBpdCBpcywgaXQgc2hvdWxkbid0IHNldCBpdHNlbGYgb24gdGhlIGFuY2VzdG9yIGNvbnRyb2xzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSB0byBkZWZpbmUgb24gYWxsIHRoZSBhbmNlc3RvciBjb250cm9scy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE5hbWUucHJvdG90eXBlLl9pc1ByZWNvbXBpbGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIHdoaWxlICghaXNOdWxsKGNvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRyb2wudHlwZS5pbmRleE9mKF9fQ09NUElMRUQpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbCA9IGNvbnRyb2wucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gTmFtZTtcclxuICAgICAgICB9KEF0dHJpYnV0ZUNvbnRyb2wpKTtcclxuICAgICAgICBjb250cm9scy5OYW1lID0gTmFtZTtcclxuICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fTmFtZSwgTmFtZSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gQXR0cmlidXRlQ29udHJvbCB0aGF0IGJpbmRzIHRvIGEgc3BlY2lmaWVkIERPTSBldmVudCBoYW5kbGVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBTaW1wbGVFdmVudENvbnRyb2wgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoU2ltcGxlRXZlbnRDb250cm9sLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBTaW1wbGVFdmVudENvbnRyb2woKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBwYXJzZWQgZm9ybSBvZiB0aGUgZXhwcmVzc2lvbiBmb3VuZCBpbiB0aGUgYXR0cmlidXRlJ3MgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX2V4cHJlc3Npb24gPSBbXTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQW4gYXJyYXkgb2YgdGhlIGFsaWFzZXMgdXNlZCBpbiB0aGUgZXhwcmVzc2lvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWxpYXNlcyA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBLaWNrcyBvZmYgZmluZGluZyBhbmQgc2V0dGluZyB0aGUgbGlzdGVuZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBTaW1wbGVFdmVudENvbnRyb2wucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwodGhpcy5lbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlID0gY2FtZWxDYXNlKHRoaXMudHlwZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGFyc2VzIGZ1bmN0aW9uIGFyZ3MgYW5kIHNldHMgdGhlIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgU2ltcGxlRXZlbnRDb250cm9sLnByb3RvdHlwZS5fc2V0TGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm4gPSB0aGlzLmF0dHJpYnV0ZXNbdGhpcy5hdHRyaWJ1dGVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkodGhpcy5ldmVudCkgfHwgaXNFbXB0eShmbikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUFyZ3MoZm4pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFkZHMgYW55IGFuZCBhbGwgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFNpbXBsZUV2ZW50Q29udHJvbC5wcm90b3R5cGUuX2FkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHRoaXMuZWxlbWVudCwgdGhpcy5ldmVudCwgdGhpcy5fb25FdmVudCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ29uc3RydWN0cyB0aGUgZnVuY3Rpb24gdG8gZXZhbHVhdGUgd2l0aFxyXG4gICAgICAgICAgICAgKiB0aGUgZXZhbHVhdGVkIGFyZ3VtZW50cyB0YWtpbmcgcmVzb3VyY2VzXHJcbiAgICAgICAgICAgICAqIGludG8gYWNjb3VudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFNpbXBsZUV2ZW50Q29udHJvbC5wcm90b3R5cGUuX2J1aWxkRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5fZXhwcmVzc2lvbi5zbGljZSgwKSwgX3BhcnNlciA9IHRoaXMuX3BhcnNlciwgcGFyZW50ID0gdGhpcy5wYXJlbnQsIGxpc3RlbmVyU3RyID0gZXhwcmVzc2lvbi5zaGlmdCgpLCBsaXN0ZW5lciwgY29udGV4dCwgZm4sIGFsaWFzZXMsIGFyZ0NvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChwYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxpYXNlcyA9IHBhcmVudC5nZXRSZXNvdXJjZXModGhpcy5fYWxpYXNlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJnQ29udGV4dCA9IHBhcmVudC5jb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyU3RyWzBdICE9PSAnQCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IHRoaXMuZmluZFByb3BlcnR5KGxpc3RlbmVyU3RyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGxpc3RlbmVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cud2FybignQ291bGQgbm90IGZpbmQgcHJvcGVydHkgJyArIGxpc3RlbmVyU3RyICsgJyBvbiBhbnkgcGFyZW50IGNvbnRyb2wuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbjogbm9vcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW11cclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlZEV4cHJlc3Npb24gPSBsaXN0ZW5lci5leHByZXNzc2lvbiwgaWRlbnRpZmllcnMgPSBwYXJzZWRFeHByZXNzaW9uLmlkZW50aWZpZXJzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpZGVudGlmaWVycy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKCdDYW5ub3QgaGF2ZSBtb3JlIHRoYW4gb25lIGlkZW50aWZpZXIgaW4gYSAnICsgdGhpcy50eXBlICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXCdzIGV4cHJlc3Npb24uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbjogbm9vcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW11cclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkZW50aWZpZXIgPSBpZGVudGlmaWVyc1swXSwgc3BsaXQgPSBpZGVudGlmaWVyLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9wIGtleSBcclxuICAgICAgICAgICAgICAgICAgICBzcGxpdC5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gc3BsaXQubGVuZ3RoID09PSAwID8gbGlzdGVuZXIuY29udHJvbCA6IF9wYXJzZXIucGFyc2Uoc3BsaXQuam9pbignLicpKS5ldmFsdWF0ZShsaXN0ZW5lci5jb250cm9sKTtcclxuICAgICAgICAgICAgICAgICAgICBmbiA9IGxpc3RlbmVyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm4gPSBpc051bGwoYWxpYXNlcykgPyBub29wIDogKGFsaWFzZXNbbGlzdGVuZXJTdHJdIHx8IG5vb3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gZXhwcmVzc2lvbi5sZW5ndGgsIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goX3BhcnNlci5wYXJzZShleHByZXNzaW9uW2ldKS5ldmFsdWF0ZShhcmdDb250ZXh0LCBhbGlhc2VzKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGZuOiBmbixcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDYWxscyB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uIHdoZW4gdGhlIERPTSBldmVudCBpcyBmaXJlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXYgVGhlIGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFNpbXBsZUV2ZW50Q29udHJvbC5wcm90b3R5cGUuX29uRXZlbnQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5fYnVpbGRFeHByZXNzaW9uKCksIGZuID0gZXhwcmVzc2lvbi5mbjtcclxuICAgICAgICAgICAgICAgIGlmICghaXNGdW5jdGlvbihmbikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cud2FybignQ2Fubm90IGZpbmQgcmVnaXN0ZXJlZCBldmVudCBtZXRob2QgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2V4cHJlc3Npb25bMF0gKyAnIGZvciBjb250cm9sOiAnICsgdGhpcy50eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmbi5hcHBseShleHByZXNzaW9uLmNvbnRleHQsIGV4cHJlc3Npb24uYXJncy5jb25jYXQoZXYpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEZpbmRzIGFsbCBhbGlhcyBjb250YWluZWQgd2l0aGluIHRoZSBleHByZXNzaW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGFyZ3MgVGhlIGFycmF5IG9mIGFyZ3VtZW50cyBhcyBzdHJpbmdzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgU2ltcGxlRXZlbnRDb250cm9sLnByb3RvdHlwZS5fZmluZEFsaWFzZXMgPSBmdW5jdGlvbiAoYXJncykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3MubGVuZ3RoLCBhcmcsIGhhc2ggPSB7fSwgYWxpYXNlcyA9IFtdLCBwYXJzZWRBbGlhc2VzID0gW10sIF9wYXJzZXIgPSB0aGlzLl9wYXJzZXI7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobGVuZ3RoLS0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnc1tsZW5ndGhdLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRBbGlhc2VzID0gcGFyc2VkQWxpYXNlcy5jb25jYXQoX3BhcnNlci5wYXJzZShhcmcpLmFsaWFzZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHBhcnNlZEFsaWFzZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZyA9IHBhcnNlZEFsaWFzZXMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNoW2FyZ10pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpYXNlcy5wdXNoKGFyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc2hbYXJnXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFsaWFzZXM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJzZXMgdGhlIGV4cHJlc3Npb24gYW5kIHNlcGFyYXRlcyB0aGUgZnVuY3Rpb25cclxuICAgICAgICAgICAgICogZnJvbSBpdHMgYXJndW1lbnRzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBUaGUgZXhwcmVzc2lvbiB0byBwYXJzZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFNpbXBsZUV2ZW50Q29udHJvbC5wcm90b3R5cGUuX3BhcnNlQXJncyA9IGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShleHByZXNzaW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBleGVjID0gdGhpcy5fcmVnZXguYXJndW1lbnRSZWdleC5leGVjKGV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGwoZXhlYykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9leHByZXNzaW9uID0gW2V4cHJlc3Npb24uc2xpY2UoMCwgZXhlYy5pbmRleCldXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQoKGV4ZWNbMV0gIT09ICcnKSA/IGV4ZWNbMV0uc3BsaXQoJywnKSA6IFtdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V4cHJlc3Npb24ucHVzaChleHByZXNzaW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2FsaWFzZXMgPSB0aGlzLl9maW5kQWxpYXNlcyh0aGlzLl9leHByZXNzaW9uKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU2ltcGxlRXZlbnRDb250cm9sLl9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgICAgICBfcGFyc2VyOiBfX1BhcnNlcixcclxuICAgICAgICAgICAgICAgIF9yZWdleDogX19SZWdleFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gU2ltcGxlRXZlbnRDb250cm9sO1xyXG4gICAgICAgIH0oQXR0cmlidXRlQ29udHJvbCkpO1xyXG4gICAgICAgIGNvbnRyb2xzLlNpbXBsZUV2ZW50Q29udHJvbCA9IFNpbXBsZUV2ZW50Q29udHJvbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFNpbXBsZUV2ZW50Q29udHJvbCBmb3IgdGhlICckdGFwJyBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgVGFwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFRhcCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gVGFwKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBldmVudCBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50ID0gX190YXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFRhcDtcclxuICAgICAgICB9KFNpbXBsZUV2ZW50Q29udHJvbCkpO1xyXG4gICAgICAgIGNvbnRyb2xzLlRhcCA9IFRhcDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFNpbXBsZUV2ZW50Q29udHJvbCBmb3IgdGhlICdibHVyJyBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgQmx1ciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhCbHVyLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBCbHVyKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBldmVudCBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50ID0gJ2JsdXInO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBCbHVyO1xyXG4gICAgICAgIH0oU2ltcGxlRXZlbnRDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuQmx1ciA9IEJsdXI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBTaW1wbGVFdmVudENvbnRyb2wgZm9yIHRoZSAnY2hhbmdlJyBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgQ2hhbmdlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKENoYW5nZSwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gQ2hhbmdlKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBldmVudCBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50ID0gJ2NoYW5nZSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIENoYW5nZTtcclxuICAgICAgICB9KFNpbXBsZUV2ZW50Q29udHJvbCkpO1xyXG4gICAgICAgIGNvbnRyb2xzLkNoYW5nZSA9IENoYW5nZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFNpbXBsZUV2ZW50Q29udHJvbCBmb3IgdGhlICdjb3B5JyBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgQ29weSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhDb3B5LCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBDb3B5KCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBldmVudCBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50ID0gJ2NvcHknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBDb3B5O1xyXG4gICAgICAgIH0oU2ltcGxlRXZlbnRDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuQ29weSA9IENvcHk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBTaW1wbGVFdmVudENvbnRyb2wgZm9yIHRoZSAnY3V0JyBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgQ3V0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKEN1dCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gQ3V0KCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBldmVudCBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50ID0gJ2N1dCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIEN1dDtcclxuICAgICAgICB9KFNpbXBsZUV2ZW50Q29udHJvbCkpO1xyXG4gICAgICAgIGNvbnRyb2xzLkN1dCA9IEN1dDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFNpbXBsZUV2ZW50Q29udHJvbCBmb3IgdGhlICdwYXN0ZScgZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFBhc3RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFBhc3RlLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBQYXN0ZSgpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgZXZlbnQgbmFtZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudCA9ICdwYXN0ZSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFBhc3RlO1xyXG4gICAgICAgIH0oU2ltcGxlRXZlbnRDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuUGFzdGUgPSBQYXN0ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFNpbXBsZUV2ZW50Q29udHJvbCBmb3IgdGhlICckZGJsdGFwJyBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgRGJsVGFwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKERibFRhcCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gRGJsVGFwKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBldmVudCBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50ID0gX19kYmx0YXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIERibFRhcDtcclxuICAgICAgICB9KFNpbXBsZUV2ZW50Q29udHJvbCkpO1xyXG4gICAgICAgIGNvbnRyb2xzLkRibFRhcCA9IERibFRhcDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFNpbXBsZUV2ZW50Q29udHJvbCBmb3IgdGhlICdmb2N1cycgZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEZvY3VzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKEZvY3VzLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBGb2N1cygpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgZXZlbnQgbmFtZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudCA9ICdmb2N1cyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIEZvY3VzO1xyXG4gICAgICAgIH0oU2ltcGxlRXZlbnRDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuRm9jdXMgPSBGb2N1cztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFNpbXBsZUV2ZW50Q29udHJvbCBmb3IgdGhlICckdG91Y2hzdGFydCcgZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFRvdWNoU3RhcnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoVG91Y2hTdGFydCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gVG91Y2hTdGFydCgpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgZXZlbnQgbmFtZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudCA9IF9fdG91Y2hzdGFydDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gVG91Y2hTdGFydDtcclxuICAgICAgICB9KFNpbXBsZUV2ZW50Q29udHJvbCkpO1xyXG4gICAgICAgIGNvbnRyb2xzLlRvdWNoU3RhcnQgPSBUb3VjaFN0YXJ0O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgU2ltcGxlRXZlbnRDb250cm9sIGZvciB0aGUgJyR0b3VjaGVuZCcgZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFRvdWNoRW5kID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFRvdWNoRW5kLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBUb3VjaEVuZCgpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgZXZlbnQgbmFtZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudCA9IF9fdG91Y2hlbmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFRvdWNoRW5kO1xyXG4gICAgICAgIH0oU2ltcGxlRXZlbnRDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuVG91Y2hFbmQgPSBUb3VjaEVuZDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFNpbXBsZUV2ZW50Q29udHJvbCBmb3IgdGhlICckdG91Y2htb3ZlJyBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgVG91Y2hNb3ZlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFRvdWNoTW92ZSwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gVG91Y2hNb3ZlKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBldmVudCBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50ID0gX190b3VjaG1vdmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFRvdWNoTW92ZTtcclxuICAgICAgICB9KFNpbXBsZUV2ZW50Q29udHJvbCkpO1xyXG4gICAgICAgIGNvbnRyb2xzLlRvdWNoTW92ZSA9IFRvdWNoTW92ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFNpbXBsZUV2ZW50Q29udHJvbCBmb3IgdGhlICckdG91Y2hjYW5jZWwnIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBUb3VjaENhbmNlbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhUb3VjaENhbmNlbCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gVG91Y2hDYW5jZWwoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGV2ZW50IG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnQgPSBfX3RvdWNoY2FuY2VsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBUb3VjaENhbmNlbDtcclxuICAgICAgICB9KFNpbXBsZUV2ZW50Q29udHJvbCkpO1xyXG4gICAgICAgIGNvbnRyb2xzLlRvdWNoQ2FuY2VsID0gVG91Y2hDYW5jZWw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBTaW1wbGVFdmVudENvbnRyb2wgZm9yIHRoZSAnJGhvbGQnIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBIb2xkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKEhvbGQsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEhvbGQoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGV2ZW50IG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnQgPSBfX2hvbGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIEhvbGQ7XHJcbiAgICAgICAgfShTaW1wbGVFdmVudENvbnRyb2wpKTtcclxuICAgICAgICBjb250cm9scy5Ib2xkID0gSG9sZDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFNpbXBsZUV2ZW50Q29udHJvbCBmb3IgdGhlICckcmVsZWFzZScgZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFJlbGVhc2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoUmVsZWFzZSwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gUmVsZWFzZSgpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgZXZlbnQgbmFtZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudCA9IF9fcmVsZWFzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gUmVsZWFzZTtcclxuICAgICAgICB9KFNpbXBsZUV2ZW50Q29udHJvbCkpO1xyXG4gICAgICAgIGNvbnRyb2xzLlJlbGVhc2UgPSBSZWxlYXNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgU2ltcGxlRXZlbnRDb250cm9sIGZvciB0aGUgJyRzd2lwZScgZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFN3aXBlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFN3aXBlLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBTd2lwZSgpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgZXZlbnQgbmFtZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudCA9IF9fc3dpcGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFN3aXBlO1xyXG4gICAgICAgIH0oU2ltcGxlRXZlbnRDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuU3dpcGUgPSBTd2lwZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFNpbXBsZUV2ZW50Q29udHJvbCBmb3IgdGhlICckc3dpcGVsZWZ0JyBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgU3dpcGVMZWZ0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFN3aXBlTGVmdCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gU3dpcGVMZWZ0KCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBldmVudCBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50ID0gX19zd2lwZWxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFN3aXBlTGVmdDtcclxuICAgICAgICB9KFNpbXBsZUV2ZW50Q29udHJvbCkpO1xyXG4gICAgICAgIGNvbnRyb2xzLlN3aXBlTGVmdCA9IFN3aXBlTGVmdDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFNpbXBsZUV2ZW50Q29udHJvbCBmb3IgdGhlICckc3dpcGVyaWdodCcgZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFN3aXBlUmlnaHQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoU3dpcGVSaWdodCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gU3dpcGVSaWdodCgpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgZXZlbnQgbmFtZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudCA9IF9fc3dpcGVyaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gU3dpcGVSaWdodDtcclxuICAgICAgICB9KFNpbXBsZUV2ZW50Q29udHJvbCkpO1xyXG4gICAgICAgIGNvbnRyb2xzLlN3aXBlUmlnaHQgPSBTd2lwZVJpZ2h0O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgU2ltcGxlRXZlbnRDb250cm9sIGZvciB0aGUgJyRzd2lwZXVwJyBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgU3dpcGVVcCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhTd2lwZVVwLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBTd2lwZVVwKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBldmVudCBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50ID0gX19zd2lwZXVwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBTd2lwZVVwO1xyXG4gICAgICAgIH0oU2ltcGxlRXZlbnRDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuU3dpcGVVcCA9IFN3aXBlVXA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBTaW1wbGVFdmVudENvbnRyb2wgZm9yIHRoZSAnJHN3aXBlZG93bicgZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFN3aXBlRG93biA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhTd2lwZURvd24sIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFN3aXBlRG93bigpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgZXZlbnQgbmFtZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudCA9IF9fc3dpcGVkb3duO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBTd2lwZURvd247XHJcbiAgICAgICAgfShTaW1wbGVFdmVudENvbnRyb2wpKTtcclxuICAgICAgICBjb250cm9scy5Td2lwZURvd24gPSBTd2lwZURvd247XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBTaW1wbGVFdmVudENvbnRyb2wgZm9yIHRoZSAnJHRyYWNrJyBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgVHJhY2sgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoVHJhY2ssIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFRyYWNrKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBldmVudCBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50ID0gX190cmFjaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gVHJhY2s7XHJcbiAgICAgICAgfShTaW1wbGVFdmVudENvbnRyb2wpKTtcclxuICAgICAgICBjb250cm9scy5UcmFjayA9IFRyYWNrO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgU2ltcGxlRXZlbnRDb250cm9sIGZvciB0aGUgJyR0cmFja2xlZnQnIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBUcmFja0xlZnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoVHJhY2tMZWZ0LCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBUcmFja0xlZnQoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGV2ZW50IG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnQgPSBfX3RyYWNrbGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gVHJhY2tMZWZ0O1xyXG4gICAgICAgIH0oU2ltcGxlRXZlbnRDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuVHJhY2tMZWZ0ID0gVHJhY2tMZWZ0O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgU2ltcGxlRXZlbnRDb250cm9sIGZvciB0aGUgJyR0cmFja3JpZ2h0JyBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgVHJhY2tSaWdodCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhUcmFja1JpZ2h0LCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBUcmFja1JpZ2h0KCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBldmVudCBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50ID0gX190cmFja3JpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBUcmFja1JpZ2h0O1xyXG4gICAgICAgIH0oU2ltcGxlRXZlbnRDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuVHJhY2tSaWdodCA9IFRyYWNrUmlnaHQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBTaW1wbGVFdmVudENvbnRyb2wgZm9yIHRoZSAnJHRyYWNrdXAnIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBUcmFja1VwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFRyYWNrVXAsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFRyYWNrVXAoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGV2ZW50IG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnQgPSBfX3RyYWNrdXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFRyYWNrVXA7XHJcbiAgICAgICAgfShTaW1wbGVFdmVudENvbnRyb2wpKTtcclxuICAgICAgICBjb250cm9scy5UcmFja1VwID0gVHJhY2tVcDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFNpbXBsZUV2ZW50Q29udHJvbCBmb3IgdGhlICckdHJhY2tkb3duJyBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgVHJhY2tEb3duID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFRyYWNrRG93biwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gVHJhY2tEb3duKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBldmVudCBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50ID0gX190cmFja2Rvd247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFRyYWNrRG93bjtcclxuICAgICAgICB9KFNpbXBsZUV2ZW50Q29udHJvbCkpO1xyXG4gICAgICAgIGNvbnRyb2xzLlRyYWNrRG93biA9IFRyYWNrRG93bjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFNpbXBsZUV2ZW50Q29udHJvbCBmb3IgdGhlICckdHJhY2tlbmQnIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBUcmFja0VuZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhUcmFja0VuZCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gVHJhY2tFbmQoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGV2ZW50IG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnQgPSBfX3RyYWNrZW5kO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBUcmFja0VuZDtcclxuICAgICAgICB9KFNpbXBsZUV2ZW50Q29udHJvbCkpO1xyXG4gICAgICAgIGNvbnRyb2xzLlRyYWNrRW5kID0gVHJhY2tFbmQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBTaW1wbGVFdmVudENvbnRyb2wgZm9yIHRoZSAnc3VibWl0JyBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgU3VibWl0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFN1Ym1pdCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gU3VibWl0KCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBldmVudCBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50ID0gJ3N1Ym1pdCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFByZXZlbnRzIHRoZSBkZWZhdWx0IHN1Ym1pdCBhY3Rpb24gdW5sZXNzXHJcbiAgICAgICAgICAgICAqIHRoZSBcImFjdGlvblwiIGF0dHJpYnV0ZSBpcyBwcmVzZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldiBUaGUgZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgU3VibWl0LnByb3RvdHlwZS5fb25FdmVudCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQuaGFzQXR0cmlidXRlKCdhY3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9vbkV2ZW50LmNhbGwodGhpcywgZXYpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gU3VibWl0O1xyXG4gICAgICAgIH0oU2ltcGxlRXZlbnRDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuU3VibWl0ID0gU3VibWl0O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgU2ltcGxlRXZlbnRDb250cm9sIGZvciB0aGUgJ2lucHV0JyBldmVudC4gSWZcclxuICAgICAgICAgKiAnaW5wdXQnIGlzIG5vdCBhbiBldmVudCwgaXQgd2lsbCBzaW11bGF0ZSBhbiAnaW5wdXQnIHVzaW5nIG90aGVyIGV2ZW50cyBsaWtlICdrZXlkb3duJyxcclxuICAgICAgICAgKiAnY3V0JywgJ3Bhc3RlJywgZXRjLiBBbHNvIGZpcmVzIG9uIHRoZSAnY2hhbmdlJyBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgUmVhY3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoUmVhY3QsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFJlYWN0KCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBldmVudCBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50ID0gJ2lucHV0JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQWRkcyBhbnkgYW5kIGFsbCBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUmVhY3QucHJvdG90eXBlLl9hZGRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCwgX2NvbXBhdCA9IHRoaXMuX2NvbXBhdCwgY29tcG9zaW5nID0gZmFsc2UsIGlucHV0RmlyZWQgPSBmYWxzZSwgaW5wdXQgPSAnaW5wdXQnLCB0aW1lb3V0LCBldmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvc2luZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9vbkV2ZW50KGV2KTtcclxuICAgICAgICAgICAgICAgIH0sIHBvc3Rwb25lZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aW1lb3V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBwb3N0cG9uZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50TGlzdGVuZXIoZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoX2NvbXBhdC5BTkRST0lEKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCAnY29tcG9zaXRpb25zdGFydCcsIGZ1bmN0aW9uICgpIHsgY29tcG9zaW5nID0gdHJ1ZTsgfSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCAnY29tcG9zaXRpb25lbmQnLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9zaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50TGlzdGVuZXIoZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBpbnB1dCwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRGaXJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRMaXN0ZW5lcihldik7XHJcbiAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgJ2NoYW5nZScsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dEZpcmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0RmlyZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBldmVudExpc3RlbmVyKGV2KTtcclxuICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGlmIChfY29tcGF0Lmhhc0V2ZW50KGlucHV0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCAna2V5ZG93bicsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBldi5rZXlDb2RlLCBjb2RlcyA9IGNvbnRyb2xzLktleUNvZGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IGNvZGVzLmx3ayB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPT09IGNvZGVzLnJ3ayB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoa2V5ID49IGNvZGVzLnNoaWZ0ICYmIGtleSA8PSBjb2Rlcy5lc2NhcGUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChrZXkgPiBjb2Rlcy5zcGFjZSAmJiBrZXkgPD0gY29kZXMuZG93bikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwb3N0cG9uZWRFdmVudExpc3RlbmVyKGV2KTtcclxuICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCAnY3V0JywgcG9zdHBvbmVkRXZlbnRMaXN0ZW5lciwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsICdwYXN0ZScsIHBvc3Rwb25lZEV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUmVhY3QuX2luamVjdCA9IHtcclxuICAgICAgICAgICAgICAgIF9jb21wYXQ6IF9fQ29tcGF0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBSZWFjdDtcclxuICAgICAgICB9KFNpbXBsZUV2ZW50Q29udHJvbCkpO1xyXG4gICAgICAgIGNvbnRyb2xzLlJlYWN0ID0gUmVhY3Q7XHJcbiAgICAgICAgcmVnaXN0ZXIuY29udHJvbChfX1RhcCwgVGFwKTtcclxuICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fQmx1ciwgQmx1cik7XHJcbiAgICAgICAgcmVnaXN0ZXIuY29udHJvbChfX0NoYW5nZSwgQ2hhbmdlKTtcclxuICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fQ29weSwgQ29weSk7XHJcbiAgICAgICAgcmVnaXN0ZXIuY29udHJvbChfX0N1dCwgQ3V0KTtcclxuICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fUGFzdGUsIFBhc3RlKTtcclxuICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fRGJsVGFwLCBEYmxUYXApO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19Gb2N1cywgRm9jdXMpO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19TdWJtaXQsIFN1Ym1pdCk7XHJcbiAgICAgICAgcmVnaXN0ZXIuY29udHJvbChfX1RvdWNoU3RhcnQsIFRvdWNoU3RhcnQpO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19Ub3VjaEVuZCwgVG91Y2hFbmQpO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19Ub3VjaE1vdmUsIFRvdWNoTW92ZSk7XHJcbiAgICAgICAgcmVnaXN0ZXIuY29udHJvbChfX1RvdWNoQ2FuY2VsLCBUb3VjaENhbmNlbCk7XHJcbiAgICAgICAgcmVnaXN0ZXIuY29udHJvbChfX0hvbGQsIEhvbGQpO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19SZWxlYXNlLCBSZWxlYXNlKTtcclxuICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fU3dpcGUsIFN3aXBlKTtcclxuICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fU3dpcGVMZWZ0LCBTd2lwZUxlZnQpO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19Td2lwZVJpZ2h0LCBTd2lwZVJpZ2h0KTtcclxuICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fU3dpcGVVcCwgU3dpcGVVcCk7XHJcbiAgICAgICAgcmVnaXN0ZXIuY29udHJvbChfX1N3aXBlRG93biwgU3dpcGVEb3duKTtcclxuICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fVHJhY2ssIFRyYWNrKTtcclxuICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fVHJhY2tMZWZ0LCBUcmFja0xlZnQpO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19UcmFja1JpZ2h0LCBUcmFja1JpZ2h0KTtcclxuICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fVHJhY2tVcCwgVHJhY2tVcCk7XHJcbiAgICAgICAgcmVnaXN0ZXIuY29udHJvbChfX1RyYWNrRG93biwgVHJhY2tEb3duKTtcclxuICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fVHJhY2tFbmQsIFRyYWNrRW5kKTtcclxuICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fUmVhY3QsIFJlYWN0KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIG1hcHBpbmcgb2YgYWxsIGtleXMgdG8gdGhlaXIgZXF1aXZhbGVudCBrZXlDb2RlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbnRyb2xzLktleUNvZGVzID0ge1xyXG4gICAgICAgICAgICAnYmFja3NwYWNlJzogOCxcclxuICAgICAgICAgICAgJ3RhYic6IDksXHJcbiAgICAgICAgICAgICdlbnRlcic6IDEzLFxyXG4gICAgICAgICAgICAnc2hpZnQnOiAxNixcclxuICAgICAgICAgICAgJ2N0cmwnOiAxNyxcclxuICAgICAgICAgICAgJ2FsdCc6IDE4LFxyXG4gICAgICAgICAgICAncGF1c2UnOiAxOSwgJ2JyZWFrJzogMTksXHJcbiAgICAgICAgICAgICdjYXBzIGxvY2snOiAyMCxcclxuICAgICAgICAgICAgJ2VzY2FwZSc6IDI3LFxyXG4gICAgICAgICAgICAnc3BhY2UnOiAzMixcclxuICAgICAgICAgICAgJ3BhZ2UgdXAnOiAzMyxcclxuICAgICAgICAgICAgJ3BhZ2UgZG93bic6IDM0LFxyXG4gICAgICAgICAgICAnZW5kJzogMzUsXHJcbiAgICAgICAgICAgICdob21lJzogMzYsXHJcbiAgICAgICAgICAgICdsZWZ0JzogMzcsICdsZWZ0IGFycm93JzogMzcsXHJcbiAgICAgICAgICAgICd1cCc6IDM4LCAndXAgYXJyb3cnOiAzOCxcclxuICAgICAgICAgICAgJ3JpZ2h0JzogMzksICdyaWdodCBhcnJvdyc6IDM5LFxyXG4gICAgICAgICAgICAnZG93bic6IDQwLCAnZG93biBhcnJvdyc6IDQwLFxyXG4gICAgICAgICAgICAnaW5zZXJ0JzogNDUsXHJcbiAgICAgICAgICAgICdkZWxldGUnOiA0NixcclxuICAgICAgICAgICAgJzAnOiA0OCwgJ3plcm8nOiA0OCxcclxuICAgICAgICAgICAgJyknOiA0OCwgJ3JpZ2h0IHBhcmVudGhlc2lzJzogNDgsXHJcbiAgICAgICAgICAgICcxJzogNDksICdvbmUnOiA0OSxcclxuICAgICAgICAgICAgJyEnOiA0OSwgJ2V4Y2xhbWF0aW9uJzogNDksICdleGNsYW1hdGlvbiBwb2ludCc6IDQ5LFxyXG4gICAgICAgICAgICAnMic6IDUwLCAndHdvJzogNTAsXHJcbiAgICAgICAgICAgICdAJzogNTAsICdhdCc6IDUwLFxyXG4gICAgICAgICAgICAnMyc6IDUxLCAndGhyZWUnOiA1MSxcclxuICAgICAgICAgICAgJyMnOiA1MSwgJ251bWJlciBzaWduJzogNTEsXHJcbiAgICAgICAgICAgICdoYXNoJzogNTEsICdwb3VuZCc6IDUxLFxyXG4gICAgICAgICAgICAnNCc6IDUyLCAnZm91cic6IDUyLFxyXG4gICAgICAgICAgICAnJCc6IDUyLCAnZG9sbGFyJzogNTIsICdkb2xsYXIgc2lnbic6IDUyLFxyXG4gICAgICAgICAgICAnNSc6IDUzLCAnZml2ZSc6IDUzLFxyXG4gICAgICAgICAgICAnJSc6IDUzLCAncGVyY2VudCc6IDUzLCAncGVyY2VudCBzaWduJzogNTMsXHJcbiAgICAgICAgICAgICc2JzogNTQsICdzaXgnOiA1NCxcclxuICAgICAgICAgICAgJ14nOiA1NCwgJ2NhcmV0JzogNTQsXHJcbiAgICAgICAgICAgICc3JzogNTUsICdzZXZlbic6IDU1LFxyXG4gICAgICAgICAgICAnJic6IDU1LCAnYW1wZXJzYW5kJzogNTUsXHJcbiAgICAgICAgICAgICc4JzogNTYsICdlaWdodCc6IDU2LFxyXG4gICAgICAgICAgICAnKic6IDU2LCAnYXN0ZXJpc2snOiA1NixcclxuICAgICAgICAgICAgJzknOiA1NywgJ25pbmUnOiA1NyxcclxuICAgICAgICAgICAgJygnOiA1NywgJ2xlZnQgcGFyZW50aGVzaXMnOiA1NyxcclxuICAgICAgICAgICAgJ2EnOiA2NSwgJ2InOiA2NiwgJ2MnOiA2NywgJ2QnOiA2OCwgJ2UnOiA2OSxcclxuICAgICAgICAgICAgJ2YnOiA3MCwgJ2cnOiA3MSwgJ2gnOiA3MiwgJ2knOiA3MywgJ2onOiA3NCxcclxuICAgICAgICAgICAgJ2snOiA3NSwgJ2wnOiA3NiwgJ20nOiA3NywgJ24nOiA3OCwgJ28nOiA3OSxcclxuICAgICAgICAgICAgJ3AnOiA4MCwgJ3EnOiA4MSwgJ3InOiA4MiwgJ3MnOiA4MywgJ3QnOiA4NCxcclxuICAgICAgICAgICAgJ3UnOiA4NSwgJ3YnOiA4NiwgJ3cnOiA4NywgJ3gnOiA4OCwgJ3knOiA4OSxcclxuICAgICAgICAgICAgJ3onOiA5MCxcclxuICAgICAgICAgICAgJ2x3ayc6IDkxLCAnbGVmdCB3aW5kb3cga2V5JzogOTEsXHJcbiAgICAgICAgICAgICdyd2snOiA5MiwgJ3JpZ2h0IHdpbmRvdyBrZXknOiA5MixcclxuICAgICAgICAgICAgJ3NlbGVjdCc6IDkzLCAnc2VsZWN0IGtleSc6IDkzLFxyXG4gICAgICAgICAgICAnbnVtcGFkIDAnOiA5NixcclxuICAgICAgICAgICAgJ251bXBhZCAxJzogOTcsXHJcbiAgICAgICAgICAgICdudW1wYWQgMic6IDk4LFxyXG4gICAgICAgICAgICAnbnVtcGFkIDMnOiA5OSxcclxuICAgICAgICAgICAgJ251bXBhZCA0JzogMTAwLFxyXG4gICAgICAgICAgICAnbnVtcGFkIDUnOiAxMDEsXHJcbiAgICAgICAgICAgICdudW1wYWQgNic6IDEwMixcclxuICAgICAgICAgICAgJ251bXBhZCA3JzogMTAzLFxyXG4gICAgICAgICAgICAnbnVtcGFkIDgnOiAxMDQsXHJcbiAgICAgICAgICAgICdudW1wYWQgOSc6IDEwNSxcclxuICAgICAgICAgICAgJ211bHRpcGx5JzogMTA2LFxyXG4gICAgICAgICAgICAnYWRkJzogMTA3LFxyXG4gICAgICAgICAgICAnc3VidHJhY3QnOiAxMDksXHJcbiAgICAgICAgICAgICdkZWNpbWFsIHBvaW50JzogMTEwLFxyXG4gICAgICAgICAgICAnZGl2aWRlJzogMTExLFxyXG4gICAgICAgICAgICAnZjEnOiAxMTIsICdmMic6IDExMywgJ2YzJzogMTE0LCAnZjQnOiAxMTUsXHJcbiAgICAgICAgICAgICdmNSc6IDExNiwgJ2Y2JzogMTE3LCAnZjcnOiAxMTgsICdmOCc6IDExOSxcclxuICAgICAgICAgICAgJ2Y5JzogMTIwLCAnZjEwJzogMTIxLCAnZjExJzogMTIyLCAnZjEyJzogMTIzLFxyXG4gICAgICAgICAgICAnbnVtIGxvY2snOiAxNDQsXHJcbiAgICAgICAgICAgICdzY3JvbGwgbG9jayc6IDE0NSxcclxuICAgICAgICAgICAgJzsnOiAxODYsICdzZW1pLWNvbG9uJzogMTg2LFxyXG4gICAgICAgICAgICAnOic6IDE4NiwgJ2NvbG9uJzogMTg2LFxyXG4gICAgICAgICAgICAnPSc6IDE4NywgJ2VxdWFsJzogMTg3LCAnZXF1YWwgc2lnbic6IDE4NyxcclxuICAgICAgICAgICAgJysnOiAxODcsICdwbHVzJzogMTg3LFxyXG4gICAgICAgICAgICAnLCc6IDE4OCwgJ2NvbW1hJzogMTg4LFxyXG4gICAgICAgICAgICAnPCc6IDE4OCwgJ2x0JzogMTg4LCAnbGVzcyB0aGFuJzogMTg4LFxyXG4gICAgICAgICAgICAnbGVmdCBhbmdsZSBicmFja2V0JzogMTg4LFxyXG4gICAgICAgICAgICAnLSc6IDE4OSwgJ2Rhc2gnOiAxODksXHJcbiAgICAgICAgICAgICdfJzogMTg5LCAndW5kZXJzY29yZSc6IDE4OSxcclxuICAgICAgICAgICAgJy4nOiAxOTAsICdwZXJpb2QnOiAxOTAsXHJcbiAgICAgICAgICAgICc+JzogMTkwLCAnZ3QnOiAxOTAsICdncmVhdGVyIHRoYW4nOiAxOTAsXHJcbiAgICAgICAgICAgICdyaWdodCBhbmdsZSBicmFja2V0JzogMTkwLFxyXG4gICAgICAgICAgICAnLyc6IDE5MSwgJ2ZvcndhcmQgc2xhc2gnOiAxOTEsXHJcbiAgICAgICAgICAgICc/JzogMTkxLCAncXVlc3Rpb24gbWFyayc6IDE5MSxcclxuICAgICAgICAgICAgJ2AnOiAxOTIsICdncmF2ZSBhY2NlbnQnOiAxOTIsXHJcbiAgICAgICAgICAgICd+JzogMTkyLCAndGlsZGUnOiAxOTIsXHJcbiAgICAgICAgICAgICdbJzogMjE5LCAnb3BlbiBicmFja2V0JzogMjE5LFxyXG4gICAgICAgICAgICAneyc6IDIxOSwgJ29wZW4gYnJhY2UnOiAyMTksXHJcbiAgICAgICAgICAgICdcXFxcJzogMjIwLCAnYmFjayBzbGFzaCc6IDIyMCxcclxuICAgICAgICAgICAgJ3wnOiAyMjAsICdwaXBlJzogMjIwLFxyXG4gICAgICAgICAgICAnXSc6IDIyMSwgJ2Nsb3NlIGJyYWNrZXQnOiAyMjEsXHJcbiAgICAgICAgICAgICd9JzogMjIxLCAnY2xvc2UgYnJhY2UnOiAyMjEsXHJcbiAgICAgICAgICAgICdcXCcnOiAyMjIsICdzaW5nbGUgcXVvdGUnOiAyMjIsXHJcbiAgICAgICAgICAgICdcIic6IDIyMiwgJ2RvdWJsZSBxdW90ZSc6IDIyMlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQmFzZSBjbGFzcyB1c2VkIGZvciBmaWx0ZXJpbmcga2V5cyBvbiBLZXlib2FyZEV2ZW50cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgS2V5Q29kZUV2ZW50Q29udHJvbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhLZXlDb2RlRXZlbnRDb250cm9sLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBLZXlDb2RlRXZlbnRDb250cm9sKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEhvbGRzIHRoZSBrZXkgbWFwcGluZ3MgdG8gZmlsdGVyIGZvciBpbiBhIEtleWJvYXJkRXZlbnQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMua2V5Q29kZXMgPSB7fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBJS2V5Ym9hcmRFdmVudElucHV0IGlzIGFuIGV4cHJlc3Npb24gb2JqZWN0XHJcbiAgICAgICAgICAgICAqIGFuZCBzZXRzIHRoZSBuZWNlc3NhcnkgbGlzdGVuZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBLZXlDb2RlRXZlbnRDb250cm9sLnByb3RvdHlwZS5fc2V0TGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IHRoaXMuYXR0cmlidXRlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkodGhpcy5ldmVudCkgfHwgaXNFbXB0eShhdHRyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5hdHRyaWJ1dGVzW2F0dHJdLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uWzBdID09PSAneycpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRPYmplY3QgPSB0aGlzLmV2YWx1YXRlRXhwcmVzc2lvbihleHByZXNzaW9uKSB8fCB7IG1ldGhvZDogJycgfSwga2V5cyA9IHRoaXMuX2ZpbHRlckFyZ3MoZXZlbnRPYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldEtleUNvZGVzKGtleXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmVsZW1lbnQsIHRoaXMuZXZlbnQsIHRoaXMuX29uRXZlbnQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9zZXRMaXN0ZW5lci5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGFyc2VzIHRoZSBwcm9wZXIgbWV0aG9kIGFyZ3MgYW5kIGZpbmRzIGFueSBrZXkgY29kZSBmaWx0ZXJzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgS2V5Q29kZUV2ZW50Q29udHJvbC5wcm90b3R5cGUuX2ZpbHRlckFyZ3MgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBpbnB1dC5rZXksIGtleXMgPSBpbnB1dC5rZXlzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VBcmdzKGlucHV0Lm1ldGhvZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShrZXlzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNTdHJpbmcoa2V5cykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2tleXNdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNBcnJheShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzU3RyaW5nKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShpc051bGwoaW5wdXQuY2hhcikgJiYgaXNOdWxsKGlucHV0LmNoYXJzKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4odGhpcy50eXBlICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgc2hvdWxkIGJlIHVzaW5nIHRoZSBwcm9wZXJ0eSBrZXkgb3Iga2V5cyB0byBkZW5vdGUga2V5IGNvZGVzIG9yIGtleXMgYW5kIG5vdCBjaGFyIGNvZGVzIG9yIGNoYXJhY3RlcnMuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTWF0Y2hlcyB0aGUgZXZlbnQncyBrZXlDb2RlIGlmIG5lY2Vzc2FyeSBhbmQgdGhlbiBoYW5kbGVzIHRoZSBldmVudCBpZlxyXG4gICAgICAgICAgICAgKiBhIG1hdGNoIGlzIGZvdW5kIG9yIGlmIHRoZXJlIGFyZSBubyBmaWx0ZXIga2V5Q29kZXMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXYgVGhlIGtleWJvYXJkIGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEtleUNvZGVFdmVudENvbnRyb2wucHJvdG90eXBlLl9vbkV2ZW50ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29tcGFyZUtleXMoZXYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fb25FdmVudC5jYWxsKHRoaXMsIGV2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE1hdGNoZXMgdGhlIGV2ZW50J3Mga2V5Q29kZSBpZiBuZWNlc3NhcnkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXYgVGhlIGtleWJvYXJkIGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEtleUNvZGVFdmVudENvbnRyb2wucHJvdG90eXBlLl9jb21wYXJlS2V5cyA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleUNvZGVzID0gdGhpcy5rZXlDb2Rlcywga2V5Q29kZSA9IGV2LmtleUNvZGUgfHwgZXYud2hpY2g7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNFbXB0eShrZXlDb2RlcykgfHwga2V5Q29kZXNba2V5Q29kZV0gPT09IHRydWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBkZWZpbmVkIGtleSBjb2RlcyBhcyB0aGV5IGNvcnJlc3BvbmQgdG9cclxuICAgICAgICAgICAgICogdGhlIEtleUNvZGVzIG1hcC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBrZXlzPyBUaGUgYXJyYXkgb2YgZGVmaW5lZCBrZXlzIHRvIHNhdGlzZnkgdGhlXHJcbiAgICAgICAgICAgICAqIGtleSBwcmVzcyBjb25kaXRpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBLZXlDb2RlRXZlbnRDb250cm9sLnByb3RvdHlwZS5fc2V0S2V5Q29kZXMgPSBmdW5jdGlvbiAoa2V5cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KGtleXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIGtleUNvZGVzID0gdGhpcy5rZXlDb2RlcywgaW5kZXg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGlzTnVtYmVyKGtleSkgPyBrZXkgOiBjb250cm9scy5LZXlDb2Rlc1trZXkudG9Mb3dlckNhc2UoKV07XHJcbiAgICAgICAgICAgICAgICAgICAga2V5Q29kZXNbaW5kZXhdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIEtleUNvZGVFdmVudENvbnRyb2w7XHJcbiAgICAgICAgfShTaW1wbGVFdmVudENvbnRyb2wpKTtcclxuICAgICAgICBjb250cm9scy5LZXlDb2RlRXZlbnRDb250cm9sID0gS2V5Q29kZUV2ZW50Q29udHJvbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVc2VkIGZvciBmaWx0ZXJpbmcga2V5cyBvbiBrZXlkb3duIGV2ZW50cy4gRG9lcyBub3QgdGFrZSBjYXBpdGFsaXphdGlvbiBpbnRvIGFjY291bnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEtleURvd24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoS2V5RG93biwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gS2V5RG93bigpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgZXZlbnQgbmFtZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudCA9ICdrZXlkb3duJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gS2V5RG93bjtcclxuICAgICAgICB9KEtleUNvZGVFdmVudENvbnRyb2wpKTtcclxuICAgICAgICBjb250cm9scy5LZXlEb3duID0gS2V5RG93bjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVc2VkIGZvciBmaWx0ZXJpbmcgb25seSBwcmludGluZyBrZXlzIChhLXosIEEtWiwgMC05LCBhbmQgc3BlY2lhbCBjaGFyYWN0ZXJzKSBvbiBrZXlkb3duIGV2ZW50cy5cclxuICAgICAgICAgKiBEb2VzIG5vdCB0YWtlIGNhcGl0YWxpemF0aW9uIGludG8gYWNjb3VudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgS2V5UHJlc3MgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoS2V5UHJlc3MsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEtleVByZXNzKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBldmVudCBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50ID0gJ2tleWRvd24nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGaWx0ZXJzIG9ubHkgJ3ByaW50aW5nIGtleXMnIChhLXosIEEtWiwgMC05LCBhbmQgc3BlY2lhbCBjaGFyYWN0ZXJzKS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldiBUaGUgS2V5Ym9hcmRFdmVudCBvYmplY3QuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBLZXlQcmVzcy5wcm90b3R5cGUuX29uRXZlbnQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5Q29kZSA9IGV2LmtleUNvZGUgfHwgZXYud2hpY2g7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3N1cGVyLnByb3RvdHlwZS5fY29tcGFyZUtleXMuY2FsbCh0aGlzLCBldikgJiYgKChrZXlDb2RlID49IDQ4ICYmIGtleUNvZGUgPD0gOTApIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGtleUNvZGUgPj0gMTg2KSB8fCAoa2V5Q29kZSA+PSA5NiAmJiBrZXlDb2RlIDw9IDExMSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW92ZV8xID0gdGhpcy5hZGRFdmVudExpc3RlbmVyKHRoaXMuZWxlbWVudCwgJ2tleXByZXNzJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlXzEoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fb25FdmVudC5jYWxsKF90aGlzLCBlKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBNYXRjaGVzIHRoZSBldmVudCdzIGtleUNvZGUgaWYgbmVjZXNzYXJ5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2IFRoZSBrZXlib2FyZCBldmVudCBvYmplY3QuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBLZXlQcmVzcy5wcm90b3R5cGUuX2NvbXBhcmVLZXlzID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIEtleVByZXNzO1xyXG4gICAgICAgIH0oS2V5Q29kZUV2ZW50Q29udHJvbCkpO1xyXG4gICAgICAgIGNvbnRyb2xzLktleVByZXNzID0gS2V5UHJlc3M7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXNlZCBmb3IgZmlsdGVyaW5nIGtleXMgb24ga2V5dXAgZXZlbnRzLiBEb2VzIG5vdCB0YWtlIGNhcGl0YWxpemF0aW9uIGludG8gYWNjb3VudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgS2V5VXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoS2V5VXAsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEtleVVwKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBldmVudCBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50ID0gJ2tleXVwJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gS2V5VXA7XHJcbiAgICAgICAgfShLZXlDb2RlRXZlbnRDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuS2V5VXAgPSBLZXlVcDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVc2VkIGZvciBmaWx0ZXJpbmcga2V5cyBvbiBrZXlwcmVzcyBldmVudHMuIFRha2VzIGNhcGl0YWxpemF0aW9uIGludG8gYWNjb3VudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgQ2hhclByZXNzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKENoYXJQcmVzcywgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gQ2hhclByZXNzKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBldmVudCBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50ID0gJ2tleXByZXNzJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGFyc2VzIHRoZSBwcm9wZXIgbWV0aG9kIGFyZ3MgYW5kIGZpbmRzIGFueSBjaGFyIGNvZGUgZmlsdGVycy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENoYXJQcmVzcy5wcm90b3R5cGUuX2ZpbHRlckFyZ3MgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGFyID0gaW5wdXQuY2hhciwgY2hhcnMgPSBpbnB1dC5jaGFycztcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlQXJncyhpbnB1dC5tZXRob2QpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoY2hhcnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNTdHJpbmcoY2hhcnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjaGFyc107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0FycmF5KGNoYXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1N0cmluZyhjaGFyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbY2hhcl07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShpc051bGwoaW5wdXQua2V5KSAmJiBpc051bGwoaW5wdXQua2V5cykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKHRoaXMudHlwZSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHNob3VsZCBiZSB1c2luZyB0aGUgcHJvcGVydHkga2V5IG9yIGtleXMgdG8gZGVub3RlIGtleSBjb2RlcyBvciBrZXlzIGFuZCBub3QgY2hhciBjb2RlcyBvciBjaGFyYWN0ZXJzLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE1hdGNoZXMgdGhlIGV2ZW50J3Mga2V5Q29kZSBpZiBuZWNlc3NhcnkgYW5kIHRoZW4gaGFuZGxlcyB0aGUgZXZlbnQgaWZcclxuICAgICAgICAgICAgICogYSBtYXRjaCBpcyBmb3VuZCBvciBpZiB0aGVyZSBhcmUgbm8gZmlsdGVyIGtleUNvZGVzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2IFRoZSBrZXlib2FyZCBldmVudCBvYmplY3QuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDaGFyUHJlc3MucHJvdG90eXBlLl9vbkV2ZW50ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5Q29kZXMgPSB0aGlzLmtleUNvZGVzLCBrZXlDb2RlID0gZXYuY2hhckNvZGUgfHwgZXYud2hpY2gsIGtleTtcclxuICAgICAgICAgICAgICAgIGlmICgha2V5Q29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGV2LmtleTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gU3RyaW5nLmZyb21DaGFyQ29kZShrZXlDb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KGtleUNvZGVzKSB8fCBrZXlDb2Rlc1trZXldID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fb25FdmVudC5jYWxsKHRoaXMsIGV2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE1hdGNoZXMgdGhlIGV2ZW50J3Mga2V5Q29kZSBpZiBuZWNlc3NhcnkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXYgVGhlIGtleWJvYXJkIGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENoYXJQcmVzcy5wcm90b3R5cGUuX2NvbXBhcmVLZXlzID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIGRlZmluZWQga2V5IGNvZGVzIGFzIHRoZXkgY29ycmVzcG9uZCB0b1xyXG4gICAgICAgICAgICAgKiB0aGUgS2V5Q29kZXMgbWFwLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGtleXM/IFRoZSBhcnJheSBvZiBkZWZpbmVkIGtleXMgdG8gc2F0aXNmeSB0aGVcclxuICAgICAgICAgICAgICoga2V5IHByZXNzIGNvbmRpdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENoYXJQcmVzcy5wcm90b3R5cGUuX3NldEtleUNvZGVzID0gZnVuY3Rpb24gKGtleXMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNBcnJheShrZXlzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCBrZXlDb2RlcyA9IHRoaXMua2V5Q29kZXMsIGluZGV4O1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGtleXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpc051bWJlcihrZXkpID8gU3RyaW5nLmZyb21DaGFyQ29kZShrZXkpIDoga2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIGtleUNvZGVzW2luZGV4XSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBDaGFyUHJlc3M7XHJcbiAgICAgICAgfShLZXlDb2RlRXZlbnRDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuQ2hhclByZXNzID0gQ2hhclByZXNzO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19LZXlEb3duLCBLZXlEb3duKTtcclxuICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fS2V5UHJlc3MsIEtleVByZXNzKTtcclxuICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fS2V5VXAsIEtleVVwKTtcclxuICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fQ2hhclByZXNzLCBDaGFyUHJlc3MpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuIEF0dHJpYnV0ZUNvbnRyb2wgdGhhdCBkZWFscyB3aXRoIGJpbmRpbmcgdG8gYSBzcGVjaWZpZWQgcHJvcGVydHkgb24gaXRzIGVsZW1lbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFNldEF0dHJpYnV0ZUNvbnRyb2wgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoU2V0QXR0cmlidXRlQ29udHJvbCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gU2V0QXR0cmlidXRlQ29udHJvbCgpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgcHJvcGVydHkgdG8gc2V0IG9uIHRoZSBhc3NvY2lhdGVkIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydHkgPSAnJztcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGZ1bmN0aW9uIHRvIHN0b3AgbGlzdGVuaW5nIGZvciB0aGUgZGVsYXllZCBhdHRyaWJ1dGUgc2V0LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdG9wU2V0dGVyID0gbm9vcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgY29ycmVzcG9uZGluZyBhdHRyaWJ1dGUge3Byb3BlcnR5fSB2YWx1ZSBhbmRcclxuICAgICAgICAgICAgICogb2JzZXJ2ZXMgdGhlIGF0dHJpYnV0ZSBmb3IgY2hhbmdlcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFNldEF0dHJpYnV0ZUNvbnRyb2wucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwodGhpcy5lbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlID0gY2FtZWxDYXNlKHRoaXMudHlwZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRlcigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3JlbW92ZUxpc3RlbmVyID0gdGhpcy5hdHRyaWJ1dGVzLm9ic2VydmUodGhpcy5zZXR0ZXIsIHRoaXMuYXR0cmlidXRlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlc2V0cyB0aGUgY29ycmVzcG9uZGluZyBhdHRyaWJ1dGUgcHJvcGVydHkgdmFsdWUgdXBvblxyXG4gICAgICAgICAgICAgKiBhIGNoYW5nZSBvZiBjb250ZXh0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgU2V0QXR0cmlidXRlQ29udHJvbC5wcm90b3R5cGUuY29udGV4dENoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHRoaXMuZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRlcigpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU3RvcHMgbGlzdGVuaW5nIHRvIGF0dHJpYnV0ZSBjaGFuZ2VzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgU2V0QXR0cmlidXRlQ29udHJvbC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BTZXR0ZXIoKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXMuX19yZW1vdmVMaXN0ZW5lcikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fcmVtb3ZlTGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fcmVtb3ZlTGlzdGVuZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGZ1bmN0aW9uIGZvciBzZXR0aW5nIHRoZSBjb3JyZXNwb25kaW5nXHJcbiAgICAgICAgICAgICAqIGF0dHJpYnV0ZSBwcm9wZXJ0eSB2YWx1ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFNldEF0dHJpYnV0ZUNvbnRyb2wucHJvdG90eXBlLnNldHRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdG9wU2V0dGVyKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdG9wU2V0dGVyID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lR2xvYmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IF90aGlzLmVsZW1lbnQsIHByb3BlcnR5ID0gX3RoaXMucHJvcGVydHk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF90aGlzLmF0dHJpYnV0ZXNbX3RoaXMuYXR0cmlidXRlXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmYWxzZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzAnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdudWxsJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKHByb3BlcnR5LCAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50W3Byb3BlcnR5XSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUocHJvcGVydHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShwcm9wZXJ0eSwgcHJvcGVydHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFtwcm9wZXJ0eV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBTZXRBdHRyaWJ1dGVDb250cm9sO1xyXG4gICAgICAgIH0oQXR0cmlidXRlQ29udHJvbCkpO1xyXG4gICAgICAgIGNvbnRyb2xzLlNldEF0dHJpYnV0ZUNvbnRyb2wgPSBTZXRBdHRyaWJ1dGVDb250cm9sO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgU2V0QXR0cmlidXRlQ29udHJvbCBmb3IgdGhlICdjaGVja2VkJyBhdHRyaWJ1dGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIENoZWNrZWQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoQ2hlY2tlZCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gQ2hlY2tlZCgpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgcHJvcGVydHkgdG8gc2V0IG9uIHRoZSBhc3NvY2lhdGVkIHRlbXBsYXRlIGNvbnRyb2wuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydHkgPSAnY2hlY2tlZCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIENoZWNrZWQ7XHJcbiAgICAgICAgfShTZXRBdHRyaWJ1dGVDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuQ2hlY2tlZCA9IENoZWNrZWQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBTZXRBdHRyaWJ1dGVDb250cm9sIGZvciB0aGUgJ2Rpc2FibGVkJyBhdHRyaWJ1dGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIERpc2FibGVkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKERpc2FibGVkLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBEaXNhYmxlZCgpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgcHJvcGVydHkgdG8gc2V0IG9uIHRoZSBhc3NvY2lhdGVkIHRlbXBsYXRlIGNvbnRyb2wuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydHkgPSAnZGlzYWJsZWQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBEaXNhYmxlZDtcclxuICAgICAgICB9KFNldEF0dHJpYnV0ZUNvbnRyb2wpKTtcclxuICAgICAgICBjb250cm9scy5EaXNhYmxlZCA9IERpc2FibGVkO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgU2V0QXR0cmlidXRlQ29udHJvbCBmb3IgdGhlICdzZWxlY3RlZCcgYXR0cmlidXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBTZWxlY3RlZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhTZWxlY3RlZCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gU2VsZWN0ZWQoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIHByb3BlcnR5IHRvIHNldCBvbiB0aGUgYXNzb2NpYXRlZCB0ZW1wbGF0ZSBjb250cm9sLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnR5ID0gJ3NlbGVjdGVkJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gU2VsZWN0ZWQ7XHJcbiAgICAgICAgfShTZXRBdHRyaWJ1dGVDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuU2VsZWN0ZWQgPSBTZWxlY3RlZDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFNldEF0dHJpYnV0ZUNvbnRyb2wgZm9yIHRoZSAncmVhZG9ubHknIGF0dHJpYnV0ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgUmVhZE9ubHkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoUmVhZE9ubHksIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFJlYWRPbmx5KCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBwcm9wZXJ0eSB0byBzZXQgb24gdGhlIGFzc29jaWF0ZWQgdGVtcGxhdGUgY29udHJvbC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eSA9ICdyZWFkb25seSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFJlYWRPbmx5O1xyXG4gICAgICAgIH0oU2V0QXR0cmlidXRlQ29udHJvbCkpO1xyXG4gICAgICAgIGNvbnRyb2xzLlJlYWRPbmx5ID0gUmVhZE9ubHk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBTZXRBdHRyaWJ1dGVDb250cm9sIGZvciB0aGUgJ3BsYXQtaGlkZScgYXR0cmlidXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBWaXNpYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFZpc2libGUsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFZpc2libGUoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIHByb3BlcnR5IHRvIHNldCBvbiB0aGUgYXNzb2NpYXRlZCBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnR5ID0gJ2Rpc3BsYXknO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgdmFsdWUgdG8gYXNzb2NpYXRlIHdpdGggdGhlIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgaW1wb3J0YW5jZSB0byBzZXQgb24gdGhlIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmltcG9ydGFuY2UgPSAnaW1wb3J0YW50JztcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIHNldC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbFZhbHVlID0gJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEhpZGVzIHRoZSBlbGVtZW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVmlzaWJsZS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuZWxlbWVudC5zdHlsZSB8fCB7IGdldFByb3BlcnR5VmFsdWU6IG5vb3AgfSwgaW5pdGlhbFZhbHVlID0gc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSh0aGlzLnByb3BlcnR5KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFZhbHVlKHRoaXMudmFsdWUsIHRoaXMuaW1wb3J0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShpbml0aWFsVmFsdWUpIHx8IGluaXRpYWxWYWx1ZSA9PT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbFZhbHVlID0gaW5pdGlhbFZhbHVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSGlkZXMgb3Igc2hvd3MgdGhlIGVsZW1lbnQgZGVwZW5kaW5nIHVwb24gdGhlIGF0dHJpYnV0ZSB2YWx1ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVmlzaWJsZS5wcm90b3R5cGUuc2V0dGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BTZXR0ZXIoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BTZXR0ZXIgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWVHbG9iYWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKF90aGlzLmVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfdGhpcy5hdHRyaWJ1dGVzW190aGlzLmF0dHJpYnV0ZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZmFsc2UnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcwJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbnVsbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2V0VmFsdWUoX3RoaXMudmFsdWUsIF90aGlzLmltcG9ydGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2V0VmFsdWUoX3RoaXMuX2luaXRpYWxWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBlbGVtZW50IHdpdGggdGhlIGdpdmVuIGltcG9ydGFuY2UuIElmIHRoZVxyXG4gICAgICAgICAgICAgKiB2YWx1ZSBpcyBudWxsIG9yIGVtcHR5IHN0cmluZywgdGhlIHByb3BlcnR5IHdpbGwgYmUgcmVtb3ZlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbXBvcnRhbmNlPyBUaGUgcHJpb3JpdHkgb3IgaW1wb3J0YW5jZSBsZXZlbCB0byBzZXQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBWaXNpYmxlLnByb3RvdHlwZS5fc2V0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIGltcG9ydGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMucHJvcGVydHksIHN0eWxlID0gdGhpcy5lbGVtZW50LnN0eWxlIHx8IHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRQcm9wZXJ0eTogbm9vcCxcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVQcm9wZXJ0eTogbm9vcCxcclxuICAgICAgICAgICAgICAgICAgICBnZXRQcm9wZXJ0eVZhbHVlOiBub29wLFxyXG4gICAgICAgICAgICAgICAgICAgIGdldFByb3BlcnR5UHJpb3JpdHk6IG5vb3BcclxuICAgICAgICAgICAgICAgIH0sIGN1cnJlbnRWYWwgPSBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KSwgY3VycmVudFByaW9yaXR5ID0gc3R5bGUuZ2V0UHJvcGVydHlQcmlvcml0eShwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IGN1cnJlbnRWYWwgJiYgaW1wb3J0YW5jZSA9PT0gY3VycmVudFByaW9yaXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNFbXB0eSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlLCBpbXBvcnRhbmNlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFZpc2libGU7XHJcbiAgICAgICAgfShTZXRBdHRyaWJ1dGVDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuVmlzaWJsZSA9IFZpc2libGU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBTZXRBdHRyaWJ1dGVDb250cm9sIGZvciB0aGUgJ3N0eWxlJyBhdHRyaWJ1dGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFN0eWxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFN0eWxlLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBTdHlsZSgpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgcHJvcGVydHkgdG8gc2V0IG9uIHRoZSBhc3NvY2lhdGVkIHRlbXBsYXRlIGNvbnRyb2wuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydHkgPSAnc3R5bGUnO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3Igc2VwYXJhdGluZyBzdHlsZSBwcm9wZXJ0aWVzIGZyb20gc3R5bGUgdmFsdWVzIGluXHJcbiAgICAgICAgICAgICAgICAgKiBpbmRpdmlkdWFsIHN0eWxlIGRlY2xhcmF0aW9ucy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3R5bGVSZWdleCA9IC8oLio/KTooLiopLztcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIHRlbXBvcmFyaWx5IGZpbmRpbmcgYW5kIHJlbW92aW5nIHVybCBkZWNsYXJhdGlvbnMgaW4gdGhlIHN0eWxlIGF0dHJpYnV0ZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXJsUmVnZXggPSAvdXJsXFwoW15cXCldKlxcKS9naTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIHRlbXBvcmFyeSByZXBsYWNlIHZhbHVlIG9mIHVybHMgZm91bmQgaW4gdGhlIHN0eWxlIGF0dHJpYnV0ZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXJsUmVwbGFjZSA9ICdbUExBVC1TVFlMRS1VUkxdJztcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQW4gb2JqZWN0IHN0b3JpbmcgYWxsIHRoZSBhZGRlZCBzdHlsZXMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX19hZGRlZFN0eWxlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBbiBvYmplY3Qgc3RvcmluZyBhbGwgdGhlIG9sZCBzdHlsZSB2YWx1ZXMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX19vbGRTdHlsZXMgPSB7fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgZXZhbHVhdGVkIHN0eWxlcyBvbiB0aGUgZWxlbWVudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFN0eWxlLnByb3RvdHlwZS5zZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RvcFNldHRlcigpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsIGV4cHJlc3Npb24gPSB0aGlzLmF0dHJpYnV0ZXNbdGhpcy5hdHRyaWJ1dGVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkoZXhwcmVzc2lvbikgfHwgaXNOdWxsKGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RvcFNldHRlciA9IHJlcXVlc3RBbmltYXRpb25GcmFtZUdsb2JhbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVybHMgPSBbXSwgdXJsUmVwbGFjZSA9IF90aGlzLl91cmxSZXBsYWNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLnJlcGxhY2UoX3RoaXMuX3VybFJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJscy5wdXNoKG1hdGNoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVybFJlcGxhY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gZWxlbWVudC5zdHlsZSwgYWRkZWRTdHlsZXMgPSBfdGhpcy5fX2FkZGVkU3R5bGVzLCBvbGRTdHlsZXMgPSBfdGhpcy5fX29sZFN0eWxlcywgbmV3U3R5bGVzID0gW10sIHByb3BzID0gZXhwcmVzc2lvbi5zcGxpdCgnOycpLCBsZW5ndGggPSBwcm9wcy5sZW5ndGgsIHByb3AsIHZhbCwgc3R5bGVSZWdleCA9IF90aGlzLl9zdHlsZVJlZ2V4LCBleGVjLCBzdHlsZUNoYW5nZXMgPSB7fSwgaTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhlYyA9IHN0eWxlUmVnZXguZXhlYyhwcm9wc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwoZXhlYykgfHwgZXhlYy5sZW5ndGggPCAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wID0gZXhlY1sxXS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wLmxlbmd0aCA9PT0gMCB8fCBpc1VuZGVmaW5lZChzdHlsZVtwcm9wXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFkZGVkU3R5bGVzLmluZGV4T2YocHJvcCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRTdHlsZXNbcHJvcF0gPSBzdHlsZVtwcm9wXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTdHlsZXMucHVzaChwcm9wKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gZXhlY1syXS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cmxzLmxlbmd0aCA+IDAgJiYgdmFsLmluZGV4T2YodXJsUmVwbGFjZSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWwucmVwbGFjZSh1cmxSZXBsYWNlLCB1cmxzLnNoaWZ0KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlQ2hhbmdlc1twcm9wXSA9IHZhbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gYWRkZWRTdHlsZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChsZW5ndGgtLSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcCA9IGFkZGVkU3R5bGVzW2xlbmd0aF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdTdHlsZXMuaW5kZXhPZihwcm9wKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlQ2hhbmdlc1twcm9wXSA9IG9sZFN0eWxlc1twcm9wXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZGVkU3R5bGVzLnNwbGljZShsZW5ndGgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3R5bGVDaGFuZ2VzKTtcclxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobGVuZ3RoLS0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3AgPSBrZXlzW2xlbmd0aF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlW3Byb3BdID0gc3R5bGVDaGFuZ2VzW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fX2FkZGVkU3R5bGVzID0gYWRkZWRTdHlsZXMuY29uY2F0KG5ld1N0eWxlcyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFN0eWxlO1xyXG4gICAgICAgIH0oU2V0QXR0cmlidXRlQ29udHJvbCkpO1xyXG4gICAgICAgIGNvbnRyb2xzLlN0eWxlID0gU3R5bGU7XHJcbiAgICAgICAgcmVnaXN0ZXIuY29udHJvbChfX0NoZWNrZWQsIENoZWNrZWQpO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19EaXNhYmxlZCwgRGlzYWJsZWQpO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19TZWxlY3RlZCwgU2VsZWN0ZWQpO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19SZWFkT25seSwgUmVhZE9ubHkpO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19WaXNpYmxlLCBWaXNpYmxlKTtcclxuICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fU3R5bGUsIFN0eWxlKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCYXNlIGNsYXNzIHVzZWQgZm9yIHNldHRpbmcgdGhlIHByb3BlcnR5IG9mIGFuIGVsZW1lbnQgKGUuZy4gaHJlZiBmb3IgYW5jaG9yIGVsZW1lbnRzKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgRWxlbWVudFByb3BlcnR5Q29udHJvbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhFbGVtZW50UHJvcGVydHlDb250cm9sLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBFbGVtZW50UHJvcGVydHlDb250cm9sKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbiBmb3Igc2V0dGluZyB0aGUgY29ycmVzcG9uZGluZ1xyXG4gICAgICAgICAgICAgKiBhdHRyaWJ1dGUgcHJvcGVydHkgdmFsdWUgdG8gdGhlIGV2YWx1YXRlZCBleHByZXNzaW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRWxlbWVudFByb3BlcnR5Q29udHJvbC5wcm90b3R5cGUuc2V0dGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsIGVsZW1lbnRQcm9wZXJ0eSA9IHRoaXMucHJvcGVydHksIGV4cHJlc3Npb24gPSB0aGlzLmF0dHJpYnV0ZXNbdGhpcy5hdHRyaWJ1dGVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkoZXhwcmVzc2lvbikgfHwgaXNOdWxsKGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChlbGVtZW50W2VsZW1lbnRQcm9wZXJ0eV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudFtlbGVtZW50UHJvcGVydHldID0gZXhwcmVzc2lvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIEVsZW1lbnRQcm9wZXJ0eUNvbnRyb2w7XHJcbiAgICAgICAgfShTZXRBdHRyaWJ1dGVDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuRWxlbWVudFByb3BlcnR5Q29udHJvbCA9IEVsZW1lbnRQcm9wZXJ0eUNvbnRyb2w7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSB0eXBlIG9mIEVsZW1lbnRQcm9wZXJ0eUNvbnRyb2wgdXNlZCB0byBzZXQgJ2hyZWYnIG9uIGFuIGFuY2hvciB0YWcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEhyZWYgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoSHJlZiwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gSHJlZigpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBVc2VkIHRvIHNldCB0aGUgZWxlbWVudCdzIGhyZWYgcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydHkgPSAnaHJlZic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIEhyZWY7XHJcbiAgICAgICAgfShFbGVtZW50UHJvcGVydHlDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuSHJlZiA9IEhyZWY7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSB0eXBlIG9mIEVsZW1lbnRQcm9wZXJ0eUNvbnRyb2wgdXNlZCB0byBzZXQgJ3NyYycgb24gYW4gYW5jaG9yIHRhZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgU3JjID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFNyYywgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gU3JjKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFVzZWQgdG8gc2V0IHRoZSBlbGVtZW50J3Mgc3JjIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnR5ID0gJ3NyYyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbiBmb3Igc2V0dGluZyB0aGUgY29ycmVzcG9uZGluZ1xyXG4gICAgICAgICAgICAgKiBhdHRyaWJ1dGUgcHJvcGVydHkgdmFsdWUgdG8gdGhlIGV2YWx1YXRlZCBleHByZXNzaW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgU3JjLnByb3RvdHlwZS5zZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCwgZWxlbWVudFByb3BlcnR5ID0gdGhpcy5wcm9wZXJ0eSwgZXhwcmVzc2lvbiA9IHRoaXMuYXR0cmlidXRlc1t0aGlzLmF0dHJpYnV0ZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShleHByZXNzaW9uKSB8fCBpc051bGwoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGVsZW1lbnRbZWxlbWVudFByb3BlcnR5XSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50W2VsZW1lbnRQcm9wZXJ0eV0gPSB0aGlzLl9icm93c2VyLnVybFV0aWxzKGV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTcmMuX2luamVjdCA9IHtcclxuICAgICAgICAgICAgICAgIF9icm93c2VyOiBfX0Jyb3dzZXJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFNyYztcclxuICAgICAgICB9KEVsZW1lbnRQcm9wZXJ0eUNvbnRyb2wpKTtcclxuICAgICAgICBjb250cm9scy5TcmMgPSBTcmM7XHJcbiAgICAgICAgcmVnaXN0ZXIuY29udHJvbChfX0hyZWYsIEhyZWYpO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19TcmMsIFNyYyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmFjaWxpdGF0ZXMgdHdvLXdheSBkYXRhYmluZGluZyBmb3IgSFRNTElucHV0RWxlbWVudHMsIEhUTUxTZWxlY3RFbGVtZW50cywgYW5kIEhUTUxUZXh0QXJlYUVsZW1lbnRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBCaW5kID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKEJpbmQsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEJpbmQoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIHByaW9yaXR5IG9mIEJpbmQgaXMgc2V0IGhpZ2ggdG8gcHJlY2VkZVxyXG4gICAgICAgICAgICAgICAgICogb3RoZXIgY29udHJvbHMgdGhhdCBtYXkgYmUgbGlzdGVuaW5nIHRvIHRoZSBzYW1lXHJcbiAgICAgICAgICAgICAgICAgKiBldmVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcmlvcml0eSA9IDEwMDtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgQmluZCBpcyBiZWluZyB1c2VkIGluIGNvbmp1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiB3aXRoIGEgVGVtcGxhdGVDb250cm9sIHRoYXQgaW1wbGVtZW50cyB0aGVcclxuICAgICAgICAgICAgICAgICAqIGludGVyZmFjZSBJU3VwcG9ydFR3b1dheUJpbmRpbmcuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX3N1cHBvcnRzVHdvV2F5QmluZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgRmlsZSBBUEkgaXMgc3VwcG9ydGVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZmlsZVN1cHBvcnRlZCA9IGFjcXVpcmUoX19Db21wYXQpLmZpbGVTdXBwb3J0ZWQ7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFVzZWQgdG8gZ3JhYiBhIGZpbGVuYW1lIGZyb20gaW5wdXRbdHlwZT1cImZpbGVcIl0uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX19maWxlTmFtZVJlZ2V4ID0gYWNxdWlyZShfX1JlZ2V4KS5maWxlTmFtZVJlZ2V4O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBVc2VkIHRvIGRlbm90ZSB0aGF0IGEgcHJvcGVydHkgY2hhbmdlIGhhcHBlbmVkIGZyb20gd2l0aGluIHRoaXMgY29udHJvbC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2lzU2VsZiA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEZXRlcm1pbmVzIHRoZSB0eXBlIG9mIEVsZW1lbnQgYmVpbmcgYm91bmQgdG9cclxuICAgICAgICAgICAgICogYW5kIHNldHMgdGhlIG5lY2Vzc2FyeSBoYW5kbGVycy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmQucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kZXRlcm1pbmVUeXBlKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJzZXMgYW5kIHdhdGNoZXMgdGhlIGV4cHJlc3Npb24gYmVpbmcgYm91bmQgdG8uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHBhcmVudCkgfHwgaXNOdWxsKHRoaXMuZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IGNhbWVsQ2FzZSh0aGlzLnR5cGUpLCBfcGFyc2VyID0gdGhpcy5fcGFyc2VyLCBleHByZXNzaW9uID0gdGhpcy5fZXhwcmVzc2lvbiA9IF9wYXJzZXIucGFyc2UodGhpcy5hdHRyaWJ1dGVzW2F0dHJdKTtcclxuICAgICAgICAgICAgICAgIHZhciBpZGVudGlmaWVycyA9IGV4cHJlc3Npb24uaWRlbnRpZmllcnM7XHJcbiAgICAgICAgICAgICAgICBpZiAoaWRlbnRpZmllcnMubGVuZ3RoICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oJ09ubHkgMSBpZGVudGlmaWVyIGFsbG93ZWQgaW4gYSAnICsgdGhpcy50eXBlICsgJyBleHByZXNzaW9uLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHRFeHByZXNzaW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgc3BsaXQgPSBpZGVudGlmaWVyc1swXS5zcGxpdCgnLicpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvcGVydHkgPSBzcGxpdC5wb3AoKTtcclxuICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uLmFsaWFzZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbGlhcyA9IGV4cHJlc3Npb24uYWxpYXNlc1swXSwgcmVzb3VyY2VPYmpfMSA9IHBhcmVudC5maW5kUmVzb3VyY2UoYWxpYXMpLCB0eXBlID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChyZXNvdXJjZU9ial8xKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gcmVzb3VyY2VPYmpfMS5yZXNvdXJjZS50eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gX19PQlNFUlZBQkxFX1JFU09VUkNFICYmIHR5cGUgIT09IF9fTElURVJBTF9SRVNPVVJDRSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZU9ial8xID0geyByZXNvdXJjZToge30gfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsaWFzID09PSBfX0NPTlRFWFRfUkVTT1VSQ0UgfHwgYWxpYXMgPT09IF9fUk9PVF9DT05URVhUX1JFU09VUkNFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHRFeHByZXNzaW9uID0gX3BhcnNlci5wYXJzZShzcGxpdC5qb2luKCcuJykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvcGVydHkgPSAndmFsdWUnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0RXhwcmVzc2lvbiA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc291cmNlT2JqXzEucmVzb3VyY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpYXNlczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiAnJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNwbGl0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0RXhwcmVzc2lvbiA9IF9wYXJzZXIucGFyc2Uoc3BsaXQuam9pbignLicpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHRFeHByZXNzaW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmFsdWF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5jb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlhc2VzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcnM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiAnJ1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3VwcG9ydHNUd29XYXlCaW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZUNvbnRyb2wub2JzZXJ2ZVByb3BlcnRpZXModGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93YXRjaEV4cHJlc3Npb24oKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwodGhpcy5fYWRkRXZlbnRUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2FkZEV2ZW50VHlwZSgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmUtb2JzZXJ2ZXMgdGhlIGV4cHJlc3Npb24gd2l0aCB0aGUgbmV3IGNvbnRleHQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kLnByb3RvdHlwZS5jb250ZXh0Q2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dhdGNoRXhwcmVzc2lvbigpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVtb3ZlcyBhbGwgb2YgdGhlIGVsZW1lbnQncyBldmVudCBsaXN0ZW5lcnMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkRXZlbnRUeXBlID0gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGJvdW5kIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMuX2V4cHJlc3Npb247XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoZXhwcmVzc2lvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ldmFsdWF0ZUV4cHJlc3Npb24oZXhwcmVzc2lvbik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEJpbmQucHJvdG90eXBlLm9ic2VydmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChsaXN0ZW5lciwgaWRlbnRpZmllciwgYXV0b2Nhc3QpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vYnNlcnZlUHJvcGVydHkobGlzdGVuZXIsIGlkZW50aWZpZXIsIGF1dG9jYXN0KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQmluZC5wcm90b3R5cGUub2JzZXJ2ZUFycmF5Q2hhbmdlID0gZnVuY3Rpb24gKGxpc3RlbmVyLCBpZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fb2JzZXJ2ZVByb3BlcnR5KGxpc3RlbmVyLCBpZGVudGlmaWVyLCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBZGRzIGEgdGV4dCBldmVudCBhcyB0aGUgZXZlbnQgbGlzdGVuZXIuXHJcbiAgICAgICAgICAgICAqIFVzZWQgZm9yIHRleHRhcmVhIGFuZCBpbnB1dFt0eXBlPVwidGV4dFwiXS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmQucHJvdG90eXBlLl9hZGRUZXh0RXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCwgX2NvbXBhdCA9IHRoaXMuX2NvbXBhdCwgY29tcG9zaW5nID0gZmFsc2UsIGlucHV0ID0gJ2lucHV0JywgdGltZW91dCwgZXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9zaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Byb3BlcnR5Q2hhbmdlZCgpO1xyXG4gICAgICAgICAgICAgICAgfSwgcG9zdHBvbmVkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aW1lb3V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBwb3N0cG9uZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50TGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKF9jb21wYXQuQU5EUk9JRCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgJ2NvbXBvc2l0aW9uc3RhcnQnLCBmdW5jdGlvbiAoKSB7IGNvbXBvc2luZyA9IHRydWU7IH0sIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgJ2NvbXBvc2l0aW9uZW5kJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb3NpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChfY29tcGF0Lmhhc0V2ZW50KGlucHV0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBpbnB1dCwgZXZlbnRMaXN0ZW5lciwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsICdrZXlkb3duJywgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBldi5rZXlDb2RlIHx8IGV2LndoaWNoLCBjb2RlcyA9IGNvbnRyb2xzLktleUNvZGVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBjb2Rlcy5sd2sgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9PT0gY29kZXMucndrIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoa2V5ID49IGNvZGVzLnNoaWZ0ICYmIGtleSA8PSBjb2Rlcy5lc2NhcGUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoa2V5ID4gY29kZXMuc3BhY2UgJiYga2V5IDw9IGNvZGVzLmRvd24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdHBvbmVkRXZlbnRMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgJ2N1dCcsIHBvc3Rwb25lZEV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgJ3Bhc3RlJywgcG9zdHBvbmVkRXZlbnRMaXN0ZW5lciwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsICdjaGFuZ2UnLCBldmVudExpc3RlbmVyLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBZGRzIGEgY2hhbmdlIGV2ZW50IGFzIHRoZSBldmVudCBsaXN0ZW5lci5cclxuICAgICAgICAgICAgICogVXNlZCBmb3Igc2VsZWN0LCBpbnB1dFt0eXBlPVwicmFkaW9cIl0sIGFuZCBpbnB1dFt0eXBlPVwicmFuZ2VcIl0uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kLnByb3RvdHlwZS5fYWRkQ2hhbmdlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmVsZW1lbnQsICdjaGFuZ2UnLCB0aGlzLl9wcm9wZXJ0eUNoYW5nZWQsIGZhbHNlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFkZHMgYSAkdGFwIGV2ZW50IGFzIHRoZSBldmVudCBsaXN0ZW5lci5cclxuICAgICAgICAgICAgICogVXNlZCBmb3IgaW5wdXRbdHlwZT1cImJ1dHRvblwiXSBhbmQgYnV0dG9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZC5wcm90b3R5cGUuX2FkZEJ1dHRvbkV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5lbGVtZW50LCBfX3RhcCwgdGhpcy5fcHJvcGVydHlDaGFuZ2VkLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBZGRzIGEgY2hhbmdlIGV2ZW50IGFzIHRoZSBldmVudCBsaXN0ZW5lci5cclxuICAgICAgICAgICAgICogVXNlZCBmb3Igc2VsZWN0LCBpbnB1dFt0eXBlPVwicmFkaW9cIl0sIGFuZCBpbnB1dFt0eXBlPVwicmFuZ2VcIl0uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kLnByb3RvdHlwZS5fYWRkUmFuZ2VFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsIGlucHV0ID0gJ2lucHV0JztcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jb21wYXQuaGFzRXZlbnQoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGlucHV0LCB0aGlzLl9wcm9wZXJ0eUNoYW5nZWQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCAnY2hhbmdlJywgdGhpcy5fcHJvcGVydHlDaGFuZ2VkLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXR0ZXIgZm9yIGlucHV0W3R5cGU9XCJjaGVja2JveFwiXSBhbmQgaW5wdXRbdHlwZT1cInJhZGlvXCJdLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZC5wcm90b3R5cGUuX2dldENoZWNrZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmNoZWNrZWQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXR0ZXIgZm9yIGlucHV0W3R5cGU9XCJ0ZXh0XCJdLCBpbnB1dFt0eXBlPVwicmFuZ2VcIl0sXHJcbiAgICAgICAgICAgICAqIHRleHRhcmVhLCBhbmQgc2VsZWN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZC5wcm90b3R5cGUuX2dldFZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC52YWx1ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHRlciBmb3IgYnV0dG9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZC5wcm90b3R5cGUuX2dldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC50ZXh0Q29udGVudDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHRlciBmb3IgaW5wdXRbdHlwZT1cImZpbGVcIl0uIENyZWF0ZXMgYSBwYXJ0aWFsIElGaWxlXHJcbiAgICAgICAgICAgICAqIGVsZW1lbnQgaWYgZmlsZSBpcyBub3Qgc3VwcG9ydGVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZC5wcm90b3R5cGUuX2dldEZpbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCwgdmFsdWUgPSBlbGVtZW50LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19maWxlU3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuZmlsZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5maWxlc1swXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHZhbHVlLnJlcGxhY2UodGhpcy5fX2ZpbGVOYW1lUmVnZXgsICcnKSxcclxuICAgICAgICAgICAgICAgICAgICBwYXRoOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICBsYXN0TW9kaWZpZWREYXRlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICBtc0RldGFjaFN0cmVhbTogbm9vcCxcclxuICAgICAgICAgICAgICAgICAgICBtc0Nsb3NlOiBub29wLFxyXG4gICAgICAgICAgICAgICAgICAgIHNsaWNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiB7fTsgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHRlciBmb3IgaW5wdXRbdHlwZT1cImZpbGVcIl0tbXVsdGlwbGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kLnByb3RvdHlwZS5fZ2V0RmlsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fZmlsZVN1cHBvcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlbGVtZW50LmZpbGVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY2FzZSBzaG91bGQgbmV2ZXIgYmUgaGl0IHNpbmNlIGllOSBkb2VzIG5vdCBzdXBwb3J0IG11bHRpLWZpbGUgdXBsb2FkcywgXHJcbiAgICAgICAgICAgICAgICAvLyBidXQga2VwdCBpbiBoZXJlIGZvciBub3cgZm9yIGNvbnNpc3RlbmN5J3Mgc2FrZSBcclxuICAgICAgICAgICAgICAgIHZhciBmaWxlbGlzdCA9IGVsZW1lbnQudmFsdWUuc3BsaXQoLyx8Oy9nKSwgbGVuZ3RoID0gZmlsZWxpc3QubGVuZ3RoLCBmaWxlcyA9IFtdLCBmaWxlVmFsdWUsIGJsb2JTbGljZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHt9OyB9O1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVWYWx1ZSA9IGZpbGVsaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmaWxlVmFsdWUucmVwbGFjZSh0aGlzLl9fZmlsZU5hbWVSZWdleCwgJycpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBmaWxlVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNb2RpZmllZERhdGU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zRGV0YWNoU3RyZWFtOiBub29wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtc0Nsb3NlOiBub29wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbGljZTogYmxvYlNsaWNlXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZXM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXR0ZXIgZm9yIHNlbGVjdC1tdWx0aXBsZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmQucHJvdG90eXBlLl9nZXRTZWxlY3RlZFZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5lbGVtZW50Lm9wdGlvbnMsIGxlbmd0aCA9IG9wdGlvbnMubGVuZ3RoLCBvcHRpb24sIHNlbGVjdGVkVmFsdWVzID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uID0gb3B0aW9uc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uLnNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzLnB1c2gob3B0aW9uLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWRWYWx1ZXM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXR0ZXIgZm9yIHRleHRhcmVhLCBpbnB1dFt0eXBlPVwidGV4dFwiXSxcclxuICAgICAgICAgICAgICogYW5kIGlucHV0W3R5cGU9XCJidXR0b25cIl0sIGFuZCBzZWxlY3QuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBuZXdWYWx1ZSBUaGUgbmV3IHZhbHVlIHRvIHNldFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2xkVmFsdWUgVGhlIHByZXZpb3VzbHkgYm91bmQgdmFsdWVcclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmaXJzdFRpbWU/IFRoZSBjb250ZXh0IGlzIGJlaW5nIGV2YWx1YXRlZCBmb3IgdGhlIGZpcnN0IHRpbWUgYW5kXHJcbiAgICAgICAgICAgICAqIHNob3VsZCB0aHVzIGNoYW5nZSB0aGUgcHJvcGVydHkgaWYgbnVsbFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZC5wcm90b3R5cGUuX3NldFRleHQgPSBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlLCBmaXJzdFRpbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9faXNTZWxmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdFRpbWUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbCh0aGlzLmVsZW1lbnQudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRWYWx1ZShuZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvcGVydHlDaGFuZ2VkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRWYWx1ZShuZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXR0ZXIgZm9yIGlucHV0W3R5cGU9XCJyYW5nZVwiXS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IG5ld1ZhbHVlIFRoZSBuZXcgdmFsdWUgdG8gc2V0XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBvbGRWYWx1ZSBUaGUgcHJldmlvdXNseSBib3VuZCB2YWx1ZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpcnN0VGltZT8gVGhlIGNvbnRleHQgaXMgYmVpbmcgZXZhbHVhdGVkIGZvciB0aGUgZmlyc3QgdGltZSBhbmRcclxuICAgICAgICAgICAgICogc2hvdWxkIHRodXMgY2hhbmdlIHRoZSBwcm9wZXJ0eSBpZiBudWxsXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kLnByb3RvdHlwZS5fc2V0UmFuZ2UgPSBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlLCBmaXJzdFRpbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9faXNTZWxmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZSA9PT0gJycgPyAnMCcgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdFRpbWUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkodGhpcy5lbGVtZW50LnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0VmFsdWUobmV3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BlcnR5Q2hhbmdlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0VmFsdWUobmV3VmFsdWUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0dGVyIGZvciBpbnB1dFt0eXBlPVwiaGlkZGVuXCJdLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gbmV3VmFsdWUgVGhlIG5ldyB2YWx1ZSB0byBzZXRcclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IG9sZFZhbHVlIFRoZSBwcmV2aW91c2x5IGJvdW5kIHZhbHVlXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlyc3RUaW1lPyBUaGUgY29udGV4dCBpcyBiZWluZyBldmFsdWF0ZWQgZm9yIHRoZSBmaXJzdCB0aW1lIGFuZFxyXG4gICAgICAgICAgICAgKiBzaG91bGQgdGh1cyBjaGFuZ2UgdGhlIHByb3BlcnR5IGlmIG51bGxcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmQucHJvdG90eXBlLl9zZXRIaWRkZW4gPSBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlLCBmaXJzdFRpbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9faXNTZWxmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RUaW1lID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KHRoaXMuZWxlbWVudC52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFZhbHVlKG5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eUNoYW5nZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFZhbHVlKG5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIHZhbHVlIG9uIGFuIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBuZXdWYWx1ZSBUaGUgbmV3IHZhbHVlIHRvIHNldFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZC5wcm90b3R5cGUuX3NldFZhbHVlID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcclxuICAgICAgICAgICAgICAgIGlmICghaXNTdHJpbmcobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKG5ld1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eVR5cGUgPSAnbnVtYmVyJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0Jvb2xlYW4obmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BlcnR5VHlwZSA9ICdib29sZWFuJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnZhbHVlID09PSBuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsZW1lbnQudmFsdWUgPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHRlciBmb3IgaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBuZXdWYWx1ZSBUaGUgbmV3IHZhbHVlIHRvIHNldFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2xkVmFsdWUgVGhlIHByZXZpb3VzbHkgYm91bmQgdmFsdWVcclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmaXJzdFRpbWU/IFRoZSBjb250ZXh0IGlzIGJlaW5nIGV2YWx1YXRlZCBmb3IgdGhlIGZpcnN0IHRpbWUgYW5kXHJcbiAgICAgICAgICAgICAqIHNob3VsZCB0aHVzIGNoYW5nZSB0aGUgcHJvcGVydHkgaWYgbnVsbFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZC5wcm90b3R5cGUuX3NldENoZWNrZWQgPSBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlLCBmaXJzdFRpbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9faXNTZWxmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzQm9vbGVhbihuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9ICEhbmV3VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0VGltZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuY2hlY2tlZCA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eUNoYW5nZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5jaGVja2VkID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXR0ZXIgZm9yIGlucHV0W3R5cGU9XCJyYWRpb1wiXVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gbmV3VmFsdWUgVGhlIG5ldyB2YWx1ZSB0byBzZXRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmQucHJvdG90eXBlLl9zZXRSYWRpbyA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2lzU2VsZikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzTnVsbChuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5jaGVja2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BlcnR5Q2hhbmdlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNTdHJpbmcobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKG5ld1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eVR5cGUgPSAnbnVtYmVyJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0Jvb2xlYW4obmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BlcnR5VHlwZSA9ICdib29sZWFuJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2hlY2tlZCA9IChlbGVtZW50LnZhbHVlID09PSBuZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXR0ZXIgZm9yIHNlbGVjdFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gbmV3VmFsdWUgVGhlIG5ldyB2YWx1ZSB0byBzZXRcclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IG9sZFZhbHVlIFRoZSBwcmV2aW91c2x5IGJvdW5kIHZhbHVlXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlyc3RUaW1lPyBUaGUgY29udGV4dCBpcyBiZWluZyBldmFsdWF0ZWQgZm9yIHRoZSBmaXJzdCB0aW1lIGFuZFxyXG4gICAgICAgICAgICAgKiBzaG91bGQgdGh1cyBjaGFuZ2UgdGhlIHByb3BlcnR5IGlmIG51bGxcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmQucHJvdG90eXBlLl9zZXRTZWxlY3RlZEluZGV4ID0gZnVuY3Rpb24gKG5ld1ZhbHVlLCBvbGRWYWx1ZSwgZmlyc3RUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2lzU2VsZikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LCB2YWx1ZSA9IGVsZW1lbnQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKG5ld1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdFRpbWUgPT09IHRydWUgfHwgIXRoaXMuX2RvY3VtZW50LmJvZHkuY29udGFpbnMoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvcGVydHlDaGFuZ2VkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zZWxlY3RlZEluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzU3RyaW5nKG5ld1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bWJlcihuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvcGVydHlUeXBlID0gJ251bWJlcic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gbmV3VmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNCb29sZWFuKG5ld1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eVR5cGUgPSAnYm9vbGVhbic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gbmV3VmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5pbmZvKCdUcnlpbmcgdG8gYmluZCBhbiBpbnZhbGlkIHZhbHVlIHRvIGEgPHNlbGVjdD4gZWxlbWVudCB1c2luZyBhICcgKyB0aGlzLnR5cGUgKyAnLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5fZG9jdW1lbnQuYm9keS5jb250YWlucyhlbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQudmFsdWUgPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC52YWx1ZSAhPT0gbmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eUNoYW5nZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxlbWVudC52YWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgdG8gbWFrZSBzdXJlIHRoZSB1c2VyIGNoYW5nZWQgdG8gYSB2YWxpZCB2YWx1ZSBcclxuICAgICAgICAgICAgICAgIC8vIHNlY29uZCBib29sZWFuIGFyZ3VtZW50IGlzIGFuIGllIGZpeCBmb3IgaW5jb25zaXN0ZW5jeSBcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnZhbHVlICE9PSBuZXdWYWx1ZSB8fCBlbGVtZW50LnNlbGVjdGVkSW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zZWxlY3RlZEluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXR0ZXIgZm9yIHNlbGVjdC1tdWx0aXBsZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gbmV3VmFsdWUgVGhlIG5ldyB2YWx1ZSB0byBzZXRcclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IG9sZFZhbHVlIFRoZSBwcmV2aW91c2x5IGJvdW5kIHZhbHVlXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlyc3RUaW1lPyBUaGUgY29udGV4dCBpcyBiZWluZyBldmFsdWF0ZWQgZm9yIHRoZSBmaXJzdCB0aW1lIGFuZFxyXG4gICAgICAgICAgICAgKiBzaG91bGQgdGh1cyBjaGFuZ2UgdGhlIHByb3BlcnR5IGlmIG51bGxcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmQucHJvdG90eXBlLl9zZXRTZWxlY3RlZEluZGljZXMgPSBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlLCBmaXJzdFRpbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9faXNTZWxmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmVsZW1lbnQub3B0aW9ucywgbGVuZ3RoID0gaXNOdWxsKG9wdGlvbnMpID8gMCA6IG9wdGlvbnMubGVuZ3RoLCBvcHRpb24sIG51bGxWYWx1ZSA9IGlzTnVsbChuZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobnVsbFZhbHVlIHx8ICFpc0FycmF5KG5ld1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdFRpbWUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvcGVydHlDaGFuZ2VkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHVuc2VsZWN0cyB0aGUgb3B0aW9ucyB1bmxlc3MgYSBtYXRjaCBpcyBmb3VuZCBcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobGVuZ3RoLS0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbiA9IG9wdGlvbnNbbGVuZ3RoXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFudWxsVmFsdWUgJiYgb3B0aW9uLnZhbHVlID09PSAnJyArIG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUsIG51bWJlclZhbHVlLCBpbmRleCwgaGlnaGVzdEluZGV4ID0gSW5maW5pdHk7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobGVuZ3RoLS0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uID0gb3B0aW9uc1tsZW5ndGhdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb3B0aW9uLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZS5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG51bWJlclZhbHVlID0gTnVtYmVyKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIobnVtYmVyVmFsdWUpICYmIChpbmRleCA9IG5ld1ZhbHVlLmluZGV4T2YobnVtYmVyVmFsdWUpKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgaGlnaGVzdEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eVR5cGUgPSAnbnVtYmVyJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hlc3RJbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgodmFsdWUgPT09ICd0cnVlJyAmJiAoaW5kZXggPSBuZXdWYWx1ZS5pbmRleE9mKHRydWUpKSAhPT0gLTEpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID09PSAnZmFsc2UnICYmIChpbmRleCA9IG5ld1ZhbHVlLmluZGV4T2YoZmFsc2UpKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgaGlnaGVzdEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eVR5cGUgPSAnYm9vbGVhbic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdoZXN0SW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEZXRlcm1pbmVzIHRoZSB0eXBlIG9mIEVsZW1lbnQgYmVpbmcgYm91bmQgdG9cclxuICAgICAgICAgICAgICogYW5kIHNldHMgdGhlIG5lY2Vzc2FyeSBoYW5kbGVycy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmQucHJvdG90eXBlLl9kZXRlcm1pbmVUeXBlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29ic2VydmluZ0JpbmRhYmxlUHJvcGVydHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChlbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaW5wdXQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGVsZW1lbnQudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYnV0dG9uJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N1Ym1pdCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyZXNldCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpbWFnZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXZlbnRUeXBlID0gdGhpcy5fYWRkQnV0dG9uRXZlbnRMaXN0ZW5lcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9nZXR0ZXIgPSB0aGlzLl9nZXRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFdmVudFR5cGUgPSB0aGlzLl9hZGRDaGFuZ2VFdmVudExpc3RlbmVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dldHRlciA9IHRoaXMuX2dldENoZWNrZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0dGVyID0gdGhpcy5fc2V0Q2hlY2tlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JhZGlvJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplUmFkaW8oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JhbmdlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFdmVudFR5cGUgPSB0aGlzLl9hZGRSYW5nZUV2ZW50TGlzdGVuZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2V0dGVyID0gdGhpcy5fZ2V0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0dGVyID0gdGhpcy5fc2V0UmFuZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmaWxlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXVsdGkgPSBlbGVtZW50Lm11bHRpcGxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEV2ZW50VHlwZSA9IHRoaXMuX2FkZENoYW5nZUV2ZW50TGlzdGVuZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2V0dGVyID0gbXVsdGkgPyB0aGlzLl9nZXRGaWxlcyA6IHRoaXMuX2dldEZpbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdoaWRkZW4nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dldHRlciA9IHRoaXMuX2dldFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldHRlciA9IHRoaXMuX3NldEhpZGRlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXZlbnRUeXBlID0gdGhpcy5fYWRkVGV4dEV2ZW50TGlzdGVuZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2V0dGVyID0gdGhpcy5fZ2V0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0dGVyID0gdGhpcy5fc2V0VGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICd0ZXh0YXJlYSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEV2ZW50VHlwZSA9IHRoaXMuX2FkZFRleHRFdmVudExpc3RlbmVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9nZXR0ZXIgPSB0aGlzLl9nZXRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0dGVyID0gdGhpcy5fc2V0VGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2VsZWN0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZVNlbGVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdidXR0b24nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFdmVudFR5cGUgPSB0aGlzLl9hZGRCdXR0b25FdmVudExpc3RlbmVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9nZXR0ZXIgPSB0aGlzLl9nZXRUZXh0Q29udGVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBPYnNlcnZlcyB0aGUgZXhwcmVzc2lvbiB0byBiaW5kIHRvLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZC5wcm90b3R5cGUuX3dhdGNoRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dEV4cHJlc3Npb24gPSB0aGlzLl9jb250ZXh0RXhwcmVzc2lvbiwgY29udGV4dCA9IHRoaXMuZXZhbHVhdGVFeHByZXNzaW9uKGNvbnRleHRFeHByZXNzaW9uKTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNPYmplY3QoY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGNvbnRleHQpICYmIGNvbnRleHRFeHByZXNzaW9uLmlkZW50aWZpZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IHRoaXMuX2NyZWF0ZUNvbnRleHQoY29udGV4dEV4cHJlc3Npb24uaWRlbnRpZmllcnNbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4odGhpcy50eXBlICsgJyBpcyB0cnlpbmcgdG8gaW5kZXggaW50byBhIHByaW1pdGl2ZSB0eXBlLiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHRFeHByZXNzaW9uLmV4cHJlc3Npb24gKyAnIGlzIGFscmVhZHkgZGVmaW5lZCBhbmQgbm90ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FuIG9iamVjdCB3aGVuIHRyeWluZyB0byBldmFsdWF0ZSAnICsgdGhpcy50eXBlICsgJz1cIicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXhwcmVzc2lvbi5leHByZXNzaW9uICsgJ1wiJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzRnVuY3Rpb24odGhpcy5fc2V0dGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3NldHRlciA9PT0gdGhpcy5fc2V0U2VsZWN0ZWRJbmRpY2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgPSB0aGlzLl9wcm9wZXJ0eTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGNvbnRleHRbcHJvcGVydHldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0W3Byb3BlcnR5XSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmVBcnJheShmdW5jdGlvbiAoYXJyYXlJbmZvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXR0ZXIoYXJyYXlJbmZvWzBdLm9iamVjdCwgbnVsbCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgY29udGV4dEV4cHJlc3Npb24gKyAnLicgKyBwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMuX2V4cHJlc3Npb247XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmVFeHByZXNzaW9uKGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2V0dGVyKG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9LCBleHByZXNzaW9uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldHRlcih0aGlzLmV2YWx1YXRlRXhwcmVzc2lvbihleHByZXNzaW9uKSwgdW5kZWZpbmVkLCB0cnVlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEhhbmRsZXMgY3JlYXRpbmcgY29udGV4dCB3aXRoIGFuIGlkZW50aWZpZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGlmaWVyIFRoZSBpZGVudGlmaWVyIHRvIGJhc2UgdGhlIGNyZWF0ZWQgY29udGV4dCBvZmYgb2YuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kLnByb3RvdHlwZS5fY3JlYXRlQ29udGV4dCA9IGZ1bmN0aW9uIChpZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3BsaXQgPSBpZGVudGlmaWVyLnNwbGl0KCcuJyksIHN0YXJ0ID0gc3BsaXQuc2hpZnQoKS5zbGljZSgxKSwgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT09IF9fUk9PVF9DT05URVhUX1JFU09VUkNFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllciA9IHNwbGl0LmpvaW4oJy4nKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSB0aGlzLnBhcmVudC5yb290O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnQgPT09IF9fQ09OVEVYVCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSBzcGxpdC5qb2luKCcuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fQ29udGV4dE1hbmFnZXIuY3JlYXRlQ29udGV4dChwYXJlbnQsIGlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSGFuZGxlcyBjYXN0aW5nIHRoZSBib3VuZCBwcm9wZXJ0eSBiYWNrIHRvIGl0cyBpbml0aWFsIHR5cGUgaWYgbmVjZXNzYXJ5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhc3QuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSB0eXBlPyBUaGUgb3B0aW9uYWwgdHlwZSB0byBjYXN0IHRoZSB2YWx1ZSB0by5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmQucHJvdG90eXBlLl9jYXN0UHJvcGVydHkgPSBmdW5jdGlvbiAodmFsdWUsIHR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjYXN0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0eXBlID0gdHlwZSB8fCB0aGlzLl9wcm9wZXJ0eVR5cGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGhfMTIgPSB2YWx1ZS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc3RWYWx1ZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aF8xMjsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXN0VmFsdWUucHVzaCh0aGlzLl9jYXN0UHJvcGVydHkodmFsdWVbaV0sIHR5cGUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0RhdGUodmFsdWUpIHx8IGlzRmlsZSh2YWx1ZSkgfHwgaXNQcm9taXNlKHZhbHVlKSB8fCBpc1dpbmRvdyh2YWx1ZSkgfHwgaXNOb2RlKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXN0VmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpLCBrZXkgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc3RWYWx1ZSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoa2V5cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXlzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzdFZhbHVlW2tleV0gPSB2YWx1ZVtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzdFZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHZhbHVlLnRvU3RyaW5nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc3RWYWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXN0VmFsdWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXN0VmFsdWUgPSBpc0VtcHR5KHZhbHVlKSA/IHVuZGVmaW5lZCA6IE51bWJlcih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndHJ1ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc3RWYWx1ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZhbHNlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcwJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdudWxsJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXN0VmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzdFZhbHVlID0gISF2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc3RWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhc3RWYWx1ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIGNvbnRleHQgcHJvcGVydHkgYmVpbmcgYm91bmQgdG8gd2hlbiB0aGVcclxuICAgICAgICAgICAgICogZWxlbWVudCdzIHByb3BlcnR5IGlzIGNoYW5nZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kLnByb3RvdHlwZS5fcHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbCh0aGlzLl9jb250ZXh0RXhwcmVzc2lvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuZXZhbHVhdGVFeHByZXNzaW9uKHRoaXMuX2NvbnRleHRFeHByZXNzaW9uKTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNPYmplY3QoY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLl9wcm9wZXJ0eSwgbmV3VmFsdWUgPSB0aGlzLl9jYXN0UHJvcGVydHkodGhpcy5fZ2V0dGVyKCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHRbcHJvcGVydHldID09PSBuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHNldCBmbGFnIHRvIGxldCBzZXR0ZXIgZnVuY3Rpb25zIGtub3cgd2UgY2hhbmdlZCB0aGUgcHJvcGVydHkgXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9faXNTZWxmID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHRbcHJvcGVydHldID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9faXNTZWxmID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBOb3JtYWxpemVzIGlucHV0W3R5cGU9XCJyYWRpb1wiXSBmb3IgY3Jvc3MtYnJvd3NlciBjb21wYXRpYmlsaXR5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZC5wcm90b3R5cGUuX2luaXRpYWxpemVSYWRpbyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkRXZlbnRUeXBlID0gdGhpcy5fYWRkQ2hhbmdlRXZlbnRMaXN0ZW5lcjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dldHRlciA9IHRoaXMuX2dldFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0dGVyID0gdGhpcy5fc2V0UmFkaW87XHJcbiAgICAgICAgICAgICAgICBpZiAoIWVsZW1lbnQuaGFzQXR0cmlidXRlKCduYW1lJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IGNhbWVsQ2FzZSh0aGlzLnR5cGUpLCBleHByZXNzaW9uID0gdGhpcy5hdHRyaWJ1dGVzW2F0dHJdO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCduYW1lJywgZXhwcmVzc2lvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndmFsdWUnLCAnJyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBOb3JtYWxpemVzIEhUTUxTZWxlY3RFbGVtZW50cyBmb3IgY3Jvc3MtYnJvd3NlciBjb21wYXRpYmlsaXR5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZC5wcm90b3R5cGUuX2luaXRpYWxpemVTZWxlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCwgbXVsdGlwbGUgPSBlbGVtZW50Lm11bHRpcGxlLCBvcHRpb25zID0gZWxlbWVudC5vcHRpb25zLCBsZW5ndGggPSBvcHRpb25zLmxlbmd0aCwgb3B0aW9uO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkRXZlbnRUeXBlID0gdGhpcy5fYWRkQ2hhbmdlRXZlbnRMaXN0ZW5lcjtcclxuICAgICAgICAgICAgICAgIGlmIChtdWx0aXBsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dldHRlciA9IHRoaXMuX2dldFNlbGVjdGVkVmFsdWVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldHRlciA9IHRoaXMuX3NldFNlbGVjdGVkSW5kaWNlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dldHRlciA9IHRoaXMuX2dldFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldHRlciA9IHRoaXMuX3NldFNlbGVjdGVkSW5kZXg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uID0gb3B0aW9uc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbi5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uLnNldEF0dHJpYnV0ZSgndmFsdWUnLCBvcHRpb24udGV4dENvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENoZWNrcyBpZiB0aGUgYXNzb2NpYXRlZCBUZW1wbGF0ZUNvbnRyb2wgaXMgaW1wbGVtZW50aW5nXHJcbiAgICAgICAgICAgICAqIElTdXBwb3J0VHdvV2F5QmluZGluZyBhbmQgaW5pdGlhbGl6ZXMgYWxsIGxpc3RlbmVycyBhY2NvcmRpbmdseS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmQucHJvdG90eXBlLl9vYnNlcnZpbmdCaW5kYWJsZVByb3BlcnR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZUNvbnRyb2wgPSB0aGlzLnRlbXBsYXRlQ29udHJvbDtcclxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCh0ZW1wbGF0ZUNvbnRyb2wpICYmIGlzRnVuY3Rpb24odGVtcGxhdGVDb250cm9sLm9uSW5wdXQpICYmIGlzRnVuY3Rpb24odGVtcGxhdGVDb250cm9sLm9ic2VydmVQcm9wZXJ0aWVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlQ29udHJvbC5vbklucHV0KGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZ2V0dGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3VmFsdWU7IH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9wcm9wZXJ0eUNoYW5nZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuX3N1cHBvcnRzVHdvV2F5QmluZGluZyA9IHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBmdW5jdGlvbiB0aGF0IGFsbG93cyBhIElTdXBwb3J0VHdvV2F5QmluZGluZyB0byBvYnNlcnZlIGVpdGhlciB0aGVcclxuICAgICAgICAgICAgICogYm91bmQgcHJvcGVydHkgc3BlY2lmaWVkIGJ5IHRoZSBpZGVudGlmaWVyIChhcyB3ZWxsIGFzIHBvdGVudGlhbCBjaGlsZCBwcm9wZXJ0aWVzIGlmIGJlaW5nIGJvdW5kIHRvIGFuIG9iamVjdCkgb3JcclxuICAgICAgICAgICAgICogQXJyYXkgbXV0YXRpb25zLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBpZGVudGlmaWVyPyBUaGUgaW5kZXggb2ZmIG9mIHRoZSBib3VuZCBvYmplY3QgdG8gbGlzdGVuIHRvIGZvciBjaGFuZ2VzIGlmIHRoZSBib3VuZCBvYmplY3QgaXMgYW4gQXJyYXkuXHJcbiAgICAgICAgICAgICAqIElmIHVuZGVmaW5lZCBvciBlbXB0eSB0aGUgbGlzdGVuZXIgd2lsbCBsaXN0ZW4gZm9yIGNoYW5nZXMgdG8gdGhlIGJvdW5kIEFycmF5IGl0c2VsZi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBhdXRvY2FzdD8gV2lsbCBjYXN0IGEgcHJpbWl0aXZlIHZhbHVlIHRvIHdoYXRldmVyIGl0IHdhcyBzZXQgdG8gaW4gY29kZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBhcnJheU11dGF0aW9ucz8gV2hldGhlciBvciBub3QgdGhpcyBpcyBmb3IgQXJyYXkgbXV0YXRpb24gY2hhbmdlcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmQucHJvdG90eXBlLl9vYnNlcnZlUHJvcGVydHkgPSBmdW5jdGlvbiAobGlzdGVuZXIsIGlkZW50aWZpZXIsIGF1dG9jYXN0LCBhcnJheU11dGF0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciBwYXJzZWRJZGVudGlmaWVyO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkoaWRlbnRpZmllcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRJZGVudGlmaWVyID0gdGhpcy5fZXhwcmVzc2lvbi5leHByZXNzaW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNOdW1iZXIoaWRlbnRpZmllcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRJZGVudGlmaWVyID0gdGhpcy5fZXhwcmVzc2lvbi5leHByZXNzaW9uICsgJy4nICsgaWRlbnRpZmllcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfcGFyc2VyID0gdGhpcy5fcGFyc2VyLCBpZGVudGlmaWVyRXhwcmVzc2lvbiA9IF9wYXJzZXIucGFyc2UoaWRlbnRpZmllciksIGlkZW50aWZpZXJzID0gaWRlbnRpZmllckV4cHJlc3Npb24uaWRlbnRpZmllcnM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkZW50aWZpZXJzLmxlbmd0aCAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cud2FybignT25seSAxIGlkZW50aWZpZXIgcGF0aCBhbGxvd2VkIHdoZW4gb2JzZXJ2aW5nIGNoYW5nZXMgdG8gYSBib3VuZCBwcm9wZXJ0eVxcJ3MgY2hpbGQgd2l0aCBhIGNvbnRyb2wgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaW1wbGVtZW50aW5nIG9ic2VydmFibGUuSVN1cHBvcnRUd29XYXlCaW5kaW5nIGFuZCB3b3JraW5nIHdpdGggJyArIHRoaXMudHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBfcGFyc2VyLnBhcnNlKHRoaXMuX2V4cHJlc3Npb24uZXhwcmVzc2lvbiArICcuJyArIGlkZW50aWZpZXJzWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRJZGVudGlmaWVyID0gZXhwcmVzc2lvbi5pZGVudGlmaWVyc1swXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3BsaXQgPSBwYXJzZWRJZGVudGlmaWVyLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3BsaXQucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRleHRFeHByZXNzaW9uID0gc3BsaXQuam9pbignLicpLCBjb250ZXh0ID0gdGhpcy5ldmFsdWF0ZUV4cHJlc3Npb24oY29udGV4dEV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNPYmplY3QoY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChjb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IHRoaXMuX0NvbnRleHRNYW5hZ2VyLmNyZWF0ZUNvbnRleHQodGhpcy5wYXJlbnQsIGNvbnRleHRFeHByZXNzaW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKCdBIGNvbnRyb2wgaW1wbGVtZW50aW5nIG9ic2VydmFibGUuSVN1cHBvcnRUd29XYXlCaW5kaW5nIGlzIHRyeWluZyB0byBpbmRleCBpbnRvIGEgcHJpbWl0aXZlIHR5cGUgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3doZW4gdHJ5aW5nIHRvIGV2YWx1YXRlICcgKyB0aGlzLnR5cGUgKyAnPVwiJyArIHRoaXMuX2V4cHJlc3Npb24uZXhwcmVzc2lvbiArICdcIicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5iaW5kKHRoaXMudGVtcGxhdGVDb250cm9sKTtcclxuICAgICAgICAgICAgICAgIGF1dG9jYXN0ID0gYXV0b2Nhc3QgPT09IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlTGlzdGVuZXI7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJyYXlNdXRhdGlvbnMgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lciA9IHRoaXMub2JzZXJ2ZUFycmF5KGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyKGNoYW5nZXMsIGlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHBhcnNlZElkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIgPSB0aGlzLm9ic2VydmUoZnVuY3Rpb24gKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX19pc1NlbGYgfHwgbmV3VmFsdWUgPT09IG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXV0b2Nhc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9wcm9wZXJ0eVR5cGUgPSBfdGhpcy5fZ2V0UHJvcGVydHlUeXBlKG5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcihuZXdWYWx1ZSwgb2xkVmFsdWUsIGlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHBhcnNlZElkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZXZhbHVhdGVFeHByZXNzaW9uKHBhcnNlZElkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdXRvY2FzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eVR5cGUgPSB0aGlzLl9nZXRQcm9wZXJ0eVR5cGUodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcih2YWx1ZSwgdW5kZWZpbmVkLCBpZGVudGlmaWVyLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVMaXN0ZW5lcjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIHByb3BlcnR5IHR5cGUgb2YgdGhlIHBhc3NlZCBpbiBhcmd1bWVudC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSB2YWx1ZSB0byBncmFiIHRoZSBwcm9wZXJ0eSB0eXBlIGZyb20uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kLnByb3RvdHlwZS5fZ2V0UHJvcGVydHlUeXBlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNOdW1iZXIodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdudW1iZXInO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNCb29sZWFuKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnYm9vbGVhbic7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEJpbmQuX2luamVjdCA9IHtcclxuICAgICAgICAgICAgICAgIF9wYXJzZXI6IF9fUGFyc2VyLFxyXG4gICAgICAgICAgICAgICAgX0NvbnRleHRNYW5hZ2VyOiBfX0NvbnRleHRNYW5hZ2VyU3RhdGljLFxyXG4gICAgICAgICAgICAgICAgX2NvbXBhdDogX19Db21wYXQsXHJcbiAgICAgICAgICAgICAgICBfZG9jdW1lbnQ6IF9fRG9jdW1lbnRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIEJpbmQ7XHJcbiAgICAgICAgfShBdHRyaWJ1dGVDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuQmluZCA9IEJpbmQ7XHJcbiAgICAgICAgcmVnaXN0ZXIuY29udHJvbChfX0JpbmQsIEJpbmQpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuIEF0dHJpYnV0ZUNvbnRyb2wgdGhhdCBkZWFscyB3aXRoIG9ic2VydmluZyBjaGFuZ2VzIGZvciBhIHNwZWNpZmllZCBwcm9wZXJ0eS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgT2JzZXJ2YWJsZUF0dHJpYnV0ZUNvbnRyb2wgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoT2JzZXJ2YWJsZUF0dHJpYnV0ZUNvbnRyb2wsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIE9ic2VydmFibGVBdHRyaWJ1dGVDb250cm9sKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBwcm9wZXJ0eSB0byBzZXQgb24gdGhlIGFzc29jaWF0ZWQgdGVtcGxhdGUgY29udHJvbC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGlzIGNvbnRyb2wgbmVlZHMgdG8gbG9hZCBiZWZvcmUgaXRzIHRlbXBsYXRlQ29udHJvbFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByaW9yaXR5ID0gMjAwO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgc2V0IG9mIGZ1bmN0aW9ucyBhZGRlZCBieSB0aGUgVGVtcGxhdGUgQ29udHJvbCB0aGF0IGxpc3RlbnNcclxuICAgICAgICAgICAgICAgICAqIGZvciBwcm9wZXJ0eSBjaGFuZ2VzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIF9hZGRMaXN0ZW5lciBmdW5jdGlvbiBib3VuZCB0byB0aGlzIGNvbnRyb2wuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX2JvdW5kQWRkTGlzdGVuZXIgPSB0aGlzLl9hZGRMaXN0ZW5lci5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBvblxyXG4gICAgICAgICAgICAgKiB0aGUgVGVtcGxhdGUgQ29udHJvbC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE9ic2VydmFibGVBdHRyaWJ1dGVDb250cm9sLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGUgPSBjYW1lbENhc2UodGhpcy50eXBlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFByb3BlcnR5KHRoaXMuX2dldFZhbHVlKCkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogT2JzZXJ2ZXMgdGhlIHByb3BlcnR5IGFuZCByZXNldHMgdGhlIHZhbHVlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgT2JzZXJ2YWJsZUF0dHJpYnV0ZUNvbnRyb2wucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29ic2VydmVQcm9wZXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0UHJvcGVydHkodGhpcy5fZ2V0VmFsdWUoKSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTdG9wcyBsaXN0ZW5pbmcgZm9yIGNoYW5nZXMgdG8gdGhlIGV2YWx1YXRlZFxyXG4gICAgICAgICAgICAgKiBleHByZXNzaW9uIGFuZCByZW1vdmVzIHJlZmVyZW5jZXMgdG8gdGhlIGxpc3RlbmVyc1xyXG4gICAgICAgICAgICAgKiBkZWZpbmVkIGJ5IHRoZSBUZW1wbGF0ZSBDb250cm9sLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgT2JzZXJ2YWJsZUF0dHJpYnV0ZUNvbnRyb2wucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzLl9yZW1vdmVMaXN0ZW5lcikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW107XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBvbiB0aGUgVGVtcGxhdGUgQ29udHJvbC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSBuZXcgdmFsdWUgb2YgdGhlIGV2YWx1YXRlZCBleHByZXNzaW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2xkVmFsdWU/IFRoZSBvbGQgdmFsdWUgb2YgdGhlIGV2YWx1YXRlZCBleHByZXNzaW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgT2JzZXJ2YWJsZUF0dHJpYnV0ZUNvbnRyb2wucHJvdG90eXBlLl9zZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZUNvbnRyb2wgPSB0aGlzLnRlbXBsYXRlQ29udHJvbDtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwodGVtcGxhdGVDb250cm9sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX0NvbnRleHRNYW5hZ2VyLmRlZmluZUdldHRlcih0ZW1wbGF0ZUNvbnRyb2wsIHRoaXMucHJvcGVydHksIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZTogdGhpcy5fYm91bmRBZGRMaXN0ZW5lclxyXG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxsTGlzdGVuZXJzKHZhbHVlLCBvbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDYWxscyB0aGUgbGlzdGVuZXJzIGRlZmluZWQgYnkgdGhlIFRlbXBsYXRlIENvbnRyb2wuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgbmV3IHZhbHVlIG9mIHRoZSBldmFsdWF0ZWQgZXhwcmVzc2lvbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgb2YgdGhlIGV2YWx1YXRlZCBleHByZXNzaW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgT2JzZXJ2YWJsZUF0dHJpYnV0ZUNvbnRyb2wucHJvdG90eXBlLl9jYWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycywgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbaV0obmV3VmFsdWUsIG9sZFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFkZHMgYSBsaXN0ZW5lciBhcyBkZWZpbmVkIGJ5IHRoZSBUZW1wbGF0ZSBDb250cm9sLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuSVByb3BlcnR5Q2hhbmdlZExpc3RlbmVyfSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgYWRkZWQgYnkgdGhlIFRlbXBsYXRlIENvbnRyb2wuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBPYnNlcnZhYmxlQXR0cmlidXRlQ29udHJvbC5wcm90b3R5cGUuX2FkZExpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5iaW5kKHRoaXMudGVtcGxhdGVDb250cm9sKTtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFdmFsdWF0ZXMgdGhlIGF0dHJpYnV0ZSdzIHZhbHVlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgT2JzZXJ2YWJsZUF0dHJpYnV0ZUNvbnRyb2wucHJvdG90eXBlLl9nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwodGhpcy50ZW1wbGF0ZUNvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZhbHVhdGVFeHByZXNzaW9uKHRoaXMuYXR0cmlidXRlc1t0aGlzLmF0dHJpYnV0ZV0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogT2JzZXJ2ZXMgdGhlIGF0dHJpYnV0ZSdzIHZhbHVlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgT2JzZXJ2YWJsZUF0dHJpYnV0ZUNvbnRyb2wucHJvdG90eXBlLl9vYnNlcnZlUHJvcGVydHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHRoaXMudGVtcGxhdGVDb250cm9sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVyID0gdGhpcy5vYnNlcnZlRXhwcmVzc2lvbih0aGlzLl9zZXRQcm9wZXJ0eSwgdGhpcy5hdHRyaWJ1dGVzW3RoaXMuYXR0cmlidXRlXSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIE9ic2VydmFibGVBdHRyaWJ1dGVDb250cm9sLl9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgICAgICBfQ29udGV4dE1hbmFnZXI6IF9fQ29udGV4dE1hbmFnZXJTdGF0aWNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIE9ic2VydmFibGVBdHRyaWJ1dGVDb250cm9sO1xyXG4gICAgICAgIH0oQXR0cmlidXRlQ29udHJvbCkpO1xyXG4gICAgICAgIGNvbnRyb2xzLk9ic2VydmFibGVBdHRyaWJ1dGVDb250cm9sID0gT2JzZXJ2YWJsZUF0dHJpYnV0ZUNvbnRyb2w7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gT2JzZXJ2YWJsZUF0dHJpYnV0ZUNvbnRyb2wgdGhhdCBzZXRzICdvcHRpb25zJyBhcyB0aGVcclxuICAgICAgICAgKiBhc3NvY2lhdGVkIHByb3BlcnR5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBPcHRpb25zID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKE9wdGlvbnMsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIE9wdGlvbnMoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIHByb3BlcnR5IHRvIHNldCBvbiB0aGUgYXNzb2NpYXRlZCB0ZW1wbGF0ZSBjb250cm9sLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnR5ID0gJ29wdGlvbnMnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBPcHRpb25zO1xyXG4gICAgICAgIH0oT2JzZXJ2YWJsZUF0dHJpYnV0ZUNvbnRyb2wpKTtcclxuICAgICAgICBjb250cm9scy5PcHRpb25zID0gT3B0aW9ucztcclxuICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fT3B0aW9ucywgT3B0aW9ucyk7XHJcbiAgICB9KShjb250cm9scyA9IHBsYXRfMS5jb250cm9scyB8fCAocGxhdF8xLmNvbnRyb2xzID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogQ2xhc3MgZm9yIGV2ZXJ5IGFwcC4gVGhpcyBjbGFzcyBjb250YWlucyBob29rcyBmb3IgQXBwbGljYXRpb24gTGlmZWN5Y2xlIEV2ZW50c1xyXG4gICAgICogYXMgd2VsbCBhcyBlcnJvciBoYW5kbGluZy5cclxuICAgICAqL1xyXG4gICAgdmFyIEFwcCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xhc3MgZm9yIGV2ZXJ5IGFwcC4gVGhpcyBjbGFzcyBjb250YWlucyBob29rcyBmb3IgQXBwbGljYXRpb24gTGlmZWN5Y2xlIE1hbmFnZW1lbnQgKEFMTSlcclxuICAgICAgICAgKiBhcyB3ZWxsIGFzIGVycm9yIGhhbmRsaW5nIGFuZCBuYXZpZ2F0aW9uIGV2ZW50cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBBcHAoKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIHVuaXF1ZSBpZCwgY3JlYXRlZCBkdXJpbmcgaW5zdGFudGlhdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMudWlkID0gdW5pcXVlSWQoX19QbGF0KTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgTG9nIGluamVjdGFibGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9sb2cgPSBBcHAuX2xvZztcclxuICAgICAgICAgICAgdmFyIG5hdmlnYXRvciA9IHRoaXMubmF2aWdhdG9yID0gYWNxdWlyZShfX05hdmlnYXRvckluc3RhbmNlKTtcclxuICAgICAgICAgICAgbmF2aWdhdG9yLmluaXRpYWxpemUoYWNxdWlyZShfX1JvdXRlclN0YXRpYykuY3VycmVudFJvdXRlcigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBzdGF0aWMgbWV0aG9kIGZvciBpbml0aWF0aW5nIHRoZSBhcHAgc3RhcnR1cC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBcHAuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghQXBwLl9jb21wYXQuaXNDb21wYXRpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQXBwLl9sb2cuZXJyb3IobmV3IEVycm9yKCdQbGF0eXB1c1RTIG9ubHkgc3VwcG9ydHMgbW9kZXJuIGJyb3dzZXJzIHdoZXJlICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdPYmplY3QuZGVmaW5lUHJvcGVydHkgaXMgZGVmaW5lZCcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBBcHAuX19hZGRQbGF0Q3NzKCk7XHJcbiAgICAgICAgICAgIHZhciBfRXZlbnRNYW5hZ2VyID0gQXBwLl9FdmVudE1hbmFnZXI7XHJcbiAgICAgICAgICAgIF9FdmVudE1hbmFnZXIuZGlzcG9zZShfX0FQUCk7XHJcbiAgICAgICAgICAgIF9FdmVudE1hbmFnZXIub24oX19BUFAsIF9fcmVhZHksIEFwcC5fX3JlYWR5KTtcclxuICAgICAgICAgICAgX0V2ZW50TWFuYWdlci5vbihfX0FQUCwgX19zaHV0ZG93biwgQXBwLl9fc2h1dGRvd24pO1xyXG4gICAgICAgICAgICBfRXZlbnRNYW5hZ2VyLmluaXRpYWxpemUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgc3RhdGljIG1ldGhvZCBjYWxsZWQgdXBvbiBhcHAgcmVnaXN0cmF0aW9uLiBQcmltYXJpbHkgdXNlZFxyXG4gICAgICAgICAqIHRvIGluaXRpYXRlIGEgcmVhZHkgc3RhdGUgaW4gdGhlIGNhc2UgdGhhdCBhbWQgaXMgYmVpbmcgdXNlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQuZGVwZW5kZW5jeS5JbmplY3RvcjxwbGF0LkFwcD59IGFwcEluamVjdG9yIFRoZSBpbmplY3RvciBmb3JcclxuICAgICAgICAgKiBpbmplY3RpbmcgdGhlIGFwcCBpbnN0YW5jZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBcHAucmVnaXN0ZXJBcHAgPSBmdW5jdGlvbiAoYXBwSW5qZWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKCFpc051bGwoQXBwLmFwcCkgJiYgaXNTdHJpbmcoQXBwLmFwcC51aWQpKSB7XHJcbiAgICAgICAgICAgICAgICBBcHAuX0V2ZW50TWFuYWdlci5kaXNwb3NlKEFwcC5hcHAudWlkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBBcHAuX19pbmplY3RvciA9IGFwcEluamVjdG9yO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogS2lja3Mgb2ZmIGNvbXBpbGF0aW9uIG9mIHRoZSBET00gZnJvbSB0aGUgc3BlY2lmaWVkIG5vZGUuIElmIG5vIG5vZGUgaXMgc3BlY2lmaWVkLFxyXG4gICAgICAgICAqIHRoZSBkZWZhdWx0IHN0YXJ0IG5vZGUgaXMgZG9jdW1lbnQuYm9keS5cclxuICAgICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgYXQgd2hpY2ggRE9NIGNvbXBpbGF0aW9uIGJlZ2lucy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBcHAubG9hZCA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBfTGlmZWN5Y2xlRXZlbnQgPSBBcHAuX0xpZmVjeWNsZUV2ZW50LCBfY29tcGlsZXIgPSBBcHAuX2NvbXBpbGVyLCBib2R5ID0gQXBwLl9kb2N1bWVudC5ib2R5LCBoZWFkID0gQXBwLl9kb2N1bWVudC5oZWFkO1xyXG4gICAgICAgICAgICBfTGlmZWN5Y2xlRXZlbnQuZGlzcGF0Y2goX19iZWZvcmVMb2FkLCBBcHApO1xyXG4gICAgICAgICAgICBpZiAoaXNOdWxsKG5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICBib2R5LnNldEF0dHJpYnV0ZShfX0hpZGUsICcnKTtcclxuICAgICAgICAgICAgICAgIHBvc3Rwb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfY29tcGlsZXIuY29tcGlsZShbaGVhZF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIF9jb21waWxlci5jb21waWxlKFtib2R5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keS5yZW1vdmVBdHRyaWJ1dGUoX19IaWRlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKG5vZGUuc2V0QXR0cmlidXRlKSkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoX19IaWRlLCAnJyk7XHJcbiAgICAgICAgICAgICAgICBwb3N0cG9uZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2NvbXBpbGVyLmNvbXBpbGUoW25vZGVdKTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShfX0hpZGUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcG9zdHBvbmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX2NvbXBpbGVyLmNvbXBpbGUoW25vZGVdKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIHN0YXRpYyBtZXRob2QgY2FsbGVkIHdoZW4gdGhlIGFwcGxpY2F0aW9uIGlzIHJlYWR5LiBJdCBjYWxscyB0aGUgYXBwIGluc3RhbmNlJ3NcclxuICAgICAgICAgKiByZWFkeSBmdW5jdGlvbiBhcyB3ZWxsIGFzIGNoZWNrcyBmb3IgdGhlIHByZXNlbmNlIG9mIGEgbW9kdWxlIGxvYWRlci4gSWYgb25lIGV4aXN0cyxcclxuICAgICAgICAgKiBsb2FkaW5nIHRoZSBET00gZmFsbHMgYmFjayB0byB0aGUgYXBwIGRldmVsb3Blci4gSWYgaXQgZG9lc24ndCwgdGhlIERPTSBpcyBsb2FkZWQgZnJvbVxyXG4gICAgICAgICAqIGRvY3VtZW50LmJvZHkuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LmV2ZW50cy5MaWZlY3ljbGVFdmVudH0gZXYgVGhlIExpZmVjeWNsZUV2ZW50IGZvciB0aGUgYXBwIHJlYWR5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFwcC5fX3JlYWR5ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGRlcGVuZGVuY3kuSW5qZWN0b3IuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgICAgICBBcHAuX19yZWdpc3RlckFwcEV2ZW50cyhldik7XHJcbiAgICAgICAgICAgIGlmICghZXYuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgICAgICAgICAgQXBwLmxvYWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBzdGF0aWMgbWV0aG9kIGNhbGxlZCB3aGVuIHRoZSBhcHBsaWNhdGlvbiB3YW50cyB0byBwcm9ncmFtbWF0aWNhbGx5IHNodXRkb3duLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFwcC5fX3NodXRkb3duID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYXBwID0gbmF2aWdhdG9yLmFwcCwgX0xpZmVjeWNsZUV2ZW50ID0gQXBwLl9MaWZlY3ljbGVFdmVudCwgZXY7XHJcbiAgICAgICAgICAgIGlmICghaXNOdWxsKGFwcCkgJiYgaXNGdW5jdGlvbihhcHAuZXhpdEFwcCkpIHtcclxuICAgICAgICAgICAgICAgIGV2ID0gX0xpZmVjeWNsZUV2ZW50LmRpc3BhdGNoKF9fZXhpdGluZywgQXBwKTtcclxuICAgICAgICAgICAgICAgIGlmIChldi5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXBwLmV4aXRBcHAoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBzdGF0aWMgbWV0aG9kIGNhbGxlZCB0byByZWdpc3RlciBhbGwgdGhlIExpZmVjeWNsZUV2ZW50cyBmb3IgYW4gYXBwIGluc3RhbmNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFwcC5fX3JlZ2lzdGVyQXBwRXZlbnRzID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIHZhciBhcHBJbmplY3RvciA9IEFwcC5fX2luamVjdG9yO1xyXG4gICAgICAgICAgICBpZiAoaXNOdWxsKGFwcEluamVjdG9yKSB8fCAhaXNGdW5jdGlvbihhcHBJbmplY3Rvci5pbmplY3QpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGFwcCA9IEFwcC5hcHAgPSBhcHBJbmplY3Rvci5pbmplY3QoKTtcclxuICAgICAgICAgICAgYXBwLm9uKF9fc3VzcGVuZCwgYXBwLnN1c3BlbmQpO1xyXG4gICAgICAgICAgICBhcHAub24oX19yZXN1bWUsIGFwcC5yZXN1bWUpO1xyXG4gICAgICAgICAgICBhcHAub24oX19vbmxpbmUsIGFwcC5vbmxpbmUpO1xyXG4gICAgICAgICAgICBhcHAub24oX19vZmZsaW5lLCBhcHAub2ZmbGluZSk7XHJcbiAgICAgICAgICAgIGFwcC5vbihfX2Vycm9yLCBhcHAuZXJyb3IpO1xyXG4gICAgICAgICAgICBhcHAub24oX19leGl0aW5nLCBhcHAuZXhpdGluZyk7XHJcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGFwcC5yZWFkeSkpIHtcclxuICAgICAgICAgICAgICAgIGFwcC5yZWFkeShldik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdlIG5lZWQgdG8gYWRkIFtwbGF0LWhpZGVdIGFzIGEgY3NzIHByb3BlcnR5IGlmIHBsYXR5cHVzLmNzcyBkb2Vzbid0IGV4aXN0IHNvIHdlIGNhbiB1c2UgaXQgdG8gdGVtcG9yYXJpbHlcclxuICAgICAgICAgKiBoaWRlIGVsZW1lbnRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFwcC5fX2FkZFBsYXRDc3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfZG9jdW1lbnQgPSBBcHAuX2RvY3VtZW50O1xyXG4gICAgICAgICAgICBpZiAoQXBwLl9jb21wYXQucGxhdENzcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc051bGwoX2RvY3VtZW50LnN0eWxlU2hlZXRzKSAmJiBfZG9jdW1lbnQuc3R5bGVTaGVldHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgX2RvY3VtZW50LnN0eWxlU2hlZXRzWzBdLmluc2VydFJ1bGUoJ1twbGF0LWhpZGVdIHsgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50OyB9JywgMCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcclxuICAgICAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSAnW3BsYXQtaGlkZV0geyBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7IH0nO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gdGhlIGFwcCBpcyBzdXNwZW5kZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LmV2ZW50cy5MaWZlY3ljbGVFdmVudH0gZXYgVGhlIExpZmVjeWNsZUV2ZW50IG9iamVjdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBcHAucHJvdG90eXBlLnN1c3BlbmQgPSBmdW5jdGlvbiAoZXYpIHsgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHRoZSBhcHAgcmVzdW1lcyBmcm9tIHRoZSBzdXNwZW5kZWQgc3RhdGUuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LmV2ZW50cy5MaWZlY3ljbGVFdmVudH0gZXYgVGhlIExpZmVjeWNsZUV2ZW50IG9iamVjdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBcHAucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uIChldikgeyB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gYW4gaW50ZXJuYWwgZXJyb3Igb2NjdXJlcy5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQuZXZlbnRzLkVycm9yRXZlbnQ8RXJyb3I+fSBldiBUaGUgRXJyb3JFdmVudCBvYmplY3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQXBwLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChldikgeyB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gdGhlIGFwcCBpcyByZWFkeS5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQuZXZlbnRzLkxpZmVjeWNsZUV2ZW50fSBldiBUaGUgTGlmZWN5Y2xlRXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFwcC5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbiAoZXYpIHsgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHRoZSBhcHAgaGFzIGJlZW4gcHJvZ3JhbWF0aWNhbGx5IHNodXRkb3duLiBUaGlzIGV2ZW50IGlzIGNhbmNlbGFibGUuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LmV2ZW50cy5MaWZlY3ljbGVFdmVudH0gZXYgVGhlIExpZmVjeWNsZUV2ZW50IG9iamVjdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBcHAucHJvdG90eXBlLmV4aXRpbmcgPSBmdW5jdGlvbiAoZXYpIHsgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHRoZSBhcHAgcmVnYWlucyBjb25uZWN0aXZpdHkgYW5kIGlzIG5vdyBpbiBhbiBvbmxpbmUgc3RhdGUuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LmV2ZW50cy5MaWZlY3ljbGVFdmVudH0gZXYgVGhlIExpZmVjeWNsZUV2ZW50IG9iamVjdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBcHAucHJvdG90eXBlLm9ubGluZSA9IGZ1bmN0aW9uIChldikgeyB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gdGhlIGFwcCBsb3NlcyBjb25uZWN0aXZpdHkgYW5kIGlzIG5vdyBpbiBhbiBvZmZsaW5lIHN0YXRlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC5ldmVudHMuTGlmZWN5Y2xlRXZlbnR9IGV2IFRoZSBMaWZlY3ljbGVFdmVudCBvYmplY3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQXBwLnByb3RvdHlwZS5vZmZsaW5lID0gZnVuY3Rpb24gKGV2KSB7IH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBEaXNwYXRjaEV2ZW50IGFuZCBwcm9wYWdhdGVzIGl0IHRvIGFsbFxyXG4gICAgICAgICAqIGxpc3RlbmVycyBiYXNlZCBvbiB0aGUgRElSRUNUIG1ldGhvZC4gUHJvcGFnYXRpb25cclxuICAgICAgICAgKiB3aWxsIGFsd2F5cyBzdGFydCB3aXRoIHRoZSBzZW5kZXIsIHNvIHRoZSBzZW5kZXIgY2FuIGJvdGggcHJvZHVjZSBhbmQgY29uc3VtZSB0aGUgc2FtZSBldmVudC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gc2VuZCwgY29vaW5jaWRlcyB3aXRoIHRoZSBuYW1lIHVzZWQgaW4gdGhlXHJcbiAgICAgICAgICogYXBwLm9uKCkgbWV0aG9kLlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gLi4uYXJncyBBbnkgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBzZW5kIHRvIGFsbCB0aGUgbGlzdGVuZXJzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFwcC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBfRXZlbnRNYW5hZ2VyID0gQXBwLl9FdmVudE1hbmFnZXIgfHwgYWNxdWlyZShfX0V2ZW50TWFuYWdlclN0YXRpYyk7XHJcbiAgICAgICAgICAgIF9FdmVudE1hbmFnZXIuZGlzcGF0Y2gobmFtZSwgdGhpcywgX0V2ZW50TWFuYWdlci5ESVJFQ1QsIGFyZ3MpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVnaXN0ZXJzIGEgbGlzdGVuZXIgZm9yIGEgRGlzcGF0Y2hFdmVudC4gVGhlIGxpc3RlbmVyIHdpbGwgYmUgY2FsbGVkIHdoZW5cclxuICAgICAgICAgKiBhIERpc3BhdGNoRXZlbnQgaXMgcHJvcGFnYXRpbmcgb3ZlciB0aGUgYXBwLiBBbnkgbnVtYmVyIG9mIGxpc3RlbmVycyBjYW4gZXhpc3QgZm9yIGEgc2luZ2xlIGV2ZW50IG5hbWUuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LCBjb29pbmNpZGluZyB3aXRoIHRoZSBEaXNwYXRjaEV2ZW50IG5hbWUuXHJcbiAgICAgICAgICogQHBhcmFtIHsoZXY6IHBsYXQuZXZlbnRzLkRpc3BhdGNoRXZlbnQsIC4uLmFyZ3M6IEFycmF5PGFueT4pID0+IHZvaWR9IGxpc3RlbmVyIFRoZSBtZXRob2QgY2FsbGVkIHdoZW5cclxuICAgICAgICAgKiB0aGUgRGlzcGF0Y2hFdmVudCBpcyBmaXJlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBcHAucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKG5hbWUsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIHZhciBfRXZlbnRNYW5hZ2VyID0gQXBwLl9FdmVudE1hbmFnZXIgfHwgYWNxdWlyZShfX0V2ZW50TWFuYWdlclN0YXRpYyk7XHJcbiAgICAgICAgICAgIHJldHVybiBfRXZlbnRNYW5hZ2VyLm9uKHRoaXMudWlkLCBuYW1lLCBsaXN0ZW5lciwgdGhpcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBLaWNrcyBvZmYgY29tcGlsYXRpb24gb2YgdGhlIERPTSBmcm9tIHRoZSBzcGVjaWZpZWQgbm9kZS4gSWYgbm8gbm9kZSBpcyBzcGVjaWZpZWQsXHJcbiAgICAgICAgICogdGhlIGRlZmF1bHQgc3RhcnQgbm9kZSBpcyBkb2N1bWVudC5ib2R5LiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIGZyb20gdGhlIGFwcCB3aGVuXHJcbiAgICAgICAgICogdXNpbmcgbW9kdWxlIGxvYWRlcnMuIElmIGEgbW9kdWxlIGxvYWRlciBpcyBpbiB1c2UsIHRoZSBhcHAgd2lsbCBkZWxheSBsb2FkaW5nIHVudGlsXHJcbiAgICAgICAgICogdGhpcyBtZXRob2QgaXMgY2FsbGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB3aGVyZSBhdCB3aGljaCBET00gY29tcGlsYXRpb24gYmVnaW5zLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFwcC5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgIEFwcC5sb2FkKG5vZGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsbHMgdG8gZXhpdCB0aGUgYXBwbGljYXRpb24uIE1ha2VzIHRoZSBuZWNlc3NhcnkgY2FsbHMgdG8gdGhlIGRldmljZSBpcyBwb3NzaWJsZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBcHAucHJvdG90eXBlLmV4aXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChfX3NodXRkb3duKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBpbnN0YW5jZSBvZiB0aGUgcmVnaXN0ZXJlZCBJQXBwLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFwcC5hcHAgPSBudWxsO1xyXG4gICAgICAgIHJldHVybiBBcHA7XHJcbiAgICB9KCkpO1xyXG4gICAgcGxhdF8xLkFwcCA9IEFwcDtcclxuICAgIC8qKlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBJQXBwU3RhdGljKF9jb21wYXQsIF9FdmVudE1hbmFnZXIsIF9kb2N1bWVudCwgX2NvbXBpbGVyLCBfTGlmZWN5Y2xlRXZlbnQsIF9sb2cpIHtcclxuICAgICAgICBBcHAuX2NvbXBhdCA9IF9jb21wYXQ7XHJcbiAgICAgICAgQXBwLl9FdmVudE1hbmFnZXIgPSBfRXZlbnRNYW5hZ2VyO1xyXG4gICAgICAgIEFwcC5fZG9jdW1lbnQgPSBfZG9jdW1lbnQ7XHJcbiAgICAgICAgQXBwLl9jb21waWxlciA9IF9jb21waWxlcjtcclxuICAgICAgICBBcHAuX0xpZmVjeWNsZUV2ZW50ID0gX0xpZmVjeWNsZUV2ZW50O1xyXG4gICAgICAgIEFwcC5fbG9nID0gX2xvZztcclxuICAgICAgICByZXR1cm4gQXBwO1xyXG4gICAgfVxyXG4gICAgcGxhdF8xLklBcHBTdGF0aWMgPSBJQXBwU3RhdGljO1xyXG4gICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX0FwcFN0YXRpYywgSUFwcFN0YXRpYywgW1xyXG4gICAgICAgIF9fQ29tcGF0LFxyXG4gICAgICAgIF9fRXZlbnRNYW5hZ2VyU3RhdGljLFxyXG4gICAgICAgIF9fRG9jdW1lbnQsXHJcbiAgICAgICAgX19Db21waWxlcixcclxuICAgICAgICBfX0xpZmVjeWNsZUV2ZW50U3RhdGljLFxyXG4gICAgICAgIF9fTG9nXHJcbiAgICBdLCBfX1NUQVRJQyk7XHJcbiAgICAvKipcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gSUFwcChfQXBwU3RhdGljKSB7XHJcbiAgICAgICAgcmV0dXJuIF9BcHBTdGF0aWMuYXBwO1xyXG4gICAgfVxyXG4gICAgcGxhdF8xLklBcHAgPSBJQXBwO1xyXG4gICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX0FwcCwgSUFwcCwgW19fQXBwU3RhdGljXSwgX19JTlNUQU5DRSk7XHJcbn0pKHBsYXQgfHwgKHBsYXQgPSB7fSkpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IHBsYXQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xyXG4vKipcclxuICogUGxhdHlwdXNVSSB2MC4xNC42IChodHRwczovL3BsYXR5cGkuaW8pXHJcbiAqIENvcHlyaWdodCAyMDE1IFBsYXR5cGksIExMQy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogUGxhdHlwdXNVSSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgYXRcclxuICogaHR0cHM6Ly9naXRodWIuY29tL1BsYXR5cGkvcGxhdHlwdXN1aS9ibG9iL21hc3Rlci9MSUNFTlNFXHJcbiAqXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGVudHJ5IHBvaW50IGludG8gdGhlIHBsYXR5cHVzIFVJIGNvbnRyb2xzIGxpYnJhcnkuXHJcbiAqL1xyXG52YXIgcGxhdHVpO1xyXG4oZnVuY3Rpb24gKHBsYXR1aSkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgLyogdHNsaW50OmRpc2FibGU6bm8tdW51c2VkLXZhcmlhYmxlICovXHJcbiAgICAvKlxyXG4gICAgICovXHJcbiAgICB2YXIgX19wcmVmaXggPSAnJCcsIF9fUHJvbWlzZSA9IF9fcHJlZml4ICsgXCJQcm9taXNlXCIsIF9fQ29tcGF0ID0gX19wcmVmaXggKyBcIkNvbXBhdFwiLCBfX1JlZ2V4ID0gX19wcmVmaXggKyBcIlJlZ2V4XCIsIF9fV2luZG93ID0gX19wcmVmaXggKyBcIldpbmRvd1wiLCBfX0RvY3VtZW50ID0gX19wcmVmaXggKyBcIkRvY3VtZW50XCIsIF9fVXRpbHMgPSBfX3ByZWZpeCArIFwiVXRpbHNcIiwgX19BbmltYXRvciA9IF9fcHJlZml4ICsgXCJBbmltYXRvclwiLCBfX0RvbUV2ZW50SW5zdGFuY2UgPSBfX3ByZWZpeCArIFwiRG9tRXZlbnRJbnN0YW5jZVwiLCBfX1RlbXBsYXRlQ29udHJvbEZhY3RvcnkgPSBfX3ByZWZpeCArIFwiVGVtcGxhdGVDb250cm9sRmFjdG9yeVwiLCBfX05vZGVNYW5hZ2VyU3RhdGljID0gX19wcmVmaXggKyBcIk5vZGVNYW5hZ2VyU3RhdGljXCIsIFxyXG4gICAgLyoqXHJcbiAgICAgKi9cclxuICAgIF9fQ09OVEVYVCA9ICdjb250ZXh0JywgXHJcbiAgICAvKipcclxuICAgICAqL1xyXG4gICAgX19QbGF0UHJlZml4ID0gJ3BsYXQnLCBfX1BsYXQgPSBfX1BsYXRQcmVmaXggKyBcIi1cIiwgX19CdXR0b24gPSBfX1BsYXQgKyBcImJ1dHRvblwiLCBfX0NoZWNrYm94ID0gX19QbGF0ICsgXCJjaGVja2JveFwiLCBfX0RyYXdlciA9IF9fUGxhdCArIFwiZHJhd2VyXCIsIF9fRHJhd2VyQ29udHJvbGxlciA9IF9fRHJhd2VyICsgXCItY29udHJvbGxlclwiLCBfX01vZGFsID0gX19QbGF0ICsgXCJtb2RhbFwiLCBfX1Byb2dyZXNzQmFyID0gX19QbGF0ICsgXCJwcm9ncmVzc1wiLCBfX1Byb2dyZXNzUmluZyA9IF9fUGxhdCArIFwicmluZ1wiLCBfX1JhZGlvID0gX19QbGF0ICsgXCJyYWRpb1wiLCBfX1RvZ2dsZSA9IF9fUGxhdCArIFwidG9nZ2xlXCIsIF9fU2xpZGVyID0gX19QbGF0ICsgXCJzbGlkZXJcIiwgX19SYW5nZSA9IF9fUGxhdCArIFwicmFuZ2VcIiwgX19TZWxlY3QgPSBfX1BsYXQgKyBcInNlbGVjdFwiLCBfX0lucHV0ID0gX19QbGF0ICsgXCJpbnB1dFwiLCBfX0ZpbGUgPSBfX1BsYXQgKyBcImZpbGVcIiwgX19DYXJvdXNlbCA9IF9fUGxhdCArIFwiY2Fyb3VzZWxcIiwgX19MaXN0dmlldyA9IF9fUGxhdCArIFwibGlzdHZpZXdcIiwgX19OYXZiYXIgPSBfX1BsYXQgKyBcIm5hdmJhclwiLCBfX0ltYWdlID0gX19QbGF0ICsgXCJpbWFnZVwiLCBcclxuICAgIC8qKlxyXG4gICAgICovXHJcbiAgICBfX0hpZGUgPSBfX1BsYXQgKyBcImhpZGVcIiwgX19IaWRkZW4gPSBfX1BsYXQgKyBcImhpZGRlblwiLCBfX0NvbnRleHQgPSBfX1BsYXQgKyBfX0NPTlRFWFQsIF9fRm9yRWFjaCA9IF9fUGxhdCArIFwiZm9yZWFjaFwiLCBfX0h0bWwgPSBfX1BsYXQgKyBcImh0bWxcIiwgX19EaXNhYmxlZCA9IF9fUGxhdCArIFwiZGlzYWJsZWRcIiwgX19SZWFkb25seSA9IF9fUGxhdCArIFwicmVhZG9ubHlcIiwgX19DYW1lbENvbnRleHQgPSBfX1BsYXRQcmVmaXggKyBcIkNvbnRleHRcIiwgX19DYW1lbENoZWNrZWQgPSBfX1BsYXRQcmVmaXggKyBcIkNoZWNrZWRcIiwgX19DYW1lbEJpbmQgPSBfX1BsYXRQcmVmaXggKyBcIkJpbmRcIiwgX19DYW1lbFNyYyA9IF9fUGxhdFByZWZpeCArIFwiU3JjXCIsIFxyXG4gICAgLyoqXHJcbiAgICAgKi9cclxuICAgIF9fbGlzdHZpZXdBbGlhc09wdGlvbnMgPSB7XHJcbiAgICAgICAgaW5kZXg6ICdpbmRleCcsXHJcbiAgICAgICAgZXZlbjogJ2V2ZW4nLFxyXG4gICAgICAgIG9kZDogJ29kZCcsXHJcbiAgICAgICAgZmlyc3Q6ICdmaXJzdCcsXHJcbiAgICAgICAgbGFzdDogJ2xhc3QnLFxyXG4gICAgICAgIGdyb3VwOiAnZ3JvdXAnXHJcbiAgICB9LCBcclxuICAgIC8qKlxyXG4gICAgICovXHJcbiAgICBfX1RyYW5zaXRpb24gPSBfX1BsYXQgKyBcInRyYW5zaXRpb25cIiwgX19FbnRlciA9IF9fUGxhdCArIFwiZW50ZXJcIiwgX19MZWF2ZSA9IF9fUGxhdCArIFwibGVhdmVcIiwgXHJcbiAgICAvKipcclxuICAgICAqL1xyXG4gICAgX18kdGFwID0gJyR0YXAnLCBfXyR0b3VjaHN0YXJ0ID0gJyR0b3VjaHN0YXJ0JywgX18kdG91Y2hlbmQgPSAnJHRvdWNoZW5kJywgX18kdG91Y2hjYW5jZWwgPSAnJHRvdWNoY2FuY2VsJywgX18kc3dpcGUgPSAnJHN3aXBlJywgX18kdHJhY2sgPSAnJHRyYWNrJywgX18kdHJhY2tlbmQgPSAnJHRyYWNrZW5kJywgX19CdXR0b25QcmVmaXggPSAnX19wbGF0LWJ1dHRvbi0nLCBfX1JhZGlvUHJlZml4ID0gJ19fcGxhdC1yYWRpby0nLCBfX0RyYXdlckNvbnRyb2xsZXJJbml0RXZlbnQgPSAnX19wbGF0RHJhd2VyQ29udHJvbGxlckluaXQnLCBfX0RyYXdlckNvbnRyb2xsZXJGZXRjaEV2ZW50ID0gJ19fcGxhdERyYXdlckNvbnRyb2xsZXJGZXRjaCcsIF9fRHJhd2VyRm91bmRFdmVudCA9ICdfX3BsYXREcmF3ZXJGb3VuZCcsIFxyXG4gICAgLyoqXHJcbiAgICAgKi9cclxuICAgIF9fUmV2ZXJzZWQgPSAnLXJldmVyc2VkJywgX19MSVRFUkFMX1JFU09VUkNFID0gJ2xpdGVyYWwnLCBfX3RyYW5zaXRpb25OZWdhdGUgPSB7XHJcbiAgICAgICAgcmlnaHQ6ICdsZWZ0JyxcclxuICAgICAgICBsZWZ0OiAncmlnaHQnLFxyXG4gICAgICAgIHVwOiAnZG93bicsXHJcbiAgICAgICAgZG93bjogJ3VwJ1xyXG4gICAgfSwgX19zcmMgPSAnc3JjJywgX19wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSwgbm9vcCA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIC8qIHRzbGludDplbmFibGU6bm8tdW51c2VkLXZhcmlhYmxlICovXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5wbGF0dWkgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5wbGF0dWkgPSBwbGF0dWk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93Lm1vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgd2luZG93Lm1vZHVsZSA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQW4gQmluZENvbnRyb2wgdGhhdCBzdGFuZGFyZGl6ZXMgYW4gSFRNTDUgYnV0dG9uLlxyXG4gICAgICovXHJcbiAgICB2YXIgQnV0dG9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoQnV0dG9uLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEJ1dHRvbigpIHtcclxuICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXBsYWNlcyB0aGUgPHBsYXQtYnV0dG9uPiBub2RlIHdpdGhcclxuICAgICAgICAgICAgICogYSA8YnV0dG9uPiBub2RlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5yZXBsYWNlV2l0aCA9ICdidXR0b24nO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBib29sZWFuIHZhbHVlIHNob3dpbmcgdGhlIHNlbGVjdGVkIHN0YXRlIG9mIHRoaXMgQnV0dG9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBjbGFzc2VzIG9uIHRoZSBwcm9wZXIgZWxlbWVudHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZT8gQW4gb3B0aW9uYWwsIGFkZGl0aW9uYWwgY2xhc3MgbmFtZSBvciBjbGFzcyBuYW1lcyB0byBzZXQgb24gdGhlIGNvbnRyb2xcclxuICAgICAgICAgKiBpbiBhZGRpdGlvbiB0byBpdHMgc3RhbmRhcmQgc2V0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudD8gVGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBjbGFzcyBuYW1lIG9uLiBTaG91bGQgZGVmYXVsdCB0b1xyXG4gICAgICAgICAqIHRoZSBjb250cm9sJ3MgZWxlbWVudCBpZiBub3Qgc3BlY2lmaWVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1dHRvbi5wcm90b3R5cGUuc2V0Q2xhc3NlcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5kb20uYWRkQ2xhc3MoZWxlbWVudCB8fCB0aGlzLmVsZW1lbnQsIF9fQnV0dG9uICsgXCIgXCIgKyAoY2xhc3NOYW1lIHx8ICcnKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIGRlZmF1bHQgY2xhc3Nlcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b24ucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0Q2xhc3NlcygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV3JhcCBhbGwgaW5uZXIgdGV4dCBub2RlcyBpbiBzcGFucy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b24ucHJvdG90eXBlLnNldFRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX2RvY3VtZW50ID0gdGhpcy5fZG9jdW1lbnQsIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsIGNoaWxkTm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlbGVtZW50LmNoaWxkTm9kZXMpLCBjaGlsZE5vZGUsIHNwYW4sIGlzRW1wdHkgPSB0aGlzLnV0aWxzLmlzRW1wdHk7XHJcbiAgICAgICAgICAgIHdoaWxlIChjaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXMuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0VtcHR5KGNoaWxkTm9kZS50ZXh0Q29udGVudC50cmltKCkubWF0Y2goL1teXFxyXFxuXS9nKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3BhbiA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uaW5zZXJ0QmVmb3JlKGNoaWxkTm9kZSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaW5zZXJ0QmVmb3JlKHNwYW4sIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNoaWxkTm9kZSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERldGVybWluZSB0aGUgYnV0dG9uIHN0eWxlIGFuZCBhcHBseSB0aGUgcHJvcGVyIGNsYXNzZXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnV0dG9uLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LCBvcHRpb25PYmogPSB0aGlzLm9wdGlvbnMgfHwge30sIG9wdGlvbnMgPSBvcHRpb25PYmoudmFsdWUgfHwge30sIGdyb3VwID0gb3B0aW9ucy5ncm91cCwgaXNTdHJpbmcgPSB0aGlzLnV0aWxzLmlzU3RyaW5nO1xyXG4gICAgICAgICAgICBpZiAoIWlzU3RyaW5nKGdyb3VwKSkge1xyXG4gICAgICAgICAgICAgICAgZ3JvdXAgPSB0aGlzLmF0dHJpYnV0ZXNbX19DYW1lbEJpbmRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGdyb3VwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyb3VwID0gZ3JvdXA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZG9tLmhhc0NsYXNzKGVsZW1lbnQsIF9fUGxhdCArIFwic2VsZWN0ZWRcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25UYXAoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9ncm91cCA9IGdyb3VwO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kb20uaGFzQ2xhc3MoZWxlbWVudCwgX19QbGF0ICsgXCJzZWxlY3RlZFwiKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fb25UYXAoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBmdW5jdGlvbiB0aGF0IGFsbG93cyB0aGlzIGNvbnRyb2wgdG8gb2JzZXJ2ZSBib3RoIHRoZSBib3VuZCBwcm9wZXJ0eSBpdHNlbGYgYXMgd2VsbCBhc1xyXG4gICAgICAgICAqIHBvdGVudGlhbCBjaGlsZCBwcm9wZXJ0aWVzIGlmIGJlaW5nIGJvdW5kIHRvIGFuIG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQub2JzZXJ2YWJsZS5JSW1wbGVtZW50VHdvV2F5QmluZGluZ30gYmluZGVyIFRoZSBjb250cm9sIHRoYXQgZmFjaWxpdGF0ZXMgdGhlXHJcbiAgICAgICAgICogZGF0YWJpbmRpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnV0dG9uLnByb3RvdHlwZS5vYnNlcnZlUHJvcGVydGllcyA9IGZ1bmN0aW9uIChiaW5kZXIpIHtcclxuICAgICAgICAgICAgYmluZGVyLm9ic2VydmVQcm9wZXJ0eSh0aGlzLl9zZXRCb3VuZFByb3BlcnR5KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgYmluZGFibGUgcHJvcGVydHkgaXMgc2V0IGV4dGVybmFsbHkuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld1ZhbHVlIFRoZSBuZXcgdmFsdWUgb2YgdGhlIGJpbmRhYmxlIHByb3BlcnR5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvbGRWYWx1ZSBUaGUgb2xkIHZhbHVlIG9mIHRoZSBiaW5kYWJsZSBwcm9wZXJ0eS5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmllciBUaGUgaWRlbnRpZmllciBvZiB0aGUgcHJvcGVydHkgYmVpbmcgb2JzZXJ2ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmaXJzdFRpbWU/IEEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSBpdHMgYmVpbmcgc2V0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1dHRvbi5wcm90b3R5cGUuX3NldEJvdW5kUHJvcGVydHkgPSBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlLCBpZGVudGlmaWVyLCBmaXJzdFRpbWUpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnV0aWxzLmlzU3RyaW5nKG5ld1ZhbHVlKSB8fCBuZXdWYWx1ZSAhPT0gdGhpcy5lbGVtZW50LnRleHRDb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fb25UYXAoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZCBldmVudCBsaXN0ZW5lcnMgZm9yIHNlbGVjdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b24ucHJvdG90eXBlLl9hZGRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHRoaXMuZWxlbWVudCwgX18kdGFwLCB0aGlzLl9vblRhcCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLm9uKF9fQnV0dG9uUHJlZml4ICsgdGhpcy5fZ3JvdXAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5faXNTZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRvbS5yZW1vdmVDbGFzcyhfdGhpcy5lbGVtZW50LCBfX1BsYXQgKyBcInNlbGVjdGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGxhY2UgdGhlIHB1c2hlZCBidXR0b24gaW4gYSBzZWxlY3RlZCBzdGF0ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b24ucHJvdG90eXBlLl9vblRhcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcclxuICAgICAgICAgICAgdGhpcy5kb20uYWRkQ2xhc3MoZWxlbWVudCwgX19QbGF0ICsgXCJzZWxlY3RlZFwiKTtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KF9fQnV0dG9uUHJlZml4ICsgdGhpcy5fZ3JvdXAsIHBsYXQuZXZlbnRzLkV2ZW50TWFuYWdlci5ESVJFQ1QpO1xyXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dENoYW5nZWQoZWxlbWVudC50ZXh0Q29udGVudCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBCdXR0b24uX2luamVjdCA9IHtcclxuICAgICAgICAgICAgX2RvY3VtZW50OiBfX0RvY3VtZW50XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQnV0dG9uO1xyXG4gICAgfShwbGF0LnVpLkJpbmRDb250cm9sKSk7XHJcbiAgICBwbGF0dWkuQnV0dG9uID0gQnV0dG9uO1xyXG4gICAgcGxhdC5yZWdpc3Rlci5jb250cm9sKF9fQnV0dG9uLCBCdXR0b24pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBCaW5kQ29udHJvbCB0aGF0IHNpbXVsYXRlcyBhIHRvZ2dsZSBzd2l0Y2guXHJcbiAgICAgKi9cclxuICAgIHZhciBUb2dnbGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhUb2dnbGUsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gVG9nZ2xlKCkge1xyXG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBIVE1MIHRlbXBsYXRlIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZVN0cmluZyA9ICc8ZGl2IGNsYXNzPVwicGxhdC10b2dnbGUtY29udGFpbmVyXCI+XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnICAgIDxkaXYgY2xhc3M9XCJwbGF0LWtub2JcIj48L2Rpdj5cXG4nICtcclxuICAgICAgICAgICAgICAgICc8L2Rpdj5cXG4nO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgY29udHJvbCBpcyBhY3RpdmVseSBzZWxlY3RlZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSB0eXBlIG9mIHRoZSBjb250cm9sJ3MgYWN0aXZhdGVkIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl90YXJnZXRUeXBlID0gJ3NsaWRlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgY2xhc3NlcyBvbiB0aGUgcHJvcGVyIGVsZW1lbnRzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWU/IEFuIG9wdGlvbmFsLCBhZGRpdGlvbmFsIGNsYXNzIG5hbWUgb3IgY2xhc3MgbmFtZXMgdG8gc2V0IG9uIHRoZSBjb250cm9sXHJcbiAgICAgICAgICogaW4gYWRkaXRpb24gdG8gaXRzIHN0YW5kYXJkIHNldC5cclxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQ/IFRoZSBlbGVtZW50IHRvIHNldCB0aGUgY2xhc3MgbmFtZSBvbi4gU2hvdWxkIGRlZmF1bHQgdG9cclxuICAgICAgICAgKiB0aGUgY29udHJvbCdzIGVsZW1lbnQgaWYgbm90IHNwZWNpZmllZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBUb2dnbGUucHJvdG90eXBlLnNldENsYXNzZXMgPSBmdW5jdGlvbiAoY2xhc3NOYW1lLCBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZENsYXNzKGVsZW1lbnQgfHwgdGhpcy5lbGVtZW50LCBfX1RvZ2dsZSArIFwiIFwiICsgKGNsYXNzTmFtZSB8fCAnJykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IHRoZSBjbGFzcyBuYW1lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRvZ2dsZS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRDbGFzc2VzKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgbGlzdGVuZXIgZm9yIHRoZSB0YXAgZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVG9nZ2xlLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xyXG4gICAgICAgICAgICB0aGlzLl90YXJnZXRFbGVtZW50ID0gZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZDtcclxuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsIF9fJHRhcCwgdGhpcy5fb25UYXApO1xyXG4gICAgICAgICAgICB0aGlzLl9jb252ZXJ0Q2hlY2tlZCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBmdW5jdGlvbiB0aGF0IGFsbG93cyB0aGlzIGNvbnRyb2wgdG8gb2JzZXJ2ZSBib3RoIHRoZSBib3VuZCBwcm9wZXJ0eSBpdHNlbGYgYXMgd2VsbCBhc1xyXG4gICAgICAgICAqIHBvdGVudGlhbCBjaGlsZCBwcm9wZXJ0aWVzIGlmIGJlaW5nIGJvdW5kIHRvIGFuIG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQub2JzZXJ2YWJsZS5JSW1wbGVtZW50VHdvV2F5QmluZGluZ30gYmluZGVyIFRoZSBjb250cm9sIHRoYXQgZmFjaWxpdGF0ZXMgdGhlXHJcbiAgICAgICAgICogZGF0YWJpbmRpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVG9nZ2xlLnByb3RvdHlwZS5vYnNlcnZlUHJvcGVydGllcyA9IGZ1bmN0aW9uIChiaW5kZXIpIHtcclxuICAgICAgICAgICAgYmluZGVyLm9ic2VydmVQcm9wZXJ0eSh0aGlzLl9zZXRCb3VuZFByb3BlcnR5KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgYmluZGFibGUgcHJvcGVydHkgaXMgc2V0IGV4dGVybmFsbHkuXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IG5ld1ZhbHVlIFRoZSBuZXcgdmFsdWUgb2YgdGhlIGJpbmRhYmxlIHByb3BlcnR5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBvbGRWYWx1ZSBUaGUgb2xkIHZhbHVlIG9mIHRoZSBiaW5kYWJsZSBwcm9wZXJ0eS5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmllciBUaGUgaWRlbnRpZmllciBvZiB0aGUgcHJvcGVydHkgYmVpbmcgb2JzZXJ2ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBzZXRQcm9wZXJ0eT8gQSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB3ZSBzaG91bGQgc2V0XHJcbiAgICAgICAgICogdGhlIHByb3BlcnR5IGlmIHdlIG5lZWQgdG8gdG9nZ2xlIHRoZSBzdGF0ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBUb2dnbGUucHJvdG90eXBlLl9zZXRCb3VuZFByb3BlcnR5ID0gZnVuY3Rpb24gKG5ld1ZhbHVlLCBvbGRWYWx1ZSwgaWRlbnRpZmllciwgc2V0UHJvcGVydHkpIHtcclxuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSBvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNldFByb3BlcnR5ID09PSB0cnVlICYmIHRoaXMudXRpbHMuaXNOdWxsKG5ld1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dENoYW5nZWQodGhpcy5pc0FjdGl2ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGlzQWN0aXZlID0gISFuZXdWYWx1ZTtcclxuICAgICAgICAgICAgaWYgKGlzQWN0aXZlID09PSB0aGlzLmlzQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlKHNldFByb3BlcnR5KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIFwiY2hlY2tlZFwiIGF0dHJpYnV0ZXMgYW5kIGhhbmRsaW5nIHRoZW0gYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IG5ld1ZhbHVlIFRoZSBuZXdWYWx1ZSBvZiB0aGUgYXR0cmlidXRlIHRvIGNvbnZlcnQuXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IG9sZFZhbHVlPyBUaGUgb2xkVmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBjb252ZXJ0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRvZ2dsZS5wcm90b3R5cGUuX2NvbnZlcnRDaGVja2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnV0aWxzLmlzTnVsbCh0aGlzLmF0dHJpYnV0ZXNbX19DYW1lbENoZWNrZWRdKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29udmVydEF0dHJpYnV0ZSh0aGlzLmF0dHJpYnV0ZXNbX19DYW1lbENoZWNrZWRdKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlcy5vYnNlcnZlKHRoaXMuX2NvbnZlcnRBdHRyaWJ1dGUsIF9fQ2FtZWxDaGVja2VkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY2hlY2tlZCcpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb252ZXJ0QXR0cmlidXRlKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGZ1bmN0aW9uIGZvciBoYW5kbGluZyB0aGUgYXR0cmlidXRlIHZhbHVlIGNvbnZlcnNpb24gZm9yIHVwZGF0aW5nIHRoZVxyXG4gICAgICAgICAqIGJvdW5kIHByb3BlcnR5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBuZXdWYWx1ZSBUaGUgbmV3VmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBjb252ZXJ0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBvbGRWYWx1ZT8gVGhlIG9sZFZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgdG8gY29udmVydC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBUb2dnbGUucHJvdG90eXBlLl9jb252ZXJ0QXR0cmlidXRlID0gZnVuY3Rpb24gKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgdXRpbHMgPSB0aGlzLnV0aWxzO1xyXG4gICAgICAgICAgICBpZiAodXRpbHMuaXNCb29sZWFuKG5ld1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NldEJvdW5kUHJvcGVydHkobmV3VmFsdWUsIG9sZFZhbHVlLCBudWxsLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghdXRpbHMuaXNTdHJpbmcobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc2V0Qm91bmRQcm9wZXJ0eShuZXdWYWx1ZSA9PT0gJ3RydWUnLCBvbGRWYWx1ZSA9PT0gJ3RydWUnLCBudWxsLCB0cnVlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjYWxsYmFjayBmb3IgYSB0YXAgZXZlbnQuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklHZXN0dXJlRXZlbnR9IGV2IFRoZSB0YXAgZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRvZ2dsZS5wcm90b3R5cGUuX29uVGFwID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZSh0cnVlKTtcclxuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcignY2hhbmdlJyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUcmlnZ2VycyBhbiBldmVudCBzdGFydGluZyBmcm9tIHRoaXMgY29udHJvbCdzIGVsZW1lbnQuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IFRoZSBldmVudCBuYW1lIHRvIHRyaWdnZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVG9nZ2xlLnByb3RvdHlwZS5fdHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICB2YXIgZG9tRXZlbnQgPSBwbGF0LmFjcXVpcmUoX19Eb21FdmVudEluc3RhbmNlKTtcclxuICAgICAgICAgICAgZG9tRXZlbnQuaW5pdGlhbGl6ZSh0aGlzLmVsZW1lbnQsIGV2ZW50KTtcclxuICAgICAgICAgICAgZG9tRXZlbnQudHJpZ2dlcigpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVG9nZ2xlcyB0aGUgbWFyayBhbmQgdXBkYXRlcyB0aGUgYmluZGFibGUgcHJvcGVydHkgaWYgbmVlZGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2V0UHJvcGVydHk/IEEgYm9vbGVhbiB2YWx1ZSBzdGF0aW5nIHdoZXRoZXIgdGhlIGJpbmRhYmxlXHJcbiAgICAgICAgICogcHJvcGVydHkgc2hvdWxkIGJlIHVwZGF0ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVG9nZ2xlLnByb3RvdHlwZS5fdG9nZ2xlID0gZnVuY3Rpb24gKHNldFByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgIHZhciB3YXNBY3RpdmUgPSB0aGlzLmlzQWN0aXZlLCBpc0FjdGl2ZSA9ICF3YXNBY3RpdmUsIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2YXRlKHRoaXMuX3RhcmdldEVsZW1lbnQgfHwgKHRoaXMuX3RhcmdldEVsZW1lbnQgPSBlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKSk7XHJcbiAgICAgICAgICAgIHRoaXMuaXNBY3RpdmUgPSBlbGVtZW50LmNoZWNrZWQgPSBpc0FjdGl2ZTtcclxuICAgICAgICAgICAgaWYgKGlzQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnY2hlY2tlZCcsICdjaGVja2VkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnY2hlY2tlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzZXRQcm9wZXJ0eSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dENoYW5nZWQoaXNBY3RpdmUsIHdhc0FjdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdGhlIGdpdmVuIGVsZW1lbnQgYnkgdG9nZ2xpbmcgdGhlXHJcbiAgICAgICAgICogY2xhc3Mgc3BlY2lmaWVkIGFzIHRoZSB0YXJnZXQgdHlwZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gYWN0aXZhdGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVG9nZ2xlLnByb3RvdHlwZS5fYWN0aXZhdGUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmRvbS50b2dnbGVDbGFzcyhlbGVtZW50LCBfX1BsYXQgKyB0aGlzLl90YXJnZXRUeXBlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBUb2dnbGU7XHJcbiAgICB9KHBsYXQudWkuQmluZENvbnRyb2wpKTtcclxuICAgIHBsYXR1aS5Ub2dnbGUgPSBUb2dnbGU7XHJcbiAgICBwbGF0LnJlZ2lzdGVyLmNvbnRyb2woX19Ub2dnbGUsIFRvZ2dsZSk7XHJcbiAgICAvKipcclxuICAgICAqIEFuIElCaW5kYWJsZVByb3BlcnR5Q29udHJvbCB0aGF0IHN0YW5kYXJkaXplcyB0aGUgSFRNTDUgY2hlY2tib3guXHJcbiAgICAgKi9cclxuICAgIHZhciBDaGVja2JveCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKENoZWNrYm94LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIENoZWNrYm94KCkge1xyXG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBIVE1MIHRlbXBsYXRlIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZVN0cmluZyA9ICc8ZGl2IGNsYXNzPVwicGxhdC1jaGVja2JveC1jb250YWluZXJcIj5cXG4nICtcclxuICAgICAgICAgICAgICAgICcgICAgPHNwYW4gY2xhc3M9XCJwbGF0LW1hcmtcIj48L3NwYW4+XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnPC9kaXY+XFxuJztcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgdGhlIHRhcmdldCB0eXBlIGhhcyBiZWVuIHNldCBhbHJlYWR5IG9yIG5vdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldFR5cGVTZXQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgY2xhc3NlcyBvbiB0aGUgcHJvcGVyIGVsZW1lbnRzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWU/IEFuIG9wdGlvbmFsLCBhZGRpdGlvbmFsIGNsYXNzIG5hbWUgb3IgY2xhc3MgbmFtZXMgdG8gc2V0IG9uIHRoZSBjb250cm9sXHJcbiAgICAgICAgICogaW4gYWRkaXRpb24gdG8gaXRzIHN0YW5kYXJkIHNldC5cclxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQ/IFRoZSBlbGVtZW50IHRvIHNldCB0aGUgY2xhc3MgbmFtZSBvbi4gU2hvdWxkIGRlZmF1bHQgdG9cclxuICAgICAgICAgKiB0aGUgY29udHJvbCdzIGVsZW1lbnQgaWYgbm90IHNwZWNpZmllZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDaGVja2JveC5wcm90b3R5cGUuc2V0Q2xhc3NlcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5kb20uYWRkQ2xhc3MoZWxlbWVudCB8fCB0aGlzLmVsZW1lbnQsIF9fQ2hlY2tib3ggKyBcIiBcIiArIChjbGFzc05hbWUgfHwgJycpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgdGhlIGlubmVyIHRlbXBsYXRlIHRvIHRoZSBET00gbWFraW5nIHN1cmUgdG8gd3JhcCB0ZXh0IG5vZGVzIGluIHNwYW5zLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENoZWNrYm94LnByb3RvdHlwZS5zZXRUZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGlzTnVsbCA9IHRoaXMudXRpbHMuaXNOdWxsLCBpbm5lclRlbXBsYXRlID0gdGhpcy5pbm5lclRlbXBsYXRlO1xyXG4gICAgICAgICAgICBpZiAoaXNOdWxsKGlubmVyVGVtcGxhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIF9kb2N1bWVudCA9IHRoaXMuX2RvY3VtZW50LCBlbGVtZW50ID0gdGhpcy5lbGVtZW50LCBjaGlsZE5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaW5uZXJUZW1wbGF0ZS5jaGlsZE5vZGVzKSwgY2hpbGROb2RlLCBzcGFuLCBtYXRjaDtcclxuICAgICAgICAgICAgd2hpbGUgKGNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlcy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGNoaWxkTm9kZS50ZXh0Q29udGVudC50cmltKCkubWF0Y2goL1teXFxyXFxuXS9nKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwgJiYgbWF0Y2gubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5pbnNlcnRCZWZvcmUoY2hpbGROb2RlLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5pbnNlcnRCZWZvcmUoc3BhbiwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5pbnNlcnRCZWZvcmUoY2hpbGROb2RlLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2tzIGZvciBjaGVja2VkIGF0dHJpYnV0ZXMgYW5kIGhhbmRsZXMgdGhlbSBhY2NvcmRpbmdseS4gQWxzbyxcclxuICAgICAgICAgKiBpbml0aWFsaXplcyB0aGUgbWFyayBhbmQgYWRkcyBhIGxpc3RlbmVyIGZvciB0aGUgdGFwIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENoZWNrYm94LnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUubG9hZGVkLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIHZhciBvcHRpb25PYmogPSB0aGlzLm9wdGlvbnMgfHwge30sIG9wdGlvbnMgPSBvcHRpb25PYmoudmFsdWUgfHwge30sIHByZXZpb3VzVHlwZSA9IHRoaXMuX3RhcmdldFR5cGUsIG1hcmsgPSB0aGlzLl90YXJnZXRUeXBlID0gb3B0aW9ucy5tYXJrIHx8ICdjaGVjayc7XHJcbiAgICAgICAgICAgIHN3aXRjaCAobWFyay50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdjaGVjayc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICd4JzpcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKFwiSW52YWxpZCBtYXJrIG9wdGlvbiBzcGVjaWZpZWQgZm9yIFwiICsgdGhpcy50eXBlICsgXCIuIERlZmF1bHRpbmcgdG8gY2hlY2ttYXJrLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXRUeXBlID0gJ2NoZWNrJztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fdGFyZ2V0VHlwZVNldCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX3RhcmdldEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5yZW1vdmVDbGFzcyh0YXJnZXQsIHByZXZpb3VzVHlwZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmF0ZSh0YXJnZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldFR5cGVTZXQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBmdW5jdGlvbiB0byBhY3RpdmF0ZSB0aGUgZ2l2ZW4gZWxlbWVudCBieSB0b2dnbGluZyB0aGVcclxuICAgICAgICAgKiBjbGFzcyBzcGVjaWZpZWQgYXMgdGhlIHRhcmdldCB0eXBlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBhY3RpdmF0ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDaGVja2JveC5wcm90b3R5cGUuX2FjdGl2YXRlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3RhcmdldFR5cGVTZXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLnRvZ2dsZUNsYXNzKGVsZW1lbnQsIF9fUGxhdCArIHRoaXMuX3RhcmdldFR5cGUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldFR5cGVTZXQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ2hlY2tib3guX2luamVjdCA9IHtcclxuICAgICAgICAgICAgX2RvY3VtZW50OiBfX0RvY3VtZW50XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQ2hlY2tib3g7XHJcbiAgICB9KFRvZ2dsZSkpO1xyXG4gICAgcGxhdHVpLkNoZWNrYm94ID0gQ2hlY2tib3g7XHJcbiAgICBwbGF0LnJlZ2lzdGVyLmNvbnRyb2woX19DaGVja2JveCwgQ2hlY2tib3gpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBJQmluZGFibGVQcm9wZXJ0eUNvbnRyb2wgdGhhdCBzdGFuZGFyZGl6ZXMgdGhlIEhUTUw1IHJhZGlvIGJ1dHRvbi5cclxuICAgICAqL1xyXG4gICAgdmFyIFJhZGlvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoUmFkaW8sIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gUmFkaW8oKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIEhUTUwgdGVtcGxhdGUgcmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlU3RyaW5nID0gJzxkaXYgY2xhc3M9XCJwbGF0LXJhZGlvLWNvbnRhaW5lclwiPlxcbicgK1xyXG4gICAgICAgICAgICAgICAgJyAgICA8ZGl2IGNsYXNzPVwicGxhdC1tYXJrXCI+PC9kaXY+XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnPC9kaXY+XFxuJztcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSByYWRpbyBncm91cHMgbmFtZSBpZiBhIHJhZGlvIGdyb3VwIGlzIHByZXNlbnQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwTmFtZSA9ICcnO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGNoZWNrIHR5cGUgdG8gYmUgcGxhY2VkIGluIHRoZSBlbGVtZW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0VHlwZSA9ICdidWxsZXQnO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciB0aGUgdGFyZ2V0IHR5cGUgaGFzIGJlZW4gc2V0IGFscmVhZHkgb3Igbm90LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0VHlwZVNldCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGNsYXNzZXMgb24gdGhlIHByb3BlciBlbGVtZW50cy5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lPyBBbiBvcHRpb25hbCwgYWRkaXRpb25hbCBjbGFzcyBuYW1lIG9yIGNsYXNzIG5hbWVzIHRvIHNldCBvbiB0aGUgY29udHJvbFxyXG4gICAgICAgICAqIGluIGFkZGl0aW9uIHRvIGl0cyBzdGFuZGFyZCBzZXQuXHJcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50PyBUaGUgZWxlbWVudCB0byBzZXQgdGhlIGNsYXNzIG5hbWUgb24uIFNob3VsZCBkZWZhdWx0IHRvXHJcbiAgICAgICAgICogdGhlIGNvbnRyb2wncyBlbGVtZW50IGlmIG5vdCBzcGVjaWZpZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFkaW8ucHJvdG90eXBlLnNldENsYXNzZXMgPSBmdW5jdGlvbiAoY2xhc3NOYW1lLCBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZENsYXNzKGVsZW1lbnQgfHwgdGhpcy5lbGVtZW50LCBfX1JhZGlvICsgXCIgXCIgKyAoY2xhc3NOYW1lIHx8ICcnKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgZm9yIGEgcmFkaW8gZ3JvdXAgYW5kIGNvbnZlcnRzIFwiY2hlY2tlZFwiIGF0dHJpYnV0ZXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFkaW8ucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldEVsZW1lbnQgPSBlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkO1xyXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgX18kdGFwLCB0aGlzLl9vblRhcCk7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnbmFtZScpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwTmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCduYW1lJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMudXRpbHMuaXNOdWxsKHRoaXMuYXR0cmlidXRlc1tfX0NhbWVsQmluZF0pKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwTmFtZSA9IHRoaXMuYXR0cmlidXRlc1tfX0NhbWVsQmluZF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fY29udmVydENoZWNrZWQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyBpZiB0aGUgcmFkaW8gaGFzIGJlZW4gc2VsZWN0ZWQgYW5kIG9ubHkgbm90aWZpZXMgb2YgYSBiaW5kYWJsZVxyXG4gICAgICAgICAqIHByb3BlcnR5IGNoYW5nZWQgaWYgaXQgaGFzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBuZXdWYWx1ZT8gVGhlIG5ldyB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgYWZ0ZXIgdGhlIGNoYW5nZS5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2xkVmFsdWU/IFRoZSBvbGQgdmFsdWUgb2YgdGhlIHByb3BlcnR5IHByaW9yIHRvIHRoZSBjaGFuZ2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFkaW8ucHJvdG90eXBlLmlucHV0Q2hhbmdlZCA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuaW5wdXRDaGFuZ2VkLmNhbGwodGhpcywgdGhpcy5fZ2V0VmFsdWUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgYmluZGFibGUgcHJvcGVydHkgaXMgc2V0IGV4dGVybmFsbHkuXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IG5ld1ZhbHVlIFRoZSBuZXcgdmFsdWUgb2YgdGhlIGJpbmRhYmxlIHByb3BlcnR5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBvbGRWYWx1ZSBUaGUgb2xkIHZhbHVlIG9mIHRoZSBiaW5kYWJsZSBwcm9wZXJ0eS5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmllciBUaGUgaWRlbnRpZmllciBvZiB0aGUgcHJvcGVydHkgYmVpbmcgb2JzZXJ2ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBzZXRQcm9wZXJ0eT8gQSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB3ZSBzaG91bGQgc2V0XHJcbiAgICAgICAgICogdGhlIHByb3BlcnR5IGlmIHdlIG5lZWQgdG8gdG9nZ2xlIHRoZSBtYXJrLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhZGlvLnByb3RvdHlwZS5fc2V0Qm91bmRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUsIGlkZW50aWZpZXIsIHNldFByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzZXRQcm9wZXJ0eSA9PT0gdHJ1ZSAmJiB0aGlzLnV0aWxzLmlzTnVsbChuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRDaGFuZ2VkKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGlzQ2hlY2tlZCA9IG5ld1ZhbHVlID09PSB0aGlzLl9nZXRWYWx1ZSgpLCB3YXNDaGVja2VkID0gdGhpcy5pc0FjdGl2ZTtcclxuICAgICAgICAgICAgaWYgKGlzQ2hlY2tlZCA9PT0gd2FzQ2hlY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZShzZXRQcm9wZXJ0eSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY2FsbGJhY2sgZm9yIGEgdGFwIGV2ZW50LiBPbmx5IGZpcmVzIHRoZSBldmVudCBpZiB0aGUgUmFkaW9cclxuICAgICAgICAgKiBoYXMgYmVlbiBzZWxlY3RlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSUdlc3R1cmVFdmVudH0gZXYgVGhlIHRhcCBldmVudCBvYmplY3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFkaW8ucHJvdG90eXBlLl9vblRhcCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX29uVGFwLmNhbGwodGhpcywgZXYpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVG9nZ2xlcyB0aGUgbWFyayBhbmQgdXBkYXRlcyB0aGUgYmluZGFibGUgcHJvcGVydHkgaWYgbmVlZGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2V0UHJvcGVydHk/IEEgYm9vbGVhbiB2YWx1ZSBzdGF0aW5nIHdoZXRoZXIgdGhlIGJpbmRhYmxlXHJcbiAgICAgICAgICogcHJvcGVydHkgc2hvdWxkIGJlIHVwZGF0ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFkaW8ucHJvdG90eXBlLl90b2dnbGUgPSBmdW5jdGlvbiAoc2V0UHJvcGVydHkpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fdG9nZ2xlLmNhbGwodGhpcywgc2V0UHJvcGVydHkpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy51dGlscy5pc0Z1bmN0aW9uKHRoaXMuX3JlbW92ZUxpc3RlbmVyKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVyID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IHRoaXMuZ3JvdXBOYW1lO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KF9fUmFkaW9QcmVmaXggKyBuYW1lXzEsIHBsYXQuZXZlbnRzLkV2ZW50TWFuYWdlci5ESVJFQ1QpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZXJfMSA9IHRoaXMuX3JlbW92ZUxpc3RlbmVyID0gdGhpcy5vbihfX1JhZGlvUHJlZml4ICsgbmFtZV8xLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RvZ2dsZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZXJfMSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgZnVuY3Rpb24gZm9yIGhhbmRsaW5nIHRoZSBhdHRyaWJ1dGUgdmFsdWUgY29udmVyc2lvbiBmb3IgdXBkYXRpbmcgdGhlXHJcbiAgICAgICAgICogYm91bmQgcHJvcGVydHkuXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IG5ld1ZhbHVlIFRoZSBuZXdWYWx1ZSBvZiB0aGUgYXR0cmlidXRlIHRvIGNvbnZlcnQuXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IG9sZFZhbHVlPyBUaGUgb2xkVmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBjb252ZXJ0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhZGlvLnByb3RvdHlwZS5fY29udmVydEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIHV0aWxzID0gdGhpcy51dGlscztcclxuICAgICAgICAgICAgaWYgKHV0aWxzLmlzQm9vbGVhbihuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldEJvdW5kUHJvcGVydHkodGhpcy5fZ2V0VmFsdWUoKSwgbnVsbCwgbnVsbCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIXV0aWxzLmlzU3RyaW5nKG5ld1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gJ3RydWUnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRCb3VuZFByb3BlcnR5KHRoaXMuX2dldFZhbHVlKCksIG51bGwsIG51bGwsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHcmFicyB0aGUgdmFsdWUgb2YgdGhpcyBSYWRpbydzIGJpbmRhYmxlIHByb3BlcnR5LiBJdCBmaXJzdCBjaGVja3MgZm9yXHJcbiAgICAgICAgICogdGhlIFwidmFsdWVcIiBhdHRyaWJ1dGUsIGFuZCBkZWZhdWx0cyB0byB0aGUgZWxlbWVudHMgdGV4dENvbnRlbnQgaWYgaXQncyB1bmF2YWlsYWJsZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYWRpby5wcm90b3R5cGUuX2dldFZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKCd2YWx1ZScpID8gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykudHJpbSgpIDogZWxlbWVudC50ZXh0Q29udGVudC50cmltKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUmFkaW87XHJcbiAgICB9KENoZWNrYm94KSk7XHJcbiAgICBwbGF0dWkuUmFkaW8gPSBSYWRpbztcclxuICAgIHBsYXQucmVnaXN0ZXIuY29udHJvbChfX1JhZGlvLCBSYWRpbyk7XHJcbiAgICAvKipcclxuICAgICAqIEFuIElUZW1wbGF0ZUNvbnRyb2wgZm9yIHNob3dpbmcgaW5kZXRlcm1pbmF0ZSBwcm9ncmVzcy5cclxuICAgICAqL1xyXG4gICAgdmFyIFByb2dyZXNzUmluZyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFByb2dyZXNzUmluZywgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBQcm9ncmVzc1JpbmcoKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIEhUTUwgdGVtcGxhdGUgcmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlU3RyaW5nID0gJzxkaXYgY2xhc3M9XCJwbGF0LWFuaW1hdGVkLXJpbmdcIj48L2Rpdj4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBjbGFzc2VzIG9uIHRoZSBwcm9wZXIgZWxlbWVudHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZT8gQW4gb3B0aW9uYWwsIGFkZGl0aW9uYWwgY2xhc3MgbmFtZSBvciBjbGFzcyBuYW1lcyB0byBzZXQgb24gdGhlIGNvbnRyb2xcclxuICAgICAgICAgKiBpbiBhZGRpdGlvbiB0byBpdHMgc3RhbmRhcmQgc2V0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudD8gVGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBjbGFzcyBuYW1lIG9uLiBTaG91bGQgZGVmYXVsdCB0b1xyXG4gICAgICAgICAqIHRoZSBjb250cm9sJ3MgZWxlbWVudCBpZiBub3Qgc3BlY2lmaWVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb2dyZXNzUmluZy5wcm90b3R5cGUuc2V0Q2xhc3NlcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5kb20uYWRkQ2xhc3MoZWxlbWVudCB8fCB0aGlzLmVsZW1lbnQsIF9fUHJvZ3Jlc3NSaW5nICsgXCIgXCIgKyAoY2xhc3NOYW1lIHx8ICcnKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdGhlIGNsYXNzIG5hbWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvZ3Jlc3NSaW5nLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldENsYXNzZXMoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0aGUgYW5pbWF0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb2dyZXNzUmluZy5wcm90b3R5cGUubG9hZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucywgdXRpbHMgPSB0aGlzLnV0aWxzLCBpc09iamVjdCA9IHV0aWxzLmlzT2JqZWN0LCBzdHlsZSA9IDA7XHJcbiAgICAgICAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSAmJiBpc09iamVjdChvcHRpb25zLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUgPSBvcHRpb25zLnZhbHVlLnN0eWxlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF1dGlscy5pc051bWJlcihzdHlsZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kb20uYWRkQ2xhc3ModGhpcy5lbGVtZW50LCBfX1Byb2dyZXNzUmluZyArIFwiLVwiICsgc3R5bGUpO1xyXG4gICAgICAgICAgICBpZiAoc3R5bGUgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9hZGRBbmltYXRlZEVsZW1lbnRzKHN0eWxlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYW55IG5lZWRlZCBET00gZm9yIHRoZSBhbmltYXRpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvZ3Jlc3NSaW5nLnByb3RvdHlwZS5fYWRkQW5pbWF0ZWRFbGVtZW50cyA9IGZ1bmN0aW9uIChzdHlsZSkge1xyXG4gICAgICAgICAgICB2YXIgX2RvY3VtZW50ID0gcGxhdC5hY3F1aXJlKF9fRG9jdW1lbnQpLCBmcmFnbWVudCA9IF9kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIGNvdW50ID0gc3R5bGUgPT09IDIgPyAxMiA6IDQsIGRpdiA9ICdkaXYnLCBjbGFzc1ByZWZpeCA9IF9fUGxhdCArIFwiYW5pbWF0ZWQtY2hpbGQgXCIgKyBfX1BsYXQgKyBcImFuaW1hdGVkLWNoaWxkLVwiLCBjaGlsZDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZCA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KGRpdik7XHJcbiAgICAgICAgICAgICAgICBjaGlsZC5jbGFzc05hbWUgPSBjbGFzc1ByZWZpeCArIGk7XHJcbiAgICAgICAgICAgICAgICBmcmFnbWVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZC5pbnNlcnRCZWZvcmUoZnJhZ21lbnQsIG51bGwpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFByb2dyZXNzUmluZztcclxuICAgIH0ocGxhdC51aS5UZW1wbGF0ZUNvbnRyb2wpKTtcclxuICAgIHBsYXR1aS5Qcm9ncmVzc1JpbmcgPSBQcm9ncmVzc1Jpbmc7XHJcbiAgICBwbGF0LnJlZ2lzdGVyLmNvbnRyb2woX19Qcm9ncmVzc1JpbmcsIFByb2dyZXNzUmluZyk7XHJcbiAgICAvKipcclxuICAgICAqIEFuIElUZW1wbGF0ZUNvbnRyb2wgZm9yIHNob3dpbmcgaW5jcmVtZW50YWwgcHJvZ3Jlc3MuXHJcbiAgICAgKi9cclxuICAgIHZhciBQcm9ncmVzc0JhciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFByb2dyZXNzQmFyLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFByb2dyZXNzQmFyKCkge1xyXG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBIVE1MIHRlbXBsYXRlIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZVN0cmluZyA9ICc8ZGl2IGNsYXNzPVwicGxhdC1wcm9ncmVzcy1jb250YWluZXJcIj5cXG4nICtcclxuICAgICAgICAgICAgICAgICcgICAgPGRpdiBjbGFzcz1cInBsYXQtYW5pbWF0ZWQtYmFyXCI+PC9kaXY+XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnPC9kaXY+XFxuJztcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gdGhhdCB3aWxsIHN0b3AgbGlzdGVuaW5nIGZvciB2aXNpYmlsaXR5IGlmIGFwcGxpY2FibGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVWaXNpYmlsaXR5TGlzdGVuZXIgPSBub29wO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBjbGFzc2VzIG9uIHRoZSBwcm9wZXIgZWxlbWVudHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZT8gQW4gb3B0aW9uYWwsIGFkZGl0aW9uYWwgY2xhc3MgbmFtZSBvciBjbGFzcyBuYW1lcyB0byBzZXQgb24gdGhlIGNvbnRyb2xcclxuICAgICAgICAgKiBpbiBhZGRpdGlvbiB0byBpdHMgc3RhbmRhcmQgc2V0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudD8gVGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBjbGFzcyBuYW1lIG9uLiBTaG91bGQgZGVmYXVsdCB0b1xyXG4gICAgICAgICAqIHRoZSBjb250cm9sJ3MgZWxlbWVudCBpZiBub3Qgc3BlY2lmaWVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb2dyZXNzQmFyLnByb3RvdHlwZS5zZXRDbGFzc2VzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSwgZWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRDbGFzcyhlbGVtZW50IHx8IHRoaXMuZWxlbWVudCwgX19Qcm9ncmVzc0JhciArIFwiIFwiICsgKGNsYXNzTmFtZSB8fCAnJykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IHRoZSBjbGFzcyBuYW1lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb2dyZXNzQmFyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldENsYXNzZXMoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdyYWJzIHRoZSBiYXIgZWxlbWVudCB0aGVuIHNldHMgYW55IGluaXRpYWwgcHJvZ3Jlc3MuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvZ3Jlc3NCYXIucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5fYmFyRWxlbWVudCA9IHRoaXMuZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZC5maXJzdEVsZW1lbnRDaGlsZDtcclxuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHRoaXMuX3dpbmRvdywgJ3Jlc2l6ZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNldFByb2dyZXNzKF90aGlzLmNvbnRleHQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5zZXRQcm9ncmVzcyh0aGlzLmNvbnRleHQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyB0aGUgdmlzaWJpbGl0eSBsaXN0ZW5lciBpZiBhcHBsaWNhYmxlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb2dyZXNzQmFyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVWaXNpYmlsaXR5TGlzdGVuZXIoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuaW1hdGVzIHRoZSBiYXIgb24gYSBjb250ZXh0IGNoYW5nZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvZ3Jlc3NCYXIucHJvdG90eXBlLmNvbnRleHRDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldFByb2dyZXNzKHRoaXMuY29udGV4dCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBwcm9ncmVzcyBiYXIgdmFsdWUuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBkZWNpbWFsIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEgdG8gc2V0IGFzIHRoZVxyXG4gICAgICAgICAqIGJhciBwZXJjZW50YWdlIChlLmcuIC0gMC41IHdvdWxkIGJlIDUwJSBjb21wbGV0ZSkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvZ3Jlc3NCYXIucHJvdG90eXBlLnNldFByb2dyZXNzID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5fUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnV0aWxzLmlzTnVtYmVyKHZhbHVlKSB8fCB2YWx1ZSA+IDEgfHwgdmFsdWUgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IFwiVGhlIHZhbHVlIG9mIGEgXFxcIlwiICsgX3RoaXMudHlwZSArIFwiXFxcIiBjb250cm9sIG11c3QgYmUgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuZGVidWcobXNnKTtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QobXNnKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgYmFyRWxlbWVudCA9IF90aGlzLl9iYXJFbGVtZW50LCBiYXJNYXggPSBiYXJFbGVtZW50LnBhcmVudEVsZW1lbnQuY2xpZW50V2lkdGg7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWJhck1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZW1vdmVWaXNpYmlsaXR5TGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVtb3ZlVmlzaWJpbGl0eUxpc3RlbmVyID0gX3RoaXMuZG9tLndoZW5WaXNpYmxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0UHJvZ3Jlc3ModmFsdWUpLnRoZW4ocmVzb2x2ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgX3RoaXMuZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2FuaW1hdG9yLmFuaW1hdGUoYmFyRWxlbWVudCwgX19UcmFuc2l0aW9uLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogTWF0aC5jZWlsKGJhck1heCAqIHZhbHVlKSArIFwicHhcIlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFByb2dyZXNzQmFyLl9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgIF93aW5kb3c6IF9fV2luZG93LFxyXG4gICAgICAgICAgICBfUHJvbWlzZTogX19Qcm9taXNlLFxyXG4gICAgICAgICAgICBfYW5pbWF0b3I6IF9fQW5pbWF0b3JcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBQcm9ncmVzc0JhcjtcclxuICAgIH0ocGxhdC51aS5UZW1wbGF0ZUNvbnRyb2wpKTtcclxuICAgIHBsYXR1aS5Qcm9ncmVzc0JhciA9IFByb2dyZXNzQmFyO1xyXG4gICAgcGxhdC5yZWdpc3Rlci5jb250cm9sKF9fUHJvZ3Jlc3NCYXIsIFByb2dyZXNzQmFyKTtcclxuICAgIC8qKlxyXG4gICAgICogQW4gQmluZENvbnRyb2wgdGhhdCBhY3RzIGFzIGEgZ2xvYmFsIGRyYXdlci5cclxuICAgICAqL1xyXG4gICAgdmFyIERyYXdlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKERyYXdlciwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBEcmF3ZXIoKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBwcm9taXNlIHRoYXQgc2lnbmlmaWVzIHRoZSBEcmF3ZXIgaXMgcmVhZHkgZm9yIGEgcGFpcmluZy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMucmVhZHkgPSB0aGlzLl9Qcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlZmVyZW5jZXMgdG8gYWxsIHRoZSBEcmF3ZXJDb250cm9sbGVycyB1c2VkIHRvIGNvbnRyb2wgdGhpcyBEcmF3ZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9jb250cm9sbGVycyA9IFtdO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIHRoaXMgY29udHJvbCBoYXMgYmVlbiBwYWlyZWQgd2l0aCBhIGNvcnJlc3BvbmRpbmcgRHJhd2VyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBib3VuZCB2YWx1ZSB0aGF0IG1heSBoYXZlIGNvbWUgdGhyb3VnaCBwcmlvciB0byBpbml0aWFsaXphdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX3ByZUluaXRpYWxpemVkVmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgcHJpdmF0ZSB2YXJpYWJsZSB0aGF0IHRlbGxzIHRoZSBEcmF3ZXIgaXRzIGxhc3Qgb3BlbiBvciBjbG9zZWQgc3RhdGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9fc3RhdGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgcHJpdmF0ZSB2YXJpYWJsZSB0aGF0IHRlbGxzIHRoZSBEcmF3ZXIgaXRzIG5leHQgb3BlbiBvciBjbG9zZWQgc3RhdGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9fbmV4dFN0YXRlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGNsYXNzZXMgb24gdGhlIHByb3BlciBlbGVtZW50cy5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lPyBBbiBvcHRpb25hbCwgYWRkaXRpb25hbCBjbGFzcyBuYW1lIG9yIGNsYXNzIG5hbWVzIHRvIHNldCBvbiB0aGUgY29udHJvbFxyXG4gICAgICAgICAqIGluIGFkZGl0aW9uIHRvIGl0cyBzdGFuZGFyZCBzZXQuXHJcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50PyBUaGUgZWxlbWVudCB0byBzZXQgdGhlIGNsYXNzIG5hbWUgb24uIFNob3VsZCBkZWZhdWx0IHRvXHJcbiAgICAgICAgICogdGhlIGNvbnRyb2wncyBlbGVtZW50IGlmIG5vdCBzcGVjaWZpZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyLnByb3RvdHlwZS5zZXRDbGFzc2VzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSwgZWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRDbGFzcyhlbGVtZW50IHx8IHRoaXMuZWxlbWVudCwgX19EcmF3ZXIgKyBcIiBcIiArIChjbGFzc05hbWUgfHwgJycpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0aGUgY2xhc3MgbmFtZSBhbmQgaGlkZXMgdGhlIGVsZW1lbnQgYW5kXHJcbiAgICAgICAgICogcmVtb3ZlcyB0aGUgaW5uZXJIVE1MIGZyb20gdGhlIERPTSBhbmQgc2F2ZXMgaXQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldENsYXNzZXMoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgdGhlIGlubmVySFRNTCBmcm9tIHRoZSBET00gYW5kIHNhdmVzIGl0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlci5wcm90b3R5cGUuc2V0VGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5uZXJUZW1wbGF0ZSA9IHRoaXMuZG9tLmFwcGVuZENoaWxkcmVuKHRoaXMuZWxlbWVudC5jaGlsZE5vZGVzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrIGZvciBhIHBvc2l0aW9uIGFuZCBpbml0aWFsaXplIGV2ZW50IGhhbmRsaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlci5wcm90b3R5cGUubG9hZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCwgdXRpbHMgPSB0aGlzLnV0aWxzLCBvcHRpb25PYmogPSB0aGlzLm9wdGlvbnMgfHwge30sIG9wdGlvbnMgPSBvcHRpb25PYmoudmFsdWUgfHwge30sIHBvc2l0aW9uID0gdGhpcy5fY3VycmVudFBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbiB8fCAnbGVmdCcsIGlkID0gb3B0aW9ucy5pZCB8fCAnJywgdGVtcGxhdGVVcmwgPSBvcHRpb25zLnRlbXBsYXRlVXJsLCBpc0VsYXN0aWMgPSBvcHRpb25zLmVsYXN0aWMgPT09IHRydWU7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKF9fSGlkZSwgJycpO1xyXG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRDbGFzcyhlbGVtZW50LCBfX1BsYXQgKyBwb3NpdGlvbik7XHJcbiAgICAgICAgICAgIGlmICh1dGlscy5pc1N0cmluZyh0ZW1wbGF0ZVVybCkpIHtcclxuICAgICAgICAgICAgICAgIHBsYXQudWkuVGVtcGxhdGVDb250cm9sLmRldGVybWluZVRlbXBsYXRlKHRoaXMsIHRlbXBsYXRlVXJsKS50aGVuKGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmlubmVyVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faW5pdGlhbGl6ZUV2ZW50cyhpZCwgcG9zaXRpb24sIGlzRWxhc3RpYyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplRXZlbnRzKGlkLCBwb3NpdGlvbiwgaXNFbGFzdGljKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE9wZW5zIHRoZSBEcmF3ZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY29udHJvbGxlciA9IHRoaXMuX2NvbnRyb2xsZXJzWzBdO1xyXG4gICAgICAgICAgICBpZiAodGhpcy51dGlscy5pc051bGwoY29udHJvbGxlcikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhcIk5vIGNvbnRyb2xsZXIsIHN1Y2ggYXMgYSBcIiArIF9fRHJhd2VyQ29udHJvbGxlciArIFwiLCBmb3VuZCBmb3IgdGhlIFwiICsgdGhpcy50eXBlICsgXCIgYXR0ZW1wdGluZyB0byBvcGVuLlwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5vcGVuKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbG9zZXMgdGhlIERyYXdlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY29udHJvbGxlciA9IHRoaXMuX2NvbnRyb2xsZXJzWzBdO1xyXG4gICAgICAgICAgICBpZiAodGhpcy51dGlscy5pc051bGwoY29udHJvbGxlcikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhcIk5vIGNvbnRyb2xsZXIsIHN1Y2ggYXMgYSBcIiArIF9fRHJhd2VyQ29udHJvbGxlciArIFwiLCBmb3VuZCBmb3IgdGhlIFwiICsgdGhpcy50eXBlICsgXCIgYXR0ZW1wdGluZyB0byBjbG9zZS5cIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuY2xvc2UoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRvZ2dsZXMgdGhlIERyYXdlcidzIG9wZW4vY2xvc2VkIHN0YXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlci5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY29udHJvbGxlciA9IHRoaXMuX2NvbnRyb2xsZXJzWzBdO1xyXG4gICAgICAgICAgICBpZiAodGhpcy51dGlscy5pc051bGwoY29udHJvbGxlcikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhcIk5vIGNvbnRyb2xsZXIsIHN1Y2ggYXMgYSBcIiArIF9fRHJhd2VyQ29udHJvbGxlciArIFwiLCBmb3VuZCBmb3IgdGhlIFwiICsgdGhpcy50eXBlICsgXCIgYXR0ZW1wdGluZyB0byB0b2dnbGUuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLnRvZ2dsZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIERyYXdlciBpcyBjdXJyZW50bHkgb3Blbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXIucHJvdG90eXBlLmlzT3BlbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSB0aGlzLl9jb250cm9sbGVyc1swXTtcclxuICAgICAgICAgICAgaWYgKHRoaXMudXRpbHMuaXNOdWxsKGNvbnRyb2xsZXIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoXCJObyBjb250cm9sbGVyLCBzdWNoIGFzIGEgXCIgKyBfX0RyYXdlckNvbnRyb2xsZXIgKyBcIiwgZm91bmQgZm9yIHRoZSBcIiArIHRoaXMudHlwZSArIFwiIGF0dGVtcHRpbmcgdG8gY2hlY2sgaWYgb3Blbi5cIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuaXNPcGVuKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGFuZCBiaW5kcyB0aGUgYWRkZWQgSFRNTCB0ZW1wbGF0ZSB0byB0aGlzIGNvbnRyb2wncyBpbmhlcml0ZWQgY29udGV4dC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgdGVtcGxhdGUgbmFtZSB0byBib3RoIGFkZCBhbmQgYmluZC5cclxuICAgICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gYWRkIGFzIGEgYmluZGFibGUgdGVtcGxhdGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyLnByb3RvdHlwZS5iaW5kVGVtcGxhdGUgPSBmdW5jdGlvbiAobmFtZSwgbm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgYmluZGFibGVUZW1wbGF0ZXMgPSB0aGlzLmJpbmRhYmxlVGVtcGxhdGVzO1xyXG4gICAgICAgICAgICBiaW5kYWJsZVRlbXBsYXRlcy5hZGQobmFtZSwgbm9kZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBiaW5kYWJsZVRlbXBsYXRlcy5iaW5kKG5hbWUpLnRoZW4oZnVuY3Rpb24gKHRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IF90aGlzLmVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kb20uY2xlYXJOb2RlKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZCh0ZW1wbGF0ZSk7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5kZWJ1ZyhcIkVycm9yIGJpbmRpbmcgdGVtcGxhdGUgZm9yIFwiICsgX3RoaXMudHlwZSArIFwiOiBcIiArIGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgRHJhd2VyQ29udHJvbGxlcnMgbGlua2VkIHRvIHRoaXNcclxuICAgICAgICAgKiBEcmF3ZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyLnByb3RvdHlwZS5jb250cm9sbGVyQ291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250cm9sbGVycy5sZW5ndGg7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGEgc3BlY2lmaWVkIERyYXdlckNvbnRyb2xsZXIgZnJvbSB0aGlzIGNvbnRyb2wncyBBcnJheSBvZlxyXG4gICAgICAgICAqIGxpbmtlZCBEcmF3ZXJDb250cm9sbGVycy5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXR1aS5EcmF3ZXJDb250cm9sbGVyfSBjb250cm9sbGVyIFRoZSBEcmF3ZXJDb250cm9sbGVyXHJcbiAgICAgICAgICogdG8gc3BsaWNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlci5wcm90b3R5cGUuc3BsaWNlQ29udHJvbGxlciA9IGZ1bmN0aW9uIChjb250cm9sbGVyKSB7XHJcbiAgICAgICAgICAgIHZhciBjb250cm9sbGVycyA9IHRoaXMuX2NvbnRyb2xsZXJzLCBpbmRleCA9IGNvbnRyb2xsZXJzLmluZGV4T2YoY29udHJvbGxlcik7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9fc3RhdGUgPSB0aGlzLl9fbmV4dFN0YXRlID0gY29udHJvbGxlcnNbaW5kZXhdLmlzT3BlbigpO1xyXG4gICAgICAgICAgICBjb250cm9sbGVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBmdW5jdGlvbiB0aGF0IGFsbG93cyB0aGlzIGNvbnRyb2wgdG8gb2JzZXJ2ZSBib3RoIHRoZSBib3VuZCBwcm9wZXJ0eSBpdHNlbGYgYXMgd2VsbCBhc1xyXG4gICAgICAgICAqIHBvdGVudGlhbCBjaGlsZCBwcm9wZXJ0aWVzIGlmIGJlaW5nIGJvdW5kIHRvIGFuIG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQub2JzZXJ2YWJsZS5JSW1wbGVtZW50VHdvV2F5QmluZGluZ30gYmluZGVyIFRoZSBjb250cm9sIHRoYXQgZmFjaWxpdGF0ZXMgdGhlXHJcbiAgICAgICAgICogZGF0YWJpbmRpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyLnByb3RvdHlwZS5vYnNlcnZlUHJvcGVydGllcyA9IGZ1bmN0aW9uIChiaW5kZXIpIHtcclxuICAgICAgICAgICAgYmluZGVyLm9ic2VydmVQcm9wZXJ0eSh0aGlzLl9zZXRCb3VuZFByb3BlcnR5KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgYmluZGFibGUgcHJvcGVydHkgaXMgc2V0IGV4dGVybmFsbHkuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBuZXdWYWx1ZSBUaGUgbmV3IHZhbHVlIG9mIHRoZSBjb250cm9sIHN0YXRlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBvZiB0aGUgYmluZGFibGUgY29udHJvbCBzdGF0ZS5cclxuICAgICAgICAgKiBAcGFyYW0ge3ZvaWR9IGlkZW50aWZpZXIgVGhlIGNoaWxkIGlkZW50aWZpZXIgb2YgdGhlIHByb3BlcnR5IGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlyc3RUaW1lPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsIHRvIGJpbmQgdGhlIHByb3BlcnR5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlci5wcm90b3R5cGUuX3NldEJvdW5kUHJvcGVydHkgPSBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlLCBpZGVudGlmaWVyLCBmaXJzdFRpbWUpIHtcclxuICAgICAgICAgICAgdmFyIHV0aWxzID0gdGhpcy51dGlscywgY29udHJvbGxlciA9IHRoaXMuX2NvbnRyb2xsZXJzWzBdO1xyXG4gICAgICAgICAgICBpZiAoZmlyc3RUaW1lID09PSB0cnVlICYmIHV0aWxzLmlzTnVsbChuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRDaGFuZ2VkKHV0aWxzLmlzTnVsbChjb250cm9sbGVyKSA/IGZhbHNlIDogY29udHJvbGxlci5pc09wZW4oKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGRyYXdlclN0YXRlID0gISFuZXdWYWx1ZTtcclxuICAgICAgICAgICAgaWYgKGRyYXdlclN0YXRlICE9PSBuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dENoYW5nZWQoZHJhd2VyU3RhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNJbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJlSW5pdGlhbGl6ZWRWYWx1ZSA9IGRyYXdlclN0YXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHV0aWxzLmlzTnVsbChjb250cm9sbGVyKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX25leHRTdGF0ZSA9IGRyYXdlclN0YXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRyYXdlclN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlci5pc09wZW4oKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIub3BlbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRyb2xsZXIuaXNPcGVuKCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hhbmdlcyB0aGUgcGxhY2VtZW50IGFuZCBpbXBsaWVkIHBvc2l0aW9uIG9mIHRoZSBEcmF3ZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBvc2l0aW9uIFRoZSBuZXcgcG9zaXRpb24gdG8gY2hhbmdlIHRvLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlci5wcm90b3R5cGUuX2NoYW5nZURpcmVjdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy51dGlscy5pc051bGwocG9zaXRpb24pIHx8IHBvc2l0aW9uID09PSB0aGlzLl9jdXJyZW50UG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZG9tID0gdGhpcy5kb20sIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhlbGVtZW50LCBfX1BsYXQgKyB0aGlzLl9jdXJyZW50UG9zaXRpb24pO1xyXG4gICAgICAgICAgICBkb20uYWRkQ2xhc3MoZWxlbWVudCwgX19QbGF0ICsgcG9zaXRpb24pO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50UG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpemVzIGFuZCBkaXNwYXRjaGVzIHB1YiBzdWIgZXZlbnRzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgb2YgdGhpcyBEcmF3ZXIgaWYgdXNlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcG9zaXRpb24gVGhlIHBvc2l0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNFbGFzdGljIFdoZXRoZXIgb3Igbm90IHRoZSBEcmF3ZXIgaGFzIGFuXHJcbiAgICAgICAgICogZWxhc3RpYyB0cmFuc2l0aW9uIGVmZmVjdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXIucHJvdG90eXBlLl9pbml0aWFsaXplRXZlbnRzID0gZnVuY3Rpb24gKGlkLCBwb3NpdGlvbiwgaXNFbGFzdGljKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciB1dGlscyA9IHRoaXMudXRpbHMsIGlubmVyVGVtcGxhdGUgPSB0aGlzLmlubmVyVGVtcGxhdGU7XHJcbiAgICAgICAgICAgIHRoaXMub24oX19EcmF3ZXJDb250cm9sbGVyRmV0Y2hFdmVudCArIFwiX1wiICsgaWQsIGZ1bmN0aW9uIChldmVudCwgY29udHJvbGxlckFyZykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSBjb250cm9sbGVyQXJnLmNvbnRyb2w7XHJcbiAgICAgICAgICAgICAgICBpZiAodXRpbHMuaXNOdWxsKGNvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKGNvbnRyb2xsZXJBcmcucG9zaXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBjb250cm9sbGVyQXJnLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9jaGFuZ2VEaXJlY3Rpb24ocG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2NvbnRyb2xsZXJzLnVuc2hpZnQoY29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRyb2xsZXJBcmcucmVjZWl2ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWFkeS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChfX0RyYXdlckZvdW5kRXZlbnQgKyBcIl9cIiArIGlkLCBwbGF0LmV2ZW50cy5FdmVudE1hbmFnZXIuRElSRUNULCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sOiBfdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IHV0aWxzLmlzTm9kZShpbm5lclRlbXBsYXRlKSA/IGlubmVyVGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsYXN0aWM6IGlzRWxhc3RpYyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBfdGhpcy5fX3N0YXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlOiBfdGhpcy5fX25leHRTdGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmICghY29udHJvbGxlckFyZy51c2VDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYmluZFRlbXBsYXRlKCdkcmF3ZXInLCBpbm5lclRlbXBsYXRlLmNsb25lTm9kZSh0cnVlKSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9jaGVja1ByZUluaXQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fY2hlY2tQcmVJbml0KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoX19EcmF3ZXJGb3VuZEV2ZW50ICsgXCJfXCIgKyBpZCwgcGxhdC5ldmVudHMuRXZlbnRNYW5hZ2VyLkRJUkVDVCwge1xyXG4gICAgICAgICAgICAgICAgY29udHJvbDogdGhpcyxcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcclxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiB1dGlscy5pc05vZGUoaW5uZXJUZW1wbGF0ZSkgPyBpbm5lclRlbXBsYXRlLmNsb25lTm9kZSh0cnVlKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBlbGFzdGljOiBpc0VsYXN0aWMsXHJcbiAgICAgICAgICAgICAgICBzdGF0ZTogdGhpcy5fX3N0YXRlLFxyXG4gICAgICAgICAgICAgICAgbmV4dFN0YXRlOiB0aGlzLl9fbmV4dFN0YXRlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2tzIHRoZSBwcmUtaW5pdGlhbGl6ZWQgdmFsdWUgYW5kIGhhbmRsZXMgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyLnByb3RvdHlwZS5fY2hlY2tQcmVJbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcHJlSW5pdGlhbGl6ZWRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHV0aWxzXzEgPSB0aGlzLnV0aWxzO1xyXG4gICAgICAgICAgICAgICAgdXRpbHNfMS5wb3N0cG9uZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSBfdGhpcy5fY29udHJvbGxlcnNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1dGlsc18xLmlzTnVsbChjb250cm9sbGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLm9wZW4oKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgRHJhd2VyLl9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgIF9Qcm9taXNlOiBfX1Byb21pc2VcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBEcmF3ZXI7XHJcbiAgICB9KHBsYXQudWkuQmluZENvbnRyb2wpKTtcclxuICAgIHBsYXR1aS5EcmF3ZXIgPSBEcmF3ZXI7XHJcbiAgICBwbGF0LnJlZ2lzdGVyLmNvbnRyb2woX19EcmF3ZXIsIERyYXdlcik7XHJcbiAgICAvKipcclxuICAgICAqIEFuIEJpbmRDb250cm9sIHRoYXQgbWFuaXB1bGF0ZXMgYW5kIGNvbnRyb2xzIGEgZ2xvYmFsIGRyYXdlci5cclxuICAgICAqL1xyXG4gICAgdmFyIERyYXdlckNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhEcmF3ZXJDb250cm9sbGVyLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIERyYXdlckNvbnRyb2xsZXIoKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIHVzZXIgaGFzIHN3aXBlZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2hhc1N3aXBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIHVzZXIgaGFzIHRhcHBlZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2hhc1RhcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIERyYXdlciBpcyBvcGVuLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5faXNPcGVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBbiBlbnVtIGRlbm90aW5nIHRoZSBjdXJyZW50IHRvdWNoIHN0YXRlIG9mIHRoZSB1c2VyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fdG91Y2hTdGF0ZSA9IDA7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGV0aGVyIHRoZSBjb3JyZXNwb25kaW5nIERyYXdlciBpcyB2ZXJ0aWNhbCBvciBob3Jpem9udGFsLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5faXNWZXJ0aWNhbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBmdW5jdGlvbiBmb3IgcmVtb3ZpbmcgdGhlIGNsaWNrIGVhdGVyIHNjcm9sbCBsaXN0ZW5pbmcgZXZlbnQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVDbGlja0VhdGVyTGlzdGVuZXIgPSBub29wO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBmdW5jdGlvbiB0byByZW1vdmUgdGhlIHRvZ2dsZSBkZWxheSBpZiBwcmVzZW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlRGVsYXkgPSBub29wO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIHRoaXMgY29udHJvbCBoYXMgYmVlbiBwYWlyZWQgd2l0aCBhIGNvcnJlc3BvbmRpbmcgRHJhd2VyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBjbGFzc2VzIG9uIHRoZSBwcm9wZXIgZWxlbWVudHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZT8gQW4gb3B0aW9uYWwsIGFkZGl0aW9uYWwgY2xhc3MgbmFtZSBvciBjbGFzcyBuYW1lcyB0byBzZXQgb24gdGhlIGNvbnRyb2xcclxuICAgICAgICAgKiBpbiBhZGRpdGlvbiB0byBpdHMgc3RhbmRhcmQgc2V0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudD8gVGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBjbGFzcyBuYW1lIG9uLiBTaG91bGQgZGVmYXVsdCB0b1xyXG4gICAgICAgICAqIHRoZSBjb250cm9sJ3MgZWxlbWVudCBpZiBub3Qgc3BlY2lmaWVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlckNvbnRyb2xsZXIucHJvdG90eXBlLnNldENsYXNzZXMgPSBmdW5jdGlvbiAoY2xhc3NOYW1lLCBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZENsYXNzKGVsZW1lbnQgfHwgdGhpcy5lbGVtZW50LCBfX0RyYXdlckNvbnRyb2xsZXIgKyBcIiBcIiArIChjbGFzc05hbWUgfHwgJycpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGNsYXNzIG5hbWUgb24gdGhlIGVsZW1lbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyQ29udHJvbGxlci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5kb20uYWRkQ2xhc3ModGhpcy5lbGVtZW50LCBfX0RyYXdlckNvbnRyb2xsZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZSB0aGUgdHJhY2sgZXZlbnRzIG9uIHRoZSBlbGVtZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlckNvbnRyb2xsZXIucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbk9iaiA9IHRoaXMub3B0aW9ucyB8fCB7fSwgb3B0aW9ucyA9IG9wdGlvbk9iai52YWx1ZSB8fCB7fSwgcG9zaXRpb24gPSBvcHRpb25zLnBvc2l0aW9uLCBpZCA9IG9wdGlvbnMuaWQgfHwgJyc7XHJcbiAgICAgICAgICAgIHRoaXMuX3R5cGUgPSBvcHRpb25zLnR5cGUgfHwgJ3RhcCB0cmFjayc7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzRWxhc3RpYyA9IG9wdGlvbnMuZWxhc3RpYztcclxuICAgICAgICAgICAgdGhpcy5fdXNlQ29udGV4dCA9IG9wdGlvbnMudXNlQ29udGV4dCA9PT0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGVVcmwgPSBvcHRpb25zLnRlbXBsYXRlVXJsO1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplRXZlbnRzKGlkLCBwb3NpdGlvbik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmUgdGhlIHRyYW5zaXRpb24gY2xhc3NlcyBvZmYgdGhlIHJvb3QgZWxlbWVudCBhbmQgcmVzZXQgdGhlIHBvc2l0aW9uIGFuZFxyXG4gICAgICAgICAqIHpJbmRleCBwcm9wZXJ0aWVzIGlmIG1vZGlmaWVkIGFuZCBvbmx5IGlmIHRoaXMgaXMgdGhlIGxhc3QgRHJhd2VyQ29udHJvbGxlclxyXG4gICAgICAgICAqIHJlZmVyZW5jaW5nIHRoaXMgRHJhd2VyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlckNvbnRyb2xsZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICB2YXIgZHJhd2VyID0gdGhpcy5fZHJhd2VyO1xyXG4gICAgICAgICAgICBpZiAodGhpcy51dGlscy5pc051bGwoZHJhd2VyKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkcmF3ZXIuY29udHJvbGxlckNvdW50KCkgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBkcmF3ZXIuc3BsaWNlQ29udHJvbGxlcih0aGlzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9pc09wZW4pIHtcclxuICAgICAgICAgICAgICAgIGRyYXdlci5yZWFkeSA9IHRoaXMuY2xvc2UoKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBkcmF3ZXIuc3BsaWNlQ29udHJvbGxlcihfdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRyYXdlci5jb250cm9sbGVyQ291bnQoKSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY2xlYW5Sb290RWxlbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZHJhd2VyLnJlYWR5LnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZHJhd2VyLnNwbGljZUNvbnRyb2xsZXIoX3RoaXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRyYXdlci5jb250cm9sbGVyQ291bnQoKSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fY2xlYW5Sb290RWxlbWVudCgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE9wZW5zIHRoZSBEcmF3ZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyQ29udHJvbGxlci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIHdhc0Nsb3NlZCA9ICF0aGlzLl9pc09wZW4sIHV0aWxzID0gdGhpcy51dGlscztcclxuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlRGVsYXkoKTtcclxuICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgdGhpcy5fUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3RvZ2dsZURlbGF5ID0gdXRpbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fb3BlbigpLnRoZW4ocmVzb2x2ZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICh3YXNDbG9zZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkcmF3ZXIgPSB0aGlzLl9kcmF3ZXI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0Q2hhbmdlZCh0cnVlKTtcclxuICAgICAgICAgICAgICAgIGlmICghdXRpbHMuaXNOdWxsKGRyYXdlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBkcmF3ZXIuaW5wdXRDaGFuZ2VkKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xvc2VzIHRoZSBEcmF3ZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyQ29udHJvbGxlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciB3YXNPcGVuID0gdGhpcy5faXNPcGVuLCB1dGlscyA9IHRoaXMudXRpbHM7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZURlbGF5KCk7XHJcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IHRoaXMuX1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl90b2dnbGVEZWxheSA9IHV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Nsb3NlKCkudGhlbihyZXNvbHZlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKHdhc09wZW4pIHtcclxuICAgICAgICAgICAgICAgIHZhciBkcmF3ZXIgPSB0aGlzLl9kcmF3ZXI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0Q2hhbmdlZChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXV0aWxzLmlzTnVsbChkcmF3ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZHJhd2VyLnJlYWR5ID0gcHJvbWlzZTtcclxuICAgICAgICAgICAgICAgICAgICBkcmF3ZXIuaW5wdXRDaGFuZ2VkKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRvZ2dsZXMgdGhlIERyYXdlcidzIG9wZW4vY2xvc2VkIHN0YXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlckNvbnRyb2xsZXIucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzT3Blbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcGVuKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgRHJhd2VyIGlzIGN1cnJlbnRseSBvcGVuLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlckNvbnRyb2xsZXIucHJvdG90eXBlLmlzT3BlbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzT3BlbjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJpbmRzIHRoZSBhZGRlZCBIVE1MIHRlbXBsYXRlIHRvIHRoaXMgY29udHJvbCdzIGluaGVyaXRlZCBjb250ZXh0IGFuZFxyXG4gICAgICAgICAqIHBsYWNlcyB0aGUgbm9kZSBpbnRvIHRoZSBEcmF3ZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIHRlbXBsYXRlIG5hbWUgdG8gYmluZC5cclxuICAgICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gYWRkIGFzIGEgYmluZGFibGUgdGVtcGxhdGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyQ29udHJvbGxlci5wcm90b3R5cGUuYmluZFRlbXBsYXRlID0gZnVuY3Rpb24gKG5hbWUsIG5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGJpbmRhYmxlVGVtcGxhdGVzID0gdGhpcy5iaW5kYWJsZVRlbXBsYXRlcztcclxuICAgICAgICAgICAgYmluZGFibGVUZW1wbGF0ZXMuYWRkKG5hbWUsIG5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gYmluZGFibGVUZW1wbGF0ZXMuYmluZChuYW1lKS50aGVuKGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBfdGhpcy5fZHJhd2VyRWxlbWVudDtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRvbS5jbGVhck5vZGUoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHRlbXBsYXRlKTtcclxuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmRlYnVnKFwiRXJyb3IgYmluZGluZyB0ZW1wbGF0ZSBmb3IgXCIgKyBfdGhpcy50eXBlICsgXCI6IFwiICsgZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgdGhpcyBjb250cm9sIHRvIG9ic2VydmUgYm90aCB0aGUgYm91bmQgcHJvcGVydHkgaXRzZWxmIGFzIHdlbGwgYXNcclxuICAgICAgICAgKiBwb3RlbnRpYWwgY2hpbGQgcHJvcGVydGllcyBpZiBiZWluZyBib3VuZCB0byBhbiBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0Lm9ic2VydmFibGUuSUltcGxlbWVudFR3b1dheUJpbmRpbmd9IGJpbmRlciBUaGUgY29udHJvbCB0aGF0IGZhY2lsaXRhdGVzIHRoZVxyXG4gICAgICAgICAqIGRhdGFiaW5kaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlckNvbnRyb2xsZXIucHJvdG90eXBlLm9ic2VydmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGJpbmRlcikge1xyXG4gICAgICAgICAgICBiaW5kZXIub2JzZXJ2ZVByb3BlcnR5KHRoaXMuX3NldEJvdW5kUHJvcGVydHkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSBiaW5kYWJsZSBwcm9wZXJ0eSBpcyBzZXQgZXh0ZXJuYWxseS5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG5ld1ZhbHVlIFRoZSBuZXcgdmFsdWUgb2YgdGhlIGNvbnRyb2wncyBzdGF0ZS5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgb2YgdGhlIGJpbmRhYmxlIGNvbnRyb2wgc3RhdGUuXHJcbiAgICAgICAgICogQHBhcmFtIHt2b2lkfSBpZGVudGlmaWVyIFRoZSBjaGlsZCBpZGVudGlmaWVyIG9mIHRoZSBwcm9wZXJ0eSBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpcnN0VGltZT8gV2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCB0byBiaW5kIHRoZSBwcm9wZXJ0eS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXJDb250cm9sbGVyLnByb3RvdHlwZS5fc2V0Qm91bmRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUsIGlkZW50aWZpZXIsIGZpcnN0VGltZSkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgdXRpbHMgPSB0aGlzLnV0aWxzO1xyXG4gICAgICAgICAgICBpZiAoZmlyc3RUaW1lID09PSB0cnVlICYmIHV0aWxzLmlzTnVsbChuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRDaGFuZ2VkKHRoaXMuX2lzT3Blbik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGRyYXdlclN0YXRlID0gISFuZXdWYWx1ZTtcclxuICAgICAgICAgICAgaWYgKGRyYXdlclN0YXRlICE9PSBuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dENoYW5nZWQoZHJhd2VyU3RhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNJbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJlSW5pdGlhbGl6ZWRWYWx1ZSA9IGRyYXdlclN0YXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRyYXdlclN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNPcGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9nZ2xlRGVsYXkoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RvZ2dsZURlbGF5ID0gdXRpbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fb3BlbigpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5faXNPcGVuKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b2dnbGVEZWxheSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgdGhpcy5fUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl90b2dnbGVEZWxheSA9IHV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoX3RoaXMuX2Nsb3NlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSksIGRyYXdlciA9IHRoaXMuX2RyYXdlcjtcclxuICAgICAgICAgICAgICAgIGlmICghdXRpbHMuaXNOdWxsKGRyYXdlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBkcmF3ZXIucmVhZHkgPSBwcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBPcGVucyB0aGUgRHJhd2VyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVzZXQ/IFdoZXRoZXIgdGhlIG9wZW4gaXMgYmVpbmcgY2FsbGVkIHRvIHJlc2V0IHRoZSBvcGVuIHN0YXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlckNvbnRyb2xsZXIucHJvdG90eXBlLl9vcGVuID0gZnVuY3Rpb24gKHJlc2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciByb290RWxlbWVudCA9IHRoaXMuX3Jvb3RFbGVtZW50LCBpc05vZGUgPSB0aGlzLnV0aWxzLmlzTm9kZSwgaXNPcGVuID0gdGhpcy5faXNPcGVuLCBvZmZzZXQgPSB0aGlzLl9nZXRPZmZzZXQoKTtcclxuICAgICAgICAgICAgaWYgKChpc09wZW4gJiYgIXJlc2V0KSB8fCAhKG9mZnNldCAmJiBpc05vZGUocm9vdEVsZW1lbnQpICYmIGlzTm9kZSh0aGlzLl9kcmF3ZXJFbGVtZW50KSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdHJhbnNsYXRpb247XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uID0gXCJ0cmFuc2xhdGUzZChcIiArIG9mZnNldCArIFwicHgsMCwwKVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uID0gXCJ0cmFuc2xhdGUzZChcIiArICgtb2Zmc2V0KSArIFwicHgsMCwwKVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbiA9IFwidHJhbnNsYXRlM2QoMCxcIiArIG9mZnNldCArIFwicHgsMClcIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb24gPSBcInRyYW5zbGF0ZTNkKDAsXCIgKyAoLW9mZnNldCkgKyBcInB4LDApXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9pc09wZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRDbGFzcyhyb290RWxlbWVudCwgdGhpcy5fZGlyZWN0aW9uYWxUcmFuc2l0aW9uUHJlcCk7XHJcbiAgICAgICAgICAgIGlmICghaXNPcGVuKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRDbGlja0VhdGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbk9wdGlvbnMgPSB7fTtcclxuICAgICAgICAgICAgYW5pbWF0aW9uT3B0aW9uc1t0aGlzLl90cmFuc2Zvcm1dID0gdHJhbnNsYXRpb247XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbmltYXRpb25UaGVuYWJsZSA9IHRoaXMuX2FuaW1hdG9yLmFuaW1hdGUocm9vdEVsZW1lbnQsIF9fVHJhbnNpdGlvbiwge1xyXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczogYW5pbWF0aW9uT3B0aW9uc1xyXG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9hbmltYXRpb25UaGVuYWJsZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fZHJhd2VyRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIF9fcHJldmVudERlZmF1bHQsIGZhbHNlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbG9zZXMgdGhlIERyYXdlci5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlc2V0PyBXaGV0aGVyIHRoZSBvcGVuIGlzIGJlaW5nIGNhbGxlZCB0byByZXNldCB0aGUgb3BlbiBzdGF0ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXJDb250cm9sbGVyLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbiAocmVzZXQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIHJvb3RFbGVtZW50ID0gdGhpcy5fcm9vdEVsZW1lbnQsIGlzTm9kZSA9IHRoaXMudXRpbHMuaXNOb2RlLCBpc0Nsb3NlZCA9ICF0aGlzLl9pc09wZW47XHJcbiAgICAgICAgICAgIGlmICgoaXNDbG9zZWQgJiYgIXJlc2V0KSB8fCAhKGlzTm9kZShyb290RWxlbWVudCkgJiYgaXNOb2RlKHRoaXMuX2RyYXdlckVsZW1lbnQpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2lzT3BlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICBhbmltYXRpb25PcHRpb25zW3RoaXMuX3RyYW5zZm9ybV0gPSB0aGlzLl9wcmVUcmFuc2Zvcm07XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbmltYXRpb25UaGVuYWJsZSA9IHRoaXMuX2FuaW1hdG9yLmFuaW1hdGUocm9vdEVsZW1lbnQsIF9fVHJhbnNpdGlvbiwge1xyXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczogYW5pbWF0aW9uT3B0aW9uc1xyXG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9hbmltYXRpb25UaGVuYWJsZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fZHJhd2VyRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIF9fcHJldmVudERlZmF1bHQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5faXNPcGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMuX3RvdWNoU3RhdGUgPCAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlbW92ZUNsaWNrRWF0ZXIoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXNldHMgdGhlIERyYXdlciB0byBpdCdzIGN1cnJlbnQgb3Blbi9jbG9zZWQgc3RhdGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyQ29udHJvbGxlci5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNPcGVuKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3Blbih0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX2Nsb3NlKHRydWUpLCBkcmF3ZXIgPSB0aGlzLl9kcmF3ZXI7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy51dGlscy5pc051bGwoZHJhd2VyKSkge1xyXG4gICAgICAgICAgICAgICAgZHJhd2VyLnJlYWR5ID0gcHJvbWlzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBjbGljayBlYXRlciB3aGVuIHRyYWNraW5nIGFuZCBjbG9zaW5nIGFuIG9wZW4gRHJhd2VyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlckNvbnRyb2xsZXIucHJvdG90eXBlLl9hZGRDbGlja0VhdGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgY2xpY2tFYXRlciA9IHRoaXMuX2NsaWNrRWF0ZXIsIHN0eWxlID0gY2xpY2tFYXRlci5zdHlsZSwgcm9vdEVsZW1lbnQgPSB0aGlzLl9yb290RWxlbWVudDtcclxuICAgICAgICAgICAgaWYgKHJvb3RFbGVtZW50LmNvbnRhaW5zKGNsaWNrRWF0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYWxpZ24gY2xpY2tFYXRlciB0byBmaWxsIHRoZSByb290RWxlbWVudCBcclxuICAgICAgICAgICAgc3R5bGUudG9wID0gcm9vdEVsZW1lbnQuc2Nyb2xsVG9wICsgXCJweFwiO1xyXG4gICAgICAgICAgICBzdHlsZS5sZWZ0ID0gcm9vdEVsZW1lbnQuc2Nyb2xsTGVmdCArIFwicHhcIjtcclxuICAgICAgICAgICAgcm9vdEVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNsaWNrRWF0ZXIsIG51bGwpO1xyXG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRDbGFzcyh0aGlzLl9yb290RWxlbWVudCwgdGhpcy5fZGlyZWN0aW9uYWxUcmFuc2l0aW9uUHJlcCk7XHJcbiAgICAgICAgICAgIHZhciByZW1vdmVTY3JvbGwsIHJlbW92ZVJlcXVlc3QgPSBub29wLCByZWFkeSA9IHRydWU7XHJcbiAgICAgICAgICAgIHJlbW92ZVNjcm9sbCA9IHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihyb290RWxlbWVudCwgJ3Njcm9sbCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcmVhZHkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZWFkeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlUmVxdWVzdCA9IF90aGlzLnV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gY2xpY2tFYXRlci5zdHlsZTtcclxuICAgICAgICAgICAgICAgICAgICByZWFkeSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxpZ24gY2xpY2tFYXRlciB0byBmaWxsIHRoZSByb290RWxlbWVudCBcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZS50b3AgPSByb290RWxlbWVudC5zY3JvbGxUb3AgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUubGVmdCA9IHJvb3RFbGVtZW50LnNjcm9sbExlZnQgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUNsaWNrRWF0ZXJMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZVJlcXVlc3QoKTtcclxuICAgICAgICAgICAgICAgIHJlbW92ZVNjcm9sbCgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyB0aGUgY2xpY2sgZWF0ZXIgYWZ0ZXIgY2xvc2luZyBhbiBvcGVuIERyYXdlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXJDb250cm9sbGVyLnByb3RvdHlwZS5fcmVtb3ZlQ2xpY2tFYXRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHJvb3RFbGVtZW50ID0gdGhpcy5fcm9vdEVsZW1lbnQsIGNsaWNrRWF0ZXIgPSB0aGlzLl9jbGlja0VhdGVyO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVDbGlja0VhdGVyTGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgaWYgKHJvb3RFbGVtZW50LmNvbnRhaW5zKGNsaWNrRWF0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICByb290RWxlbWVudC5yZW1vdmVDaGlsZChjbGlja0VhdGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmRvbS5yZW1vdmVDbGFzcyhyb290RWxlbWVudCwgdGhpcy5fZGlyZWN0aW9uYWxUcmFuc2l0aW9uUHJlcCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIHN3aXBlIGV2ZW50cyB0byB0aGUgY29udHJvbGxlciBlbGVtZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlckNvbnRyb2xsZXIucHJvdG90eXBlLl9hZGRTd2lwZVRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsIHJlbW92ZVN3aXBlT3BlbiA9IHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBfXyRzd2lwZSArIF9fdHJhbnNpdGlvbk5lZ2F0ZVt0aGlzLl9wb3NpdGlvbl0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9oYXNTd2lwZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMub3BlbigpO1xyXG4gICAgICAgICAgICB9LCBmYWxzZSksIHJlbW92ZVN3aXBlQ2xvc2UgPSB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgX18kc3dpcGUgKyB0aGlzLl9wb3NpdGlvbiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2hhc1N3aXBlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVN3aXBlVG9nZ2xlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlU3dpcGVPcGVuKCk7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVTd2lwZUNsb3NlKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIHN3aXBlIGNsb3NlIGV2ZW50IHRvIHRoZSByb290IGVsZW1lbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyQ29udHJvbGxlci5wcm90b3R5cGUuX2FkZFN3aXBlQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoaXMuX29wZW5Td2lwZVJlbW92ZXIgPSB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5fY2xpY2tFYXRlciwgX18kc3dpcGUgKyB0aGlzLl9wb3NpdGlvbiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2hhc1N3aXBlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9LCBmYWxzZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIHRhcCB0b2dnbGUgZXZlbnQgdG8gdGhlIGNvbnRyb2xsZXIgZWxlbWVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXJDb250cm9sbGVyLnByb3RvdHlwZS5fYWRkVGFwVG9nZ2xlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVUYXAgPSB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5lbGVtZW50LCBfXyR0YXAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9oYXNUYXBwZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudG9nZ2xlKCk7XHJcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgdGFwIGNsb3NlIGV2ZW50IHRvIHRoZSByb290IGVsZW1lbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyQ29udHJvbGxlci5wcm90b3R5cGUuX2FkZFRhcENsb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLl9vcGVuVGFwUmVtb3ZlciA9IHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9jbGlja0VhdGVyLCBfXyR0YXAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9oYXNUYXBwZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcclxuICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBwcmltYXJ5IGFuZCBzZWNvbmRhcnkgdHJhY2tpbmcgZXZlbnRzIHRvIHRoZSBEcmF3ZXJDb250cm9sbGVyIGVsZW1lbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyQ29udHJvbGxlci5wcm90b3R5cGUuX2FkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCwgaXNOdWxsID0gdGhpcy51dGlscy5pc051bGwsIHR5cGVzID0gdGhpcy5fdHlwZS5zcGxpdCgnICcpLCBwb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uO1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgZXZlbnQgbGlzdGVuZXJzIGhlcmUgZmlyc3QgaWYgd2Ugd2FudCB0byBsYXRlciBiZSBhYmxlIHRvIGR5bmFtaWNhbGx5IGNoYW5nZSBwb3NpdGlvbiBvZiBkcmF3ZXIuIFxyXG4gICAgICAgICAgICAvLyB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpOyBcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzVGFwID0gKHR5cGVzLmluZGV4T2YoJ3RhcCcpICE9PSAtMSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRhcFRvZ2dsZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkVGFwQ2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNTd2lwZSA9ICh0eXBlcy5pbmRleE9mKCdzd2lwZScpICE9PSAtMSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFN3aXBlVG9nZ2xlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRTd2lwZUNsb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzVHJhY2sgPSAodHlwZXMuaW5kZXhPZigndHJhY2snKSAhPT0gLTEpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhY2tGbiA9IHRoaXMuX3RyYWNrLCB0cmFja0RpcmVjdGlvbiA9IHZvaWQgMCwgY2xpY2tFYXRlciA9IHRoaXMuX2NsaWNrRWF0ZXI7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja0RpcmVjdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICd0b3AnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja0RpcmVjdGlvbiA9ICd1cCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrRGlyZWN0aW9uID0gJ2Rvd24nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJpbWFyeVRyYWNrID0gX18kdHJhY2sgKyBfX3RyYW5zaXRpb25OZWdhdGVbdHJhY2tEaXJlY3Rpb25dLCBzZWNvbmRhcnlUcmFjayA9IF9fJHRyYWNrICsgdHJhY2tEaXJlY3Rpb24sIHJlbW92ZVByaW1hcnlUcmFja18xID0gdGhpcy5hZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsIHByaW1hcnlUcmFjaywgdHJhY2tGbiwgZmFsc2UpLCByZW1vdmVTZWNvbmRhcnlUcmFja18xID0gdGhpcy5hZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsIHNlY29uZGFyeVRyYWNrLCB0cmFja0ZuLCBmYWxzZSksIG9wZW5UcmFja1ByaW1hcnlSZW1vdmVyXzEgPSB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoY2xpY2tFYXRlciwgcHJpbWFyeVRyYWNrLCB0cmFja0ZuLCBmYWxzZSksIG9wZW5UcmFja1NlY29uZGFyeVJlbW92ZXJfMSA9IHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihjbGlja0VhdGVyLCBzZWNvbmRhcnlUcmFjaywgdHJhY2tGbiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlVHJhY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlUHJpbWFyeVRyYWNrXzEoKTtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVTZWNvbmRhcnlUcmFja18xKCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fb3BlblRyYWNrUmVtb3ZlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcGVuVHJhY2tQcmltYXJ5UmVtb3Zlcl8xKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlblRyYWNrU2Vjb25kYXJ5UmVtb3Zlcl8xKCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbCh0aGlzLl9sYXN0VG91Y2gpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvdWNoU3RhcnQgPSB0aGlzLl90b3VjaFN0YXJ0LCB0b3VjaEVuZCA9IHRoaXMuX3RvdWNoRW5kO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RUb3VjaCA9IHsgeDogMCwgeTogMCB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBfXyR0b3VjaHN0YXJ0LCB0b3VjaFN0YXJ0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsIF9fJHRvdWNoZW5kLCB0b3VjaEVuZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBfXyR0cmFja2VuZCwgdG91Y2hFbmQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoY2xpY2tFYXRlciwgX18kdG91Y2hzdGFydCwgdG91Y2hTdGFydCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihjbGlja0VhdGVyLCBfXyR0cmFja2VuZCwgdG91Y2hFbmQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoY2xpY2tFYXRlciwgX18kdG91Y2hlbmQsIHRvdWNoRW5kLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHRoaXMuX3dpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX2hhbmRsZVJlc2l6ZSwgZmFsc2UpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSGFuZGxlcyBhIFdpbmRvdyByZXNpemUgZXZlbnQgYnkgY2xvc2luZyB0aGUgRHJhd2VyIGltbWVkaWF0ZWx5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlckNvbnRyb2xsZXIucHJvdG90eXBlLl9oYW5kbGVSZXNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNPcGVuKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGlzTnVsbCA9IHRoaXMudXRpbHMuaXNOdWxsLCByb290RWxlbWVudCA9IHRoaXMuX3Jvb3RFbGVtZW50LCBkcmF3ZXIgPSB0aGlzLl9kcmF3ZXI7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzT3BlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0Q2hhbmdlZChmYWxzZSk7XHJcbiAgICAgICAgICAgIGlmICghaXNOdWxsKHJvb3RFbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQuc3R5bGVbdGhpcy5fdHJhbnNmb3JtXSA9IHRoaXMuX3ByZVRyYW5zZm9ybTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbChkcmF3ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBkcmF3ZXIuaW5wdXRDaGFuZ2VkKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdlckVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBfX3ByZXZlbnREZWZhdWx0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX3RvdWNoU3RhdGUgPCAyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVDbGlja0VhdGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgYWxsIGV2ZW50IGxpc3RlbmVycy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXJDb250cm9sbGVyLnByb3RvdHlwZS5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gdGhpcy51dGlscy5pc0Z1bmN0aW9uO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNUYXApIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXMuX3JlbW92ZVRhcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVUYXAoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVUYXAgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpcy5fb3BlblRhcFJlbW92ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3BlblRhcFJlbW92ZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcGVuVGFwUmVtb3ZlciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzVHJhY2spIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXMuX3JlbW92ZVRyYWNrKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVRyYWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlVHJhY2sgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpcy5fb3BlblRyYWNrUmVtb3ZlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcGVuVHJhY2tSZW1vdmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3BlblRyYWNrUmVtb3ZlciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzU3dpcGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXMuX3JlbW92ZVN3aXBlVG9nZ2xlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVN3aXBlVG9nZ2xlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlU3dpcGVUb2dnbGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpcy5fb3BlblN3aXBlUmVtb3ZlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcGVuU3dpcGVSZW1vdmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3BlblN3aXBlUmVtb3ZlciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExvZyB3aGVuIHRoZSB1c2VyIHRvdWNoZXMgdGhlIERyYXdlckNvbnRyb2xsZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklHZXN0dXJlRXZlbnR9IGV2IFRoZSB0b3VjaCBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXJDb250cm9sbGVyLnByb3RvdHlwZS5fdG91Y2hTdGFydCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdG91Y2hTdGF0ZSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoU3RhdGUgPSAxO1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0VG91Y2ggPSB7XHJcbiAgICAgICAgICAgICAgICB4OiBldi5jbGllbnRYLFxyXG4gICAgICAgICAgICAgICAgeTogZXYuY2xpZW50WVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlICR0b3VjaGVuZCBhbmQgJHRyYWNrZW5kIGV2ZW50IGhhbmRsZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklHZXN0dXJlRXZlbnR9IGV2IFRoZSB0b3VjaCBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXJDb250cm9sbGVyLnByb3RvdHlwZS5fdG91Y2hFbmQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgdmFyIG5vVG91Y2ggPSB0aGlzLl90b3VjaFN0YXRlID09PSAwLCBoYXNTd2lwZWQgPSB0aGlzLl9oYXNTd2lwZWQsIGhhc1RhcHBlZCA9IHRoaXMuX2hhc1RhcHBlZDtcclxuICAgICAgICAgICAgdGhpcy5faGFzU3dpcGVkID0gdGhpcy5faGFzVGFwcGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoU3RhdGUgPSAwO1xyXG4gICAgICAgICAgICBpZiAoaGFzVGFwcGVkIHx8IG5vVG91Y2ggfHwgaGFzU3dpcGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlTW92ZWQgPSB0aGlzLl9pc1ZlcnRpY2FsID8gZXYuY2xpZW50WSAtIHRoaXMuX2xhc3RUb3VjaC55IDogZXYuY2xpZW50WCAtIHRoaXMuX2xhc3RUb3VjaC54O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNSaWdodERpcmVjdGlvbihkaXN0YW5jZU1vdmVkKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX2dldE9mZnNldCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChNYXRoLmFicyhkaXN0YW5jZU1vdmVkKSA+IE1hdGguY2VpbChvZmZzZXQgLyAyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzZXQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9pc0VsYXN0aWMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhkaXN0YW5jZU1vdmVkKSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLl9pc09wZW4pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUNsaWNrRWF0ZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlICR0cmFjayBldmVudCBoYW5kbGVyLiBVc2VkIGZvciB0cmFja2luZyBvbmx5IGhvcml6b250YWwgb3IgdmVydGljYWwgdHJhY2tpbmcgbW90aW9uc1xyXG4gICAgICAgICAqIGRlcGVuZGluZyBvbiB0aGUgZGVmaW5lZCBwb3NpdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSUdlc3R1cmVFdmVudH0gZXYgVGhlICR0cmFja2luZyBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXJDb250cm9sbGVyLnByb3RvdHlwZS5fdHJhY2sgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIHRvdWNoU3RhdGUgPSB0aGlzLl90b3VjaFN0YXRlO1xyXG4gICAgICAgICAgICBpZiAodG91Y2hTdGF0ZSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRvdWNoU3RhdGUgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy51dGlscy5pc051bGwodGhpcy5fYW5pbWF0aW9uVGhlbmFibGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uVGhlbmFibGUuY2FuY2VsKCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hZGRDbGlja0VhdGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy51dGlscy5pc05vZGUoX3RoaXMuX2RyYXdlckVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZHJhd2VyRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIF9fcHJldmVudERlZmF1bHQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkQ2xpY2tFYXRlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnV0aWxzLmlzTm9kZSh0aGlzLl9kcmF3ZXJFbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmF3ZXJFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgX19wcmV2ZW50RGVmYXVsdCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3RvdWNoU3RhdGUgPSAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudXRpbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9yb290RWxlbWVudC5zdHlsZVtfdGhpcy5fdHJhbnNmb3JtXSA9IF90aGlzLl9jYWxjdWxhdGVUcmFuc2xhdGlvbihldik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2tzIHRvIG1ha2Ugc3VyZSB0aGUgdXNlciBoYXMgYmVlbiB0cmFja2luZyBpbiB0aGUgcmlnaHQgZGlyZWN0aW9uIHRvXHJcbiAgICAgICAgICogdG9nZ2xlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZU1vdmVkIFRoZSBkaXN0YW5jZSB0aGUgdXNlcidzIHBvaW50ZXIgaGFzIG1vdmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlckNvbnRyb2xsZXIucHJvdG90eXBlLl9pc1JpZ2h0RGlyZWN0aW9uID0gZnVuY3Rpb24gKGRpc3RhbmNlTW92ZWQpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICd0b3AnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc09wZW4gPyBkaXN0YW5jZU1vdmVkIDwgMCA6IGRpc3RhbmNlTW92ZWQgPiAwO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faXNPcGVuID8gZGlzdGFuY2VNb3ZlZCA+IDAgOiBkaXN0YW5jZU1vdmVkIDwgMDtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSB0cmFuc2xhdGlvbiB2YWx1ZSBmb3Igc2V0dGluZyB0aGUgdHJhbnNmb3JtIHZhbHVlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JR2VzdHVyZUV2ZW50fSBldiBUaGUgJHRyYWNraW5nIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlckNvbnRyb2xsZXIucHJvdG90eXBlLl9jYWxjdWxhdGVUcmFuc2xhdGlvbiA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fZ2V0T2Zmc2V0KCksIGRpc3RhbmNlTW92ZWQ7XHJcbiAgICAgICAgICAgIGlmICghb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJlVHJhbnNmb3JtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlTW92ZWQgPSB0aGlzLl9jaGVja0VsYXN0aWNpdHkob2Zmc2V0LCBldi5jbGllbnRYIC0gdGhpcy5fbGFzdFRvdWNoLngpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZU1vdmVkID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcmVUcmFuc2Zvcm07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInRyYW5zbGF0ZTNkKFwiICsgZGlzdGFuY2VNb3ZlZCArIFwicHgsMCwwKVwiO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlTW92ZWQgPSB0aGlzLl9jaGVja0VsYXN0aWNpdHkob2Zmc2V0LCB0aGlzLl9sYXN0VG91Y2gueCAtIGV2LmNsaWVudFgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZU1vdmVkID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcmVUcmFuc2Zvcm07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInRyYW5zbGF0ZTNkKFwiICsgKC1kaXN0YW5jZU1vdmVkKSArIFwicHgsMCwwKVwiO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcclxuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZU1vdmVkID0gdGhpcy5fY2hlY2tFbGFzdGljaXR5KG9mZnNldCwgZXYuY2xpZW50WSAtIHRoaXMuX2xhc3RUb3VjaC55KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2VNb3ZlZCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJlVHJhbnNmb3JtO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUzZCgwLFwiICsgZGlzdGFuY2VNb3ZlZCArIFwicHgsMClcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2VNb3ZlZCA9IHRoaXMuX2NoZWNrRWxhc3RpY2l0eShvZmZzZXQsIHRoaXMuX2xhc3RUb3VjaC55IC0gZXYuY2xpZW50WSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlTW92ZWQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByZVRyYW5zZm9ybTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlM2QoMCxcIiArICgtZGlzdGFuY2VNb3ZlZCkgKyBcInB4LDApXCI7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcmVUcmFuc2Zvcm07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyBmb3IgZWxhc3RpY2l0eSBhbmQgcG90ZW50aWFsbHkgcmVhZGp1c3RzIHRoZSB1c2VyJ3NcclxuICAgICAgICAgKiBkaXN0YW5jZSBtb3ZlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4T2Zmc2V0IFRoZSBtYXhpbXVtIGRpc3RhbmNlIHRoZSBjb3JyZXNwb25kaW5nIERyYXdlciBjYW4gdHJhbnNsYXRlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YSBUaGUgZGlzdGFuY2UgdGhlIHVzZXIncyBmaW5nZXIgbW92ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyQ29udHJvbGxlci5wcm90b3R5cGUuX2NoZWNrRWxhc3RpY2l0eSA9IGZ1bmN0aW9uIChtYXhPZmZzZXQsIGRlbHRhKSB7XHJcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZU1vdmVkID0gdGhpcy5faXNPcGVuID8gbWF4T2Zmc2V0ICsgZGVsdGEgOiBkZWx0YTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzRWxhc3RpYykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpc3RhbmNlTW92ZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlTW92ZWQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBkaXN0YW5jZU1vdmVkID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkaXN0YW5jZU1vdmVkID4gbWF4T2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICBkaXN0YW5jZU1vdmVkID0gbWF4T2Zmc2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkaXN0YW5jZU1vdmVkO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgYW5kIGRpc3BhdGNoZXMgcHViIHN1YiBldmVudHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBJRCBvZiB0aGlzIERyYXdlckNvbnRyb2xsZXIgaWYgdXNlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcG9zaXRpb24gVGhlIHBvc2l0aW9uIG9mIHRoZSBEcmF3ZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyQ29udHJvbGxlci5wcm90b3R5cGUuX2luaXRpYWxpemVFdmVudHMgPSBmdW5jdGlvbiAoaWQsIHBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciB1c2VDb250ZXh0ID0gdGhpcy5fdXNlQ29udGV4dCwgZXZlbnRSZW1vdmVyID0gdGhpcy5vbihfX0RyYXdlckZvdW5kRXZlbnQgKyBcIl9cIiArIGlkLCBmdW5jdGlvbiAoZXZlbnQsIGRyYXdlckFyZykge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRSZW1vdmVyKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdXRpbHMgPSBfdGhpcy51dGlscywgaXNTdHJpbmcgPSB1dGlscy5pc1N0cmluZywgaXNVbmRlZmluZWQgPSB1dGlscy5pc1VuZGVmaW5lZCwgZHJhd2VyID0gKF90aGlzLl9kcmF3ZXIgPSBkcmF3ZXJBcmcuY29udHJvbCkgfHwge30sIGRyYXdlckVsZW1lbnQgPSBfdGhpcy5fZHJhd2VyRWxlbWVudCA9IGRyYXdlci5lbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1N0cmluZyhwb3NpdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcoZHJhd2VyQXJnLnBvc2l0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGRyYXdlckFyZy5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuZGVidWcoKFwiXFxcInBvc2l0aW9uXFxcIiBpcyBpbmNvcnJlY3RseSBkZWZpbmVkIGZvciBhIGNvbnRyb2wgc3VjaCBhcyBcXFwiXCIgKyBfX0RyYXdlciArIFwiXFxcIiBcIikgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwib3IgXFxcIlwiICsgX3RoaXMudHlwZSArIFwiLlxcXCIgUGxlYXNlIGVuc3VyZSBpdCBpcyBhIHN0cmluZy5cIikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZHJhd2VyRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoX19IaWRlKTtcclxuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX2NvbnRyb2xsZXJJc1ZhbGlkKHBvc2l0aW9uLnRvTG93ZXJDYXNlKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3NldFRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoX3RoaXMuX2lzRWxhc3RpYykpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faXNFbGFzdGljID0gZHJhd2VyQXJnLmVsYXN0aWMgPT09IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRyYXdlckFyZy5yZWNlaXZlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoX19EcmF3ZXJDb250cm9sbGVyRmV0Y2hFdmVudCArIFwiX1wiICsgaWQsIHBsYXQuZXZlbnRzLkV2ZW50TWFuYWdlci5ESVJFQ1QsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbDogX3RoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUNvbnRleHQ6IHVzZUNvbnRleHRcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChkcmF3ZXJBcmcuc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faXNPcGVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbnB1dENoYW5nZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkcmF3ZXJBcmcubmV4dFN0YXRlICYmIHV0aWxzLmlzTnVsbChfdGhpcy5fcHJlSW5pdGlhbGl6ZWRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3ByZUluaXRpYWxpemVkVmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkcmF3ZXJBcmcubmV4dFN0YXRlICYmIHV0aWxzLmlzTnVsbChfdGhpcy5fcHJlSW5pdGlhbGl6ZWRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcHJlSW5pdGlhbGl6ZWRWYWx1ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZmluaXNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY2hlY2tQcmVJbml0KCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaWYgKCF1c2VDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2RldGVybWluZVRlbXBsYXRlKGRyYXdlckFyZy50ZW1wbGF0ZSkudGhlbihmaW5pc2gpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KF9fRHJhd2VyQ29udHJvbGxlckZldGNoRXZlbnQgKyBcIl9cIiArIGlkLCBwbGF0LmV2ZW50cy5FdmVudE1hbmFnZXIuRElSRUNULCB7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sOiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgdXNlQ29udGV4dDogdXNlQ29udGV4dFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyB0aGUgcHJlLWluaXRpYWxpemVkIHZhbHVlIGFuZCBoYW5kbGVzIGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlckNvbnRyb2xsZXIucHJvdG90eXBlLl9jaGVja1ByZUluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX3ByZUluaXRpYWxpemVkVmFsdWUsIHV0aWxzID0gdGhpcy51dGlscywgaXNOdWxsID0gdXRpbHMuaXNOdWxsO1xyXG4gICAgICAgICAgICBpZiAoaXNOdWxsKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpc09wZW4gPSB0aGlzLl9pc09wZW47XHJcbiAgICAgICAgICAgIGlmIChpc09wZW4gJiYgdmFsdWUgfHwgIShpc09wZW4gfHwgdmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlRGVsYXkoKTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b2dnbGVEZWxheSA9IHV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9vcGVuLmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IHRoaXMuX1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl90b2dnbGVEZWxheSA9IHV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShfdGhpcy5fY2xvc2UoKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSksIGRyYXdlciA9IHRoaXMuX2RyYXdlcjtcclxuICAgICAgICAgICAgaWYgKCFpc051bGwoZHJhd2VyKSkge1xyXG4gICAgICAgICAgICAgICAgZHJhd2VyLnJlYWR5ID0gcHJvbWlzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGV0ZXJtaW5lcyB0aGUgcHJvcGVyIEhUTUwgdGVtcGxhdGUsIGJpbmRzIGl0LCBhbmQgaW5zZXJ0cyBpdCBpZiBuZWVkZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtOb2RlfSBmcmFnbWVudD8gQSBOb2RlIHRvIGluc2VydCBhcyB0aGUgRHJhd2VyJ3MgSFRNTCB0ZW1wbGF0ZVxyXG4gICAgICAgICAqIGlmIG5vIHRlbXBsYXRlVXJsIGlzIHByZXNlbnQgb24gdGhpcyBEcmF3ZXJDb250cm9sbGVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlckNvbnRyb2xsZXIucHJvdG90eXBlLl9kZXRlcm1pbmVUZW1wbGF0ZSA9IGZ1bmN0aW9uIChmcmFnbWVudCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgdXRpbHMgPSB0aGlzLnV0aWxzO1xyXG4gICAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcodGhpcy5fdGVtcGxhdGVVcmwpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGxhdC51aS5UZW1wbGF0ZUNvbnRyb2wuZGV0ZXJtaW5lVGVtcGxhdGUodGhpcywgdGhpcy5fdGVtcGxhdGVVcmwpLnRoZW4oZnVuY3Rpb24gKHRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmJpbmRUZW1wbGF0ZSgnZHJhd2VyJywgdGVtcGxhdGUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodXRpbHMuaXNOb2RlKGZyYWdtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmluZFRlbXBsYXRlKCdkcmF3ZXInLCBmcmFnbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT2J0YWlucyB0aGUgY3VycmVudCBicm93c2VyJ3MgdHJhbnNmb3JtIHByb3BlcnR5IHZhbHVlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlckNvbnRyb2xsZXIucHJvdG90eXBlLl9zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuX3Jvb3RFbGVtZW50LnN0eWxlLCBpc1VuZGVmaW5lZCA9IHRoaXMudXRpbHMuaXNVbmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHZhciB2ZW5kb3JQcmVmaXggPSB0aGlzLl9jb21wYXQudmVuZG9yUHJlZml4O1xyXG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX3ByZVRyYW5zZm9ybSA9IHN0eWxlWyh2ZW5kb3JQcmVmaXgubG93ZXJDYXNlICsgXCJUcmFuc2Zvcm1cIildKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtID0gdmVuZG9yUHJlZml4Lmxvd2VyQ2FzZSArIFwiVHJhbnNmb3JtXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX3ByZVRyYW5zZm9ybSA9IHN0eWxlWyh2ZW5kb3JQcmVmaXgudXBwZXJDYXNlICsgXCJUcmFuc2Zvcm1cIildKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtID0gdmVuZG9yUHJlZml4LnVwcGVyQ2FzZSArIFwiVHJhbnNmb3JtXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm0gPSAndHJhbnNmb3JtJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoaXMgY29udHJvbCBoYXMgYWxsIHZhbGlkIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBvc2l0aW9uIFRoZSBwb3NpdGlvbiBvZiB0aGUgRHJhd2VyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlckNvbnRyb2xsZXIucHJvdG90eXBlLl9jb250cm9sbGVySXNWYWxpZCA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgdXRpbHMgPSB0aGlzLnV0aWxzLCBpc051bGwgPSB1dGlscy5pc051bGw7XHJcbiAgICAgICAgICAgIGlmIChpc051bGwodGhpcy5fZHJhd2VyRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhcIkNvdWxkIG5vdCBmaW5kIGEgY29ycmVzcG9uZGluZyBjb250cm9sIHN1Y2ggYXMgXFxcIlwiICsgX19EcmF3ZXIgKyBcIlxcXCIgZm9yIHRoaXMgXFxcIlwiICsgdGhpcy50eXBlICsgXCIuXFxcIlwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd0b3AnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc1ZlcnRpY2FsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhcIkluY29ycmVjdCBwb3NpdGlvbjogXFxcIlwiICsgcG9zaXRpb24gKyBcIlxcXCIgZGVmaW5lZCBmb3IgdGhlIGEgY29udHJvbCBzdWNoIGFzIGEgXFxcIlwiICsgX19EcmF3ZXIgKyBcIlxcXCIsIG9yIFxcXCJcIiArIHRoaXMudHlwZSArIFwiLlxcXCJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByb290RWxlbWVudCA9IHRoaXMuX3Jvb3RFbGVtZW50ID0gdGhpcy5fZ2V0Um9vdEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgaWYgKGlzTnVsbChyb290RWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhcIkNhbm5vdCBoYXZlIGEgXFxcIlwiICsgdGhpcy50eXBlICsgXCJcXFwiIGluIGEgaGllcmFyY2h5IGFib3ZlIHRoZSBjb3JyZXNwb25kaW5nIGNvbnRyb2wgc3VjaCBhcyBcXFwiXCIgKyBfX0RyYXdlciArIFwiLlxcXCJcIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xyXG4gICAgICAgICAgICBkb20uYWRkQ2xhc3Mocm9vdEVsZW1lbnQsIF9fRHJhd2VyICsgXCItcm9vdFwiKTtcclxuICAgICAgICAgICAgZG9tLmFkZENsYXNzKHRoaXMuZWxlbWVudCwgKHRoaXMuX2lzVmVydGljYWwgPyBfX1BsYXQgKyBcInZlcnRpY2FsXCIgOiBfX1BsYXQgKyBcImhvcml6b250YWxcIikpO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb25hbFRyYW5zaXRpb25QcmVwID0gX19EcmF3ZXIgKyBcIi10cmFuc2l0aW9uLVwiICsgcG9zaXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuX2NsaWNrRWF0ZXIgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgdGhpcy5fY2xpY2tFYXRlci5jbGFzc05hbWUgPSBfX1BsYXQgKyBcImNsaWNrZWF0ZXJcIjtcclxuICAgICAgICAgICAgdGhpcy5fc3R5bGVSb290RWxlbWVudCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE9idGFpbnMgdGhlIHJvb3QgZWxlbWVudCB0byB0cmFuc2xhdGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyQ29udHJvbGxlci5wcm90b3R5cGUuX2dldFJvb3RFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZHJhd2VyID0gdGhpcy5fZHJhd2VyLCB1dGlscyA9IHRoaXMudXRpbHM7XHJcbiAgICAgICAgICAgIGlmICghdXRpbHMuaXNOdWxsKGRyYXdlci5zdG9yZWRQcm9wZXJ0aWVzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRyYXdlci5zdG9yZWRQcm9wZXJ0aWVzLnJvb3RFbGVtZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpc05vZGUgPSB1dGlscy5pc05vZGUsIHJvb3QgPSB0aGlzLnJvb3QsIGVsZW1lbnQgPSB1dGlscy5pc09iamVjdChyb290KSAmJiBpc05vZGUocm9vdC5lbGVtZW50KSA/IHJvb3QuZWxlbWVudCA6IHRoaXMuZWxlbWVudCwgZHJhd2VyRWwgPSB0aGlzLl9kcmF3ZXJFbGVtZW50LCBwYXJlbnQ7XHJcbiAgICAgICAgICAgIHdoaWxlIChpc05vZGUocGFyZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50KSAmJiAhcGFyZW50LmNvbnRhaW5zKGRyYXdlckVsKSkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHBhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhhbmRsZXMgcm9vdCBlbGVtZW50IHN0eWxpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXJDb250cm9sbGVyLnByb3RvdHlwZS5fc3R5bGVSb290RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF93aW5kb3cgPSB0aGlzLl93aW5kb3csIHV0aWxzID0gdGhpcy51dGlscywgZHJhd2VyID0gdGhpcy5fZHJhd2VyLCByb290RWxlbWVudCA9IHRoaXMuX3Jvb3RFbGVtZW50LCBwYXJlbnQgPSByb290RWxlbWVudC5wYXJlbnRFbGVtZW50LCBjb21wdXRlZFN0eWxlID0gX3dpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHJvb3RFbGVtZW50KSwgc3R5bGUgPSByb290RWxlbWVudC5zdHlsZSwgcG9zaXRpb24gPSBjb21wdXRlZFN0eWxlLnBvc2l0aW9uLCB6SW5kZXggPSBOdW1iZXIoY29tcHV0ZWRTdHlsZS56SW5kZXgpLCByb290RWxlbWVudFN0eWxlID0ge1xyXG4gICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQ6IHJvb3RFbGVtZW50XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcclxuICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50U3R5bGUucG9zaXRpb24gPSBzdHlsZS5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIHN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXV0aWxzLmlzTnVtYmVyKHpJbmRleCkgfHwgekluZGV4IDwgMSkge1xyXG4gICAgICAgICAgICAgICAgcm9vdEVsZW1lbnRTdHlsZS56SW5kZXggPSBzdHlsZS56SW5kZXg7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS56SW5kZXggPSAnMSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHV0aWxzLmlzTm9kZShwYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29tcHV0ZWRQYXJlbnRTdHlsZSA9IF93aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpLCBvdmVyZmxvdyA9IGNvbXB1dGVkUGFyZW50U3R5bGUub3ZlcmZsb3c7XHJcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmZsb3cgIT09ICdoaWRkZW4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXB1dGVkRGlyZWN0aW9uYWxPdmVyZmxvdyA9IHZvaWQgMCwga2V5ID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1ZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9ICdvdmVyZmxvd1knO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlZERpcmVjdGlvbmFsT3ZlcmZsb3cgPSBjb21wdXRlZFBhcmVudFN0eWxlLm92ZXJmbG93WTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9ICdvdmVyZmxvd1gnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlZERpcmVjdGlvbmFsT3ZlcmZsb3cgPSBjb21wdXRlZFBhcmVudFN0eWxlLm92ZXJmbG93WDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXB1dGVkRGlyZWN0aW9uYWxPdmVyZmxvdyAhPT0gJ2hpZGRlbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudFN0eWxlID0gcGFyZW50LnN0eWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByb290RWxlbWVudFN0eWxlLnBhcmVudE92ZXJmbG93ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGFyZW50U3R5bGVba2V5XVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRTdHlsZVtrZXldID0gJ2hpZGRlbic7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRyYXdlci5zdG9yZWRQcm9wZXJ0aWVzID0gcm9vdEVsZW1lbnRTdHlsZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVuaW5pdGlhbGl6ZXMgdGhlIHJvb3QgZWxlbWVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXJDb250cm9sbGVyLnByb3RvdHlwZS5fY2xlYW5Sb290RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHV0aWxzID0gdGhpcy51dGlscywgaXNPYmplY3QgPSB1dGlscy5pc09iamVjdCwgaXNOb2RlID0gdXRpbHMuaXNOb2RlLCByb290RWxlbWVudCA9IHRoaXMuX3Jvb3RFbGVtZW50LCBkcmF3ZXIgPSB0aGlzLl9kcmF3ZXI7XHJcbiAgICAgICAgICAgIGlmICghaXNOb2RlKHJvb3RFbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZUNsYXNzKHJvb3RFbGVtZW50LCBfX0RyYXdlciArIFwiLXJvb3QgXCIgKyB0aGlzLl9kaXJlY3Rpb25hbFRyYW5zaXRpb25QcmVwKTtcclxuICAgICAgICAgICAgaWYgKHV0aWxzLmlzTnVsbChkcmF3ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHN0b3JlZFN0eWxlID0gZHJhd2VyLnN0b3JlZFByb3BlcnRpZXM7XHJcbiAgICAgICAgICAgIGlmICghaXNPYmplY3Qoc3RvcmVkU3R5bGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJvb3RFbGVtZW50U3R5bGUgPSByb290RWxlbWVudC5zdHlsZSwgcGFyZW50ID0gcm9vdEVsZW1lbnQucGFyZW50RWxlbWVudCwgb3ZlcmZsb3cgPSBzdG9yZWRTdHlsZS5wYXJlbnRPdmVyZmxvdztcclxuICAgICAgICAgICAgcm9vdEVsZW1lbnRTdHlsZS5wb3NpdGlvbiA9IHN0b3JlZFN0eWxlLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICByb290RWxlbWVudFN0eWxlLnpJbmRleCA9IHN0b3JlZFN0eWxlLnpJbmRleDtcclxuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KG92ZXJmbG93KSAmJiBpc05vZGUocGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50LnN0eWxlW292ZXJmbG93LmtleV0gPSBvdmVyZmxvdy52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWxldGUgZHJhd2VyLnN0b3JlZFByb3BlcnRpZXM7XHJcbiAgICAgICAgICAgIHRoaXMuX2RyYXdlckVsZW1lbnQuc2V0QXR0cmlidXRlKF9fSGlkZSwgJycpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgbWF4IG9mZnNldCB0byB0cmFuc2xhdGUgdGhlIGNvcnJlc3BvbmRpbmcgRHJhd2VyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlckNvbnRyb2xsZXIucHJvdG90eXBlLl9nZXRPZmZzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1ZlcnRpY2FsID8gdGhpcy5fZHJhd2VyRWxlbWVudC5vZmZzZXRIZWlnaHQgOiB0aGlzLl9kcmF3ZXJFbGVtZW50Lm9mZnNldFdpZHRoO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRHJhd2VyQ29udHJvbGxlci5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICBfZG9jdW1lbnQ6IF9fRG9jdW1lbnQsXHJcbiAgICAgICAgICAgIF93aW5kb3c6IF9fV2luZG93LFxyXG4gICAgICAgICAgICBfY29tcGF0OiBfX0NvbXBhdCxcclxuICAgICAgICAgICAgX2FuaW1hdG9yOiBfX0FuaW1hdG9yLFxyXG4gICAgICAgICAgICBfUHJvbWlzZTogX19Qcm9taXNlXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRHJhd2VyQ29udHJvbGxlcjtcclxuICAgIH0ocGxhdC51aS5CaW5kQ29udHJvbCkpO1xyXG4gICAgcGxhdHVpLkRyYXdlckNvbnRyb2xsZXIgPSBEcmF3ZXJDb250cm9sbGVyO1xyXG4gICAgcGxhdC5yZWdpc3Rlci5jb250cm9sKF9fRHJhd2VyQ29udHJvbGxlciwgRHJhd2VyQ29udHJvbGxlcik7XHJcbiAgICAvKipcclxuICAgICAqIEFuIEJpbmRDb250cm9sIGZvciBzaG93aW5nIGEgdGVtcGxhdGVkIGFuZCBhbmltYXRlZCBvdmVybGF5LlxyXG4gICAgICovXHJcbiAgICB2YXIgTW9kYWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhNb2RhbCwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY29uc3RydWN0b3IgZm9yIGEgTW9kYWwuIENyZWF0ZXMgdGhlIG1vZGFsTG9hZGVkIFByb21pc2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gTW9kYWwoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIEhUTUwgdGVtcGxhdGUgcmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlU3RyaW5nID0gdGhpcy5fX3RlbXBsYXRlU3RyaW5nO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIG1vZGFsIGlzIGN1cnJlbnRseSB2aXNpYmxlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5faXNWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIGZ1bmN0aW9uIHRvIHN0b3AgbGlzdGVuaW5nIHRvIHNjcm9sbCBldmVudHMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxSZW1vdmVyID0gbm9vcDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gdG8gc3RvcCBsaXN0ZW5pbmcgZm9yIERPTSBwcmVzZW5jZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX3ByZXNlbmNlUmVtb3ZlciA9IG5vb3A7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIG1vZGFsLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsVG9wID0gMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgaGFzaCBmb3IgdmFsaWRhdGluZyBhdmFpbGFibGUgdHJhbnNpdGlvbnMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uSGFzaCA9IHtcclxuICAgICAgICAgICAgICAgIHVwOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZG93bjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGxlZnQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICByaWdodDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGZhZGU6IHRydWVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBwcml2YXRlIHRlbXBsYXRlIHN0cmluZyB1c2VkIHRvIGNoZWNrIGZvciBhIHRlbXBsYXRlIG92ZXJ3cml0ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX190ZW1wbGF0ZVN0cmluZyA9ICc8ZGl2IGNsYXNzPVwicGxhdC1tb2RhbC1jb250YWluZXJcIj48L2Rpdj5cXG4nO1xyXG4gICAgICAgICAgICB0aGlzLm1vZGFsTG9hZGVkID0gbmV3IHRoaXMuX1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX19yZXNvbHZlRm4gPSByZXNvbHZlO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX19yZWplY3RGbiA9IHJlamVjdDtcclxuICAgICAgICAgICAgfSkuY2F0Y2gobm9vcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGNsYXNzZXMgb24gdGhlIHByb3BlciBlbGVtZW50cy5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lPyBBbiBvcHRpb25hbCwgYWRkaXRpb25hbCBjbGFzcyBuYW1lIG9yIGNsYXNzIG5hbWVzIHRvIHNldCBvbiB0aGUgY29udHJvbFxyXG4gICAgICAgICAqIGluIGFkZGl0aW9uIHRvIGl0cyBzdGFuZGFyZCBzZXQuXHJcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50PyBUaGUgZWxlbWVudCB0byBzZXQgdGhlIGNsYXNzIG5hbWUgb24uIFNob3VsZCBkZWZhdWx0IHRvXHJcbiAgICAgICAgICogdGhlIGNvbnRyb2wncyBlbGVtZW50IGlmIG5vdCBzcGVjaWZpZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTW9kYWwucHJvdG90eXBlLnNldENsYXNzZXMgPSBmdW5jdGlvbiAoY2xhc3NOYW1lLCBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZENsYXNzKGVsZW1lbnQgfHwgdGhpcy5lbGVtZW50LCBfX01vZGFsICsgXCIgXCIgKyBfX0hpZGUgKyBcIiBcIiArIChjbGFzc05hbWUgfHwgJycpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrIGZvciB0ZW1wbGF0ZVVybCBhbmQgc2V0IGlmIG5lZWRlZCB0aGVuIGhpZGUgdGhlIGNvbnRyb2wuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTW9kYWwucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBvcHRpb25PYmogPSB0aGlzLm9wdGlvbnMgfHwgKHRoaXMub3B0aW9ucyA9IHt9KSwgb3B0aW9ucyA9IG9wdGlvbk9iai52YWx1ZSB8fCAob3B0aW9uT2JqLnZhbHVlID0ge30pO1xyXG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlVXJsID0gb3B0aW9ucy50ZW1wbGF0ZVVybCB8fCB0aGlzLnRlbXBsYXRlVXJsO1xyXG4gICAgICAgICAgICB0aGlzLnNldENsYXNzZXMoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZCB0aGUgaW5uZXJUZW1wbGF0ZSB0byB0aGUgY29udHJvbCdzIGVsZW1lbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTW9kYWwucHJvdG90eXBlLnNldFRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy50ZW1wbGF0ZVN0cmluZyAhPT0gdGhpcy5fX3RlbXBsYXRlU3RyaW5nIHx8IHRoaXMudXRpbHMuaXNTdHJpbmcodGhpcy50ZW1wbGF0ZVVybCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkb20gPSB0aGlzLmRvbSwgZnJhZ21lbnQgPSBkb20uc2VyaWFsaXplSHRtbCh0aGlzLl9fdGVtcGxhdGVTdHJpbmcpLCBlbGVtZW50ID0gdGhpcy5lbGVtZW50LCBtb2RhbENvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlubmVyVGVtcGxhdGUgPSBkb20uYXBwZW5kQ2hpbGRyZW4oZWxlbWVudC5jaGlsZE5vZGVzKTtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVjayBmb3IgYSB0cmFuc2l0aW9uIGFuZCBpbml0aWFsaXplIGl0IGlmIG5lY2Vzc2FyeS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBNb2RhbC5wcm90b3R5cGUubG9hZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy52YWx1ZSwgdHJhbnNpdGlvbiA9IG9wdGlvbnMudHJhbnNpdGlvbiwgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcclxuICAgICAgICAgICAgLy8gaW4gY2FzZSBvZiBjbG9uaW5nIFxyXG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgfHwgZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZDtcclxuICAgICAgICAgICAgdGhpcy5fcHJlc2VuY2VSZW1vdmVyID0gdGhpcy5kb20ud2hlblByZXNlbnQodGhpcy5faW5qZWN0RWxlbWVudC5iaW5kKHRoaXMpLCBlbGVtZW50KTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnV0aWxzLmlzU3RyaW5nKHRyYW5zaXRpb24pIHx8IHRyYW5zaXRpb24gPT09ICdub25lJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb20uYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCBfX1BsYXQgKyBcIm5vLXRyYW5zaXRpb25cIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuX3RyYW5zaXRpb25IYXNoW3RyYW5zaXRpb25dKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoXCJDdXN0b20gdHJhbnNpdGlvbjogXFxcIlwiICsgdHJhbnNpdGlvbiArIFwiXFxcIiBkZWZpbmVkIGZvciBcXFwiXCIgKyB0aGlzLnR5cGUgKyBcIi5cXFwiIFBsZWFzZSBlbnN1cmUgdGhlIHRyYW5zaXRpb24gaXMgZGVmaW5lZCB0byBhdm9pZCBlcnJvcnMuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhbmltYXRpb25FdmVudHMgPSB0aGlzLl9jb21wYXQuYW5pbWF0aW9uRXZlbnRzO1xyXG4gICAgICAgICAgICBpZiAodGhpcy51dGlscy5pc051bGwoYW5pbWF0aW9uRXZlbnRzKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKCdUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBDU1MzIGFuaW1hdGlvbnMuJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsIF9fUGxhdCArIFwibm8tdHJhbnNpdGlvblwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uRW5kID0gYW5pbWF0aW9uRXZlbnRzLiR0cmFuc2l0aW9uRW5kO1xyXG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsIChfX1BsYXQgKyB0cmFuc2l0aW9uKSArIFwiIFwiICsgX19QbGF0ICsgXCJtb2RhbC10cmFuc2l0aW9uXCIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xlYW4gdXAgdGhlIGF1dG8gc2Nyb2xsLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE1vZGFsLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsUmVtb3ZlcigpO1xyXG4gICAgICAgICAgICB0aGlzLl9wcmVzZW5jZVJlbW92ZXIoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMudXRpbHMuaXNGdW5jdGlvbih0aGlzLl9fcmVqZWN0Rm4pKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fcmVqZWN0Rm4oKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19yZWplY3RGbiA9IHRoaXMuX19yZXNvbHZlRm4gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTaG93cyB0aGUgTW9kYWwuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTW9kYWwucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB3YXNIaWRkZW4gPSAhdGhpcy5faXNWaXNpYmxlLCBwcm9taXNlID0gdGhpcy5fc2hvdygpO1xyXG4gICAgICAgICAgICBpZiAod2FzSGlkZGVuKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0Q2hhbmdlZCh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhpZGVzIHRoZSBNb2RhbC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBNb2RhbC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHdhc1Zpc2libGUgPSB0aGlzLmlzVmlzaWJsZSwgcHJvbWlzZSA9IHRoaXMuX2hpZGUoKTtcclxuICAgICAgICAgICAgaWYgKHdhc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRDaGFuZ2VkKGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRvZ2dsZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIE1vZGFsLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE1vZGFsLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhpZGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaG93KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgTW9kYWwgaXMgY3VycmVudGx5IHZpc2libGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTW9kYWwucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVmlzaWJsZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgdGhpcyBjb250cm9sIHRvIG9ic2VydmUgYm90aCB0aGUgYm91bmQgcHJvcGVydHkgaXRzZWxmIGFzIHdlbGwgYXNcclxuICAgICAgICAgKiBwb3RlbnRpYWwgY2hpbGQgcHJvcGVydGllcyBpZiBiZWluZyBib3VuZCB0byBhbiBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0Lm9ic2VydmFibGUuSUltcGxlbWVudFR3b1dheUJpbmRpbmd9IGJpbmRlciBUaGUgY29udHJvbCB0aGF0IGZhY2lsaXRhdGVzIHRoZVxyXG4gICAgICAgICAqIGRhdGFiaW5kaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE1vZGFsLnByb3RvdHlwZS5vYnNlcnZlUHJvcGVydGllcyA9IGZ1bmN0aW9uIChiaW5kZXIpIHtcclxuICAgICAgICAgICAgYmluZGVyLm9ic2VydmVQcm9wZXJ0eSh0aGlzLl9zZXRCb3VuZFByb3BlcnR5KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgYmluZGFibGUgcHJvcGVydHkgaXMgc2V0IGV4dGVybmFsbHkuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBtb2RhbFN0YXRlIFRoZSBuZXcgdmFsdWUgb2YgdGhlIGNvbnRyb2wgc3RhdGUuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBvbGRWYWx1ZSBUaGUgb2xkIHZhbHVlIG9mIHRoZSBjb250cm9sIHN0YXRlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7dm9pZH0gaWRlbnRpZmllciBUaGUgY2hpbGQgaWRlbnRpZmllciBvZiB0aGUgcHJvcGVydHkgYmVpbmcgb2JzZXJ2ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmaXJzdFRpbWU/IFdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwgdG8gYmluZCB0aGUgcHJvcGVydHkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTW9kYWwucHJvdG90eXBlLl9zZXRCb3VuZFByb3BlcnR5ID0gZnVuY3Rpb24gKG1vZGFsU3RhdGUsIG9sZFZhbHVlLCBpZGVudGlmaWVyLCBmaXJzdFRpbWUpIHtcclxuICAgICAgICAgICAgdmFyIHV0aWxzID0gdGhpcy51dGlscztcclxuICAgICAgICAgICAgaWYgKGZpcnN0VGltZSA9PT0gdHJ1ZSAmJiB1dGlscy5pc051bGwobW9kYWxTdGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRDaGFuZ2VkKHRoaXMuX2lzVmlzaWJsZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHV0aWxzLmlzQm9vbGVhbihtb2RhbFN0YXRlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1vZGFsU3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKFwiQXR0ZW1wdGluZyB0byBzaG93IG9yIGhpZGUgYSBcIiArIHRoaXMudHlwZSArIFwiIHdpdGggYSBib3VuZCB2YWx1ZSB0aGF0IGlzIHNvbWV0aGluZyBvdGhlciB0aGFuIGEgYm9vbGVhbi5cIik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTaG93cyB0aGUgTW9kYWwuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTW9kYWwucHJvdG90eXBlLl9zaG93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgZG9tID0gdGhpcy5kb20sIHV0aWxzID0gdGhpcy51dGlscztcclxuICAgICAgICAgICAgaWYgKCF1dGlscy5pc051bGwodGhpcy5pbm5lclRlbXBsYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmRJbm5lclRlbXBsYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5faXNWaXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLl9Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgICAgICB1dGlscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9hbGlnbk1vZGFsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKF90aGlzLmVsZW1lbnQsIF9fSGlkZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdXRpbHMuZGVmZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1dGlscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tLmFkZENsYXNzKF90aGlzLl9jb250YWluZXIsIF9fUGxhdCArIFwiYWN0aXZhdGVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIDIwKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFsaWducyB0aGUgY29udHJvbCB0byB0aGUgdG9wIG9mIHRoZSB2aWV3cG9ydC5cclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldj8gVGhlIHNjcm9sbCBldmVudCBvYmplY3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTW9kYWwucHJvdG90eXBlLl9hbGlnbk1vZGFsID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciB1dGlscyA9IHRoaXMudXRpbHMsIGlzTnVsbCA9IHV0aWxzLmlzTnVsbCwgX2RvY3VtZW50ID0gdGhpcy5fZG9jdW1lbnQsIGRvY3VtZW50RWwgPSBfZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBzY3JvbGxFbCA9IGlzTnVsbChkb2N1bWVudEVsKSB8fCAhZG9jdW1lbnRFbC5zY3JvbGxUb3AgPyBfZG9jdW1lbnQuYm9keSA6IGRvY3VtZW50RWwsIHNjcm9sbFRvcCA9IHNjcm9sbEVsLnNjcm9sbFRvcDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Njcm9sbFRvcCA9PT0gc2Nyb2xsVG9wKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc051bGwoZXYpKSB7XHJcbiAgICAgICAgICAgICAgICB1dGlscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVsZW1lbnQuc3R5bGUudG9wID0gc2Nyb2xsVG9wICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUudG9wID0gc2Nyb2xsVG9wICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2Nyb2xsUmVtb3ZlciA9IHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl93aW5kb3csICdzY3JvbGwnLCB0aGlzLl9hbGlnbk1vZGFsLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSGlkZXMgdGhlIE1vZGFsLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE1vZGFsLnByb3RvdHlwZS5faGlkZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGRvbSA9IHRoaXMuZG9tLCB1dGlscyA9IHRoaXMudXRpbHMsIHByb21pc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFJlbW92ZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsUmVtb3ZlciA9IG5vb3A7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcodGhpcy5fdHJhbnNpdGlvbkVuZCkpIHtcclxuICAgICAgICAgICAgICAgIHByb21pc2UgPSB0aGlzLl9hZGRIaWRlT25UcmFuc2l0aW9uRW5kKCk7XHJcbiAgICAgICAgICAgICAgICB1dGlscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhfdGhpcy5fY29udGFpbmVyLCBfX1BsYXQgKyBcImFjdGl2YXRlXCIpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gbmV3IHRoaXMuX1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICB1dGlscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb20uYWRkQ2xhc3MoX3RoaXMuZWxlbWVudCwgX19IaWRlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKF90aGlzLl9jb250YWluZXIsIF9fUGxhdCArIFwiYWN0aXZhdGVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyB0aGUgaW5uZXJUZW1wbGF0ZSB0byBCaW5kYWJsZVRlbXBsYXRlcywgYmluZHMgaXQsXHJcbiAgICAgICAgICogYW5kIGFkZHMgaXQgdG8gdGhlIERPTS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBNb2RhbC5wcm90b3R5cGUuX2JpbmRJbm5lclRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgaW5uZXJUZW1wbGF0ZSA9IHRoaXMuaW5uZXJUZW1wbGF0ZSwgYmluZGFibGVUZW1wbGF0ZXMgPSB0aGlzLmJpbmRhYmxlVGVtcGxhdGVzLCBtb2RhbCA9ICdtb2RhbCc7XHJcbiAgICAgICAgICAgIGJpbmRhYmxlVGVtcGxhdGVzLmFkZChtb2RhbCwgaW5uZXJUZW1wbGF0ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5uZXJUZW1wbGF0ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybiBiaW5kYWJsZVRlbXBsYXRlcy5iaW5kKG1vZGFsKS50aGVuKGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2NvbnRhaW5lci5pbnNlcnRCZWZvcmUodGVtcGxhdGUsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnV0aWxzLmlzRnVuY3Rpb24oX3RoaXMuX19yZXNvbHZlRm4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19yZXNvbHZlRm4oKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fX3Jlc29sdmVGbiA9IF90aGlzLl9fcmVqZWN0Rm4gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9zaG93KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBpdHNlbGYgZnJvbSB0aGUgRE9NIGFuZCBpbnNlcnRzIGl0c2VsZiBpbnRvIHRoZSBib2R5IHRvIHdvcmsgd2l0aFxyXG4gICAgICAgICAqIGFic29sdXRlIHBvc2l0aW9uaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE1vZGFsLnByb3RvdHlwZS5faW5qZWN0RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsIHBhcmVudEVsZW1lbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQsIGJvZHkgPSB0aGlzLl9kb2N1bWVudC5ib2R5O1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMudXRpbHMuaXNOb2RlKHBhcmVudEVsZW1lbnQpIHx8IHBhcmVudEVsZW1lbnQgPT09IGJvZHkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBib2R5Lmluc2VydEJlZm9yZShlbGVtZW50LCBudWxsKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExpc3RlbnMgZm9yIHRoZSB0cmFuc2l0aW9uIHRvIGVuZCBhbmQgaGlkZXMgdGhlIGVsZW1lbnQgYWZ0ZXIgaXQgaXMgZmluaXNoZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTW9kYWwucHJvdG90eXBlLl9hZGRIaWRlT25UcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuX1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gX3RoaXMuZWxlbWVudCwgcmVtb3ZlID0gX3RoaXMuYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBfdGhpcy5fdHJhbnNpdGlvbkVuZCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRvbS5hZGRDbGFzcyhlbGVtZW50LCBfX0hpZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBNb2RhbC5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICBfd2luZG93OiBfX1dpbmRvdyxcclxuICAgICAgICAgICAgX2RvY3VtZW50OiBfX0RvY3VtZW50LFxyXG4gICAgICAgICAgICBfY29tcGF0OiBfX0NvbXBhdCxcclxuICAgICAgICAgICAgX1Byb21pc2U6IF9fUHJvbWlzZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIE1vZGFsO1xyXG4gICAgfShwbGF0LnVpLkJpbmRDb250cm9sKSk7XHJcbiAgICBwbGF0dWkuTW9kYWwgPSBNb2RhbDtcclxuICAgIHBsYXQucmVnaXN0ZXIuY29udHJvbChfX01vZGFsLCBNb2RhbCk7XHJcbiAgICAvKipcclxuICAgICAqIEFuIEJpbmRDb250cm9sIHRoYXQgc3RhbmRhcmRpemVzIGFuIEhUTUw1IGlucHV0W3R5cGU9XCJyYW5nZVwiXS5cclxuICAgICAqL1xyXG4gICAgdmFyIFNsaWRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFNsaWRlciwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBTbGlkZXIoKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIEhUTUwgdGVtcGxhdGUgcmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlU3RyaW5nID0gJzxkaXYgY2xhc3M9XCJwbGF0LXNsaWRlci1jb250YWluZXJcIj5cXG4nICtcclxuICAgICAgICAgICAgICAgICcgICAgPGRpdiBjbGFzcz1cInBsYXQtc2xpZGVyLXRyYWNrXCI+XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnICAgICAgICA8ZGl2IGNsYXNzPVwicGxhdC1rbm9iXCI+PC9kaXY+XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnICAgIDwvZGl2PlxcbicgK1xyXG4gICAgICAgICAgICAgICAgJzwvZGl2Plxcbic7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGV0aGVyIHRoZSBjb250cm9sIGlzIHZlcnRpY2FsIG9yIGhvcml6b250YWwuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9pc1ZlcnRpY2FsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY3VycmVudCBrbm9iIG9mZnNldC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2tub2JPZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQW4gZW51bSBkZW5vdGluZyB0aGUgY3VycmVudCB0b3VjaCBzdGF0ZSBvZiB0aGUgdXNlci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoU3RhdGUgPSAwO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBmdW5jdGlvbiB0aGF0IHdpbGwgc3RvcCBsaXN0ZW5pbmcgZm9yIHZpc2liaWxpdHkgaWYgYXBwbGljYWJsZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVZpc2liaWxpdHlMaXN0ZW5lciA9IG5vb3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGNsYXNzZXMgb24gdGhlIHByb3BlciBlbGVtZW50cy5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lPyBBbiBvcHRpb25hbCwgYWRkaXRpb25hbCBjbGFzcyBuYW1lIG9yIGNsYXNzIG5hbWVzIHRvIHNldCBvbiB0aGUgY29udHJvbFxyXG4gICAgICAgICAqIGluIGFkZGl0aW9uIHRvIGl0cyBzdGFuZGFyZCBzZXQuXHJcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50PyBUaGUgZWxlbWVudCB0byBzZXQgdGhlIGNsYXNzIG5hbWUgb24uIFNob3VsZCBkZWZhdWx0IHRvXHJcbiAgICAgICAgICogdGhlIGNvbnRyb2wncyBlbGVtZW50IGlmIG5vdCBzcGVjaWZpZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2xpZGVyLnByb3RvdHlwZS5zZXRDbGFzc2VzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSwgZWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRDbGFzcyhlbGVtZW50IHx8IHRoaXMuZWxlbWVudCwgX19TbGlkZXIgKyBcIiBcIiArIChjbGFzc05hbWUgfHwgJycpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0aGUgcHJvcGVyIGNsYXNzZXMgZm9yIHRoZSBjb250cm9sLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNsaWRlci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRDbGFzc2VzKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZXRlcm1pbmUgdGhlIGJ1dHRvbiB0eXBlIGFuZCBhcHBseSB0aGUgcHJvcGVyIGNsYXNzZXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2xpZGVyLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LCBzbGlkZXIgPSB0aGlzLl9zbGlkZXIgPSBlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkLmZpcnN0RWxlbWVudENoaWxkLCBpc051bWJlciA9IHRoaXMudXRpbHMuaXNOdW1iZXIsIG9wdGlvbk9iaiA9IHRoaXMub3B0aW9ucyB8fCB7fSwgb3B0aW9ucyA9IG9wdGlvbk9iai52YWx1ZSB8fCB7fSwgb3B0aW9uVmFsdWUgPSBOdW1iZXIob3B0aW9ucy52YWx1ZSksIG9wdGlvbk1pbiA9IG9wdGlvbnMubWluLCBvcHRpb25NYXggPSBvcHRpb25zLm1heCwgc3RlcCA9IG9wdGlvbnMuc3RlcCwgcmV2ZXJzZWQgPSB0aGlzLl9yZXZlcnNlZCA9IChvcHRpb25zLnJldmVyc2UgPT09IHRydWUpLCBtaW4gPSB0aGlzLm1pbiA9IGlzTnVtYmVyKG9wdGlvbk1pbikgPyBNYXRoLmZsb29yKG9wdGlvbk1pbikgOiAwLCBtYXggPSB0aGlzLm1heCA9IGlzTnVtYmVyKG9wdGlvbk1heCkgPyBNYXRoLmNlaWwob3B0aW9uTWF4KSA6IDEwMCwgdmFsdWUgPSBpc051bWJlcihvcHRpb25WYWx1ZSkgPyBNYXRoLnJvdW5kKG9wdGlvblZhbHVlKSA6IG1pbiwgY2xhc3NOYW1lID0gX19QbGF0ICsgdGhpcy5fdmFsaWRhdGVPcmllbnRhdGlvbihvcHRpb25zLm9yaWVudGF0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5fa25vYiA9IHNsaWRlci5maXJzdEVsZW1lbnRDaGlsZDtcclxuICAgICAgICAgICAgaWYgKHJldmVyc2VkKSB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgKz0gX19SZXZlcnNlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpO1xyXG4gICAgICAgICAgICAvLyByZXNldCB2YWx1ZSB0byBtaW5pbXVtIGluIGNhc2UgQmluZCBzZXQgaXQgdG8gYSB2YWx1ZSBcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG1pbjtcclxuICAgICAgICAgICAgdGhpcy5fc3RlcCA9IGlzTnVtYmVyKHN0ZXApID8gKHN0ZXAgPiAwID8gTWF0aC5yb3VuZChzdGVwKSA6IDEpIDogMTtcclxuICAgICAgICAgICAgaWYgKG1pbiA+PSBtYXgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhcIlxcXCJcIiArIHRoaXMudHlwZSArIFwiJ3NcXFwiIG1pbiBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gaXRzIG1heC4gU2V0dGluZyBtYXggdG8gbWluICsgMS5cIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1heCA9IG1pbiArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc2V0TGVuZ3RoKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVFdmVudHMoKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSh2YWx1ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIHRoZSB2aXNpYmlsaXR5IGxpc3RlbmVyIGlmIGFwcGxpY2FibGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2xpZGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlVmlzaWJpbGl0eUxpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NsaWRlclZpc2libGUgPSBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IHRoZSB2YWx1ZSBvZiB0aGUgU2xpZGVyLiBJZiBhbiBpbnZhbGlkIHZhbHVlIGlzIHBhc3NlZCBpblxyXG4gICAgICAgICAqIG5vdGhpbmcgd2lsbCBoYXBwZW4uXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQgdGhlIFNsaWRlciB0by5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTbGlkZXIucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldFZhbHVlKHZhbHVlLCB0cnVlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgdGhpcyBjb250cm9sIHRvIG9ic2VydmUgYm90aCB0aGUgYm91bmQgcHJvcGVydHkgaXRzZWxmIGFzIHdlbGwgYXNcclxuICAgICAgICAgKiBwb3RlbnRpYWwgY2hpbGQgcHJvcGVydGllcyBpZiBiZWluZyBib3VuZCB0byBhbiBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0Lm9ic2VydmFibGUuSUltcGxlbWVudFR3b1dheUJpbmRpbmd9IGJpbmRlciBUaGUgY29udHJvbCB0aGF0IGZhY2lsaXRhdGVzIHRoZVxyXG4gICAgICAgICAqIGRhdGFiaW5kaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNsaWRlci5wcm90b3R5cGUub2JzZXJ2ZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoYmluZGVyKSB7XHJcbiAgICAgICAgICAgIGJpbmRlci5vYnNlcnZlUHJvcGVydHkodGhpcy5fc2V0Qm91bmRQcm9wZXJ0eSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIGJpbmRhYmxlIHZhbHVlIGlzIHNldCBleHRlcm5hbGx5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdWYWx1ZSBUaGUgbmV3IHZhbHVlIG9mIHRoZSBiaW5kYWJsZSB2YWx1ZS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBvZiB0aGUgYmluZGFibGUgaW5kZXguXHJcbiAgICAgICAgICogQHBhcmFtIHt2b2lkfSBpZGVudGlmaWVyIFRoZSBjaGlsZCBpZGVudGlmaWVyIG9mIHRoZSBwcm9wZXJ0eSBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpcnN0VGltZT8gV2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCB0byBiaW5kIHRoZSBwcm9wZXJ0eS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTbGlkZXIucHJvdG90eXBlLl9zZXRCb3VuZFByb3BlcnR5ID0gZnVuY3Rpb24gKG5ld1ZhbHVlLCBvbGRWYWx1ZSwgaWRlbnRpZmllciwgZmlyc3RUaW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldFZhbHVlKG5ld1ZhbHVlLCBmYWxzZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgU2xpZGVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJvcGVydHlDaGFuZ2VkIFdoZXRoZXIgb3Igbm90IHdlIG5lZWQgdG8gZmlyZSBhIHByb3BlcnR5Q2hhbmdlZCBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTbGlkZXIucHJvdG90eXBlLl9zZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgcHJvcGVydHlDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgIHZhciB1dGlscyA9IHRoaXMudXRpbHM7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl90b3VjaFN0YXRlID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoXCJDYW5ub3Qgc2V0IHRoZSB2YWx1ZSBvZiBcIiArIHRoaXMudHlwZSArIFwiIHdoaWxlIHRoZSB1c2VyIGlzIG1hbmlwdWxhdGluZyBpdC5cIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodXRpbHMuaXNOdWxsKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLm1pbjtcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5Q2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF1dGlscy5pc051bWJlcih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBudW1iZXJWYWwgPSBOdW1iZXIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKG51bWJlclZhbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bWJlclZhbDtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4odGhpcy50eXBlICsgXCIgaGFzIGl0cyB2YWx1ZSBib3VuZCB0byBhIHByb3BlcnR5IHRoYXQgY2Fubm90IGJlIGludGVycHJldGVkIGFzIGEgTnVtYmVyLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc2V0VmFsdWVQcm9wZXJ0eSh2YWx1ZSwgdHJ1ZSwgcHJvcGVydHlDaGFuZ2VkKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpemUgdGhlIHByb3BlciB0cmFja2luZyBldmVudHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2xpZGVyLnByb3RvdHlwZS5faW5pdGlhbGl6ZUV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsIHRyYWNrRm4gPSB0aGlzLl90cmFjaywgdG91Y2hFbmQgPSB0aGlzLl90b3VjaEVuZCwgdHJhY2ssIHJldmVyc2VUcmFjaztcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzVmVydGljYWwpIHtcclxuICAgICAgICAgICAgICAgIHRyYWNrID0gX18kdHJhY2sgKyBcImRvd25cIjtcclxuICAgICAgICAgICAgICAgIHJldmVyc2VUcmFjayA9IF9fJHRyYWNrICsgXCJ1cFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdHJhY2sgPSBfXyR0cmFjayArIFwicmlnaHRcIjtcclxuICAgICAgICAgICAgICAgIHJldmVyc2VUcmFjayA9IF9fJHRyYWNrICsgXCJsZWZ0XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsIF9fJHRvdWNoc3RhcnQsIHRoaXMuX3RvdWNoU3RhcnQsIGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsIHRyYWNrLCB0cmFja0ZuLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCByZXZlcnNlVHJhY2ssIHRyYWNrRm4sIGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsIF9fJHRvdWNoZW5kLCB0b3VjaEVuZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgX18kdHJhY2tlbmQsIHRvdWNoRW5kLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl93aW5kb3csICdyZXNpemUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnV0aWxzLmlzTnVsbChfdGhpcy5fc2xpZGVyVmlzaWJsZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fc2V0TGVuZ3RoKCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fc2V0S25vYigpO1xyXG4gICAgICAgICAgICB9LCBmYWxzZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMb2cgdGhlIGZpcnN0IHRvdWNoLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JR2VzdHVyZUV2ZW50fSBldiBUaGUgdG91Y2ggZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNsaWRlci5wcm90b3R5cGUuX3RvdWNoU3RhcnQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3RvdWNoU3RhdGUgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90b3VjaFN0YXRlID0gMTtcclxuICAgICAgICAgICAgdGhpcy5fbGFzdFRvdWNoID0ge1xyXG4gICAgICAgICAgICAgICAgeDogZXYuY2xpZW50WCxcclxuICAgICAgICAgICAgICAgIHk6IGV2LmNsaWVudFksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXYudGFyZ2V0O1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSB0aGlzLl9rbm9iKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG9mZnNldDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzVmVydGljYWwpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IHRoaXMuZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX3JldmVyc2VkID8gZXYub2Zmc2V0WSAtIHRoaXMuX3NsaWRlck9mZnNldCA6IHRoaXMuX21heE9mZnNldCAtIChldi5vZmZzZXRZIC0gdGhpcy5fc2xpZGVyT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldCA9PT0gdGhpcy5fc2xpZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fcmV2ZXJzZWQgPyBldi5vZmZzZXRZIDogdGhpcy5fa25vYk9mZnNldCAtIGV2Lm9mZnNldFk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9yZXZlcnNlZCA/IGV2Lm9mZnNldFkgOiB0aGlzLl9tYXhPZmZzZXQgLSBldi5vZmZzZXRZO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gdGhpcy5lbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fcmV2ZXJzZWQgPyB0aGlzLl9tYXhPZmZzZXQgLSAoZXYub2Zmc2V0WCAtIHRoaXMuX3NsaWRlck9mZnNldCkgOiBldi5vZmZzZXRYIC0gdGhpcy5fc2xpZGVyT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0ID09PSB0aGlzLl9zbGlkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9yZXZlcnNlZCA/IHRoaXMuX2tub2JPZmZzZXQgLSBldi5vZmZzZXRYIDogZXYub2Zmc2V0WDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX3JldmVyc2VkID8gdGhpcy5fbWF4T2Zmc2V0IC0gZXYub2Zmc2V0WCA6IGV2Lm9mZnNldFg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy51dGlscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2tub2JPZmZzZXQgPSBfdGhpcy5fc2V0U2xpZGVyUHJvcGVydGllcyhvZmZzZXQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0aGUgbmV3IHNsaWRlciBvZmZzZXQuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklHZXN0dXJlRXZlbnR9IGV2IFRoZSAkdHJhY2tlbmQgZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNsaWRlci5wcm90b3R5cGUuX3RvdWNoRW5kID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl90b3VjaFN0YXRlICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b3VjaFN0YXRlID0gMDtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90b3VjaFN0YXRlID0gMjtcclxuICAgICAgICAgICAgdmFyIG5ld09mZnNldCA9IHRoaXMuX2NhbGN1bGF0ZU9mZnNldChldiksIG1heE9mZnNldCA9IHRoaXMuX21heE9mZnNldDtcclxuICAgICAgICAgICAgdGhpcy51dGlscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3RvdWNoU3RhdGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9sYXN0VG91Y2gudmFsdWUgIT09IF90aGlzLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RyaWdnZXIoJ2NoYW5nZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5ld09mZnNldCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fa25vYk9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmV3T2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2tub2JPZmZzZXQgPSBtYXhPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2tub2JPZmZzZXQgPSBuZXdPZmZzZXQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJhY2sgdGhlIGtub2IgbW92ZW1lbnQuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklHZXN0dXJlRXZlbnR9IGV2IFRoZSAkdHJhY2sgZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNsaWRlci5wcm90b3R5cGUuX3RyYWNrID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl90b3VjaFN0YXRlID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy51dGlscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3NldFNsaWRlclByb3BlcnRpZXMoX3RoaXMuX2NhbGN1bGF0ZU9mZnNldChldikpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0aGUgU2xpZGVyJ3Mga25vYiBwb3NpdGlvbiBhbmQgY29ycmVzcG9uZGluZyB2YWx1ZS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIHZhbHVlIHRvIHNldCB0aGUga25vYiB0byBwcmlvciB0b1xyXG4gICAgICAgICAqIG5vcm1hbGl6YXRpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2xpZGVyLnByb3RvdHlwZS5fc2V0U2xpZGVyUHJvcGVydGllcyA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgbWF4T2Zmc2V0ID0gdGhpcy5fbWF4T2Zmc2V0LCB2YWx1ZTtcclxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5taW47XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgLSB0aGlzLnZhbHVlID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocG9zaXRpb24gPj0gbWF4T2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMubWF4O1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBtYXhPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgLSB0aGlzLnZhbHVlIDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2NhbGN1bGF0ZVZhbHVlKHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zZXRWYWx1ZVByb3BlcnR5KHZhbHVlLCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NsaWRlci5zdHlsZVt0aGlzLl9sZW5ndGhQcm9wZXJ0eV0gPSBwb3NpdGlvbiArIFwicHhcIjtcclxuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgY3VycmVudCB2YWx1ZSBiYXNlZCBvbiBrbm9iIHBvc2l0aW9uIGFuZCBzbGlkZXIgd2lkdGguXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFRoZSBjdXJyZW50IHdpZHRoIG9mIHRoZSBzbGlkZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2xpZGVyLnByb3RvdHlwZS5fY2FsY3VsYXRlVmFsdWUgPSBmdW5jdGlvbiAod2lkdGgpIHtcclxuICAgICAgICAgICAgdmFyIHN0ZXAgPSB0aGlzLl9zdGVwO1xyXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMubWluICsgTWF0aC5yb3VuZCh3aWR0aCAvIHRoaXMuX2luY3JlbWVudCAvIHN0ZXApICogc3RlcCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxjdWxhdGVzIGtub2IgcG9zaXRpb24gYmFzZWQgb24gY3VycmVudCB2YWx1ZS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHtsaW5rIHBsYXR1aS5TbGlkZXJ8U2xpZGVyfS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTbGlkZXIucHJvdG90eXBlLl9jYWxjdWxhdGVLbm9iUG9zaXRpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSAtIHRoaXMubWluKSAqIHRoaXMuX2luY3JlbWVudDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIG5ldyBvZmZzZXQgb2YgdGhlIHNsaWRlciBiYXNlZCBvbiB0aGUgb2xkIG9mZnNldCBhbmQgdGhlIGRpc3RhbmNlIG1vdmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JR2VzdHVyZUV2ZW50fSBldiBUaGUgJHRyYWNrIG9yICR0cmFja2VuZCBldmVudCBvYmplY3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2xpZGVyLnByb3RvdHlwZS5fY2FsY3VsYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1ZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV2ZXJzZWQgP1xyXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLl9rbm9iT2Zmc2V0ICsgZXYuY2xpZW50WSAtIHRoaXMuX2xhc3RUb3VjaC55KSA6XHJcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuX2tub2JPZmZzZXQgKyB0aGlzLl9sYXN0VG91Y2gueSAtIGV2LmNsaWVudFkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldmVyc2VkID9cclxuICAgICAgICAgICAgICAgICAgICAodGhpcy5fa25vYk9mZnNldCArIHRoaXMuX2xhc3RUb3VjaC54IC0gZXYuY2xpZW50WCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLl9rbm9iT2Zmc2V0ICsgZXYuY2xpZW50WCAtIHRoaXMuX2xhc3RUb3VjaC54KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgcHJvcGVydHkgdG8gdXNlIGZvciBsZW5ndGggYW5kIHNldHMgdGhlIG1heCBsZW5ndGggb2YgdGhlIHNsaWRlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTbGlkZXIucHJvdG90eXBlLl9zZXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuX3NsaWRlci5wYXJlbnRFbGVtZW50O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGVuZ3RoUHJvcGVydHkgPSAnaGVpZ2h0JztcclxuICAgICAgICAgICAgICAgIHRoaXMuX21heE9mZnNldCA9IGVsLmNsaWVudEhlaWdodDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NsaWRlck9mZnNldCA9IGVsLm9mZnNldFRvcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xlbmd0aFByb3BlcnR5ID0gJ3dpZHRoJztcclxuICAgICAgICAgICAgICAgIHRoaXMuX21heE9mZnNldCA9IGVsLmNsaWVudFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2xpZGVyT2Zmc2V0ID0gZWwub2Zmc2V0TGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX21heE9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2xpZGVyVmlzaWJsZSA9IG5ldyB0aGlzLl9Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlbW92ZVZpc2liaWxpdHlMaXN0ZW5lciA9IF90aGlzLmRvbS53aGVuVmlzaWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9zbGlkZXJWaXNpYmxlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3NldExlbmd0aCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZWwpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc2V0SW5jcmVtZW50KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBpbmNyZW1lbnQgZm9yIHNsaWRpbmcgdGhlIHtsaW5rIHBsYXR1aS5TbGlkZXJ8U2xpZGVyfS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTbGlkZXIucHJvdG90eXBlLl9zZXRJbmNyZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5faW5jcmVtZW50ID0gdGhpcy5fbWF4T2Zmc2V0IC8gKHRoaXMubWF4IC0gdGhpcy5taW4pKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBTbGlkZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG5ld1ZhbHVlIFRoZSBuZXcgdmFsdWUgdG8gc2V0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2V0S25vYiBXaGV0aGVyIG9yIG5vdCB3ZSBuZWVkIHRvIHNldCB0aGUga25vYiBwb3NpdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByb3BlcnR5Q2hhbmdlZCBXaGV0aGVyIG9yIG5vdCB3ZSBuZWVkIHRvIGZpcmUgYSBwcm9wZXJ0eUNoYW5nZWQgZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2xpZGVyLnByb3RvdHlwZS5fc2V0VmFsdWVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgc2V0S25vYiwgcHJvcGVydHlDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChuZXdWYWx1ZSA+PSB0aGlzLm1heCkge1xyXG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSB0aGlzLm1heDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChuZXdWYWx1ZSA8PSB0aGlzLm1pbikge1xyXG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSB0aGlzLm1pbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChNYXRoLmFicyhuZXdWYWx1ZSAtIHZhbHVlKSA8IHRoaXMuX3N0ZXApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5lbGVtZW50LnZhbHVlID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChzZXRLbm9iKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRLbm9iKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByb3BlcnR5Q2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dENoYW5nZWQobmV3VmFsdWUsIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyKCdpbnB1dCcpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW5pbWF0ZXMgYW5kIHNldHMgdGhlIGtub2IgcG9zaXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlPyBUaGUgdmFsdWUgdG8gdXNlIHRvIGNhbGN1bGF0ZSB0aGUga25vYiBwb3NpdGlvbi4gSWYgbm8gdmFsdWUgaXNcclxuICAgICAgICAgKiBzcGVjaWZpZWQsIHRoZSBjdXJyZW50IFNsaWRlcidzIHZhbHVlIHdpbGwgYmUgdXNlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTbGlkZXIucHJvdG90eXBlLl9zZXRLbm9iID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoaXMuX1Byb21pc2UucmVzb2x2ZSh0aGlzLl9zbGlkZXJWaXNpYmxlKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25PcHRpb25zID0ge30sIGxlbmd0aCA9IF90aGlzLl9jYWxjdWxhdGVLbm9iUG9zaXRpb24oKHZhbHVlIHx8IF90aGlzLnZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID09PSBfdGhpcy5fa25vYk9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbk9wdGlvbnNbX3RoaXMuX2xlbmd0aFByb3BlcnR5XSA9IGxlbmd0aCArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9hbmltYXRvci5hbmltYXRlKF90aGlzLl9zbGlkZXIsIF9fVHJhbnNpdGlvbiwge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IGFuaW1hdGlvbk9wdGlvbnNcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2tub2JPZmZzZXQgPSBsZW5ndGg7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJpZ2dlcnMgYW4gZXZlbnQgc3RhcnRpbmcgZnJvbSB0aGlzIGNvbnRyb2wncyBlbGVtZW50LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCBUaGUgZXZlbnQgbmFtZSB0byB0cmlnZ2VyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNsaWRlci5wcm90b3R5cGUuX3RyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgdmFyIGRvbUV2ZW50ID0gcGxhdC5hY3F1aXJlKF9fRG9tRXZlbnRJbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIGRvbUV2ZW50LmluaXRpYWxpemUodGhpcy5lbGVtZW50LCBldmVudCk7XHJcbiAgICAgICAgICAgIGRvbUV2ZW50LnRyaWdnZXIoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyB0aGUgb3JpZW50YXRpb24gb2YgdGhlIGNvbnRyb2wgYW5kIGVuc3VyZXMgaXQgaXMgdmFsaWQuXHJcbiAgICAgICAgICogV2lsbCBkZWZhdWx0IHRvIFwiaG9yaXpvbnRhbFwiIGlmIGludmFsaWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWVudGF0aW9uIFRoZSBlbGVtZW50IHRvIGJhc2UgdGhlIGxlbmd0aCBvZmYgb2YuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2xpZGVyLnByb3RvdHlwZS5fdmFsaWRhdGVPcmllbnRhdGlvbiA9IGZ1bmN0aW9uIChvcmllbnRhdGlvbikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy51dGlscy5pc1VuZGVmaW5lZChvcmllbnRhdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnaG9yaXpvbnRhbCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHZhbGlkT3JpZW50YXRpb247XHJcbiAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZE9yaWVudGF0aW9uID0gb3JpZW50YXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcclxuICAgICAgICAgICAgICAgIHZhbGlkT3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzVmVydGljYWwgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKFwiSW52YWxpZCBvcmllbnRhdGlvbiBcXFwiXCIgKyBvcmllbnRhdGlvbiArIFwiXFxcIiBmb3IgXCIgKyB0aGlzLnR5cGUgKyBcIi4gRGVmYXVsdGluZyB0byBcXFwiaG9yaXpvbnRhbC5cXFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFsaWRPcmllbnRhdGlvbiA9ICdob3Jpem9udGFsJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsaWRPcmllbnRhdGlvbjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNsaWRlci5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICBfZG9jdW1lbnQ6IF9fRG9jdW1lbnQsXHJcbiAgICAgICAgICAgIF93aW5kb3c6IF9fV2luZG93LFxyXG4gICAgICAgICAgICBfUHJvbWlzZTogX19Qcm9taXNlLFxyXG4gICAgICAgICAgICBfYW5pbWF0b3I6IF9fQW5pbWF0b3JcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBTbGlkZXI7XHJcbiAgICB9KHBsYXQudWkuQmluZENvbnRyb2wpKTtcclxuICAgIHBsYXR1aS5TbGlkZXIgPSBTbGlkZXI7XHJcbiAgICBwbGF0LnJlZ2lzdGVyLmNvbnRyb2woX19TbGlkZXIsIFNsaWRlcik7XHJcbiAgICAvKipcclxuICAgICAqIEEgQmluZENvbnRyb2wgdGhhdCBhbGxvd3MgZm9yIGEgbG93ZXIgYW5kIHVwcGVyIHZhbHVlLFxyXG4gICAgICogdGh1cyBjcmVhdGluZyBhIHZhcmlhYmxlIHJhbmdlIG9mIGluY2x1ZGVkIHZhbHVlcy5cclxuICAgICAqL1xyXG4gICAgdmFyIFJhbmdlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoUmFuZ2UsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gUmFuZ2UoKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIEhUTUwgdGVtcGxhdGUgcmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlU3RyaW5nID0gJzxkaXYgY2xhc3M9XCJwbGF0LXJhbmdlLWNvbnRhaW5lclwiPlxcbicgK1xyXG4gICAgICAgICAgICAgICAgJyAgICA8ZGl2IGNsYXNzPVwicGxhdC1yYW5nZS10cmFja1wiPlxcbicgK1xyXG4gICAgICAgICAgICAgICAgJyAgICAgICAgPGRpdiBjbGFzcz1cInBsYXQtbG93ZXIta25vYlwiPjwvZGl2PlxcbicgK1xyXG4gICAgICAgICAgICAgICAgJyAgICAgICAgPGRpdiBjbGFzcz1cInBsYXQtdXBwZXIta25vYlwiPjwvZGl2PlxcbicgK1xyXG4gICAgICAgICAgICAgICAgJyAgICA8L2Rpdj5cXG4nICtcclxuICAgICAgICAgICAgICAgICc8L2Rpdj5cXG4nO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciB0aGUgY29udHJvbCBpcyB2ZXJ0aWNhbCBvciBob3Jpem9udGFsLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5faXNWZXJ0aWNhbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQW4gZW51bSBkZW5vdGluZyB0aGUgY3VycmVudCB0b3VjaCBzdGF0ZSBvZiB0aGUgdXNlci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoU3RhdGUgPSAwO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBmdW5jdGlvbiB0aGF0IHdpbGwgc3RvcCBsaXN0ZW5pbmcgZm9yIHZpc2liaWxpdHkgaWYgYXBwbGljYWJsZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVZpc2liaWxpdHlMaXN0ZW5lciA9IG5vb3A7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIGJvb2xlYW4gdmFsdWUgdGhhdCBmb3JjZXMgYSBvbmUtdGltZSB0cmlnZ2VyIHVwb24gdGhlIGZpcnN0IGJvdW5kIHZhbHVlIGNoYW5nZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2ZvcmNlRmlyc3RUaW1lID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGNsYXNzZXMgb24gdGhlIHByb3BlciBlbGVtZW50cy5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lPyBBbiBvcHRpb25hbCwgYWRkaXRpb25hbCBjbGFzcyBuYW1lIG9yIGNsYXNzIG5hbWVzIHRvIHNldCBvbiB0aGUgY29udHJvbFxyXG4gICAgICAgICAqIGluIGFkZGl0aW9uIHRvIGl0cyBzdGFuZGFyZCBzZXQuXHJcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50PyBUaGUgZWxlbWVudCB0byBzZXQgdGhlIGNsYXNzIG5hbWUgb24uIFNob3VsZCBkZWZhdWx0IHRvXHJcbiAgICAgICAgICogdGhlIGNvbnRyb2wncyBlbGVtZW50IGlmIG5vdCBzcGVjaWZpZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZ2UucHJvdG90eXBlLnNldENsYXNzZXMgPSBmdW5jdGlvbiAoY2xhc3NOYW1lLCBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZENsYXNzKGVsZW1lbnQgfHwgdGhpcy5lbGVtZW50LCBfX1JhbmdlICsgXCIgXCIgKyAoY2xhc3NOYW1lIHx8ICcnKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdGhlIHByb3BlciBjbGFzc2VzIGZvciB0aGUgY29udHJvbC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5nZS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRDbGFzc2VzKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZXRlcm1pbmUgdGhlIGJ1dHRvbiB0eXBlIGFuZCBhcHBseSB0aGUgcHJvcGVyIGNsYXNzZXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZ2UucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsIHNsaWRlciA9IHRoaXMuX3NsaWRlciA9IGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQuZmlyc3RFbGVtZW50Q2hpbGQsIGlzTnVtYmVyID0gdGhpcy51dGlscy5pc051bWJlciwgb3B0aW9uT2JqID0gdGhpcy5vcHRpb25zIHx8IHt9LCBvcHRpb25zID0gb3B0aW9uT2JqLnZhbHVlIHx8IHt9LCBvcHRpb25Mb3dlciA9IE51bWJlcihvcHRpb25zLmxvd2VyKSwgb3B0aW9uVXBwZXIgPSBOdW1iZXIob3B0aW9ucy51cHBlciksIGlkZW50aWZpZXJzID0gb3B0aW9ucy5pZGVudGlmaWVycyB8fCB7fSwgb3B0aW9uTWluID0gb3B0aW9ucy5taW4sIG9wdGlvbk1heCA9IG9wdGlvbnMubWF4LCBzdGVwID0gb3B0aW9ucy5zdGVwLCByZXZlcnNlZCA9IHRoaXMuX3JldmVyc2VkID0gKG9wdGlvbnMucmV2ZXJzZSA9PT0gdHJ1ZSksIG1pbiA9IHRoaXMubWluID0gaXNOdW1iZXIob3B0aW9uTWluKSA/IE1hdGguZmxvb3Iob3B0aW9uTWluKSA6IDAsIG1heCA9IHRoaXMubWF4ID0gaXNOdW1iZXIob3B0aW9uTWF4KSA/IE1hdGguY2VpbChvcHRpb25NYXgpIDogMTAwLCBsb3dlciA9IGlzTnVtYmVyKG9wdGlvbkxvd2VyKSA/IE1hdGgucm91bmQob3B0aW9uTG93ZXIpIDogbWluLCB1cHBlciA9IGlzTnVtYmVyKG9wdGlvblVwcGVyKSA/IE1hdGgucm91bmQob3B0aW9uVXBwZXIpIDogbWF4LCBjbGFzc05hbWUgPSBfX1BsYXQgKyB0aGlzLl92YWxpZGF0ZU9yaWVudGF0aW9uKG9wdGlvbnMub3JpZW50YXRpb24pO1xyXG4gICAgICAgICAgICB0aGlzLl9sb3dlcktub2IgPSBzbGlkZXIuZmlyc3RFbGVtZW50Q2hpbGQ7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwcGVyS25vYiA9IHNsaWRlci5sYXN0RWxlbWVudENoaWxkO1xyXG4gICAgICAgICAgICB0aGlzLl9sb3dlcklkZW50aWZpZXIgPSBpZGVudGlmaWVycy5sb3dlciB8fCAnbG93ZXInO1xyXG4gICAgICAgICAgICB0aGlzLl91cHBlcklkZW50aWZpZXIgPSBpZGVudGlmaWVycy51cHBlciB8fCAndXBwZXInO1xyXG4gICAgICAgICAgICAvLyBpZiBpdCdzIGEgcmV2ZXJzZWQgZGlyZWN0aW9uLCBzd2FwIGtub2JzLiBcclxuICAgICAgICAgICAgaWYgKHJldmVyc2VkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbG93ZXJLbm9iID0gdGhpcy5fbG93ZXJLbm9iO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG93ZXJLbm9iID0gdGhpcy5fdXBwZXJLbm9iO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBwZXJLbm9iID0gbG93ZXJLbm9iO1xyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lICs9IF9fUmV2ZXJzZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kb20uYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKTtcclxuICAgICAgICAgICAgLy8gcmVzZXQgdmFsdWUgdG8gbWluaW11bSBpbiBjYXNlIGNvbnRleHQgaXMgYWxyZWFkeSBzZXQgdG8gYSB2YWx1ZSBcclxuICAgICAgICAgICAgdGhpcy5sb3dlciA9IG1pbjtcclxuICAgICAgICAgICAgdGhpcy51cHBlciA9IG1heDtcclxuICAgICAgICAgICAgdGhpcy5fc3RlcCA9IGlzTnVtYmVyKHN0ZXApID8gKHN0ZXAgPiAwID8gTWF0aC5yb3VuZChzdGVwKSA6IDEpIDogMTtcclxuICAgICAgICAgICAgaWYgKG1pbiA+PSBtYXgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhcIlxcXCJcIiArIHRoaXMudHlwZSArIFwiJ3NcXFwiIG1pbiBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gaXRzIG1heC4gU2V0dGluZyBtYXggdG8gbWluICsgMS5cIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1heCA9IG1pbiArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc2V0UG9zaXRpb25BbmRMZW5ndGgoKTtcclxuICAgICAgICAgICAgLy8gbXVzdCBzZXQgdGhpcyBpbiBjYXNlIHRoZSB2YWx1ZSBpcyBub3Qgc2V0IGFuZCBsb3dlciBrbm9iIGlzIG5ldmVyIHBvc2l0aW9uZWQgZHVlIHRvIHNldExvd2VyIGZ1bmN0aW9uLiBcclxuICAgICAgICAgICAgdGhpcy5fc2V0TG93ZXJLbm9iUG9zaXRpb24obWluKTtcclxuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZUV2ZW50cygpO1xyXG4gICAgICAgICAgICB0aGlzLnNldExvd2VyKGxvd2VyKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRVcHBlcih1cHBlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBsb3dlciB2YWx1ZSBvZiB0aGUgUmFuZ2UuIElmIGFuIGludmFsaWQgdmFsdWUgaXMgcGFzc2VkIGluXHJcbiAgICAgICAgICogbm90aGluZyB3aWxsIGhhcHBlbi5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldCB0aGUgUmFuZ2UgdG8uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZ2UucHJvdG90eXBlLnNldExvd2VyID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldExvd2VyKHZhbHVlLCB0cnVlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIHVwcGVyIHZhbHVlIG9mIHRoZSBSYW5nZS4gSWYgYW4gaW52YWxpZCB2YWx1ZSBpcyBwYXNzZWQgaW5cclxuICAgICAgICAgKiBub3RoaW5nIHdpbGwgaGFwcGVuLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0IHRoZSBSYW5nZSB0by5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5nZS5wcm90b3R5cGUuc2V0VXBwZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0VXBwZXIodmFsdWUsIHRydWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBmdW5jdGlvbiB0aGF0IGFsbG93cyB0aGlzIGNvbnRyb2wgdG8gb2JzZXJ2ZSBib3RoIHRoZSBib3VuZCBwcm9wZXJ0eSBpdHNlbGYgYXMgd2VsbCBhc1xyXG4gICAgICAgICAqIHBvdGVudGlhbCBjaGlsZCBwcm9wZXJ0aWVzIGlmIGJlaW5nIGJvdW5kIHRvIGFuIG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQub2JzZXJ2YWJsZS5JSW1wbGVtZW50VHdvV2F5QmluZGluZ30gYmluZGVyIFRoZSBjb250cm9sIHRoYXQgZmFjaWxpdGF0ZXMgdGhlXHJcbiAgICAgICAgICogZGF0YWJpbmRpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZ2UucHJvdG90eXBlLm9ic2VydmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGJpbmRlcikge1xyXG4gICAgICAgICAgICBiaW5kZXIub2JzZXJ2ZVByb3BlcnR5KHRoaXMuX3NldExvd2VyQm91bmRQcm9wZXJ0eSwgdGhpcy5fbG93ZXJJZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgYmluZGVyLm9ic2VydmVQcm9wZXJ0eSh0aGlzLl9zZXRVcHBlckJvdW5kUHJvcGVydHksIHRoaXMuX3VwcGVySWRlbnRpZmllcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIGJpbmRhYmxlIGxvd2VyIHZhbHVlIGlzIHNldCBleHRlcm5hbGx5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdWYWx1ZSBUaGUgbmV3IGxvd2VyIHZhbHVlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvbGRWYWx1ZSBUaGUgb2xkIHZhbHVlIG9mIHRoZSBiaW5kYWJsZSBpbmRleC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmllciBUaGUgY2hpbGQgaWRlbnRpZmllciBvZiB0aGUgcHJvcGVydHkgYmVpbmcgb2JzZXJ2ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmaXJzdFRpbWU/IFdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwgdG8gYmluZCB0aGUgcHJvcGVydHkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZ2UucHJvdG90eXBlLl9zZXRMb3dlckJvdW5kUHJvcGVydHkgPSBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlLCBpZGVudGlmaWVyLCBmaXJzdFRpbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0TG93ZXIobmV3VmFsdWUsIGZhbHNlLCBmaXJzdFRpbWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSBiaW5kYWJsZSB1cHBlciB2YWx1ZSBpcyBzZXQgZXh0ZXJuYWxseS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3VmFsdWUgVGhlIG5ldyB1cHBlciB2YWx1ZS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBvZiB0aGUgYmluZGFibGUgaW5kZXguXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aWZpZXIgVGhlIGNoaWxkIGlkZW50aWZpZXIgb2YgdGhlIHByb3BlcnR5IGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlyc3RUaW1lPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsIHRvIGJpbmQgdGhlIHByb3BlcnR5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmdlLnByb3RvdHlwZS5fc2V0VXBwZXJCb3VuZFByb3BlcnR5ID0gZnVuY3Rpb24gKG5ld1ZhbHVlLCBvbGRWYWx1ZSwgaWRlbnRpZmllciwgZmlyc3RUaW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldFVwcGVyKG5ld1ZhbHVlLCBmYWxzZSwgZmlyc3RUaW1lKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGxvd2VyIHZhbHVlIG9mIHRoZSBSYW5nZS4gSWYgYW4gaW52YWxpZCB2YWx1ZSBpcyBwYXNzZWQgaW5cclxuICAgICAgICAgKiBub3RoaW5nIHdpbGwgaGFwcGVuLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0IHRoZSBSYW5nZSB0by5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByb3BlcnR5Q2hhbmdlZCBXaGV0aGVyIG9yIG5vdCB0aGUgcHJvcGVydHkgd2FzIGNoYW5nZWQgYnkgdGhlIHVzZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmaXJzdFRpbWU/IFdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwgdG8gc2V0IHRoZSBsb3dlciB2YWx1ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5nZS5wcm90b3R5cGUuX3NldExvd2VyID0gZnVuY3Rpb24gKHZhbHVlLCBwcm9wZXJ0eUNoYW5nZWQsIGZpcnN0VGltZSkge1xyXG4gICAgICAgICAgICB2YXIgdXRpbHMgPSB0aGlzLnV0aWxzO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdG91Y2hTdGF0ZSA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKFwiQ2Fubm90IHNldCB0aGUgdmFsdWUgb2YgdGhlIFwiICsgdGhpcy50eXBlICsgXCIncyBsb3dlciBrbm9iIHdoaWxlIHRoZSB1c2VyIGlzIG1hbmlwdWxhdGluZyBpdC5cIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodXRpbHMuaXNOdWxsKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLm1pbjtcclxuICAgICAgICAgICAgICAgIGlmIChmaXJzdFRpbWUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mb3JjZUZpcnN0VGltZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdXRpbHMuaXNOdW1iZXIodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbnVtYmVyVmFsID0gTnVtYmVyKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGlmICh1dGlscy5pc051bWJlcihudW1iZXJWYWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBudW1iZXJWYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0VGltZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mb3JjZUZpcnN0VGltZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKHRoaXMudHlwZSArIFwiIGhhcyBpdHMgbG93ZXIgdmFsdWUgYm91bmQgdG8gYSBwcm9wZXJ0eSB0aGF0IGNhbm5vdCBiZSBpbnRlcnByZXRlZCBhcyBhIE51bWJlci5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3NldExvd2VyVmFsdWUodmFsdWUsIHRydWUsIHByb3BlcnR5Q2hhbmdlZCwgdHJ1ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSB1cHBwZXIgdmFsdWUgb2YgdGhlIFJhbmdlLiBJZiBhbiBpbnZhbGlkIHZhbHVlIGlzIHBhc3NlZCBpblxyXG4gICAgICAgICAqIG5vdGhpbmcgd2lsbCBoYXBwZW4uXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQgdGhlIFJhbmdlIHRvLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJvcGVydHlDaGFuZ2VkIFdoZXRoZXIgb3Igbm90IHRoZSBwcm9wZXJ0eSB3YXMgY2hhbmdlZCBieSB0aGUgdXNlci5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpcnN0VGltZT8gV2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCB0byBzZXQgdGhlIHVwcGVyIHZhbHVlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmdlLnByb3RvdHlwZS5fc2V0VXBwZXIgPSBmdW5jdGlvbiAodmFsdWUsIHByb3BlcnR5Q2hhbmdlZCwgZmlyc3RUaW1lKSB7XHJcbiAgICAgICAgICAgIHZhciB1dGlscyA9IHRoaXMudXRpbHM7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl90b3VjaFN0YXRlID09PSAzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoXCJDYW5ub3Qgc2V0IHRoZSB2YWx1ZSBvZiB0aGUgXCIgKyB0aGlzLnR5cGUgKyBcIidzIHVwcGVyIGtub2Igd2hpbGUgdGhlIHVzZXIgaXMgbWFuaXB1bGF0aW5nIGl0LlwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh1dGlscy5pc051bGwodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMubWF4O1xyXG4gICAgICAgICAgICAgICAgcHJvcGVydHlDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXV0aWxzLmlzTnVtYmVyKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG51bWJlclZhbCA9IE51bWJlcih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodXRpbHMuaXNOdW1iZXIobnVtYmVyVmFsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbnVtYmVyVmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5Q2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cud2Fybih0aGlzLnR5cGUgKyBcIiBoYXMgaXRzIHVwcGVyIHZhbHVlIGJvdW5kIHRvIGEgcHJvcGVydHkgdGhhdCBjYW5ub3QgYmUgaW50ZXJwcmV0ZWQgYXMgYSBOdW1iZXIuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zZXRVcHBlclZhbHVlKHZhbHVlLCB0cnVlLCBwcm9wZXJ0eUNoYW5nZWQgfHwgKGZpcnN0VGltZSA9PT0gdHJ1ZSAmJiB0aGlzLl9mb3JjZUZpcnN0VGltZSksIHRydWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZSB0aGUgcHJvcGVyIHRyYWNraW5nIGV2ZW50cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5nZS5wcm90b3R5cGUuX2luaXRpYWxpemVFdmVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBsb3dlcktub2IgPSB0aGlzLl9sb3dlcktub2IsIHVwcGVyS25vYiA9IHRoaXMuX3VwcGVyS25vYiwgdG91Y2hzdGFydCA9IHRoaXMuX3RvdWNoU3RhcnQsIHRvdWNoRW5kID0gdGhpcy5fdG91Y2hFbmQsIHRyYWNrTG93ZXIgPSB0aGlzLl90cmFja0xvd2VyLCB0cmFja1VwcGVyID0gdGhpcy5fdHJhY2tVcHBlciwgdHJhY2ssIHJldmVyc2VUcmFjaztcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzVmVydGljYWwpIHtcclxuICAgICAgICAgICAgICAgIHRyYWNrID0gX18kdHJhY2sgKyBcImRvd25cIjtcclxuICAgICAgICAgICAgICAgIHJldmVyc2VUcmFjayA9IF9fJHRyYWNrICsgXCJ1cFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdHJhY2sgPSBfXyR0cmFjayArIFwicmlnaHRcIjtcclxuICAgICAgICAgICAgICAgIHJldmVyc2VUcmFjayA9IF9fJHRyYWNrICsgXCJsZWZ0XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGxvd2VyS25vYiwgX18kdG91Y2hzdGFydCwgdG91Y2hzdGFydCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodXBwZXJLbm9iLCBfXyR0b3VjaHN0YXJ0LCB0b3VjaHN0YXJ0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihsb3dlcktub2IsIHRyYWNrLCB0cmFja0xvd2VyLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihsb3dlcktub2IsIHJldmVyc2VUcmFjaywgdHJhY2tMb3dlciwgZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodXBwZXJLbm9iLCB0cmFjaywgdHJhY2tVcHBlciwgZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodXBwZXJLbm9iLCByZXZlcnNlVHJhY2ssIHRyYWNrVXBwZXIsIGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGxvd2VyS25vYiwgX18kdG91Y2hlbmQsIHRvdWNoRW5kLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih1cHBlcktub2IsIF9fJHRvdWNoZW5kLCB0b3VjaEVuZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIobG93ZXJLbm9iLCBfXyR0cmFja2VuZCwgdG91Y2hFbmQsIGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHVwcGVyS25vYiwgX18kdHJhY2tlbmQsIHRvdWNoRW5kLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl93aW5kb3csICdyZXNpemUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnV0aWxzLmlzTnVsbChfdGhpcy5fcmFuZ2VWaXNpYmxlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLl9zZXRQb3NpdGlvbkFuZExlbmd0aCgpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3NldExvd2VyS25vYlBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fc2V0VXBwZXJLbm9iUG9zaXRpb24oKTtcclxuICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTG9nIHRoZSBmaXJzdCB0b3VjaC5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSUdlc3R1cmVFdmVudH0gZXYgVGhlIHRvdWNoIGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5nZS5wcm90b3R5cGUuX3RvdWNoU3RhcnQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgdmFyIHRvdWNoU3RhdGUgPSB0aGlzLl90b3VjaFN0YXRlO1xyXG4gICAgICAgICAgICBpZiAodG91Y2hTdGF0ZSA9PT0gMSB8fCB0b3VjaFN0YXRlID09PSAyIHx8IHRvdWNoU3RhdGUgPT09IDMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90b3VjaFN0YXRlID0gMTtcclxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGV2LmN1cnJlbnRUYXJnZXQsIGxhc3RUb3VjaCA9IHRoaXMuX2xhc3RUb3VjaDtcclxuICAgICAgICAgICAgaWYgKHRoaXMudXRpbHMuaXNOdWxsKGxhc3RUb3VjaCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmFkZENsYXNzKHRhcmdldCwgX19QbGF0ICsgXCJ0b3BcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobGFzdFRvdWNoLnRhcmdldCAhPT0gdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZG9tID0gdGhpcy5kb207XHJcbiAgICAgICAgICAgICAgICBkb20uYWRkQ2xhc3ModGFyZ2V0LCBfX1BsYXQgKyBcInRvcFwiKTtcclxuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhsYXN0VG91Y2gudGFyZ2V0LCBfX1BsYXQgKyBcInRvcFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9sYXN0VG91Y2ggPSB7XHJcbiAgICAgICAgICAgICAgICB4OiBldi5jbGllbnRYLFxyXG4gICAgICAgICAgICAgICAgeTogZXYuY2xpZW50WSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB0YXJnZXQgPT09IHRoaXMuX2xvd2VyS25vYiA/IHRoaXMubG93ZXIgOiB0aGlzLnVwcGVyLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0aGUgbmV3IHNsaWRlciBlbGVtZW50IG9mZnNldC5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSUdlc3R1cmVFdmVudH0gZXYgVGhlICR0cmFja2VuZCBldmVudCBvYmplY3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZ2UucHJvdG90eXBlLl90b3VjaEVuZCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgdG91Y2hTdGF0ZSA9IHRoaXMuX3RvdWNoU3RhdGU7XHJcbiAgICAgICAgICAgIGlmICh0b3VjaFN0YXRlID09PSAwIHx8IHRvdWNoU3RhdGUgPT09IDQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RvdWNoU3RhdGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoU3RhdGUgPSA0O1xyXG4gICAgICAgICAgICB2YXIgbGFzdFRvdWNoID0gdGhpcy5fbGFzdFRvdWNoLCB0YXJnZXQgPSBldi5jdXJyZW50VGFyZ2V0O1xyXG4gICAgICAgICAgICBpZiAodGhpcy51dGlscy5pc051bGwobGFzdFRvdWNoKSB8fCAobGFzdFRvdWNoLnRhcmdldCAhPT0gdGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudXRpbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl90b3VjaFN0YXRlID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciBpc0xvd2VyID0gdGFyZ2V0ID09PSBfdGhpcy5fbG93ZXJLbm9iLCBuZXdPZmZzZXQgPSBfdGhpcy5fY2FsY3VsYXRlT2Zmc2V0KGV2LCBpc0xvd2VyKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0xvd2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RUb3VjaC52YWx1ZSAhPT0gX3RoaXMubG93ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RyaWdnZXIoJ2NoYW5nZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxhc3RUb3VjaC52YWx1ZSAhPT0gX3RoaXMudXBwZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdHJpZ2dlcignY2hhbmdlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fc2V0T2Zmc2V0KG5ld09mZnNldCwgaXNMb3dlcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgZGVzaWduYXRlZCBrbm9iIGVsZW1lbnQncyBvZmZzZXQgdG8gdGhlIGdpdmVuIHZhbHVlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIG5ldyBvZmZzZXQuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBpc0xvd2VyIFdoZXRoZXIgd2UncmUgc2V0dGluZyB0aGUgbG93ZXIgb3IgdXBwZXIga25vYi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5nZS5wcm90b3R5cGUuX3NldE9mZnNldCA9IGZ1bmN0aW9uIChvZmZzZXQsIGlzTG93ZXIpIHtcclxuICAgICAgICAgICAgdmFyIG1heE9mZnNldCA9IHRoaXMuX21heE9mZnNldDtcclxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gKHRoaXMuX2xvd2VyS25vYk9mZnNldCA9IDApIDpcclxuICAgICAgICAgICAgICAgICAgICAodGhpcy5fdXBwZXJLbm9iT2Zmc2V0ID0gMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICh0aGlzLl9sb3dlcktub2JPZmZzZXQgPSBtYXhPZmZzZXQpIDpcclxuICAgICAgICAgICAgICAgICAgICAodGhpcy5fdXBwZXJLbm9iT2Zmc2V0ID0gbWF4T2Zmc2V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICh0aGlzLl9sb3dlcktub2JPZmZzZXQgPSBvZmZzZXQpIDpcclxuICAgICAgICAgICAgICAgICh0aGlzLl91cHBlcktub2JPZmZzZXQgPSBvZmZzZXQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJhY2sgdGhlIGxvd2VyIGtub2IgbW92ZW1lbnQuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklHZXN0dXJlRXZlbnR9IGV2IFRoZSAkdHJhY2sgZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmdlLnByb3RvdHlwZS5fdHJhY2tMb3dlciA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICB2YXIgdG91Y2hTdGF0ZSA9IHRoaXMuX3RvdWNoU3RhdGU7XHJcbiAgICAgICAgICAgIGlmICh0b3VjaFN0YXRlICE9PSAyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodG91Y2hTdGF0ZSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RvdWNoU3RhdGUgPSAyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG91Y2hTdGF0ZSA9PT0gMCB8fCB0b3VjaFN0YXRlID09PSAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtYXhPZmZzZXQgPSB0aGlzLl9tYXhPZmZzZXQsIHBvc2l0aW9uID0gdGhpcy5fY2FsY3VsYXRlT2Zmc2V0KGV2LCB0cnVlKSwgdmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMubWluO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIC0gdGhpcy5sb3dlciA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBvc2l0aW9uID49IG1heE9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLm1heDtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAtIHRoaXMubG93ZXIgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gbWF4T2Zmc2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9jYWxjdWxhdGVWYWx1ZShwb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgLSB0aGlzLmxvd2VyID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+IHRoaXMuX3VwcGVyS25vYk9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25Ub2dldGhlcihwb3NpdGlvbiwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0T2Zmc2V0KHBvc2l0aW9uLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25Mb3dlcihwb3NpdGlvbiwgdmFsdWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJhY2sgdGhlIHVwcGVyIGtub2IgbW92ZW1lbnQuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklHZXN0dXJlRXZlbnR9IGV2IFRoZSAkdHJhY2sgZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmdlLnByb3RvdHlwZS5fdHJhY2tVcHBlciA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICB2YXIgdG91Y2hTdGF0ZSA9IHRoaXMuX3RvdWNoU3RhdGU7XHJcbiAgICAgICAgICAgIGlmICh0b3VjaFN0YXRlICE9PSAzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodG91Y2hTdGF0ZSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RvdWNoU3RhdGUgPSAzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG91Y2hTdGF0ZSA9PT0gMCB8fCB0b3VjaFN0YXRlID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtYXhPZmZzZXQgPSB0aGlzLl9tYXhPZmZzZXQsIHBvc2l0aW9uID0gdGhpcy5fY2FsY3VsYXRlT2Zmc2V0KGV2LCBmYWxzZSksIHZhbHVlO1xyXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLm1pbjtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAtIHRoaXMudXBwZXIgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwb3NpdGlvbiA+PSBtYXhPZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5tYXg7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgLSB0aGlzLnVwcGVyIDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IG1heE9mZnNldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fY2FsY3VsYXRlVmFsdWUocG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIC0gdGhpcy51cHBlciA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPCB0aGlzLl9sb3dlcktub2JPZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uVG9nZXRoZXIocG9zaXRpb24sIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldE9mZnNldChwb3NpdGlvbiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25VcHBlcihwb3NpdGlvbiwgdmFsdWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUG9zaXRpb25zIHRoZSBzbGlkZXIgZWxlbWVudCBhbmQgYWRqdXN0cyBpdCdzIGxlbmd0aCB0byBhY2NvdW50XHJcbiAgICAgICAgICogZm9yIGxvd2VyIGtub2IgbW92ZW1lbnQuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIFRoZSBuZXcgcG9zaXRpb24gb2YgdGhlIGxvd2VyIGtub2IuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlPyBUaGUgbmV3IHZhbHVlIHRvIHNldCBpZiBzcGVjaWZpZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZ2UucHJvdG90eXBlLl9wb3NpdGlvbkxvd2VyID0gZnVuY3Rpb24gKHBvc2l0aW9uLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLnV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBfdGhpcy5fc2xpZGVyLnN0eWxlO1xyXG4gICAgICAgICAgICAgICAgc3R5bGVbX3RoaXMuX3Bvc2l0aW9uUHJvcGVydHldID0gcG9zaXRpb24gKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICBzdHlsZVtfdGhpcy5fbGVuZ3RoUHJvcGVydHldID0gKF90aGlzLl91cHBlcktub2JPZmZzZXQgLSBwb3NpdGlvbikgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fc2V0TG93ZXJWYWx1ZSh2YWx1ZSwgZmFsc2UsIHRydWUsIHRydWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBvc2l0aW9ucyB0aGUgc2xpZGVyIGVsZW1lbnQgYW5kIGFkanVzdHMgaXQncyBsZW5ndGggdG8gYWNjb3VudFxyXG4gICAgICAgICAqIGZvciB1cHBlciBrbm9iIG1vdmVtZW50LlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiBUaGUgbmV3IHBvc2l0aW9uIG9mIHRoZSB1cHBlciBrbm9iLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZT8gVGhlIG5ldyB2YWx1ZSB0byBzZXQgaWYgc3BlY2lmaWVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmdlLnByb3RvdHlwZS5fcG9zaXRpb25VcHBlciA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy51dGlscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3NsaWRlci5zdHlsZVtfdGhpcy5fbGVuZ3RoUHJvcGVydHldID0gKHBvc2l0aW9uIC0gX3RoaXMuX2xvd2VyS25vYk9mZnNldCkgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fc2V0VXBwZXJWYWx1ZSh2YWx1ZSwgZmFsc2UsIHRydWUsIHRydWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBvc2l0aW9ucyB0aGUgc2xpZGVyIGVsZW1lbnQgYW5kIGFkanVzdHMgaXQncyBsZW5ndGggdG8gYWNjb3VudFxyXG4gICAgICAgICAqIGZvciBzeW5jaHJvbml6ZWQga25vYiBtb3ZlbWVudC5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gVGhlIG5ldyBwb3NpdGlvbiBvZiB0aGUga25vYnMuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlPyBUaGUgbmV3IHZhbHVlIHRvIHNldCBpZiBzcGVjaWZpZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZ2UucHJvdG90eXBlLl9wb3NpdGlvblRvZ2V0aGVyID0gZnVuY3Rpb24gKHBvc2l0aW9uLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLnV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBfdGhpcy5fc2xpZGVyLnN0eWxlO1xyXG4gICAgICAgICAgICAgICAgc3R5bGVbX3RoaXMuX3Bvc2l0aW9uUHJvcGVydHldID0gcG9zaXRpb24gKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICBzdHlsZVtfdGhpcy5fbGVuZ3RoUHJvcGVydHldID0gJzBweCc7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fc2V0TG93ZXJWYWx1ZSh2YWx1ZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fc2V0VXBwZXJWYWx1ZSh2YWx1ZSwgZmFsc2UsIHRydWUsIHRydWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGN1cnJlbnQgdmFsdWUgYmFzZWQgb24ga25vYiBwb3NpdGlvbiBhbmQgc2xpZGVyIGVsZW1lbnQgd2lkdGguXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFRoZSBjdXJyZW50IHdpZHRoIG9mIHRoZSBzbGlkZXIgZWxlbWVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5nZS5wcm90b3R5cGUuX2NhbGN1bGF0ZVZhbHVlID0gZnVuY3Rpb24gKHdpZHRoKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGVwID0gdGhpcy5fc3RlcDtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLm1pbiArIE1hdGgucm91bmQod2lkdGggLyB0aGlzLl9pbmNyZW1lbnQgLyBzdGVwKSAqIHN0ZXApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgbmV3IG9mZnNldCBvZiB0aGUgc2xpZGVyIGVsZW1lbnQgYmFzZWQgb24gdGhlIG9sZCBvZmZzZXQgYW5kIHRoZSBkaXN0YW5jZSBtb3ZlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSUdlc3R1cmVFdmVudH0gZXYgVGhlICR0cmFjayBvciAkdHJhY2tlbmQgZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMb3dlciBXaGV0aGVyIHRoZSBjdXJyZW50IGtub2IgaXMgdGhlIGxvd2VyIG9yIHRoZSB1cHBlciBrbm9iLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmdlLnByb3RvdHlwZS5fY2FsY3VsYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKGV2LCBpc0xvd2VyKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50T2Zmc2V0ID0gaXNMb3dlciA/IHRoaXMuX2xvd2VyS25vYk9mZnNldCA6IHRoaXMuX3VwcGVyS25vYk9mZnNldCwgZGlzcGxhY2VtZW50O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgZGlzcGxhY2VtZW50ID0gdGhpcy5fcmV2ZXJzZWQgPyBldi5jbGllbnRZIC0gdGhpcy5fbGFzdFRvdWNoLnkgOiB0aGlzLl9sYXN0VG91Y2gueSAtIGV2LmNsaWVudFk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGFjZW1lbnQgPSB0aGlzLl9yZXZlcnNlZCA/IHRoaXMuX2xhc3RUb3VjaC54IC0gZXYuY2xpZW50WCA6IGV2LmNsaWVudFggLSB0aGlzLl9sYXN0VG91Y2gueDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudE9mZnNldCArIGRpc3BsYWNlbWVudDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZXMga25vYiBwb3NpdGlvbiBiYXNlZCBvbiBjdXJyZW50IHZhbHVlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUge2xpbmsgcGxhdHVpLlJhbmdlfFJhbmdlfS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5nZS5wcm90b3R5cGUuX2NhbGN1bGF0ZUtub2JQb3NpdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlIC0gdGhpcy5taW4pICogdGhpcy5faW5jcmVtZW50O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgbG93ZXIgdmFsdWUgb2YgdGhlIFJhbmdlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdWYWx1ZSBUaGUgbmV3IHZhbHVlIHRvIHNldC5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNldEtub2IgV2hldGhlciBvciBub3Qgd2UgbmVlZCB0byBzZXQgdGhlIGtub2IgcG9zaXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBwcm9wZXJ0eUNoYW5nZWQgV2hldGhlciBvciBub3QgdGhlIHByb3BlcnR5IHdhcyBjaGFuZ2VkIGJ5IHRoZSB1c2VyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdHJpZ2dlciBXaGV0aGVyIG9yIG5vdCB0byB0cmlnZ2VyIHRoZSAnaW5wdXQnIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmdlLnByb3RvdHlwZS5fc2V0TG93ZXJWYWx1ZSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgc2V0S25vYiwgcHJvcGVydHlDaGFuZ2VkLCB0cmlnZ2VyKSB7XHJcbiAgICAgICAgICAgIHZhciBsb3dlciA9IHRoaXMubG93ZXI7XHJcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gbG93ZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChuZXdWYWx1ZSA+PSB0aGlzLm1heCkge1xyXG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSB0aGlzLm1heDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChuZXdWYWx1ZSA8PSB0aGlzLm1pbikge1xyXG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSB0aGlzLm1pbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChNYXRoLmFicyhuZXdWYWx1ZSAtIGxvd2VyKSA8IHRoaXMuX3N0ZXApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmxvd2VyID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChzZXRLbm9iKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRMb3dlcktub2JQb3NpdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eUNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmVDaGFuZ2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHJpZ2dlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcignaW5wdXQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIFJhbmdlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdWYWx1ZSBUaGUgbmV3IHZhbHVlIHRvIHNldC5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNldEtub2IgV2hldGhlciBvciBub3Qgd2UgbmVlZCB0byBzZXQgdGhlIGtub2IgcG9zaXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBwcm9wZXJ0eUNoYW5nZWQgV2hldGhlciBvciBub3QgdGhlIHByb3BlcnR5IHdhcyBjaGFuZ2VkIGJ5IHRoZSB1c2VyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdHJpZ2dlciBXaGV0aGVyIG9yIG5vdCB0byB0cmlnZ2VyIHRoZSAnaW5wdXQnIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmdlLnByb3RvdHlwZS5fc2V0VXBwZXJWYWx1ZSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgc2V0S25vYiwgcHJvcGVydHlDaGFuZ2VkLCB0cmlnZ2VyKSB7XHJcbiAgICAgICAgICAgIHZhciB1cHBlciA9IHRoaXMudXBwZXI7XHJcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdXBwZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChuZXdWYWx1ZSA+PSB0aGlzLm1heCkge1xyXG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSB0aGlzLm1heDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChuZXdWYWx1ZSA8PSB0aGlzLm1pbikge1xyXG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSB0aGlzLm1pbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChNYXRoLmFicyhuZXdWYWx1ZSAtIHVwcGVyKSA8IHRoaXMuX3N0ZXApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnVwcGVyID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChzZXRLbm9iKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRVcHBlcktub2JQb3NpdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eUNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmVDaGFuZ2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHJpZ2dlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcignaW5wdXQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgaW5jcmVtZW50IGZvciBzbGlkaW5nIHRoZSB7bGluayBwbGF0dWkuUmFuZ2V8UmFuZ2V9LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmdlLnByb3RvdHlwZS5fc2V0SW5jcmVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuX2luY3JlbWVudCA9IHRoaXMuX21heE9mZnNldCAvICh0aGlzLm1heCAtIHRoaXMubWluKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0aWVzIHRvIHVzZSBmb3IgbGVuZ3RoIGFuZCBwb3NpdGlvbiBhbmQgc2V0cyB0aGUgbWF4IGxlbmd0aCBvZiB0aGUgc2xpZGluZyBlbGVtZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmdlLnByb3RvdHlwZS5fc2V0UG9zaXRpb25BbmRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuX3NsaWRlci5wYXJlbnRFbGVtZW50O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGVuZ3RoUHJvcGVydHkgPSAnaGVpZ2h0JztcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uUHJvcGVydHkgPSB0aGlzLl9yZXZlcnNlZCA/ICd0b3AnIDogJ2JvdHRvbSc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXhPZmZzZXQgPSBlbC5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sZW5ndGhQcm9wZXJ0eSA9ICd3aWR0aCc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3NpdGlvblByb3BlcnR5ID0gdGhpcy5fcmV2ZXJzZWQgPyAncmlnaHQnIDogJ2xlZnQnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWF4T2Zmc2V0ID0gZWwuY2xpZW50V2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9tYXhPZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JhbmdlVmlzaWJsZSA9IG5ldyB0aGlzLl9Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlbW92ZVZpc2liaWxpdHlMaXN0ZW5lciA9IF90aGlzLmRvbS53aGVuVmlzaWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yYW5nZVZpc2libGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2V0UG9zaXRpb25BbmRMZW5ndGgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIGVsKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3NldEluY3JlbWVudCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW5pbWF0ZXMgYW5kIHNldHMgdGhlIGtub2IgcG9zaXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlPyBUaGUgdmFsdWUgdG8gdXNlIHRvIGNhbGN1bGF0ZSB0aGUga25vYiBwb3NpdGlvbi4gSWYgbm8gdmFsdWUgaXNcclxuICAgICAgICAgKiBzcGVjaWZpZWQsIHRoZSBjdXJyZW50IFJhbmdlJ3MgdmFsdWUgd2lsbCBiZSB1c2VkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmdlLnByb3RvdHlwZS5fc2V0TG93ZXJLbm9iUG9zaXRpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5fUHJvbWlzZS5yZXNvbHZlKHRoaXMuX3JhbmdlVmlzaWJsZSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uT3B0aW9ucyA9IHt9LCB1cHBlcktub2JPZmZzZXQgPSBfdGhpcy5fdXBwZXJLbm9iT2Zmc2V0LCB1cHBlck9mZnNldCA9IF90aGlzLnV0aWxzLmlzTnVtYmVyKHVwcGVyS25vYk9mZnNldCkgP1xyXG4gICAgICAgICAgICAgICAgICAgIHVwcGVyS25vYk9mZnNldCA6XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3NldE9mZnNldChfdGhpcy5fY2FsY3VsYXRlS25vYlBvc2l0aW9uKF90aGlzLnVwcGVyKSwgZmFsc2UpLCBwb3NpdGlvbiA9IF90aGlzLl9jYWxjdWxhdGVLbm9iUG9zaXRpb24oKHZhbHVlIHx8IF90aGlzLmxvd2VyKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IF90aGlzLl9sb3dlcktub2JPZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb25PcHRpb25zW190aGlzLl9wb3NpdGlvblByb3BlcnR5XSA9IHBvc2l0aW9uICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uT3B0aW9uc1tfdGhpcy5fbGVuZ3RoUHJvcGVydHldID0gKHVwcGVyT2Zmc2V0IC0gcG9zaXRpb24pICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2FuaW1hdG9yLmFuaW1hdGUoX3RoaXMuX3NsaWRlciwgX19UcmFuc2l0aW9uLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogYW5pbWF0aW9uT3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG93ZXJLbm9iT2Zmc2V0ID0gcG9zaXRpb247XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW5pbWF0ZXMgYW5kIHNldHMgdGhlIGtub2IgcG9zaXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlPyBUaGUgdmFsdWUgdG8gdXNlIHRvIGNhbGN1bGF0ZSB0aGUga25vYiBwb3NpdGlvbi4gSWYgbm8gdmFsdWUgaXNcclxuICAgICAgICAgKiBzcGVjaWZpZWQsIHRoZSBjdXJyZW50IFJhbmdlJ3MgdmFsdWUgd2lsbCBiZSB1c2VkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmdlLnByb3RvdHlwZS5fc2V0VXBwZXJLbm9iUG9zaXRpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5fUHJvbWlzZS5yZXNvbHZlKHRoaXMuX3JhbmdlVmlzaWJsZSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uT3B0aW9ucyA9IHt9LCBsZW5ndGggPSBfdGhpcy5fY2FsY3VsYXRlS25vYlBvc2l0aW9uKCh2YWx1ZSB8fCBfdGhpcy51cHBlcikpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gX3RoaXMuX3VwcGVyS25vYk9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbk9wdGlvbnNbX3RoaXMuX2xlbmd0aFByb3BlcnR5XSA9IChsZW5ndGggLSBfdGhpcy5fbG93ZXJLbm9iT2Zmc2V0KSArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9hbmltYXRvci5hbmltYXRlKF90aGlzLl9zbGlkZXIsIF9fVHJhbnNpdGlvbiwge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IGFuaW1hdGlvbk9wdGlvbnNcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3VwcGVyS25vYk9mZnNldCA9IGxlbmd0aDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaXJlcyBhbiBpbnB1dENoYW5nZWQgZXZlbnQgd2l0aCB0aGUgbmV3IGJvdW5kIHZhbHVlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmdlLnByb3RvdHlwZS5fZmlyZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG5ld1Byb3BlcnR5ID0ge307XHJcbiAgICAgICAgICAgIG5ld1Byb3BlcnR5W3RoaXMuX2xvd2VySWRlbnRpZmllcl0gPSB0aGlzLmxvd2VyO1xyXG4gICAgICAgICAgICBuZXdQcm9wZXJ0eVt0aGlzLl91cHBlcklkZW50aWZpZXJdID0gdGhpcy51cHBlcjtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dENoYW5nZWQobmV3UHJvcGVydHkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJpZ2dlcnMgYW4gZXZlbnQgc3RhcnRpbmcgZnJvbSB0aGlzIGNvbnRyb2wncyBlbGVtZW50LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCBUaGUgZXZlbnQgbmFtZSB0byB0cmlnZ2VyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmdlLnByb3RvdHlwZS5fdHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICB2YXIgZG9tRXZlbnQgPSBwbGF0LmFjcXVpcmUoX19Eb21FdmVudEluc3RhbmNlKTtcclxuICAgICAgICAgICAgZG9tRXZlbnQuaW5pdGlhbGl6ZSh0aGlzLmVsZW1lbnQsIGV2ZW50KTtcclxuICAgICAgICAgICAgZG9tRXZlbnQudHJpZ2dlcigpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2tzIHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgY29udHJvbCBhbmQgZW5zdXJlcyBpdCBpcyB2YWxpZC5cclxuICAgICAgICAgKiBXaWxsIGRlZmF1bHQgdG8gXCJob3Jpem9udGFsXCIgaWYgaW52YWxpZC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3JpZW50YXRpb24gVGhlIGVsZW1lbnQgdG8gYmFzZSB0aGUgbGVuZ3RoIG9mZiBvZi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5nZS5wcm90b3R5cGUuX3ZhbGlkYXRlT3JpZW50YXRpb24gPSBmdW5jdGlvbiAob3JpZW50YXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudXRpbHMuaXNVbmRlZmluZWQob3JpZW50YXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hvcml6b250YWwnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB2YWxpZE9yaWVudGF0aW9uO1xyXG4gICAgICAgICAgICBpZiAob3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xyXG4gICAgICAgICAgICAgICAgdmFsaWRPcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZE9yaWVudGF0aW9uID0gb3JpZW50YXRpb247XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1ZlcnRpY2FsID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhcIkludmFsaWQgb3JpZW50YXRpb24gXFxcIlwiICsgb3JpZW50YXRpb24gKyBcIlxcXCIgZm9yIFwiICsgdGhpcy50eXBlICsgXCIuIERlZmF1bHRpbmcgdG8gXFxcImhvcml6b250YWwuXFxcIlwiKTtcclxuICAgICAgICAgICAgICAgIHZhbGlkT3JpZW50YXRpb24gPSAnaG9yaXpvbnRhbCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkT3JpZW50YXRpb247XHJcbiAgICAgICAgfTtcclxuICAgICAgICBSYW5nZS5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICBfZG9jdW1lbnQ6IF9fRG9jdW1lbnQsXHJcbiAgICAgICAgICAgIF93aW5kb3c6IF9fV2luZG93LFxyXG4gICAgICAgICAgICBfUHJvbWlzZTogX19Qcm9taXNlLFxyXG4gICAgICAgICAgICBfYW5pbWF0b3I6IF9fQW5pbWF0b3JcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBSYW5nZTtcclxuICAgIH0ocGxhdC51aS5CaW5kQ29udHJvbCkpO1xyXG4gICAgcGxhdHVpLlJhbmdlID0gUmFuZ2U7XHJcbiAgICBwbGF0LnJlZ2lzdGVyLmNvbnRyb2woX19SYW5nZSwgUmFuZ2UpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBJVGVtcGxhdGVDb250cm9sIHRoYXQgYWxsb3dzIGZvciBkYXRhYmluZGluZyBhIHNlbGVjdCBib3ggYW5kIGFkZHNcclxuICAgICAqIGN1c3RvbSBzdHlsaW5nIHRvIG1ha2UgaXQgbG9vayBjb25zaXN0ZW50IGFjcm9zcyBhbGwgcGxhdGZvcm1zLlxyXG4gICAgICovXHJcbiAgICB2YXIgU2VsZWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoU2VsZWN0LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFNlbGVjdCgpIHtcclxuICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGNsYXNzZXMgb24gdGhlIHByb3BlciBlbGVtZW50cy5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lPyBBbiBvcHRpb25hbCwgYWRkaXRpb25hbCBjbGFzcyBuYW1lIG9yIGNsYXNzIG5hbWVzIHRvIHNldCBvbiB0aGUgY29udHJvbFxyXG4gICAgICAgICAqIGluIGFkZGl0aW9uIHRvIGl0cyBzdGFuZGFyZCBzZXQuXHJcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50PyBUaGUgZWxlbWVudCB0byBzZXQgdGhlIGNsYXNzIG5hbWUgb24uIFNob3VsZCBkZWZhdWx0IHRvXHJcbiAgICAgICAgICogdGhlIGNvbnRyb2wncyBlbGVtZW50IGlmIG5vdCBzcGVjaWZpZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2VsZWN0LnByb3RvdHlwZS5zZXRDbGFzc2VzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSwgZWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRDbGFzcyhlbGVtZW50IHx8IHRoaXMuZWxlbWVudCwgX19TZWxlY3QgKyBcIiBcIiArIChjbGFzc05hbWUgfHwgJycpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0aGUgY2xhc3MgbmFtZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTZWxlY3QucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLnNldENsYXNzZXMoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBTZWxlY3Q7XHJcbiAgICB9KHBsYXQudWkuY29udHJvbHMuU2VsZWN0KSk7XHJcbiAgICBwbGF0dWkuU2VsZWN0ID0gU2VsZWN0O1xyXG4gICAgcGxhdC5yZWdpc3Rlci5jb250cm9sKF9fU2VsZWN0LCBTZWxlY3QpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBCaW5kQ29udHJvbCB0aGF0IHN0YW5kYXJkaXplcyBhbmQgc3R5bGVzXHJcbiAgICAgKiBhbiBIVE1MIGlucHV0IGVsZW1lbnQgb2YgdmFyaW91cyB0eXBlcy5cclxuICAgICAqL1xyXG4gICAgdmFyIElucHV0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoSW5wdXQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gSW5wdXQoKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVwbGFjZXMgdGhlIGNvbnRyb2wncyBlbGVtZW50IHdpdGggYW4gSFRNTElucHV0RWxlbWVudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZVdpdGggPSAnaW5wdXQnO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGN1cnJlbnQgdmFsdWUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGNsYXNzZXMgb24gdGhlIHByb3BlciBlbGVtZW50cy5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lPyBBbiBvcHRpb25hbCwgYWRkaXRpb25hbCBjbGFzcyBuYW1lIG9yIGNsYXNzIG5hbWVzIHRvIHNldCBvbiB0aGUgY29udHJvbFxyXG4gICAgICAgICAqIGluIGFkZGl0aW9uIHRvIGl0cyBzdGFuZGFyZCBzZXQuXHJcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50PyBUaGUgZWxlbWVudCB0byBzZXQgdGhlIGNsYXNzIG5hbWUgb24uIFNob3VsZCBkZWZhdWx0IHRvXHJcbiAgICAgICAgICogdGhlIGNvbnRyb2wncyBlbGVtZW50IGlmIG5vdCBzcGVjaWZpZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgSW5wdXQucHJvdG90eXBlLnNldENsYXNzZXMgPSBmdW5jdGlvbiAoY2xhc3NOYW1lLCBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZENsYXNzKGVsZW1lbnQgfHwgdGhpcy5lbGVtZW50LCBfX0lucHV0ICsgXCIgXCIgKyAoY2xhc3NOYW1lIHx8ICcnKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdGhlIGNsYXNzIG5hbWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgSW5wdXQucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0Q2xhc3NlcygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IGFsbCBIVE1MRWxlbWVudCByZWZlcmVuY2VzIGFuZCBwb3RlbnRpYWwgYXR0cmlidXRlIGNvbnRyb2xzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIElucHV0LnByb3RvdHlwZS5zZXRUZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5kb20uY2xlYXJOb2RlKHRoaXMuZWxlbWVudCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdGhlIHN0eWxlIGFuZCBpbml0aWFsaXplIHRoZSBhY3Rpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgSW5wdXQucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbk9iaiA9IHRoaXMub3B0aW9ucyB8fCB7fSwgb3B0aW9ucyA9IG9wdGlvbk9iai52YWx1ZSB8fCB7fSwgcGF0dGVybiA9IG9wdGlvbnMucGF0dGVybiwgdmFsaWRhdGlvbiA9IG9wdGlvbnMudmFsaWRhdGlvbiwgaXNTdHJpbmcgPSB0aGlzLnV0aWxzLmlzU3RyaW5nO1xyXG4gICAgICAgICAgICB0aGlzLl90eXBlID0gdGhpcy5hdHRyaWJ1dGVzWyd0eXBlJ10gfHwgb3B0aW9ucy50eXBlIHx8ICd0ZXh0JztcclxuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKHBhdHRlcm4pICYmIHBhdHRlcm4gIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGF0dGVyblswXSA9PT0gJy8nICYmIHBhdHRlcm5bcGF0dGVybi5sZW5ndGggLSAxXSA9PT0gJy8nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4uc2xpY2UoMSwgLTEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGF0dGVybiA9IG5ldyBSZWdFeHAocGF0dGVybik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKHZhbGlkYXRpb24pICYmIHZhbGlkYXRpb24gIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGlvblswXSA9PT0gJy8nICYmIHZhbGlkYXRpb25bdmFsaWRhdGlvbi5sZW5ndGggLSAxXSA9PT0gJy8nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbiA9IHZhbGlkYXRpb24uc2xpY2UoMSwgLTEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGlvbiA9IG5ldyBSZWdFeHAodmFsaWRhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZVR5cGUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgZnVuY3Rpb24gdG8gdmFsaWRhdGUgdGhlIHVzZXIncyBpbnB1dC4gRm9yIGFjdGlvbj1cImVtYWlsXCIgaXQgcmV0dXJuc1xyXG4gICAgICAgICAqIHRydWUgaWYgdGhlIGVtYWlsIGNhbiBiZSBhIHZhbGlkIGVtYWlsIGFkZHJlc3MuIEZvciBhbGwgb3RoZXJcclxuICAgICAgICAgKiBhY3Rpb25zIGl0IHJldHVybnMgdHJ1ZSBpZiB0aGUgaW5wdXQgaXMgbm90IGVtcHR5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIElucHV0LnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRpb24udGVzdCh0aGlzLmVsZW1lbnQudmFsdWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xlYXJzIHRoZSB1c2VyJ3MgaW5wdXQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgSW5wdXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCwgdmFsdWUgPSBlbGVtZW50LnZhbHVlO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxlbWVudC52YWx1ZSA9IHRoaXMudmFsdWUgPSAnJztcclxuICAgICAgICAgICAgdGhpcy5pbnB1dENoYW5nZWQodGhpcy52YWx1ZSwgdmFsdWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRm9jdXNlcyB0aGUgaW5wdXQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgSW5wdXQucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuZm9jdXMoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJsdXJzIHRoZSBpbnB1dC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBJbnB1dC5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmJsdXIoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgdGhpcyBjb250cm9sIHRvIG9ic2VydmUgYm90aCB0aGUgYm91bmQgcHJvcGVydHkgaXRzZWxmIGFzIHdlbGwgYXNcclxuICAgICAgICAgKiBwb3RlbnRpYWwgY2hpbGQgcHJvcGVydGllcyBpZiBiZWluZyBib3VuZCB0byBhbiBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0Lm9ic2VydmFibGUuSUltcGxlbWVudFR3b1dheUJpbmRpbmd9IGJpbmRlciBUaGUgY29udHJvbCB0aGF0IGZhY2lsaXRhdGVzIHRoZVxyXG4gICAgICAgICAqIGRhdGFiaW5kaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIElucHV0LnByb3RvdHlwZS5vYnNlcnZlUHJvcGVydGllcyA9IGZ1bmN0aW9uIChiaW5kZXIpIHtcclxuICAgICAgICAgICAgYmluZGVyLm9ic2VydmVQcm9wZXJ0eSh0aGlzLl9zZXRCb3VuZFByb3BlcnR5LCBudWxsLCB0cnVlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgYmluZGFibGUgdGV4dCBpcyBzZXQgZXh0ZXJuYWxseS5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3VmFsdWUgVGhlIG5ldyB2YWx1ZSBvZiB0aGUgYmluZGFibGUgdGV4dC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBvZiB0aGUgYmluZGFibGUgdGV4dC5cclxuICAgICAgICAgKiBAcGFyYW0ge3ZvaWR9IGlkZW50aWZpZXIgVGhlIGNoaWxkIGlkZW50aWZpZXIgb2YgdGhlIHByb3BlcnR5IGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlyc3RUaW1lPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsIHRvIGJpbmQgdGhlIHByb3BlcnR5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIElucHV0LnByb3RvdHlwZS5fc2V0Qm91bmRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUsIGlkZW50aWZpZXIsIGZpcnN0VGltZSkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmVsZW1lbnQudmFsdWU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnV0aWxzLmlzTnVsbChuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gJyc7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RUaW1lID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudXRpbHMuaXNOdWxsKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbklucHV0Q2hhbmdlZChuZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChuZXdWYWx1ZSA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9vbklucHV0Q2hhbmdlZChuZXdWYWx1ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbml0aWFsaXplcyB0aGUgdHlwZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBJbnB1dC5wcm90b3R5cGUuX2luaXRpYWxpemVUeXBlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaW5wdXRUeXBlID0gdGhpcy5fdHlwZTtcclxuICAgICAgICAgICAgc3dpdGNoIChpbnB1dFR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhdHRlcm4gPSB0aGlzLl9wYXR0ZXJuIHx8IC9bXFxTXFxzXSovO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRpb24gPSB0aGlzLl92YWxpZGF0aW9uIHx8IHRoaXMuX3BhdHRlcm47XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdlbWFpbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGF0dGVybiA9IHRoaXMuX3BhdHRlcm4gfHwgL1tcXFNcXHNdKi87XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGlvbiA9IHRoaXMuX3ZhbGlkYXRpb24gfHwgdGhpcy5fcmVnZXgudmFsaWRhdGVFbWFpbDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3Bhc3N3b3JkJzpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXR0ZXJuID0gdGhpcy5fcGF0dGVybiB8fCAvW1xcU1xcc10qLztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWxpZGF0aW9uID0gdGhpcy5fdmFsaWRhdGlvbiB8fCB0aGlzLl9wYXR0ZXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAndGVsZXBob25lJzpcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dFR5cGUgPSAndGVsJztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3RlbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGF0dGVybiA9IHRoaXMuX3BhdHRlcm4gfHwgdGhpcy5fcmVnZXgudmFsaWRhdGVUZWxlcGhvbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGlvbiA9IHRoaXMuX3ZhbGlkYXRpb24gfHwgdGhpcy5fcGF0dGVybjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGF0dGVybiA9IHRoaXMuX3BhdHRlcm4gfHwgL15bMC05XFwuLF0qJC87XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGlvbiA9IHRoaXMuX3ZhbGlkYXRpb24gfHwgdGhpcy5fcGF0dGVybjtcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dFR5cGUgPSAndGVsJztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2hpZGRlbic6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShfX0hpZGUsICcnKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBjYXNlICdyYWRpbyc6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKGlucHV0VHlwZSArIFwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgXCIgKyB0aGlzLnR5cGUgKyBcIi4gUGxlYXNlIHVzZSBhIFwiICsgX19SYWRpbyArIFwiIGluc3RlYWQuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoaW5wdXRUeXBlICsgXCIgaXMgbm90IHN1cHBvcnRlZCBieSBcIiArIHRoaXMudHlwZSArIFwiLiBQbGVhc2UgdXNlIGEgXCIgKyBfX0NoZWNrYm94ICsgXCIgaW5zdGVhZC5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncmFuZ2UnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhpbnB1dFR5cGUgKyBcIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IFwiICsgdGhpcy50eXBlICsgXCIuIFBsZWFzZSB1c2UgYSBcIiArIF9fU2xpZGVyICsgXCIgaW5zdGVhZC5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZmlsZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKGlucHV0VHlwZSArIFwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgXCIgKyB0aGlzLnR5cGUgKyBcIi4gUGxlYXNlIHVzZSBhIFwiICsgX19GaWxlICsgXCIgaW5zdGVhZC5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoaW5wdXRUeXBlICsgXCIgaXMgbm90IHlldCBmdWxseSBzdXBwb3J0ZWQgYnkgXCIgKyB0aGlzLnR5cGUgKyBcIi4gRGVmYXVsdGluZyB0byB0eXBlPVxcXCJ0ZXh0XFxcIi5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRUeXBlID0gJ3RleHQnO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhdHRlcm4gPSB0aGlzLl9wYXR0ZXJuIHx8IC9bXFxTXFxzXSovO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRpb24gPSB0aGlzLl92YWxpZGF0aW9uIHx8IHRoaXMuX3BhdHRlcm47XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYWRkVGV4dEV2ZW50TGlzdGVuZXIoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSB0ZXh0IGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBpbnB1dCBlbGVtZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIElucHV0LnByb3RvdHlwZS5fYWRkVGV4dEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuZWxlbWVudCwgY29tcGF0ID0gdGhpcy5fY29tcGF0LCB1dGlscyA9IHRoaXMudXRpbHMsIGNvbXBvc2luZyA9IGZhbHNlLCB0aW1lb3V0LCBldmVudExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvc2luZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLl9vbklucHV0KCk7XHJcbiAgICAgICAgICAgIH0sIHBvc3Rwb25lZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbih0aW1lb3V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSB1dGlscy5wb3N0cG9uZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmICh1dGlscy5pc1VuZGVmaW5lZChjb21wYXQuQU5EUk9JRCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihpbnB1dCwgJ2NvbXBvc2l0aW9uc3RhcnQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiAoY29tcG9zaW5nID0gdHJ1ZSk7IH0sIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihpbnB1dCwgJ2NvbXBvc2l0aW9uZW5kJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvc2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29tcGF0Lmhhc0V2ZW50KCdpbnB1dCcpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoaW5wdXQsICdpbnB1dCcsIGV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihpbnB1dCwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gZXYua2V5Q29kZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSA5MSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPT09IDkyIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChrZXkgPiAxNSAmJiBrZXkgPCAyOCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGtleSA+IDMyICYmIGtleSA8IDQxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gX3RoaXMuX3BhdHRlcm4sIGNoYXIgPSBldi5jaGFyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHBhdHRlcm4udGVzdChjaGFyKSAmJiBwYXR0ZXJuLnRlc3QoaW5wdXQudmFsdWUgKyBjaGFyKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwb3N0cG9uZWRFdmVudExpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoaW5wdXQsICdjdXQnLCBwb3N0cG9uZWRFdmVudExpc3RlbmVyLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoaW5wdXQsICdwYXN0ZScsIHBvc3Rwb25lZEV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoaW5wdXQsICdjaGFuZ2UnLCBldmVudExpc3RlbmVyLCBmYWxzZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZXZlbnQgaGFuZGxlciB1cG9uIHVzZXIgdGV4dCBpbnB1dC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBJbnB1dC5wcm90b3R5cGUuX29uSW5wdXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LCB2YWx1ZSA9IGVsZW1lbnQudmFsdWUsIHN0cmlwcGVkVmFsdWUgPSB0aGlzLl9zdHJpcElucHV0KGVsZW1lbnQudmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHN0cmlwcGVkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gZWxlbWVudC52YWx1ZSA9IHN0cmlwcGVkVmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB0aGlzLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGVsZW1lbnQudmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXRDaGFuZ2VkKHRoaXMudmFsdWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGV2ZW50IGhhbmRsZXIgdXBvbiBib3VuZCB0ZXh0IGJlaW5nIGNoYW5nZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld1ZhbHVlIFRoZSBuZXcgdmFsdWUgb2YgdGhlIGJvdW5kIHRleHQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgSW5wdXQucHJvdG90eXBlLl9vbklucHV0Q2hhbmdlZCA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcclxuICAgICAgICAgICAgbmV3VmFsdWUgPSB0aGlzLl9zdHJpcElucHV0KG5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgZWxlbWVudC52YWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gZWxlbWVudC52YWx1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBhcnNlcyB0aGUgaW5wdXQgYW5kIHN0cmlwcyBpdCBvZiBjaGFyYWN0ZXJzIHRoYXQgZG9uJ3QgZml0IGl0cyBwYXR0ZXJuLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgY3VycmVudCB2YWx1ZSB0byBwYXJzZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBJbnB1dC5wcm90b3R5cGUuX3N0cmlwSW5wdXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gJycsIHJldmVydCA9IG5ld1ZhbHVlLCBjaGFyLCBwYXR0ZXJuID0gdGhpcy5fcGF0dGVybiwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFyID0gdmFsdWVbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybi50ZXN0KGNoYXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgKz0gY2hhcjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGF0dGVybi50ZXN0KG5ld1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXZlcnQgPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gcmV2ZXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3VmFsdWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBJbnB1dC5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICBfY29tcGF0OiBfX0NvbXBhdCxcclxuICAgICAgICAgICAgX3JlZ2V4OiBfX1JlZ2V4XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gSW5wdXQ7XHJcbiAgICB9KHBsYXQudWkuQmluZENvbnRyb2wpKTtcclxuICAgIHBsYXR1aS5JbnB1dCA9IElucHV0O1xyXG4gICAgcGxhdC5yZWdpc3Rlci5jb250cm9sKF9fSW5wdXQsIElucHV0KTtcclxuICAgIC8qKlxyXG4gICAgICogQW4gQmluZENvbnRyb2wgdGhhdCBzdGFuZGFyZGl6ZXMgYW5kIHN0eWxlc1xyXG4gICAgICogYW4gSFRNTCBpbnB1dFt0eXBlPVwiZmlsZVwiXSBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICB2YXIgRmlsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEZpbGUsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gRmlsZSgpIHtcclxuICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgSFRNTCB0ZW1wbGF0ZSByZXByZXNlbnRlZCBhcyBhIHN0cmluZy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGVTdHJpbmcgPSAnPGRpdiBjbGFzcz1cInBsYXQtZmlsZS1jb250YWluZXJcIj5cXG4nICtcclxuICAgICAgICAgICAgICAgICcgICAgPGlucHV0IHR5cGU9XCJmaWxlXCIgY2xhc3M9XCJwbGF0LWZpbGUtaGlkZGVuXCIgLz5cXG4nICtcclxuICAgICAgICAgICAgICAgICcgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJwbGF0LWZpbGUtaW5wdXRcIiBwbGF0LWtleWRvd249XCJfb25LZXlEb3duXCIgLz5cXG4nICtcclxuICAgICAgICAgICAgICAgICcgICAgPGJ1dHRvbiBjbGFzcz1cInBsYXQtZmlsZS1idXR0b25cIiBwbGF0LXRhcD1cIl9zZWxlY3RGaWxlc1wiPjwvYnV0dG9uPlxcbicgK1xyXG4gICAgICAgICAgICAgICAgJzwvZGl2Plxcbic7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIGZ1bmN0aW9uIGZvciByZW1vdmluZyB0aGUgJ2NoYW5nZScgZXZlbnQgbGlzdGVuZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGNsYXNzZXMgb24gdGhlIHByb3BlciBlbGVtZW50cy5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lPyBBbiBvcHRpb25hbCwgYWRkaXRpb25hbCBjbGFzcyBuYW1lIG9yIGNsYXNzIG5hbWVzIHRvIHNldCBvbiB0aGUgY29udHJvbFxyXG4gICAgICAgICAqIGluIGFkZGl0aW9uIHRvIGl0cyBzdGFuZGFyZCBzZXQuXHJcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50PyBUaGUgZWxlbWVudCB0byBzZXQgdGhlIGNsYXNzIG5hbWUgb24uIFNob3VsZCBkZWZhdWx0IHRvXHJcbiAgICAgICAgICogdGhlIGNvbnRyb2wncyBlbGVtZW50IGlmIG5vdCBzcGVjaWZpZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRmlsZS5wcm90b3R5cGUuc2V0Q2xhc3NlcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5kb20uYWRkQ2xhc3MoZWxlbWVudCB8fCB0aGlzLmVsZW1lbnQsIF9fRmlsZSArIFwiIFwiICsgKGNsYXNzTmFtZSB8fCAnJykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IHRoZSBjbGFzcyBuYW1lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZpbGUucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0Q2xhc3NlcygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IGFsbCBIVE1MRWxlbWVudCByZWZlcmVuY2VzIGFuZCBwb3RlbnRpYWwgYXR0cmlidXRlIGNvbnRyb2xzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZpbGUucHJvdG90eXBlLnNldFRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCwgaGlkZGVuSW5wdXQgPSB0aGlzLl9oaWRkZW5JbnB1dCA9IGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQuZmlyc3RFbGVtZW50Q2hpbGQsIHZpc2libGVJbnB1dCA9IHRoaXMuX3Zpc2libGVJbnB1dCA9IGhpZGRlbklucHV0Lm5leHRFbGVtZW50U2libGluZywgYnV0dG9uSW5wdXQgPSB2aXNpYmxlSW5wdXQubmV4dEVsZW1lbnRTaWJsaW5nLCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzLCBrZXlzID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcyksIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBjb250cm9sSW5qZWN0b3JzID0gcGxhdC5kZXBlbmRlbmN5LmluamVjdG9ycy5jb250cm9sLCBhdHRyUmVnZXggPSAvcGxhdC0oPzpjb250cm9sfGhpZGV8Y29udGV4dCl8Y2xhc3N8c3R5bGUvLCBoYXNNdWx0aXBsZSA9IGZhbHNlLCB1dGlscyA9IHRoaXMudXRpbHMsIGlzTnVsbCA9IHV0aWxzLmlzTnVsbCwgZGVsaW1pdCA9IHV0aWxzLmRlbGltaXQsIGlzU3RyaW5nID0gdXRpbHMuaXNTdHJpbmcsIGtleSwgbmFtZSwgdmFsdWU7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGtleSA9IGtleXNbaV07XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gZGVsaW1pdChrZXksICctJyk7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGF0dHJpYnV0ZXNba2V5XTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNTdHJpbmcodmFsdWUpIHx8IGF0dHJSZWdleC50ZXN0KG5hbWUpIHx8ICFpc051bGwoY29udHJvbEluamVjdG9yc1tuYW1lXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gX19EaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW5JbnB1dC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlSW5wdXQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uSW5wdXQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnaWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuSW5wdXQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdtdWx0aXBsZScpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNNdWx0aXBsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuSW5wdXQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdkaXNhYmxlZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBoaWRkZW5JbnB1dC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZpc2libGVJbnB1dC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbklucHV0LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBoaWRkZW5JbnB1dC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc051bGwodGhpcy5pbm5lclRlbXBsYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgYnV0dG9uSW5wdXQudGV4dENvbnRlbnQgPSBoYXNNdWx0aXBsZSA/ICdTZWxlY3QgZmlsZXMnIDogJ1NlbGVjdCBhIGZpbGUnO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBidXR0b25UZXh0ID0gdGhpcy5pbm5lclRlbXBsYXRlLnRleHRDb250ZW50LnJlcGxhY2UoL1xccnxcXG4vZywgJycpO1xyXG4gICAgICAgICAgICBpZiAodXRpbHMuaXNFbXB0eShidXR0b25UZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgYnV0dG9uSW5wdXQudGV4dENvbnRlbnQgPSBoYXNNdWx0aXBsZSA/ICdTZWxlY3QgZmlsZXMnIDogJ1NlbGVjdCBhIGZpbGUnO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJ1dHRvbklucHV0LnRleHRDb250ZW50ID0gYnV0dG9uVGV4dDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0aGUgc3R5bGUgYW5kIGluaXRpYWxpemUgdGhlIGFjdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBGaWxlLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBoaWRkZW5JbnB1dCA9IHRoaXMuX2hpZGRlbklucHV0ID0gdGhpcy5faGlkZGVuSW5wdXQgfHwgdGhpcy5lbGVtZW50LmZpcnN0RWxlbWVudENoaWxkLmZpcnN0RWxlbWVudENoaWxkO1xyXG4gICAgICAgICAgICB0aGlzLl92aXNpYmxlSW5wdXQgPSB0aGlzLl92aXNpYmxlSW5wdXQgfHwgaGlkZGVuSW5wdXQubmV4dEVsZW1lbnRTaWJsaW5nO1xyXG4gICAgICAgICAgICB0aGlzLl9hZGRDaGFuZ2VMaXN0ZW5lcigpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBmdW5jdGlvbiB0byB2YWxpZGF0ZSB0aGUgdXNlcidzIGlucHV0LiBSZXR1cm5zIHRydWUgaWYgdGhlIGlucHV0IGlzIG5vdCBlbXB0eS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBGaWxlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLnV0aWxzLmlzRW1wdHkodGhpcy5faGlkZGVuSW5wdXQudmFsdWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xlYXJzIHRoZSB1c2VyJ3MgaW5wdXQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRmlsZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBoaWRkZW5JbnB1dCA9IHRoaXMuX2hpZGRlbklucHV0O1xyXG4gICAgICAgICAgICBpZiAodGhpcy51dGlscy5pc0VtcHR5KGhpZGRlbklucHV0LnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGhpZGRlbklucHV0LnZhbHVlID0gbnVsbDtcclxuICAgICAgICAgICAgdmFyIGNsb25lID0gdGhpcy5faGlkZGVuSW5wdXQgPSBoaWRkZW5JbnB1dC5jbG9uZU5vZGUodHJ1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZC5yZXBsYWNlQ2hpbGQoY2xvbmUsIGhpZGRlbklucHV0KTtcclxuICAgICAgICAgICAgdGhpcy5fYWRkQ2hhbmdlTGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5fdmlzaWJsZUlucHV0LnZhbHVlID0gJyc7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXRDaGFuZ2VkKG51bGwpO1xyXG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyKCdjaGFuZ2UnKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFjdHMgYXMgYSBwcm9ncmFtbWF0aWMgY2xpY2sgZm9yIGZpbGUgc2VsZWN0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZpbGUucHJvdG90eXBlLmNsaWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RGaWxlcygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiBGaWxlIGNvbnRyb2wuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRmlsZS5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBoaWRkZW5JbnB1dCA9IHRoaXMuX2hpZGRlbklucHV0LCBmaWxlcyA9IGhpZGRlbklucHV0LmZpbGVzO1xyXG4gICAgICAgICAgICBpZiAodGhpcy51dGlscy5pc051bGwoZmlsZXMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWhpZGRlbklucHV0Lm11bHRpcGxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZXNbMF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZpbGVzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERpc2FibGVzIHRoZSBjb250cm9sLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZpbGUucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBkaXNhYmxlZCA9ICdkaXNhYmxlZCcsIHZpc2libGVJbnB1dCA9IHRoaXMuX3Zpc2libGVJbnB1dDtcclxuICAgICAgICAgICAgdGhpcy5faGlkZGVuSW5wdXQuc2V0QXR0cmlidXRlKGRpc2FibGVkLCBkaXNhYmxlZCk7XHJcbiAgICAgICAgICAgIHZpc2libGVJbnB1dC5zZXRBdHRyaWJ1dGUoZGlzYWJsZWQsIGRpc2FibGVkKTtcclxuICAgICAgICAgICAgdmlzaWJsZUlucHV0Lm5leHRFbGVtZW50U2libGluZy5zZXRBdHRyaWJ1dGUoZGlzYWJsZWQsIGRpc2FibGVkKTtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShkaXNhYmxlZCwgZGlzYWJsZWQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5hYmxlcyB0aGUgY29udHJvbC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBGaWxlLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBkaXNhYmxlZCA9ICdkaXNhYmxlZCcsIHZpc2libGVJbnB1dCA9IHRoaXMuX3Zpc2libGVJbnB1dDtcclxuICAgICAgICAgICAgdGhpcy5faGlkZGVuSW5wdXQucmVtb3ZlQXR0cmlidXRlKGRpc2FibGVkKTtcclxuICAgICAgICAgICAgdmlzaWJsZUlucHV0LnJlbW92ZUF0dHJpYnV0ZShkaXNhYmxlZCk7XHJcbiAgICAgICAgICAgIHZpc2libGVJbnB1dC5uZXh0RWxlbWVudFNpYmxpbmcucmVtb3ZlQXR0cmlidXRlKGRpc2FibGVkKTtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShkaXNhYmxlZCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHRoaXMgY29udHJvbCB0byBvYnNlcnZlIGJvdGggdGhlIGJvdW5kIHByb3BlcnR5IGl0c2VsZiBhcyB3ZWxsIGFzXHJcbiAgICAgICAgICogcG90ZW50aWFsIGNoaWxkIHByb3BlcnRpZXMgaWYgYmVpbmcgYm91bmQgdG8gYW4gb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC5vYnNlcnZhYmxlLklJbXBsZW1lbnRUd29XYXlCaW5kaW5nfSBiaW5kZXIgVGhlIGNvbnRyb2wgdGhhdCBmYWNpbGl0YXRlcyB0aGVcclxuICAgICAgICAgKiBkYXRhYmluZGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBGaWxlLnByb3RvdHlwZS5vYnNlcnZlUHJvcGVydGllcyA9IGZ1bmN0aW9uIChiaW5kZXIpIHtcclxuICAgICAgICAgICAgYmluZGVyLm9ic2VydmVQcm9wZXJ0eSh0aGlzLl9zZXRCb3VuZFByb3BlcnR5KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgYmluZGFibGUgdGV4dCBpcyBzZXQgZXh0ZXJuYWxseS5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gbmV3VmFsdWUgVGhlIG5ldyB2YWx1ZSBvZiB0aGUgYmluZGFibGUgZmlsZShzKS5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBvZiB0aGUgYmluZGFibGUgZmlsZShzKS5cclxuICAgICAgICAgKiBAcGFyYW0ge3ZvaWR9IGlkZW50aWZpZXIgVGhlIGNoaWxkIGlkZW50aWZpZXIgb2YgdGhlIHByb3BlcnR5IGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlyc3RUaW1lPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsIHRvIGJpbmQgdGhlIHByb3BlcnR5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZpbGUucHJvdG90eXBlLl9zZXRCb3VuZFByb3BlcnR5ID0gZnVuY3Rpb24gKG5ld1ZhbHVlLCBvbGRWYWx1ZSwgaWRlbnRpZmllciwgZmlyc3RUaW1lKSB7XHJcbiAgICAgICAgICAgIHZhciB1dGlscyA9IHRoaXMudXRpbHM7XHJcbiAgICAgICAgICAgIGlmICghdXRpbHMuaXNGaWxlKG5ld1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBoaWRkZW5JbnB1dCA9IHRoaXMuX2hpZGRlbklucHV0LCBmaWxlcyA9IGhpZGRlbklucHV0LmZpbGVzO1xyXG4gICAgICAgICAgICBpZiAodXRpbHMuaXNOdWxsKGZpbGVzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaGlkZGVuSW5wdXQubXVsdGlwbGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gZmlsZXNbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0Q2hhbmdlZChmaWxlc1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcignY2hhbmdlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5pbnB1dENoYW5nZWQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZmlsZXMpKTtcclxuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcignY2hhbmdlJyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIHRoZSAnY2hhbmdlJyBldmVudCBsaXN0ZW5lciB0byB0aGUgaGlkZGVuIGlucHV0W3R5cGU9ZmlsZV0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRmlsZS5wcm90b3R5cGUuX2FkZENoYW5nZUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lciA9IHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9oaWRkZW5JbnB1dCwgJ2NoYW5nZScsIHRoaXMuX2ZpbGVzU2VsZWN0ZWQsIGZhbHNlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuIGV2ZW50IGxpc3RlbmVyIHRvIGhhbmRsZSBhIFwia2V5ZG93blwiIGV2ZW50IG9uIHRoZSB2aXNpYmxlIGlucHV0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXYgVGhlIFwia2V5ZG93blwiIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZpbGUucHJvdG90eXBlLl9vbktleURvd24gPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgdmFyIGtleSA9IGV2LmtleUNvZGUsIGtleUNvZGVzID0gcGxhdC5jb250cm9scy5LZXlDb2RlcztcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0ga2V5Q29kZXMudGFiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IGtleUNvZGVzLmJhY2tzcGFjZSB8fCBrZXkgPT09IGtleUNvZGVzLmRlbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEtpY2tzIG9mZiB0aGUgZmlsZSBzZWxlY3Rpb24gcHJvY2Vzcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBGaWxlLnByb3RvdHlwZS5fc2VsZWN0RmlsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hpZGRlbklucHV0LmNsaWNrKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbiBldmVudCBpbmRpY2F0aW5nIHRoYXQgZmlsZXMgaGF2ZSBiZWVuIHNlbGVjdGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZpbGUucHJvdG90eXBlLl9maWxlc1NlbGVjdGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaGlkZGVuSW5wdXQgPSB0aGlzLl9oaWRkZW5JbnB1dCwgdmlzaWJsZUlucHV0ID0gdGhpcy5fdmlzaWJsZUlucHV0LCBmaWxlcyA9IGhpZGRlbklucHV0LmZpbGVzO1xyXG4gICAgICAgICAgICBpZiAodGhpcy51dGlscy5pc0VtcHR5KGZpbGVzKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFoaWRkZW5JbnB1dC5tdWx0aXBsZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpbGUgPSBmaWxlc1swXTtcclxuICAgICAgICAgICAgICAgIHZpc2libGVJbnB1dC52YWx1ZSA9IGZpbGUubmFtZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRDaGFuZ2VkKGZpbGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpbGVOYW1lcyA9IFtdLCBsZW5ndGhfMSA9IGZpbGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoXzE7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lcy5wdXNoKGZpbGVzW2ldLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmlzaWJsZUlucHV0LnZhbHVlID0gZmlsZU5hbWVzLmpvaW4oJywgJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0Q2hhbmdlZChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmaWxlcykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIoJ2NoYW5nZScpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJpZ2dlcnMgYW4gZXZlbnQgc3RhcnRpbmcgZnJvbSB0aGlzIGNvbnRyb2wncyBlbGVtZW50LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCBUaGUgZXZlbnQgbmFtZSB0byB0cmlnZ2VyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZpbGUucHJvdG90eXBlLl90cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBkb21FdmVudCA9IHBsYXQuYWNxdWlyZShfX0RvbUV2ZW50SW5zdGFuY2UpO1xyXG4gICAgICAgICAgICBkb21FdmVudC5pbml0aWFsaXplKHRoaXMuZWxlbWVudCwgZXZlbnQpO1xyXG4gICAgICAgICAgICBkb21FdmVudC50cmlnZ2VyKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBGaWxlLl9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgIF9jb21wYXQ6IF9fQ29tcGF0XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRmlsZTtcclxuICAgIH0ocGxhdC51aS5CaW5kQ29udHJvbCkpO1xyXG4gICAgcGxhdHVpLkZpbGUgPSBGaWxlO1xyXG4gICAgcGxhdC5yZWdpc3Rlci5jb250cm9sKF9fRmlsZSwgRmlsZSk7XHJcbiAgICAvKipcclxuICAgICAqIEFuIGV4dGVuc2lvbiBvZiB0aGUgRm9yRWFjaCB0aGF0IGFjdHMgYXMgYSBIVE1MIHRlbXBsYXRlIGNhcm91c2VsXHJcbiAgICAgKiBhbmQgY2FuIGJpbmQgdGhlIHNlbGVjdGVkIGluZGV4IHRvIGEgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIHZhciBDYXJvdXNlbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKENhcm91c2VsLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIENhcm91c2VsKCkge1xyXG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBIVE1MIHRlbXBsYXRlIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZVN0cmluZyA9ICc8ZGl2IGNsYXNzPVwicGxhdC1jYXJvdXNlbC12aWV3cG9ydFwiPlxcbicgK1xyXG4gICAgICAgICAgICAgICAgJyAgICA8ZGl2IGNsYXNzPVwicGxhdC1jYXJvdXNlbC1jb250YWluZXJcIj48L2Rpdj5cXG4nICtcclxuICAgICAgICAgICAgICAgICc8L2Rpdj5cXG4nO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHNldCBvZiBmdW5jdGlvbnMgYWRkZWQgZXh0ZXJuYWxseSB0aGF0IGxpc3RlbnNcclxuICAgICAgICAgICAgICogZm9yIHByb3BlcnR5IGNoYW5nZXMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgdGhlIGNvbnRyb2wgaXMgdmVydGljYWwgb3IgaG9yaXpvbnRhbC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2lzVmVydGljYWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSB1c2VyIGhhcyBzd2lwZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9oYXNTd2lwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSB1c2VyIGlzIGN1cnJlbnRseSB0b3VjaGluZyB0aGUgc2NyZWVuLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5faW5Ub3VjaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIHVzZXIgaXMgY3VycmVudGx5IHRvdWNoaW5nIHRoZSBzY3JlZW4gYW5kIGhhcyBtb3ZlZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2hhc01vdmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgbGFzdCB0b3VjaCBzdGFydCByZWNvcmRlZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RUb3VjaCA9IHsgeDogMCwgeTogMCB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIGNvbnRyb2wgaGFzIGJlZW4gbG9hZGVkIGJhc2VkIG9uIGl0cyBjb250ZXh0IGJlaW5nIGFuIEFycmF5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fbG9hZGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY3VycmVudCBpbmRleCBzZWVuIGluIHRoZSBDYXJvdXNlbC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gLTE7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgcHJldmlvdXMgaW5kZXggb2YgdGhlIENhcm91c2VsIGluIHJlbGF0aW9uIHRvIHRoZSBpdGVtIG5vZGVzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNJbmRleCA9IC0xO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIG5leHQgaW5kZXggb2YgdGhlIENhcm91c2VsIGluIHJlbGF0aW9uIHRvIHRoZSBpdGVtIG5vZGVzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fbmV4dEluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY3VycmVudCBvZmZzZXQgb2YgdGhlIHRyYW5zbGF0ZWQgQ2Fyb3VzZWwncyBzbGlkaW5nIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50T2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGNsZWFyIHRoZSBhdXRvIHNjcm9sbCBpbnRlcnZhbC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUludGVydmFsID0gbm9vcDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGNsZWFyIHRoZSBzdXNwZW5kZWQgYXV0byBzY3JvbGwgaW50ZXJ2YWwuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVTdXNwZW5kID0gbm9vcDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IGF1dG9tYXRpYyBzY3JvbGxpbmcgaXMgZW5hYmxlZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2lzQXV0byA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgYXV0b21hdGljIHNjcm9sbGluZyBpcyBjdXJyZW50bHkgcGF1c2VkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBjb250cm9sIGlzIHJlc3BvbnNpYmxlIGZvciBwYXVzaW5nIGl0c2VsZi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX3NlbGZQYXVzZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQW4gQXJyYXkgb2YgYWxsIHRoZSBjdXJyZW50IG5vZGVzIGluIHRoZSBjb250cm9sLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5faXRlbU5vZGVzID0gW107XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIGNvbGxlY3Rpb24gb2YgcmVtb3ZlIGxpc3RlbmVycyB0byBzdG9wIGxpc3RlbmluZyBmb3IgZXZlbnRzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzID0gW107XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgc3RhcnQgb3V0ZXIgaXRlbSBub2RlIGhhcyBiZWVuIGluaXRpYWxpemVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fb3V0ZXJTdGFydCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIGVuZCBvdXRlciBpdGVtIG5vZGUgaGFzIGJlZW4gaW5pdGlhbGl6ZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9vdXRlckVuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQW4gaW50ZXJ2YWwgY29uc3RhbnQgdXNlZCB0byByZWd1bGF0ZSB0aGUgc3BlZWQgb2YgdGhlIGF1dG8gc2Nyb2xsXHJcbiAgICAgICAgICAgICAqIHdoZW4gdGhlIGdvVG9JbmRleCBmdW5jdGlvbiBpcyBjYWxsZWQgYW5kIGlzIG5vdCBkaXJlY3QuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9nb1RvSW50ZXJ2YWxDb25zdGFudCA9IDEyNTtcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhcm91c2VsLnByb3RvdHlwZSwgXCJpbmRleFwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgQ2Fyb3VzZWwuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbmRleDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgY2xhc3NlcyBvbiB0aGUgcHJvcGVyIGVsZW1lbnRzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWU/IEFuIG9wdGlvbmFsLCBhZGRpdGlvbmFsIGNsYXNzIG5hbWUgb3IgY2xhc3MgbmFtZXMgdG8gc2V0IG9uIHRoZSBjb250cm9sXHJcbiAgICAgICAgICogaW4gYWRkaXRpb24gdG8gaXRzIHN0YW5kYXJkIHNldC5cclxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQ/IFRoZSBlbGVtZW50IHRvIHNldCB0aGUgY2xhc3MgbmFtZSBvbi4gU2hvdWxkIGRlZmF1bHQgdG9cclxuICAgICAgICAgKiB0aGUgY29udHJvbCdzIGVsZW1lbnQgaWYgbm90IHNwZWNpZmllZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuc2V0Q2xhc3NlcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5kb20uYWRkQ2xhc3MoZWxlbWVudCB8fCB0aGlzLmVsZW1lbnQsIF9fQ2Fyb3VzZWwgKyBcIiBcIiArIChjbGFzc05hbWUgfHwgJycpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyBpZiB0aGUgY29udHJvbCBoYXMgYmVlbiBpbml0aWFsaXplZCwgb3RoZXJ3aXNlIGl0IGRvZXMgc28uXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBuZXdWYWx1ZSBUaGUgbmV3IGFycmF5IGNvbnRleHQuXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBvbGRWYWx1ZSBUaGUgb2xkIGFycmF5IGNvbnRleHQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLmNvbnRleHRDaGFuZ2VkID0gZnVuY3Rpb24gKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgdXRpbHMgPSB0aGlzLnV0aWxzO1xyXG4gICAgICAgICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbih0aGlzLl9vbkxvYWQpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodXRpbHMuaXNBcnJheShuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKHRoaXMudHlwZSArIFwiIGNvbnRleHQgc2V0IHRvIHNvbWV0aGluZyBvdGhlciB0aGFuIGFuIEFycmF5LlwiKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZXhlY3V0ZUV2ZW50KFt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogbmV3VmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzcGxpY2UnXHJcbiAgICAgICAgICAgICAgICAgICAgfV0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZUluZGV4KDApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVkKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdGhlIGNsYXNzIG5hbWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0Q2xhc3NlcygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5zZXJ0cyB0aGUgaW5uZXJIVE1MIG9mIHRoaXMgY29udHJvbCBpbnRvIGEgY2hpbGQgRm9yRWFjaCBjb250cm9sLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5zZXRUZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGl0ZW1Db250YWluZXIgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgaXRlbUNvbnRhaW5lci5jbGFzc05hbWUgPSBfX0Nhcm91c2VsICsgXCItaXRlbVwiO1xyXG4gICAgICAgICAgICBpdGVtQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuaW5uZXJUZW1wbGF0ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYmluZGFibGVUZW1wbGF0ZXMuYWRkKCdpdGVtJywgaXRlbUNvbnRhaW5lcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgY29udGV4dCBhbmQgd2FybnMgaWYgbm90IGFuIEFycmF5LCB0aGVuIGluaXRpYWxpemVzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciB1dGlscyA9IHRoaXMudXRpbHMsIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgICAgIGlmICghdXRpbHMuaXNBcnJheShjb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJUaGUgY29udGV4dCBvZiBhIFwiICsgdGhpcy50eXBlICsgXCIgbXVzdCBiZSBhbiBBcnJheS5cIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc2luY2Ugd2UncmUgZXh0ZW5kaW5nIHRoZSBGb3JFYWNoLCB3ZSBtdXN0IHNldCB0aGlzIGFuaW1hdGUgdG8gZmFsc2UgYXMgaXQgcmVmZXJzIHRvIGl0ZW0gbWFuaXB1bGF0aW9uLiBcclxuICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9uT2JqID0gdGhpcy5vcHRpb25zIHx8IHt9LCBvcHRpb25zID0gb3B0aW9uT2JqLnZhbHVlIHx8IHt9LCBpbmRleCA9IG9wdGlvbnMuaW5kZXgsIGlzTnVtYmVyID0gdXRpbHMuaXNOdW1iZXIsIG9yaWVudGF0aW9uID0gdGhpcy5fdmFsaWRhdGVPcmllbnRhdGlvbihvcHRpb25zLm9yaWVudGF0aW9uKSwgaW50ZXJ2YWwgPSBvcHRpb25zLmludGVydmFsLCBpbnRlcnZhbE51bSA9IHRoaXMuX2ludGVydmFsID0gaXNOdW1iZXIoaW50ZXJ2YWwpID8gTWF0aC5hYnMoaW50ZXJ2YWwpIDogMzAwMCwgc3VzcGVuZCA9IG9wdGlvbnMuc3VzcGVuZCwgZG9tID0gdGhpcy5kb20sIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsIHZpZXdwb3J0ID0gdGhpcy5fdmlld3BvcnQgPSBlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkO1xyXG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXIgPSB2aWV3cG9ydC5maXJzdEVsZW1lbnRDaGlsZDtcclxuICAgICAgICAgICAgdGhpcy5fdHlwZSA9IG9wdGlvbnMudHlwZSB8fCAndHJhY2sgc3dpcGUnO1xyXG4gICAgICAgICAgICB0aGlzLl9pc0luZmluaXRlID0gb3B0aW9ucy5pbmZpbml0ZSA9PT0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fc3VzcGVuZCA9IE1hdGguYWJzKGlzTnVtYmVyKHN1c3BlbmQpID8gaW50ZXJ2YWxOdW0gLSBzdXNwZW5kIDogaW50ZXJ2YWxOdW0gLSAzMDAwKTtcclxuICAgICAgICAgICAgZG9tLmFkZENsYXNzKGVsZW1lbnQsIF9fUGxhdCArIG9yaWVudGF0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5fb25Mb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNldEluZGV4ID0gX3RoaXMuX2luZGV4O1xyXG4gICAgICAgICAgICAgICAgaW5kZXggPSBpc051bWJlcihpbmRleCkgJiYgaW5kZXggPj0gMCA/IGluZGV4IDwgY29udGV4dC5sZW5ndGggPyBpbmRleCA6IChjb250ZXh0Lmxlbmd0aCAtIDEpIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9pbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICBkb20ud2hlblZpc2libGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9pbml0aWFsaXplSW5kZXgoaW5kZXggPT09IG51bGwgPyBzZXRJbmRleCA6IGluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9hZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0sIGVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZHZhbmNlcyB0aGUgcG9zaXRpb24gb2YgdGhlIENhcm91c2VsIHRvIHRoZSBuZXh0IHN0YXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5nb1RvTmV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dvVG9OZXh0KGZhbHNlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoYW5nZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBDYXJvdXNlbCB0byB0aGUgcHJldmlvdXMgc3RhdGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLmdvVG9QcmV2aW91cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dvVG9QcmV2aW91cyhmYWxzZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGFuZ2VzIHRoZSBwb3NpdGlvbiBvZiB0aGUgQ2Fyb3VzZWwgdG8gdGhlIHN0YXRlXHJcbiAgICAgICAgICogc3BlY2lmaWVkIGJ5IHRoZSBpbnB1dCBpbmRleC5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIG5ldyBpbmRleCBvZiB0aGUgQ2Fyb3VzZWwuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBkaXJlY3Q/IElmIHRydWUsIHdpbGwgZ28gc3RyYWlnaHQgdG8gdGhlIHNwZWNpZmllZCBpbmRleCB3aXRob3V0IHRyYW5zaXRpb25pbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLmdvVG9JbmRleCA9IGZ1bmN0aW9uIChpbmRleCwgZGlyZWN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nb1RvSW5kZXgoaW5kZXgsIGZhbHNlLCBkaXJlY3QpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3RvcHMgYXV0byBzY3JvbGxpbmcgaWYgYXV0byBzY3JvbGxpbmcgaXMgZW5hYmxlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NlbGZQYXVzZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzQXV0byB8fCB0aGlzLl9pc1BhdXNlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlU3VzcGVuZCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVTdXNwZW5kID0gbm9vcDtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlSW50ZXJ2YWwoKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlSW50ZXJ2YWwgPSBub29wO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVzdW1lcyBhdXRvIHNjcm9sbGluZyBpZiBhdXRvIHNjcm9sbGluZyBpcyBlbmFibGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghKHRoaXMuX2lzQXV0byAmJiB0aGlzLl9pc1BhdXNlZCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IHRoaXMuX3NlbGZQYXVzZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0aWF0ZUludGVydmFsKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbGVhbiB1cCB0aGUgYXV0byBzY3JvbGwgaW50ZXJ2YWwgaWYgbmVjZXNzYXJ5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgbGlzdGVuZXIgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGJpbmRhYmxlIHByb3BlcnR5IGNoYW5nZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LklQcm9wZXJ0eUNoYW5nZWRMaXN0ZW5lcjxhbnk+fSBsaXN0ZW5lciBUaGUgZnVuY3Rpb24gdGhhdCBhY3RzIGFzIGEgbGlzdGVuZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLm9uSW5wdXQgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcclxuICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBmdW5jdGlvbiB0aGF0IHNpZ25pZmllcyB3aGVuIHRoaXMgY29udHJvbCdzIGJpbmRhYmxlIHByb3BlcnR5IGhhcyBjaGFuZ2VkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBuZXdWYWx1ZSBUaGUgbmV3IHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBhZnRlciB0aGUgY2hhbmdlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBvbGRWYWx1ZT8gVGhlIG9sZCB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgcHJpb3IgdG8gdGhlIGNoYW5nZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuaW5wdXRDaGFuZ2VkID0gZnVuY3Rpb24gKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycywgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzW2ldKG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgdGhpcyBjb250cm9sIHRvIG9ic2VydmUgYm90aCB0aGUgYm91bmQgcHJvcGVydHkgaXRzZWxmIGFzIHdlbGwgYXNcclxuICAgICAgICAgKiBwb3RlbnRpYWwgY2hpbGQgcHJvcGVydGllcyBpZiBiZWluZyBib3VuZCB0byBhbiBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0Lm9ic2VydmFibGUuSUltcGxlbWVudFR3b1dheUJpbmRpbmd9IGJpbmRlciBUaGUgY29udHJvbCB0aGF0IGZhY2lsaXRhdGVzIHRoZVxyXG4gICAgICAgICAqIGRhdGFiaW5kaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5vYnNlcnZlUHJvcGVydGllcyA9IGZ1bmN0aW9uIChiaW5kZXIpIHtcclxuICAgICAgICAgICAgYmluZGVyLm9ic2VydmVQcm9wZXJ0eSh0aGlzLl9zZXRCb3VuZFByb3BlcnR5KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgYmluZGFibGUgaW5kZXggaXMgc2V0IGV4dGVybmFsbHkuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBuZXcgdmFsdWUgb2YgdGhlIGJpbmRhYmxlIGluZGV4LlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvbGRWYWx1ZSBUaGUgb2xkIHZhbHVlIG9mIHRoZSBiaW5kYWJsZSBpbmRleC5cclxuICAgICAgICAgKiBAcGFyYW0ge3ZvaWR9IGlkZW50aWZpZXIgVGhlIGNoaWxkIGlkZW50aWZpZXIgb2YgdGhlIHByb3BlcnR5IGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlyc3RUaW1lPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsIHRvIGJpbmQgdGhlIHByb3BlcnR5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5fc2V0Qm91bmRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChpbmRleCwgb2xkVmFsdWUsIGlkZW50aWZpZXIsIGZpcnN0VGltZSkge1xyXG4gICAgICAgICAgICB2YXIgdXRpbHMgPSB0aGlzLnV0aWxzO1xyXG4gICAgICAgICAgICBpZiAodXRpbHMuaXNOdWxsKGluZGV4KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0VGltZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0Q2hhbmdlZCgwLCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCF1dGlscy5pc051bWJlcihpbmRleCkpIHtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gTnVtYmVyKGluZGV4KTtcclxuICAgICAgICAgICAgICAgIGlmICghdXRpbHMuaXNOdW1iZXIoaW5kZXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4odGhpcy50eXBlICsgXCIgaGFzIGl0cyBpbmRleCBib3VuZCB0byBhIHByb3BlcnR5IHRoYXQgY2Fubm90IGJlIGludGVycHJldGVkIGFzIGEgTnVtYmVyLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0Q2hhbmdlZCgwLCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplSW5kZXgoMCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9sb2FkZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZ29Ub0luZGV4KGluZGV4LCB0cnVlLCBmaXJzdFRpbWUgPT09IHRydWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVzZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgQ2Fyb3VzZWwgdG8gaXRzIGN1cnJlbnQgc3RhdGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbk9wdGlvbnMgPSB7fTtcclxuICAgICAgICAgICAgYW5pbWF0aW9uT3B0aW9uc1t0aGlzLl90cmFuc2Zvcm1dID0gdGhpcy5fY2FsY3VsYXRlU3RhdGljVHJhbnNsYXRpb24oMCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYXRlQW5pbWF0aW9uKHsgcHJvcGVydGllczogYW5pbWF0aW9uT3B0aW9ucyB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFZlcmlmaWVzIHRoYXQgdGhlIGN1cnJlbnQgbGVuZ3RoIG9mIHRoZSBjb250ZXh0IGFsaWducyB3aXRoIHRoZSBwb3NpdGlvbiBvZiB0aGUgQ2Fyb3VzZWwuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLl92ZXJpZnlMZW5ndGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0LCBpbmRleCA9IHRoaXMuX2luZGV4O1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMudXRpbHMuaXNBcnJheShjb250ZXh0KSB8fCBjb250ZXh0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnV0aWxzLmlzVW5kZWZpbmVkKGluZGV4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRDaGFuZ2VkKCh0aGlzLl9pbmRleCA9IHVuZGVmaW5lZCksIGluZGV4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5zdHlsZVt0aGlzLl90cmFuc2Zvcm1dID0gdGhpcy5fY2FsY3VsYXRlU3RhdGljVHJhbnNsYXRpb24oLXRoaXMuX2N1cnJlbnRPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrQXJyb3dzKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG1heEluZGV4ID0gY29udGV4dC5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPiBtYXhJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nb1RvSW5kZXgobWF4SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrQXJyb3dzKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBwcmV2aW91cyBhbmQgbmV4dCBpbmRpY2VzIGluIHJlbGF0aW9uIHRvIGl0ZW0gbm9kZXMgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IGluZGV4LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5fc2V0SW5kZXhXaW5kb3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2luZGV4LCBsYXN0SW5kZXggPSB0aGlzLl9pdGVtTm9kZXMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgaWYgKGxhc3RJbmRleCA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzSW5kZXggPSB0aGlzLl9uZXh0SW5kZXggPSBsYXN0SW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaW5kZXggPj0gbGFzdEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuX2luZGV4ID0gbGFzdEluZGV4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNJbmRleCA9IGluZGV4IC0gMTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX25leHRJbmRleCA9IHRoaXMuX2lzSW5maW5pdGUgPyAwIDogLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaW5kZXggPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5faW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNJbmRleCA9IHRoaXMuX2lzSW5maW5pdGUgPyBsYXN0SW5kZXggOiAtMTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX25leHRJbmRleCA9IGluZGV4ICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzSW5kZXggPSBpbmRleCAtIDE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9uZXh0SW5kZXggPSBpbmRleCArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkdmFuY2VzIHRoZSBwb3NpdGlvbiBvZiB0aGUgQ2Fyb3VzZWwgdG8gdGhlIG5leHQgc3RhdGUuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBpbnB1dENoYW5nZWQgV2hldGhlciBvciBub3QgdGhpcyB3YXMgdGhlIHJlc3VsdCBvZiBhIGJvdW5kIGlucHV0IGNoYW5nZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuX2dvVG9OZXh0ID0gZnVuY3Rpb24gKGlucHV0Q2hhbmdlZCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5hbGwodGhpcy5fYWRkUXVldWUpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gX3RoaXMuX2luZGV4LCByZXNldCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKChpbmRleCA+PSBfdGhpcy5faXRlbU5vZGVzLmxlbmd0aCAtIDEpICYmICEocmVzZXQgPSBfdGhpcy5faXNJbmZpbml0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2lzQXV0byAmJiAhX3RoaXMuX2lzUGF1c2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnBhdXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZWxmUGF1c2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX1Byb21pc2UucmVzb2x2ZShmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gX3RoaXMuX2dldExlbmd0aCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZ29Ub0luZGV4KF90aGlzLl9uZXh0SW5kZXgsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jYW5jZWxDdXJyZW50QW5pbWF0aW9ucygpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX291dGVyRW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9pbml0aWFsaXplT3V0ZXJOb2RlcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbk9wdGlvbnNbX3RoaXMuX3RyYW5zZm9ybV0gPSBfdGhpcy5fY2FsY3VsYXRlU3RhdGljVHJhbnNsYXRpb24oLWxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IF90aGlzLl9pbml0aWF0ZUFuaW1hdGlvbih7IHByb3BlcnRpZXM6IGFuaW1hdGlvbk9wdGlvbnMgfSksIG5leHRJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2luZGV4ID0gbmV4dEluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRJbmRleCA9ICsrX3RoaXMuX2luZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlucHV0Q2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbnB1dENoYW5nZWQoX3RoaXMuX2luZGV4LCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhbmltYXRpb24udGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9oYW5kbGVOZXh0KG5leHRJbmRleCwgbGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NoZWNrQXJyb3dzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hhbmdlcyB0aGUgcG9zaXRpb24gb2YgdGhlIENhcm91c2VsIHRvIHRoZSBwcmV2aW91cyBzdGF0ZS5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlucHV0Q2hhbmdlZCBXaGV0aGVyIG9yIG5vdCB0aGlzIHdhcyB0aGUgcmVzdWx0IG9mIGEgYm91bmQgaW5wdXQgY2hhbmdlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5fZ29Ub1ByZXZpb3VzID0gZnVuY3Rpb24gKGlucHV0Q2hhbmdlZCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5hbGwodGhpcy5fYWRkUXVldWUpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gX3RoaXMuX2luZGV4LCByZXNldCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDw9IDAgJiYgIShyZXNldCA9IF90aGlzLl9pc0luZmluaXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLl9zZWxmUGF1c2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXN1bWUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBfdGhpcy5fZ2V0TGVuZ3RoKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5nb1RvSW5kZXgoX3RoaXMuX3ByZXZpb3VzSW5kZXgsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jYW5jZWxDdXJyZW50QW5pbWF0aW9ucygpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX291dGVyU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2luaXRpYWxpemVPdXRlck5vZGVzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25PcHRpb25zID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uT3B0aW9uc1tfdGhpcy5fdHJhbnNmb3JtXSA9IF90aGlzLl9jYWxjdWxhdGVTdGF0aWNUcmFuc2xhdGlvbihsZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb24gPSBfdGhpcy5faW5pdGlhdGVBbmltYXRpb24oeyBwcm9wZXJ0aWVzOiBhbmltYXRpb25PcHRpb25zIH0pLCBwcmV2aW91c0luZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5faW5kZXggPSBwcmV2aW91c0luZGV4ID0gX3RoaXMuX2l0ZW1Ob2Rlcy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNJbmRleCA9IC0tX3RoaXMuX2luZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlucHV0Q2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbnB1dENoYW5nZWQoX3RoaXMuX2luZGV4LCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhbmltYXRpb24udGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9oYW5kbGVQcmV2aW91cyhwcmV2aW91c0luZGV4LCAtbGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NoZWNrQXJyb3dzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hhbmdlcyB0aGUgcG9zaXRpb24gb2YgdGhlIENhcm91c2VsIHRvIHRoZSBzdGF0ZVxyXG4gICAgICAgICAqIHNwZWNpZmllZCBieSB0aGUgaW5wdXQgaW5kZXguXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBuZXcgaW5kZXggb2YgdGhlIENhcm91c2VsLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5wdXRDaGFuZ2VkIFdoZXRoZXIgb3Igbm90IHRoaXMgd2FzIHRoZSByZXN1bHQgb2YgYSBib3VuZCBpbnB1dCBjaGFuZ2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBkaXJlY3Q/IElmIHRydWUsIHdpbGwgZ28gc3RyYWlnaHQgdG8gdGhlIHNwZWNpZmllZCBpbmRleCB3aXRob3V0IHRyYW5zaXRpb25pbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9nb1RvSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgsIGlucHV0Q2hhbmdlZCwgZGlyZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLmFsbCh0aGlzLl9hZGRRdWV1ZSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2xkSW5kZXggPSBfdGhpcy5faW5kZXg7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMudXRpbHMuaXNVbmRlZmluZWQob2xkSW5kZXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2luaXRpYWxpemVJbmRleCgwKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbnB1dENoYW5nZWQoX3RoaXMuX2luZGV4LCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5faXNJbmZpbml0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBfdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fc2VsZlBhdXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVzdW1lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMuX2lzQXV0byAmJiAhX3RoaXMuX2lzUGF1c2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wYXVzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3NlbGZQYXVzZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9Qcm9taXNlLnJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpbmRleCA9PT0gb2xkSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX1Byb21pc2UucmVzb2x2ZShmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkaXJlY3QgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faW5pdGlhbGl6ZUluZGV4KGluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbnB1dENoYW5nZWQoX3RoaXMuX2luZGV4LCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5faXNJbmZpbml0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBfdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fc2VsZlBhdXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVzdW1lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMuX2lzQXV0byAmJiAhX3RoaXMuX2lzUGF1c2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wYXVzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3NlbGZQYXVzZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9Qcm9taXNlLnJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpbmRleCAtIG9sZEluZGV4ID4gMCAmJiBpbmRleCA9PT0gX3RoaXMuX25leHRJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZ29Ub05leHQoaW5wdXRDaGFuZ2VkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4ID09PSBfdGhpcy5fcHJldmlvdXNJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZ29Ub1ByZXZpb3VzKGlucHV0Q2hhbmdlZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2hhbmRsZUdvVG9JbmRleChpbmRleCwgaW5wdXRDaGFuZ2VkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGFuZ2VzIHRoZSBwb3NpdGlvbiBvZiB0aGUgQ2Fyb3VzZWwgdG8gdGhlIHN0YXRlXHJcbiAgICAgICAgICogc3BlY2lmaWVkIGJ5IHRoZSBpbnB1dCBpbmRleC5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIG5ldyBpbmRleCBvZiB0aGUgQ2Fyb3VzZWwuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBpbnB1dENoYW5nZWQgV2hldGhlciBvciBub3QgdGhpcyB3YXMgdGhlIHJlc3VsdCBvZiBhIGJvdW5kIGlucHV0IGNoYW5nZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuX2hhbmRsZUdvVG9JbmRleCA9IGZ1bmN0aW9uIChpbmRleCwgaW5wdXRDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgIHZhciBvbGRJbmRleCA9IHRoaXMuX2luZGV4O1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IG9sZEluZGV4IHx8IGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmNvbnRleHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zZWxmUGF1c2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzdW1lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9nZXRMZW5ndGgoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZUluZGV4KGluZGV4KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLnJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIF9Qcm9taXNlID0gdGhpcy5fUHJvbWlzZSwgZGVmZXIgPSB0aGlzLnV0aWxzLmRlZmVyLCBtb3ZlLCBkaWZmLCByZXZlcnNlRGlmZjtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID4gb2xkSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIG1vdmUgPSB0aGlzLl9nb1RvTmV4dDtcclxuICAgICAgICAgICAgICAgIGRpZmYgPSBpbmRleCAtIG9sZEluZGV4O1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW5maW5pdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXZlcnNlRGlmZiA9IHRoaXMuX2l0ZW1Ob2Rlcy5sZW5ndGggLSBpbmRleCArIG9sZEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXZlcnNlRGlmZiA8IGRpZmYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZSA9IHRoaXMuX2dvVG9QcmV2aW91cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlmZiA9IHJldmVyc2VEaWZmO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1vdmUgPSB0aGlzLl9nb1RvUHJldmlvdXM7XHJcbiAgICAgICAgICAgICAgICBkaWZmID0gb2xkSW5kZXggLSBpbmRleDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0luZmluaXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZURpZmYgPSB0aGlzLl9pdGVtTm9kZXMubGVuZ3RoIC0gb2xkSW5kZXggKyBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmV2ZXJzZURpZmYgPCBkaWZmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmUgPSB0aGlzLl9nb1RvTmV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlmZiA9IHJldmVyc2VEaWZmO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtb3ZlID0gbW92ZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXSwgcmVtb3ZlTGlzdGVuZXJzID0gdGhpcy5fcmVtb3ZlTGlzdGVuZXJzLCBjb25zdGFudCA9IHRoaXMuX2dvVG9JbnRlcnZhbENvbnN0YW50LCBpbnRlcnZhbCA9IDAsIG1vdmVyID0gZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZW1vdmUgPSBkZWZlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW92ZUluZGV4ID0gcmVtb3ZlTGlzdGVuZXJzLmluZGV4T2YocmVtb3ZlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZlSW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVycy5zcGxpY2UocmVtb3ZlSW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG1vdmUoaW5wdXRDaGFuZ2VkKSk7XHJcbiAgICAgICAgICAgICAgICB9LCBpbnRlcnZhbCArPSBNYXRoLnJvdW5kKGNvbnN0YW50IC8gZGlmZikpO1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzLnB1c2gocmVtb3ZlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgd2hpbGUgKC0tZGlmZiA+IDApIHtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gobmV3IF9Qcm9taXNlKG1vdmVyKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChtb3ZlKGlucHV0Q2hhbmdlZCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gX1Byb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAocmVzdWx0cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0IHx8IHJlc3VsdHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhhbmRsZXMgc3dhcHBpbmcgYW5kIHRyYW5zbGF0aW5nIG5vZGVzIGZvciBhIFwibmV4dFwiIG9wZXJhdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIG5ldyBpbmRleCBhdCB0aGUgdGltZSBvZiB0aGUgYW5pbWF0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggVGhlIGxlbmd0aCB0byBzdGF0aWNhbGx5IHRyYW5zaXRpb24gYmFjayB0by5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuX2hhbmRsZU5leHQgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgaXNJbmZpbml0ZSA9IHRoaXMuX2lzSW5maW5pdGUsIGl0ZW1Ob2RlcyA9IHRoaXMuX2l0ZW1Ob2Rlcywgbm9kZUxlbmd0aCA9IGl0ZW1Ob2Rlcy5sZW5ndGgsIGlzTm9kZSA9IHRoaXMudXRpbHMuaXNOb2RlO1xyXG4gICAgICAgICAgICBpZiAoaXNJbmZpbml0ZSAmJiAobm9kZUxlbmd0aCA8IDMgfHwgaXNOb2RlKHRoaXMuX3ByZUNsb25lZE5vZGUpIHx8IGlzTm9kZSh0aGlzLl9wb3N0Q2xvbmVkTm9kZSkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplSW5kZXgoaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9vdXRlclN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNJbmZpbml0ZSB8fCBpbmRleCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5pbnNlcnRCZWZvcmUoaXRlbU5vZGVzW3RoaXMuX3ByZXZpb3VzSW5kZXhdLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjb250YWluZXIuY2hpbGROb2RlcywgMCwgMykpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZVt0aGlzLl90cmFuc2Zvcm1dID0gdGhpcy5fY2FsY3VsYXRlU3RhdGljVHJhbnNsYXRpb24obGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mb3JjZVJlcGFpbnQoY29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX291dGVyU3RhcnQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3NldEluZGV4V2luZG93KCk7XHJcbiAgICAgICAgICAgIGlmICghKGlzSW5maW5pdGUgfHwgaW5kZXggPCBub2RlTGVuZ3RoIC0gMSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKGl0ZW1Ob2Rlc1t0aGlzLl9uZXh0SW5kZXhdLCBudWxsKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhhbmRsZXMgc3dhcHBpbmcgYW5kIHRyYW5zbGF0aW5nIG5vZGVzIGZvciBhIFwicHJldmlvdXNcIiBvcGVyYXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBuZXcgaW5kZXggYXQgdGhlIHRpbWUgb2YgdGhlIGFuaW1hdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSBsZW5ndGggdG8gc3RhdGljYWxseSB0cmFuc2l0aW9uIGJhY2sgdG8uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9oYW5kbGVQcmV2aW91cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHZhciBpc0luZmluaXRlID0gdGhpcy5faXNJbmZpbml0ZSwgaXRlbU5vZGVzID0gdGhpcy5faXRlbU5vZGVzLCBub2RlTGVuZ3RoID0gaXRlbU5vZGVzLmxlbmd0aCwgaXNOb2RlID0gdGhpcy51dGlscy5pc05vZGU7XHJcbiAgICAgICAgICAgIGlmIChpc0luZmluaXRlICYmIChub2RlTGVuZ3RoIDwgMyB8fCBpc05vZGUodGhpcy5fcHJlQ2xvbmVkTm9kZSkgfHwgaXNOb2RlKHRoaXMuX3Bvc3RDbG9uZWROb2RlKSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVJbmRleChpbmRleCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX291dGVyRW5kKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNJbmZpbml0ZSB8fCBpbmRleCA8IG5vZGVMZW5ndGggLSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uaW5zZXJ0QmVmb3JlKGl0ZW1Ob2Rlc1t0aGlzLl9uZXh0SW5kZXhdLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjb250YWluZXIuY2hpbGROb2RlcywgLTMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX291dGVyRW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zZXRJbmRleFdpbmRvdygpO1xyXG4gICAgICAgICAgICBpZiAoIShpc0luZmluaXRlIHx8IGluZGV4ID4gMCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKGl0ZW1Ob2Rlc1t0aGlzLl9wcmV2aW91c0luZGV4XSwgY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xyXG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGVbdGhpcy5fdHJhbnNmb3JtXSA9IHRoaXMuX2NhbGN1bGF0ZVN0YXRpY1RyYW5zbGF0aW9uKGxlbmd0aCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZvcmNlUmVwYWludChjb250YWluZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xlYXJzIGFsbCB0aGUgaW5uZXIgbm9kZXMgb2YgdGhlIGNvbnRyb2wuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9jbGVhcklubmVyTm9kZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUNsb25lcygpO1xyXG4gICAgICAgICAgICB0aGlzLl9vdXRlclN0YXJ0ID0gdGhpcy5fb3V0ZXJFbmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIGl0ZW1Ob2RlcyA9IHRoaXMuX2l0ZW1Ob2RlcztcclxuICAgICAgICAgICAgaWYgKGl0ZW1Ob2Rlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2NvbnRhaW5lci5jaGlsZE5vZGVzKSwgaW5zZXJ0QmVmb3JlID0gdGhpcy5kb20uaW5zZXJ0QmVmb3JlO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGNoaWxkTm9kZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDk6XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlKGl0ZW1Ob2Rlc1t0aGlzLl9wcmV2aW91c0luZGV4XSwgY2hpbGROb2Rlcy5zcGxpY2UoMCwgMykpO1xyXG4gICAgICAgICAgICAgICAgICAgIGluc2VydEJlZm9yZShpdGVtTm9kZXNbdGhpcy5fbmV4dEluZGV4XSwgY2hpbGROb2Rlcy5zcGxpY2UoLTMsIDMpKTtcclxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmUoaXRlbU5vZGVzW3RoaXMuX2luZGV4XSwgY2hpbGROb2Rlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSB0aGlzLl9uZXh0SW5kZXgsIGluZGV4ID0gdGhpcy5faW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPCAwIHx8IG5leHQgPT09IGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydEJlZm9yZShpdGVtTm9kZXNbaW5kZXhdLCBjaGlsZE5vZGVzLnNwbGljZSgtMywgMykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmUoaXRlbU5vZGVzW2luZGV4ID09PSAwID8gdGhpcy5fcHJldmlvdXNJbmRleCArIDEgOiBpbmRleCAtIDFdLCBjaGlsZE5vZGVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGluc2VydEJlZm9yZShpdGVtTm9kZXNbbmV4dF0sIGNoaWxkTm9kZXMuc3BsaWNlKC0zLCAzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlKGl0ZW1Ob2Rlc1tpbmRleF0sIGNoaWxkTm9kZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIGluc2VydEJlZm9yZShpdGVtTm9kZXNbdGhpcy5faW5kZXhdLCBjaGlsZE5vZGVzKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpemVzIGl0ZW0gbm9kZXMgYXQgdGhlIGdpdmVuIGluZGV4LlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgbmV3IGluZGV4IGF0IHRoZSB0aW1lIG9mIHRoZSBhbmltYXRpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9pbml0aWFsaXplSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgdmFyIGlubmVyTm9kZXNDbGVhcmVkID0gdGhpcy5fY2xlYXJJbm5lck5vZGVzKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pdGVtTm9kZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldEluZGV4V2luZG93KCk7XHJcbiAgICAgICAgICAgIGlmICghaW5uZXJOb2Rlc0NsZWFyZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xyXG4gICAgICAgICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKHRoaXMuX2l0ZW1Ob2Rlc1tpbmRleF0sIG51bGwpO1xyXG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGVbdGhpcy5fdHJhbnNmb3JtXSA9IHRoaXMuX2NhbGN1bGF0ZVN0YXRpY1RyYW5zbGF0aW9uKC10aGlzLl9jdXJyZW50T2Zmc2V0KTtcclxuICAgICAgICAgICAgdGhpcy5fZm9yY2VSZXBhaW50KGNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVPdXRlck5vZGVzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrQXJyb3dzKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgcHJlIGFuZCBwb3N0IGl0ZW0gbm9kZXMgZm9yIHRoZSBjdXJyZW50IGluZGV4LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5faW5pdGlhbGl6ZU91dGVyTm9kZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSB0aGlzLl9nZXRMZW5ndGgoKTtcclxuICAgICAgICAgICAgaWYgKCFsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX291dGVyU3RhcnQgPSB0aGlzLl9vdXRlckVuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpdGVtTm9kZXMgPSB0aGlzLl9pdGVtTm9kZXMsIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciwgbm9kZUxlbmd0aCA9IGl0ZW1Ob2Rlcy5sZW5ndGgsIG5vZGVUb0luc2VydDtcclxuICAgICAgICAgICAgaWYgKG5vZGVMZW5ndGggPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW5maW5pdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbG9uZUZvckluZmluaXRlKC1sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBpc05vZGUgPSB0aGlzLnV0aWxzLmlzTm9kZTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fb3V0ZXJFbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlVG9JbnNlcnQgPSBpdGVtTm9kZXNbdGhpcy5fbmV4dEluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOb2RlKG5vZGVUb0luc2VydCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmluc2VydEJlZm9yZShub2RlVG9JbnNlcnQsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vdXRlckVuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVMZW5ndGggPiAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9vdXRlclN0YXJ0ICYmICh0aGlzLl9pc0luZmluaXRlIHx8IHRoaXMuX2luZGV4ID4gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVRvSW5zZXJ0ID0gaXRlbU5vZGVzW3RoaXMuX3ByZXZpb3VzSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOb2RlKG5vZGVUb0luc2VydCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUobm9kZVRvSW5zZXJ0LCBjb250YWluZXIuZmlyc3RDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuc3R5bGVbdGhpcy5fdHJhbnNmb3JtXSA9IHRoaXMuX2NhbGN1bGF0ZVN0YXRpY1RyYW5zbGF0aW9uKC1sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZm9yY2VSZXBhaW50KGNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vdXRlclN0YXJ0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzSW5maW5pdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbG9uZUZvckluZmluaXRlKC1sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbmltYXRlcyB0aGUgY2Fyb3VzZWwgd2l0aCBhIHNldCBvZiBjaGFyYWN0ZXJpc3RpY3MgcGFzc2VkIGluIGFzIGFuIGFyZ3VtZW50LlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC5JT2JqZWN0PHN0cmluZz59IGFuaW1hdGlvbk9wdGlvbnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcga2V5LXZhbHVlIHBhaXJzXHJcbiAgICAgICAgICogb2YgcHJvcGVydGllcyB0byBhbmltYXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5faW5pdGlhdGVBbmltYXRpb24gPSBmdW5jdGlvbiAoYW5pbWF0aW9uT3B0aW9ucykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYW5pbWF0aW9uVGhlbmFibGUgPVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0b3IuYW5pbWF0ZSh0aGlzLl9jb250YWluZXIsIF9fVHJhbnNpdGlvbiwgYW5pbWF0aW9uT3B0aW9ucyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbml0aWFsaXplcyB0aGUgY29udHJvbCBhbmQgYWRkcyBhbGwgZXZlbnQgbGlzdGVuZXJzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGFkZFF1ZXVlID0gdGhpcy5fYWRkUXVldWUsIGl0ZW1Db3VudCA9IHRoaXMuY29udGV4dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldEFsaWFzZXMoKTtcclxuICAgICAgICAgICAgdmFyIGFkZFByb21pc2UgPSB0aGlzLl9hZGRJdGVtcygwLCBpdGVtQ291bnQsIDApLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYWRkUXVldWUuaW5kZXhPZihhZGRQcm9taXNlKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRRdWV1ZS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuX29uTG9hZCgpO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmRlYnVnKFwiQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgcHJvY2Vzc2luZyB0aGUgXCIgKyBfdGhpcy50eXBlICsgXCIuIFBsZWFzZSBlbnN1cmUgeW91J3JlIGNvbnRleHQgaXMgY29ycmVjdC5cIik7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9hZGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBhZGRRdWV1ZS5wdXNoKGFkZFByb21pc2UpO1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRUcmFuc2Zvcm0oKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYWxsIGV2ZW50IGxpc3RlbmVycyBvbiB0aGlzIGNvbnRyb2wncyBlbGVtZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5fYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciB0eXBlcyA9IHRoaXMuX3R5cGUuc3BsaXQoJyAnKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVzLmluZGV4T2YoJ3RhcCcpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZVRhcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlcy5pbmRleE9mKCdzd2lwZScpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZVN3aXBlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVzLmluZGV4T2YoJ3RyYWNrJykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplVHJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZXMuaW5kZXhPZignYXV0bycpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZUF1dG8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZmlyZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHRoaXMuX3dpbmRvdywgJ3Jlc2l6ZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmaXJlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZpcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlyZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudExlbmd0aCA9IF90aGlzLl9sZW5ndGgsIGxlbmd0aCA9IF90aGlzLl9nZXRMZW5ndGgoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWxlbmd0aCB8fCBjdXJyZW50TGVuZ3RoID09PSBsZW5ndGggfHwgKCFfdGhpcy5faXNJbmZpbml0ZSAmJiBfdGhpcy5faW5kZXggPT09IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NvbnRhaW5lci5zdHlsZVtfdGhpcy5fdHJhbnNmb3JtXSA9IF90aGlzLl9jYWxjdWxhdGVTdGF0aWNUcmFuc2xhdGlvbihjdXJyZW50TGVuZ3RoIC0gbGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LCBmYWxzZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGFsbCBldmVudCBsaXN0ZW5lcnMgb24gdGhpcyBjb250cm9sJ3MgZWxlbWVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuX3JlbW92ZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcmVtb3ZlTGlzdGVuZXJzID0gdGhpcy5fcmVtb3ZlTGlzdGVuZXJzO1xyXG4gICAgICAgICAgICB3aGlsZSAocmVtb3ZlTGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVycy5wb3AoKSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUludGVydmFsKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVN1c3BlbmQoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW5maW5pdGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUNsb25lcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX29uTG9hZCA9IG5vb3A7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGUgdGhlIGNsb25lcyBjYXNlIHdoZXJlIGl0ZW0gbGVuZ3RoIGlzIGxlc3MgdGhhbiAzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggVGhlIGxlbmd0aCB0byB0cmFuc2xhdGUgdGhlIG9mZnNldCBjbG9uZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuX2Nsb25lRm9ySW5maW5pdGUgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUNsb25lcygpO1xyXG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnV0aWxzLmlzQXJyYXkoY29udGV4dCkgfHwgY29udGV4dC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgb3V0ZXJTdGFydCA9IHRoaXMuX291dGVyU3RhcnQsIG91dGVyRW5kID0gdGhpcy5fb3V0ZXJFbmQ7XHJcbiAgICAgICAgICAgIGlmIChvdXRlclN0YXJ0ICYmIG91dGVyRW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcclxuICAgICAgICAgICAgaWYgKCFvdXRlckVuZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvc3RDbG9uZSA9IHRoaXMuX3Bvc3RDbG9uZWROb2RlID0gY29udGFpbmVyLmZpcnN0RWxlbWVudENoaWxkLmNsb25lTm9kZSh0cnVlKTtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUocG9zdENsb25lLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX291dGVyRW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIW91dGVyU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwcmVDbG9uZSA9IHRoaXMuX3ByZUNsb25lZE5vZGUgPSBjb250YWluZXIubGFzdEVsZW1lbnRDaGlsZC5jbG9uZU5vZGUodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKHByZUNsb25lLCBjb250YWluZXIuZmlyc3RDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXIuc3R5bGVbdGhpcy5fdHJhbnNmb3JtXSA9IHRoaXMuX2NhbGN1bGF0ZVN0YXRpY1RyYW5zbGF0aW9uKGxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mb3JjZVJlcGFpbnQoY29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX291dGVyU3RhcnQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIHRoZSBjbG9uZXMgZm9yIGluZmluaXRlIHNjcm9sbGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuX3JlbW92ZUNsb25lcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciwgcHJlQ2xvbmUgPSB0aGlzLl9wcmVDbG9uZWROb2RlLCBwb3N0Q2xvbmUgPSB0aGlzLl9wb3N0Q2xvbmVkTm9kZSwgaXNOb2RlID0gdGhpcy51dGlscy5pc05vZGU7XHJcbiAgICAgICAgICAgIGlmIChpc05vZGUocHJlQ2xvbmUpICYmIGNvbnRhaW5lci5jb250YWlucyhwcmVDbG9uZSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChwcmVDbG9uZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzTm9kZShwb3N0Q2xvbmUpICYmIGNvbnRhaW5lci5jb250YWlucyhwb3N0Q2xvbmUpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQocG9zdENsb25lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9wcmVDbG9uZWROb2RlID0gdGhpcy5fcG9zdENsb25lZE5vZGUgPSBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhbGwgbmVjZXNzYXJ5IGVsZW1lbnRzIGFuZCBldmVudCBsaXN0ZW5lcnMgdG8gc2V0dXAgYXV0byBzY3JvbGwuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9pbml0aWFsaXplQXV0byA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5faXNBdXRvID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5faW5pdGlhdGVJbnRlcnZhbCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQmVnaW5zIGF1dG8gc2Nyb2xsaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5faW5pdGlhdGVJbnRlcnZhbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlSW50ZXJ2YWwgPSB0aGlzLnV0aWxzLnNldEludGVydmFsKHRoaXMuZ29Ub05leHQsIHRoaXMuX2ludGVydmFsLCBudWxsLCB0aGlzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyBmb3IgYXV0b21hdGljIHNjcm9sbGluZyBhbmQgc3VzcGVuZHMgaWYgbmVjZXNzYXJ5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5fc3VzcGVuZEludGVydmFsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzQXV0byB8fCB0aGlzLl9pc1BhdXNlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVN1c3BlbmQoKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlSW50ZXJ2YWwoKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlU3VzcGVuZCA9IHRoaXMudXRpbHMuZGVmZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2luaXRpYXRlSW50ZXJ2YWwoKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9yZW1vdmVTdXNwZW5kID0gbm9vcDtcclxuICAgICAgICAgICAgfSwgdGhpcy5fc3VzcGVuZCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGFsbCBuZWNlc3NhcnkgZWxlbWVudHMgYW5kIGV2ZW50IGxpc3RlbmVycyB0byBoYW5kbGUgdGFwIGV2ZW50cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuX2luaXRpYWxpemVUYXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy51dGlscy5pc05vZGUodGhpcy5fZm9yd2FyZEFycm93KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlQXJyb3dFbGVtZW50cygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByZW1vdmVMaXN0ZW5lcnMgPSB0aGlzLl9yZW1vdmVMaXN0ZW5lcnM7XHJcbiAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVycy5wdXNoKHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9iYWNrQXJyb3csIF9fJHRhcCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3N1c3BlbmRJbnRlcnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZ29Ub1ByZXZpb3VzKCk7XHJcbiAgICAgICAgICAgIH0sIGZhbHNlKSk7XHJcbiAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVycy5wdXNoKHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9mb3J3YXJkQXJyb3csIF9fJHRhcCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3N1c3BlbmRJbnRlcnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZ29Ub05leHQoKTtcclxuICAgICAgICAgICAgfSwgZmFsc2UpKTtcclxuICAgICAgICAgICAgdGhpcy5fY2hlY2tBcnJvd3MoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgdGhlIGFycm93IGVsZW1lbnRzIGZvciB0eXBlIGB0YXBgIGFuZCBwbGFjZXMgdGhlbSBpbiB0aGUgRE9NLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5fY3JlYXRlQXJyb3dFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF9kb2N1bWVudCA9IHRoaXMuX2RvY3VtZW50LCB2aWV3cG9ydCA9IHRoaXMuX3ZpZXdwb3J0LCBiYWNrQXJyb3dDb250YWluZXIgPSB0aGlzLl9iYWNrQXJyb3cgPSBfZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIGZvcndhcmRBcnJvd0NvbnRhaW5lciA9IHRoaXMuX2ZvcndhcmRBcnJvdyA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgYmFja0Fycm93ID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKSwgZm9yd2FyZEFycm93ID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzVmVydGljYWwpIHtcclxuICAgICAgICAgICAgICAgIGJhY2tBcnJvdy5jbGFzc05hbWUgPSBfX1BsYXQgKyBcImljb24tYXJyb3ctdXBcIjtcclxuICAgICAgICAgICAgICAgIGZvcndhcmRBcnJvdy5jbGFzc05hbWUgPSBfX1BsYXQgKyBcImljb24tYXJyb3ctZG93blwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYmFja0Fycm93LmNsYXNzTmFtZSA9IF9fUGxhdCArIFwiaWNvbi1hcnJvdy1sZWZ0XCI7XHJcbiAgICAgICAgICAgICAgICBmb3J3YXJkQXJyb3cuY2xhc3NOYW1lID0gX19QbGF0ICsgXCJpY29uLWFycm93LXJpZ2h0XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYmFja0Fycm93Q29udGFpbmVyLmNsYXNzTmFtZSA9IF9fUGxhdCArIFwiYmFjay1hcnJvd1wiO1xyXG4gICAgICAgICAgICBmb3J3YXJkQXJyb3dDb250YWluZXIuY2xhc3NOYW1lID0gX19QbGF0ICsgXCJmb3J3YXJkLWFycm93XCI7XHJcbiAgICAgICAgICAgIGJhY2tBcnJvd0NvbnRhaW5lci5hcHBlbmRDaGlsZChiYWNrQXJyb3cpO1xyXG4gICAgICAgICAgICBmb3J3YXJkQXJyb3dDb250YWluZXIuYXBwZW5kQ2hpbGQoZm9yd2FyZEFycm93KTtcclxuICAgICAgICAgICAgdmlld3BvcnQuYXBwZW5kQ2hpbGQoYmFja0Fycm93Q29udGFpbmVyKTtcclxuICAgICAgICAgICAgdmlld3BvcnQuYXBwZW5kQ2hpbGQoZm9yd2FyZEFycm93Q29udGFpbmVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyB0aGUgdmFsaWRpdHkgb2YgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZvcndhcmQgYW5kIGJhY2sgYXJyb3dzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5fY2hlY2tBcnJvd3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1dGlscyA9IHRoaXMudXRpbHMsIGlzTm9kZSA9IHV0aWxzLmlzTm9kZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW5maW5pdGUgfHwgIShpc05vZGUodGhpcy5fZm9yd2FyZEFycm93KSAmJiBpc05vZGUodGhpcy5fYmFja0Fycm93KSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY29udGV4dExlbmd0aCA9IHRoaXMuY29udGV4dC5sZW5ndGgsIGluZGV4ID0gdGhpcy5faW5kZXg7XHJcbiAgICAgICAgICAgIGlmICh1dGlscy5pc051bGwoaW5kZXgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9iYWNrQXJyb3cuc2V0QXR0cmlidXRlKF9fSGlkZSwgJycpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZm9yd2FyZEFycm93LnNldEF0dHJpYnV0ZShfX0hpZGUsICcnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaW5kZXggPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmFja0Fycm93LnNldEF0dHJpYnV0ZShfX0hpZGUsICcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2JhY2tBcnJvdy5yZW1vdmVBdHRyaWJ1dGUoX19IaWRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gY29udGV4dExlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZvcndhcmRBcnJvdy5zZXRBdHRyaWJ1dGUoX19IaWRlLCAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mb3J3YXJkQXJyb3cucmVtb3ZlQXR0cmlidXRlKF9fSGlkZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYWxsIGV2ZW50IGxpc3RlbmVycyB0byBoYW5kbGUgc3dpcGUgZXZlbnRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5faW5pdGlhbGl6ZVN3aXBlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fdmlld3BvcnQsIHN3aXBlRm4gPSB0aGlzLl9oYW5kbGVTd2lwZSwgc3dpcGUsIHJldmVyc2VTd2lwZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzVmVydGljYWwpIHtcclxuICAgICAgICAgICAgICAgIHN3aXBlID0gX18kc3dpcGUgKyBcInVwXCI7XHJcbiAgICAgICAgICAgICAgICByZXZlcnNlU3dpcGUgPSBfXyRzd2lwZSArIFwiZG93blwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3dpcGUgPSBfXyRzd2lwZSArIFwibGVmdFwiO1xyXG4gICAgICAgICAgICAgICAgcmV2ZXJzZVN3aXBlID0gX18kc3dpcGUgKyBcInJpZ2h0XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJlbW92ZUxpc3RlbmVycyA9IHRoaXMuX3JlbW92ZUxpc3RlbmVycztcclxuICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzLnB1c2godGhpcy5hZGRFdmVudExpc3RlbmVyKGNvbnRhaW5lciwgc3dpcGUsIHN3aXBlRm4sIGZhbHNlKSk7XHJcbiAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVycy5wdXNoKHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihjb250YWluZXIsIHJldmVyc2VTd2lwZSwgc3dpcGVGbiwgZmFsc2UpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYWxsIGV2ZW50IGxpc3RlbmVycyB0byBoYW5kbGUgdHJhY2tpbmcgZXZlbnRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5faW5pdGlhbGl6ZVRyYWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdmlld3BvcnQgPSB0aGlzLl92aWV3cG9ydCwgdHJhY2tGbiA9IHRoaXMuX3RyYWNrLCB0b3VjaEVuZCA9IHRoaXMuX3RvdWNoRW5kLCB0cmFjaywgcmV2ZXJzZVRyYWNrO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgdHJhY2sgPSBfXyR0cmFjayArIFwidXBcIjtcclxuICAgICAgICAgICAgICAgIHJldmVyc2VUcmFjayA9IF9fJHRyYWNrICsgXCJkb3duXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0cmFjayA9IF9fJHRyYWNrICsgXCJsZWZ0XCI7XHJcbiAgICAgICAgICAgICAgICByZXZlcnNlVHJhY2sgPSBfXyR0cmFjayArIFwicmlnaHRcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmVtb3ZlTGlzdGVuZXJzID0gdGhpcy5fcmVtb3ZlTGlzdGVuZXJzO1xyXG4gICAgICAgICAgICByZW1vdmVMaXN0ZW5lcnMucHVzaCh0aGlzLmFkZEV2ZW50TGlzdGVuZXIodmlld3BvcnQsIHRyYWNrLCB0cmFja0ZuLCBmYWxzZSkpO1xyXG4gICAgICAgICAgICByZW1vdmVMaXN0ZW5lcnMucHVzaCh0aGlzLmFkZEV2ZW50TGlzdGVuZXIodmlld3BvcnQsIHJldmVyc2VUcmFjaywgdHJhY2tGbiwgZmFsc2UpKTtcclxuICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzLnB1c2godGhpcy5hZGRFdmVudExpc3RlbmVyKHZpZXdwb3J0LCBfXyR0b3VjaHN0YXJ0LCB0aGlzLl90b3VjaFN0YXJ0LCBmYWxzZSkpO1xyXG4gICAgICAgICAgICByZW1vdmVMaXN0ZW5lcnMucHVzaCh0aGlzLmFkZEV2ZW50TGlzdGVuZXIodmlld3BvcnQsIF9fJHRyYWNrZW5kLCB0b3VjaEVuZCwgZmFsc2UpKTtcclxuICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzLnB1c2godGhpcy5hZGRFdmVudExpc3RlbmVyKHZpZXdwb3J0LCBfXyR0b3VjaGVuZCwgdG91Y2hFbmQsIGZhbHNlKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIYW5kbGVzIGEgc3dpcGUgZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9oYW5kbGVTd2lwZSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gZXYuZGlyZWN0aW9uLnByaW1hcnksIGhhc1N3aXBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1ZlcnRpY2FsICYmICh0aGlzLl9pc0luZmluaXRlIHx8IHRoaXMuX2luZGV4IDwgdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N1c3BlbmRJbnRlcnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNTd2lwZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdvVG9OZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNWZXJ0aWNhbCAmJiAodGhpcy5faXNJbmZpbml0ZSB8fCB0aGlzLl9pbmRleCA+IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N1c3BlbmRJbnRlcnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNTd2lwZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdvVG9QcmV2aW91cygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3VwJzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNWZXJ0aWNhbCAmJiAodGhpcy5faXNJbmZpbml0ZSB8fCB0aGlzLl9pbmRleCA8IHRoaXMuY29udGV4dC5sZW5ndGggLSAxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdXNwZW5kSW50ZXJ2YWwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzU3dpcGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nb1RvTmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2Rvd24nOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1ZlcnRpY2FsICYmICh0aGlzLl9pc0luZmluaXRlIHx8IHRoaXMuX2luZGV4ID4gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3VzcGVuZEludGVydmFsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1N3aXBlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ29Ub1ByZXZpb3VzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5faGFzU3dpcGVkID0gaGFzU3dpcGVkO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTG9nIHdoZW4gdGhlIHVzZXIgdG91Y2hlcyB0aGUgQ2Fyb3VzZWwuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklHZXN0dXJlRXZlbnR9IGV2IFRoZSB0b3VjaCBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuX3RvdWNoU3RhcnQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2luVG91Y2gpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9pc0F1dG8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUludGVydmFsKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVJbnRlcnZhbCA9IG5vb3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5faW5Ub3VjaCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhc01vdmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RUb3VjaCA9IHtcclxuICAgICAgICAgICAgICAgIHg6IGV2LmNsaWVudFgsXHJcbiAgICAgICAgICAgICAgICB5OiBldi5jbGllbnRZXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgJHRvdWNoZW5kIGFuZCAkdHJhY2tlbmQgZXZlbnQgaGFuZGxlci5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSUdlc3R1cmVFdmVudH0gZXYgVGhlIHRvdWNoIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5fdG91Y2hFbmQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGluVG91Y2ggPSB0aGlzLl9pblRvdWNoLCBoYXNNb3ZlZCA9IHRoaXMuX2hhc01vdmVkLCBoYXNTd2lwZWQgPSB0aGlzLl9oYXNTd2lwZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2luVG91Y2ggPSB0aGlzLl9oYXNTd2lwZWQgPSB0aGlzLl9oYXNNb3ZlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoIWluVG91Y2ggfHwgaGFzU3dpcGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5faXNBdXRvICYmICF0aGlzLl9pc1BhdXNlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhdGVJbnRlcnZhbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaGFzTW92ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2VNb3ZlZCA9IHRoaXMuX2lzVmVydGljYWwgPyAoZXYuY2xpZW50WSAtIHRoaXMuX2xhc3RUb3VjaC55KSA6IChldi5jbGllbnRYIC0gdGhpcy5fbGFzdFRvdWNoLngpLCBsZW5ndGggPSB0aGlzLl9nZXRMZW5ndGgoKTtcclxuICAgICAgICAgICAgaWYgKCFsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoTWF0aC5hYnMoZGlzdGFuY2VNb3ZlZCkgPiBNYXRoLmNlaWwobGVuZ3RoIC8gMikpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZU1vdmVkIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ29Ub05leHQoKS50aGVuKGZ1bmN0aW9uIChzdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3VjY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Jlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdvVG9QcmV2aW91cygpLnRoZW4oZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Jlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fcmVzZXQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSAkdHJhY2sgZXZlbnQgaGFuZGxlci4gVXNlZCBmb3IgdHJhY2tpbmcgb25seSBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHRyYWNraW5nIG1vdGlvbnNcclxuICAgICAgICAgKiBkZXBlbmRpbmcgb24gdGhlIGRlZmluZWQgb3JpZW50YXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklHZXN0dXJlRXZlbnR9IGV2IFRoZSAkdHJhY2tpbmcgZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLl90cmFjayA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2luVG91Y2gpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5faGFzTW92ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbmNlbEN1cnJlbnRBbmltYXRpb25zKCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoX3RoaXMuX291dGVyU3RhcnQgJiYgX3RoaXMuX291dGVyRW5kKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5faW5pdGlhbGl6ZU91dGVyTm9kZXMoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9oYXNNb3ZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMudXRpbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0cmFuc2xhdGlvbiA9IF90aGlzLl9jYWxjdWxhdGVEeW5hbWljVHJhbnNsYXRpb24oZXYpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zbGF0aW9uID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2NvbnRhaW5lci5zdHlsZVtfdGhpcy5fdHJhbnNmb3JtXSA9IHRyYW5zbGF0aW9uO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIHRyYW5zbGF0aW9uIHZhbHVlIGZvciBzZXR0aW5nIHRoZSB0cmFuc2Zvcm0gdmFsdWUgZHVyaW5nIGEgc3RhdGljIGluZGV4IHNldC5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW50ZXJ2YWwgVGhlIGludGVydmFsIGNoYW5nZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuX2NhbGN1bGF0ZVN0YXRpY1RyYW5zbGF0aW9uID0gZnVuY3Rpb24gKGludGVydmFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1ZlcnRpY2FsID8gXCJ0cmFuc2xhdGUzZCgwLFwiICsgKHRoaXMuX2N1cnJlbnRPZmZzZXQgKz0gaW50ZXJ2YWwpICsgXCJweCwwKVwiIDpcclxuICAgICAgICAgICAgICAgIFwidHJhbnNsYXRlM2QoXCIgKyAodGhpcy5fY3VycmVudE9mZnNldCArPSBpbnRlcnZhbCkgKyBcInB4LDAsMClcIjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIHRyYW5zbGF0aW9uIHZhbHVlIGZvciBzZXR0aW5nIHRoZSB0cmFuc2Zvcm0gdmFsdWUgZHVyaW5nIHRyYWNraW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JR2VzdHVyZUV2ZW50fSBldiBUaGUgJHRyYWNraW5nIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5fY2FsY3VsYXRlRHluYW1pY1RyYW5zbGF0aW9uID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQ7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1ZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBldi5jbGllbnRZIC0gdGhpcy5fbGFzdFRvdWNoLnk7XHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMob2Zmc2V0KSA+IHRoaXMuX2dldExlbmd0aCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG91Y2hFbmQoZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlM2QoMCxcIiArICh0aGlzLl9jdXJyZW50T2Zmc2V0ICsgb2Zmc2V0KSArIFwicHgsMClcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvZmZzZXQgPSBldi5jbGllbnRYIC0gdGhpcy5fbGFzdFRvdWNoLng7XHJcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhvZmZzZXQpID4gdGhpcy5fZ2V0TGVuZ3RoKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RvdWNoRW5kKGV2KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBcInRyYW5zbGF0ZTNkKFwiICsgKHRoaXMuX2N1cnJlbnRPZmZzZXQgKyBvZmZzZXQpICsgXCJweCwwLDApXCI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBPYnRhaW5zIHRoZSBjdXJyZW50IGJyb3dzZXIncyB0cmFuc2Zvcm0gcHJvcGVydHkgdmFsdWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuX2NvbnRhaW5lci5zdHlsZSwgaXNVbmRlZmluZWQgPSB0aGlzLnV0aWxzLmlzVW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB2YXIgdmVuZG9yUHJlZml4ID0gdGhpcy5fY29tcGF0LnZlbmRvclByZWZpeDtcclxuICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChzdHlsZVsodmVuZG9yUHJlZml4Lmxvd2VyQ2FzZSArIFwiVHJhbnNmb3JtXCIpXSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybSA9IHZlbmRvclByZWZpeC5sb3dlckNhc2UgKyBcIlRyYW5zZm9ybVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc1VuZGVmaW5lZChzdHlsZVsodmVuZG9yUHJlZml4LnVwcGVyQ2FzZSArIFwiVHJhbnNmb3JtXCIpXSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybSA9IHZlbmRvclByZWZpeC51cHBlckNhc2UgKyBcIlRyYW5zZm9ybVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtID0gJ3RyYW5zZm9ybSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGludGVydmFsIGxlbmd0aCBvZiB0aGUgc2xpZGluZyBjb250YWluZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9nZXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZW5ndGggPSAodGhpcy5faXNWZXJ0aWNhbCA/IHRoaXMuX3ZpZXdwb3J0Lm9mZnNldEhlaWdodCA6IHRoaXMuX3ZpZXdwb3J0Lm9mZnNldFdpZHRoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyB0aGUgb3JpZW50YXRpb24gb2YgdGhlIGNvbnRyb2wgYW5kIGVuc3VyZXMgaXQgaXMgdmFsaWQuXHJcbiAgICAgICAgICogV2lsbCBkZWZhdWx0IHRvIFwiaG9yaXpvbnRhbFwiIGlmIGludmFsaWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWVudGF0aW9uIFRoZSBlbGVtZW50IHRvIGJhc2UgdGhlIGxlbmd0aCBvZmYgb2YuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLl92YWxpZGF0ZU9yaWVudGF0aW9uID0gZnVuY3Rpb24gKG9yaWVudGF0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnV0aWxzLmlzVW5kZWZpbmVkKG9yaWVudGF0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdob3Jpem9udGFsJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdmFsaWRPcmllbnRhdGlvbjtcclxuICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcclxuICAgICAgICAgICAgICAgIHZhbGlkT3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xyXG4gICAgICAgICAgICAgICAgdmFsaWRPcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNWZXJ0aWNhbCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoXCJJbnZhbGlkIG9yaWVudGF0aW9uIFxcXCJcIiArIG9yaWVudGF0aW9uICsgXCJcXFwiIGZvciBcIiArIHRoaXMudHlwZSArIFwiLiBEZWZhdWx0aW5nIHRvIFxcXCJob3Jpem9udGFsLlxcXCJcIik7XHJcbiAgICAgICAgICAgICAgICB2YWxpZE9yaWVudGF0aW9uID0gJ2hvcml6b250YWwnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWxpZE9yaWVudGF0aW9uO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhbiBBcnJheSBvZiBpdGVtcyB0byB0aGUgZWxlbWVudCB3aXRob3V0IGFuaW1hdGluZy5cclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PE5vZGU+fSBpdGVtcyBUaGUgQXJyYXkgb2YgaXRlbXMgdG8gYWRkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5fYXBwZW5kSXRlbXMgPSBmdW5jdGlvbiAoaXRlbXMpIHtcclxuICAgICAgICAgICAgdGhpcy5faXRlbU5vZGVzID0gdGhpcy5faXRlbU5vZGVzLmNvbmNhdChpdGVtcyk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9sb2FkZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2luZGV4O1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gcmVtb3ZlIGxpc3RlbmVycyBleGlzdCB3ZSBrbm93IHRoYXQgd2UgaGFkIHByZXZpb3VzbHkgcmVtb3ZlZCB0aGVtLiBcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZW1vdmVMaXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplSW5kZXgoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dENoYW5nZWQoMCwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSB0aGlzLl9pdGVtTm9kZXMubGVuZ3RoIC0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVJbmRleChpbmRleCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgaXRlbXMgZnJvbSB0aGUgY29udHJvbCdzIGVsZW1lbnQuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCB0byBzdGFydCBkaXNwb3NpbmcgZnJvbS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyT2ZJdGVtcyBUaGUgbnVtYmVyIG9mIGl0ZW1zIHRvIHJlbW92ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuX3JlbW92ZUl0ZW1zID0gZnVuY3Rpb24gKGluZGV4LCBudW1iZXJPZkl0ZW1zKSB7XHJcbiAgICAgICAgICAgIHZhciBkaXNwb3NlID0gdGhpcy5fVGVtcGxhdGVDb250cm9sRmFjdG9yeS5kaXNwb3NlLCBjb250cm9scyA9IHRoaXMuY29udHJvbHMsIGl0ZW1Ob2RlcyA9IHRoaXMuX2l0ZW1Ob2RlcywgbGFzdCA9IGluZGV4ICsgbnVtYmVyT2ZJdGVtcztcclxuICAgICAgICAgICAgd2hpbGUgKGxhc3QtLSA+IGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBkaXNwb3NlKGNvbnRyb2xzW2xhc3RdKTtcclxuICAgICAgICAgICAgICAgIGl0ZW1Ob2Rlcy5wb3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVSZXNvdXJjZShjb250cm9scy5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgdGhpcy5fdmVyaWZ5TGVuZ3RoKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYW5jZWxzIHRoZSBjdXJyZW50IGFuaW1hdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuX2NhbmNlbEN1cnJlbnRBbmltYXRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy51dGlscy5pc051bGwodGhpcy5fYW5pbWF0aW9uVGhlbmFibGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FuaW1hdGlvblRoZW5hYmxlLmNhbmNlbCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRm9yY2VzIGEgcmVwYWludCAvIHJlZmxvdy5cclxuICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGZvcmNlIHRoZSByZXBhaW50IC8gcmVmbG93IG9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5fZm9yY2VSZXBhaW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdmFyIHN0eWxlID0gZWxlbWVudC5zdHlsZSwgZGlzcGxheSA9IHN0eWxlLmRpc3BsYXksIG5vbmUgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgIGlmIChzdHlsZS5kaXNwbGF5ID09PSBub25lKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm9mZnNldFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0eWxlLmRpc3BsYXkgPSBub25lO1xyXG4gICAgICAgICAgICBlbGVtZW50Lm9mZnNldFdpZHRoO1xyXG4gICAgICAgICAgICBzdHlsZS5kaXNwbGF5ID0gZGlzcGxheTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIENhcm91c2VsLl9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgIF9kb2N1bWVudDogX19Eb2N1bWVudCxcclxuICAgICAgICAgICAgX3dpbmRvdzogX19XaW5kb3csXHJcbiAgICAgICAgICAgIF9jb21wYXQ6IF9fQ29tcGF0LFxyXG4gICAgICAgICAgICBfVGVtcGxhdGVDb250cm9sRmFjdG9yeTogX19UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQ2Fyb3VzZWw7XHJcbiAgICB9KHBsYXQudWkuY29udHJvbHMuRm9yRWFjaCkpO1xyXG4gICAgcGxhdHVpLkNhcm91c2VsID0gQ2Fyb3VzZWw7XHJcbiAgICBwbGF0LnJlZ2lzdGVyLmNvbnRyb2woX19DYXJvdXNlbCwgQ2Fyb3VzZWwpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBJVGVtcGxhdGVDb250cm9sIGZvciBjcmVhdGluZyBhIGNvbXBsZXggbGlzdCBvZiBpdGVtcyB3aXRoXHJcbiAgICAgKiBleHRlbnNpdmUgZnVuY3Rpb25hbGl0eS5cclxuICAgICAqL1xyXG4gICAgdmFyIExpc3R2aWV3ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoTGlzdHZpZXcsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGNvbnN0cnVjdG9yIGZvciBhIExpc3R2aWV3LiBDcmVhdGVzIHRoZSBpdGVtc0xvYWRlZCBQcm9taXNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIExpc3R2aWV3KCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBIVE1MIHRlbXBsYXRlIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZVN0cmluZyA9IHRoaXMuX190ZW1wbGF0ZVN0cmluZztcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFVzZWQgdG8gaG9sZCB0aGUgYWxpYXMgdG9rZW5zIGZvciB0aGUgYnVpbHQtaW4gYWxpYXNlcy4gWW91XHJcbiAgICAgICAgICAgICAqIGNhbiBvdmVyd3JpdGUgdGhlc2Ugd2l0aCB0aGUgb3B0aW9ucyBmb3JcclxuICAgICAgICAgICAgICogdGhlIExpc3R2aWV3IGNvbnRyb2wuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9hbGlhc2VzID0ge1xyXG4gICAgICAgICAgICAgICAgaW5kZXg6IF9fbGlzdHZpZXdBbGlhc09wdGlvbnMuaW5kZXgsXHJcbiAgICAgICAgICAgICAgICBldmVuOiBfX2xpc3R2aWV3QWxpYXNPcHRpb25zLmV2ZW4sXHJcbiAgICAgICAgICAgICAgICBvZGQ6IF9fbGlzdHZpZXdBbGlhc09wdGlvbnMub2RkLFxyXG4gICAgICAgICAgICAgICAgZmlyc3Q6IF9fbGlzdHZpZXdBbGlhc09wdGlvbnMuZmlyc3QsXHJcbiAgICAgICAgICAgICAgICBsYXN0OiBfX2xpc3R2aWV3QWxpYXNPcHRpb25zLmxhc3QsXHJcbiAgICAgICAgICAgICAgICBncm91cDogX19saXN0dmlld0FsaWFzT3B0aW9ucy5ncm91cFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5vZGUgbmFtZXMgb2YgdGhlIExpc3R2aWV3J3MgZGVmaW5lZCB0ZW1wbGF0ZXMgYW5kXHJcbiAgICAgICAgICAgICAqIHRoZWlyIGNvcnJlc3BvbmRpbmcgdGVtcGxhdGUgbm9kZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlcyA9IHt9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciB0aGUgY29udHJvbCBpcyB2ZXJ0aWNhbCBvciBob3Jpem9udGFsLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5faXNWZXJ0aWNhbCA9IHRydWU7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgc2Nyb2xsIGZ1bmN0aW9uIGlzIHJlYWR5IHRvIGJlIGhhbmRsZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxSZWFkeSA9IHRydWU7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgdXNlciBpcyBjdXJyZW50bHkgcGVyZm9ybWluZyBhIGxvYWQgb3BlcmF0aW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5faXNMb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIGNvbnRhaW5lci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFBvc2l0aW9uID0gMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gdGhhdCByZW1vdmVzIHRoZSBzY3JvbGwgZXZlbnQgbGlzdGVuZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVTY3JvbGwgPSBub29wO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIHVzZXIgaXMgY3VycmVudGx5IHBlcmZvcm1pbmcgYSByZWZyZXNoIG9wZXJhdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2lzUmVmcmVzaGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQW4gZW51bWVyYXRpb24gdmFsdWUgc2lnbmlmeWluZyB0aGUgY3VycmVudCB0b3VjaCBzdGF0ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoU3RhdGUgPSAwO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciB0aGUgdXNlciBpcyB0cmFja2luZyBpbiBhIGZhc2hpb24gdGhhdCBhdHRlbXB0cyB0byByZWZyZXNoIHRoZSBsaXN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5faGFzTW92ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBsYXN0IHRvdWNoIHN0YXJ0IHJlY29yZGVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fbGFzdFRvdWNoID0geyB4OiAwLCB5OiAwIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3Igbm9ybWFsaXppbmcgYSBub2RlIG5hbWUgYnkgcmVtb3ZpbmcgcG90ZW50aWFsIHNwZWNpYWwgY2hhcmFjdGVycy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX25vZGVOb3JtYWxpemVSZWdleCA9IC8tfFxcLnxfL2c7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgc2VsZWN0IGlzIGdyb3VwZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9pc0dyb3VwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgc2V0IG9mIGZ1bmN0aW9ucyB0byByZW1vdmUgYWxsIHZpc2liaWxpdHkgbGlzdGVuZXJzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fdmlzaWJpbGl0eVJlbW92ZUxpc3RlbmVycyA9IFtdO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHByaXZhdGUgdGVtcGxhdGUgc3RyaW5nIHVzZWQgdG8gY2hlY2sgZm9yIGEgdGVtcGxhdGUgb3ZlcndyaXRlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fX3RlbXBsYXRlU3RyaW5nID0gJzxkaXYgY2xhc3M9XCJwbGF0LWxpc3R2aWV3LXZpZXdwb3J0XCI+XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnICAgIDxkaXYgY2xhc3M9XCJwbGF0LXNjcm9sbC1jb250YWluZXJcIj5cXG4nICtcclxuICAgICAgICAgICAgICAgICcgICAgICAgIDxkaXYgY2xhc3M9XCJwbGF0LWxpc3R2aWV3LWNvbnRhaW5lclwiPjwvZGl2PlxcbicgK1xyXG4gICAgICAgICAgICAgICAgJyAgICA8L2Rpdj5cXG4nICtcclxuICAgICAgICAgICAgICAgICc8L2Rpdj5cXG4nO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIG1haW4gQXJyYXkgbGlzdGVuZXIgaGFzIGJlZW4gc2V0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fX2xpc3RlbmVyU2V0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuaXRlbXNMb2FkZWQgPSBuZXcgdGhpcy5fUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fX3Jlc29sdmVGbiA9IHJlc29sdmU7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fX3JlamVjdEZuID0gcmVqZWN0O1xyXG4gICAgICAgICAgICB9KS5jYXRjaChub29wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgY2xhc3NlcyBvbiB0aGUgcHJvcGVyIGVsZW1lbnRzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWU/IEFuIG9wdGlvbmFsLCBhZGRpdGlvbmFsIGNsYXNzIG5hbWUgb3IgY2xhc3MgbmFtZXMgdG8gc2V0IG9uIHRoZSBjb250cm9sXHJcbiAgICAgICAgICogaW4gYWRkaXRpb24gdG8gaXRzIHN0YW5kYXJkIHNldC5cclxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQ/IFRoZSBlbGVtZW50IHRvIHNldCB0aGUgY2xhc3MgbmFtZSBvbi4gU2hvdWxkIGRlZmF1bHQgdG9cclxuICAgICAgICAgKiB0aGUgY29udHJvbCdzIGVsZW1lbnQgaWYgbm90IHNwZWNpZmllZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuc2V0Q2xhc3NlcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5kb20uYWRkQ2xhc3MoZWxlbWVudCB8fCB0aGlzLmVsZW1lbnQsIF9fTGlzdHZpZXcgKyBcIiBcIiArIChjbGFzc05hbWUgfHwgJycpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrIGZvciB0ZW1wbGF0ZVVybCBhbmQgc2V0IGlmIG5lZWRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbk9iaiA9IHRoaXMub3B0aW9ucyB8fCAodGhpcy5vcHRpb25zID0ge30pLCBvcHRpb25zID0gb3B0aW9uT2JqLnZhbHVlIHx8IChvcHRpb25PYmoudmFsdWUgPSB7fSk7XHJcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGVVcmwgPSBvcHRpb25zLnRlbXBsYXRlVXJsIHx8IHRoaXMudGVtcGxhdGVVcmw7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0Q2xhc3NlcygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGFyc2UgdGhlIGlubmVyVGVtcGxhdGUgYW5kIGFkZCBpdCB0byB0aGUgY29udHJvbCdzIGVsZW1lbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLnNldFRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy50ZW1wbGF0ZVN0cmluZyAhPT0gdGhpcy5fX3RlbXBsYXRlU3RyaW5nIHx8IHRoaXMudXRpbHMuaXNTdHJpbmcodGhpcy50ZW1wbGF0ZVVybCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IHRoaXMuZG9tLnNlcmlhbGl6ZUh0bWwodGhpcy5fX3RlbXBsYXRlU3RyaW5nKSwgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5uZXJUZW1wbGF0ZSA9IHRoaXMuZG9tLmFwcGVuZENoaWxkcmVuKGVsZW1lbnQuY2hpbGROb2Rlcyk7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGZyYWdtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmUtc3luY3MgdGhlIExpc3R2aWV3IGNoaWxkIGNvbnRyb2xzIGFuZCBET00gd2l0aCB0aGUgbmV3XHJcbiAgICAgICAgICogYXJyYXkuXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBuZXdWYWx1ZT8gVGhlIG5ldyBBcnJheVxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gb2xkVmFsdWU/IFRoZSBvbGQgQXJyYXlcclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuY29udGV4dENoYW5nZWQgPSBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnV0aWxzLmlzQXJyYXkobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKHRoaXMudHlwZSArIFwiIGNvbnRleHQgc2V0IHRvIHNvbWV0aGluZyBvdGhlciB0aGFuIGFuIEFycmF5LlwiKTtcclxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZXhlY3V0ZUV2ZW50KFt7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBuZXdWYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3BsaWNlJ1xyXG4gICAgICAgICAgICAgICAgfV0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGV0ZXJtaW5lIGl0ZW0gdGVtcGxhdGVzIGFuZCBraWNrIG9mZiByZW5kZXJpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMudmFsdWUsIHV0aWxzID0gdGhpcy51dGlscywgaXNTdHJpbmcgPSB1dGlscy5pc1N0cmluZywgZWxlbWVudCA9IHRoaXMuZWxlbWVudCwgdmlld3BvcnQgPSB0aGlzLl92aWV3cG9ydCA9IGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQsIHNjcm9sbENvbnRhaW5lciA9IHRoaXMuX3Njcm9sbENvbnRhaW5lciA9IHZpZXdwb3J0LmZpcnN0RWxlbWVudENoaWxkLCBsb2FkaW5nID0gdGhpcy5fbG9hZGluZyA9IG9wdGlvbnMubG9hZGluZywgYW5pbWF0ZSA9IHRoaXMuX2FuaW1hdGUgPSBvcHRpb25zLmFuaW1hdGUgPT09IHRydWUsIHJlcXVlc3RJdGVtcyA9IG9wdGlvbnMub25JdGVtc1JlcXVlc3RlZCwgcmVmcmVzaCA9IG9wdGlvbnMub25SZWZyZXNoLCBpdGVtVGVtcGxhdGUgPSBvcHRpb25zLml0ZW1UZW1wbGF0ZSwgc2Nyb2xsRWxlbWVudCA9IG9wdGlvbnMuc2Nyb2xsRWxlbWVudDtcclxuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyID0gc2Nyb2xsQ29udGFpbmVyLmZpcnN0RWxlbWVudENoaWxkO1xyXG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRDbGFzcyhlbGVtZW50LCBfX1BsYXQgKyB0aGlzLl92YWxpZGF0ZU9yaWVudGF0aW9uKG9wdGlvbnMub3JpZW50YXRpb24pICtcclxuICAgICAgICAgICAgICAgIChhbmltYXRlID8gKFwiIFwiICsgX19QbGF0ICsgXCJhbmltYXRlZFwiKSA6ICcnKSk7XHJcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhzY3JvbGxFbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgc2Nyb2xsRWxlbWVudCA9IHRoaXMuX2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2Nyb2xsRWxlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHV0aWxzLmlzTm9kZShzY3JvbGxFbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2Nyb2xsQ29udGFpbmVyID0gc2Nyb2xsRWxlbWVudDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmFkZENsYXNzKGVsZW1lbnQsIF9fUGxhdCArIFwibm8tc2Nyb2xsZXJcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc1N0cmluZyhpdGVtVGVtcGxhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoXCJObyBpdGVtIHRlbXBsYXRlIG9yIGl0ZW0gdGVtcGxhdGUgc2VsZWN0b3Igc3BlY2lmaWVkIGZvciBcIiArIHRoaXMudHlwZSArIFwiLlwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbm9ybWFsaXplZEl0ZW1UZW1wbGF0ZSA9IHRoaXMuX25vcm1hbGl6ZVRlbXBsYXRlTmFtZShpdGVtVGVtcGxhdGUpLCBoZWFkZXJUZW1wbGF0ZSA9IG9wdGlvbnMuaGVhZGVyVGVtcGxhdGUsIG5vcm1hbGl6ZWRHcm91cFRlbXBsYXRlID0gaXNTdHJpbmcoaGVhZGVyVGVtcGxhdGUpID8gdGhpcy5fbm9ybWFsaXplVGVtcGxhdGVOYW1lKGhlYWRlclRlbXBsYXRlKSA6IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlSW5uZXJUZW1wbGF0ZShub3JtYWxpemVkSXRlbVRlbXBsYXRlLCBub3JtYWxpemVkR3JvdXBUZW1wbGF0ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RldGVybWluZVRlbXBsYXRlcyhpdGVtVGVtcGxhdGUsIG5vcm1hbGl6ZWRJdGVtVGVtcGxhdGUsIG5vcm1hbGl6ZWRHcm91cFRlbXBsYXRlKTtcclxuICAgICAgICAgICAgdGhpcy5fZGVmYXVsdEdyb3VwID0ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogbnVsbCxcclxuICAgICAgICAgICAgICAgIGNvbnRyb2w6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBpdGVtQ29udGFpbmVyOiB0aGlzLl9jb250YWluZXIsXHJcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgaW5kZXg6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBpdGVtQ291bnQ6IDAsXHJcbiAgICAgICAgICAgICAgICBhZGRRdWV1ZTogW10sXHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb25RdWV1ZTogW11cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGlzUmVmcmVzaGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcobG9hZGluZykpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhyZXF1ZXN0SXRlbXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGV0ZXJtaW5lTG9hZGluZyhyZXF1ZXN0SXRlbXMsIG9wdGlvbnMuaW5maW5pdGVQcm9ncmVzcyAhPT0gZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKHRoaXMudHlwZSArIFwiIGxvYWRpbmcgdHlwZSBzcGVjaWZpZWQgYXMgXFxcIlwiICsgbG9hZGluZyArIFwiXFxcIiBidXQgbm8gb3B0aW9uIHNwZWNpZnlpbmcgYW4gb25JdGVtc1JlcXVlc3RlZCBoYW5kbGVyLlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcocmVmcmVzaCkpIHtcclxuICAgICAgICAgICAgICAgIGlzUmVmcmVzaGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplUmVmcmVzaChyZWZyZXNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplVHJhY2tpbmcobG9hZGluZyA9PT0gJ2luY3JlbWVudGFsJywgaXNSZWZyZXNoaW5nKTtcclxuICAgICAgICAgICAgaWYgKCF1dGlscy5pc0FycmF5KHRoaXMuY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdXRpbHMuaXNOdWxsKHRoaXMuY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcodGhpcy50eXBlICsgXCIncyBjb250ZXh0IG11c3QgYmUgYW4gQXJyYXkuXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3NldEFsaWFzZXMoKTtcclxuICAgICAgICAgICAgdGhpcy5fc2V0Q29udGFpbmVySGVpZ2h0KCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldExpc3RlbmVyKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGFueSBwb3RlbnRpYWxseSBoZWxkIG1lbW9yeS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHZpc2liaWxpdHlSZW1vdmVycyA9IHRoaXMuX3Zpc2liaWxpdHlSZW1vdmVMaXN0ZW5lcnM7XHJcbiAgICAgICAgICAgIHdoaWxlICh2aXNpYmlsaXR5UmVtb3ZlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eVJlbW92ZXJzLnBvcCgpKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlU2Nyb2xsKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnV0aWxzLmlzRnVuY3Rpb24odGhpcy5fX3JlamVjdEZuKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3JlamVjdEZuKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fcmVzb2x2ZUZuID0gdGhpcy5fX3JlamVjdEZuID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQmxvdyBvdXQgdGhlIERPTSBzdGFydGluZyBhdCB0aGUgaW5kZXgsIGRldGVybWluZSBob3cgdG8gcmVuZGVyLCBhbmQgcmVuZGVyIHRoZSBjb3VudCBhY2NvcmRpbmdseS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXg/IFRoZSBzdGFydGluZyBpbmRleCB0byByZW5kZXIuIElmIG5vdCBzcGVjaWZpZWQsIGl0IHdpbGwgc3RhcnQgYXQgY3VycmVudENvdW50LlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudD8gVGhlIG51bWJlciBvZiBpdGVtcyB0byByZW5kZXIuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB3aG9sZSBjb250ZXh0XHJcbiAgICAgICAgICogZnJvbSB0aGUgc3BlY2lmaWVkIGluZGV4IHdpbGwgYmUgcmVuZGVyZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0dWkuSUdyb3VwSGFzaH0gZ3JvdXA/IFRoZSBncm91cCB3ZSdyZSByZW5kZXJpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChpbmRleCwgY291bnQsIGdyb3VwKSB7XHJcbiAgICAgICAgICAgIHZhciBpc051bWJlciA9IHRoaXMudXRpbHMuaXNOdW1iZXIsIG9wR3JvdXAgPSBncm91cCB8fCB0aGlzLl9kZWZhdWx0R3JvdXAsIGNvbnRyb2wgPSBvcEdyb3VwLmNvbnRyb2wsIGNvbnRleHQgPSB0aGlzID09PSBjb250cm9sID8gdGhpcy5jb250ZXh0IDogY29udHJvbC5jb250ZXh0Lml0ZW1zO1xyXG4gICAgICAgICAgICBpZiAoIWlzTnVtYmVyKGluZGV4KSkge1xyXG4gICAgICAgICAgICAgICAgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtYXhDb3VudCA9IGNvbnRleHQubGVuZ3RoIC0gaW5kZXgsIGl0ZW1Db3VudCA9IGlzTnVtYmVyKGNvdW50KSAmJiBtYXhDb3VudCA+PSBjb3VudCA/IGNvdW50IDogbWF4Q291bnQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUl0ZW1zKGluZGV4LCBpdGVtQ291bnQsIG9wR3JvdXAsIDApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQmxvdyBvdXQgYWxsIHRoZSBET00sIGRldGVybWluZSBob3cgdG8gcmVuZGVyLCBhbmQgcmVuZGVyIGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdHVpLklHcm91cEhhc2h9IGdyb3VwPyBUaGUgZ3JvdXAgd2UncmUgcmVyZW5kZXJpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLnJlcmVuZGVyID0gZnVuY3Rpb24gKGdyb3VwKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKDAsIG51bGwsIGdyb3VwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlLXN5bmNzIHRoZSBMaXN0dmlldyBjaGlsZCBpdGVtcyBhbmQgRE9NIHdpdGggdGhlIG5ldyBpdGVtc1xyXG4gICAgICAgICAqIGFycmF5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBncm91cE5hbWUgVGhlIGdyb3VwIG5hbWUgb2YgdGhlIGN1cnJlbnRseSBjaGFuZ2luZyBBcnJheS5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gbmV3VmFsdWU/IFRoZSBuZXcgY2hpbGQgYXJyYXkgb2YgaXRlbXNcclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2xkVmFsdWU/IFRoZSBvbGQgY2hpbGQgYXJyYXkgb2YgaXRlbXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX2NoaWxkQ29udGV4dENoYW5nZWQgPSBmdW5jdGlvbiAoZ3JvdXBOYW1lLCBuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZXhlY3V0ZUNoaWxkRXZlbnQoZ3JvdXBOYW1lLCBbe1xyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogbmV3VmFsdWUgfHwgW10sXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3NwbGljZSdcclxuICAgICAgICAgICAgICAgIH1dKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgYSBsaXN0ZW5lciBmb3IgdGhlIGNoYW5nZXMgdG8gdGhlIGFycmF5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fc2V0TGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fX2xpc3RlbmVyU2V0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmVBcnJheSh0aGlzLl9leGVjdXRlRXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2xpc3RlbmVyU2V0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgYWxpYXMgdG9rZW5zIHRvIHVzZSBmb3IgYWxsIHRoZSBpdGVtcyBpbiB0aGUgTGlzdHZpZXcgY29udGV4dCBhcnJheS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX3NldEFsaWFzZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhbGlhc2VzID0gdGhpcy5vcHRpb25zLnZhbHVlLmFsaWFzZXMsIHV0aWxzID0gdGhpcy51dGlscztcclxuICAgICAgICAgICAgaWYgKCF1dGlscy5pc09iamVjdChhbGlhc2VzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBfYWxpYXNlcyA9IHRoaXMuX2FsaWFzZXMsIGlzU3RyaW5nID0gdXRpbHMuaXNTdHJpbmcsIGtleXMgPSBPYmplY3Qua2V5cyhfYWxpYXNlcyksIGxlbmd0aCA9IGtleXMubGVuZ3RoLCB2YWx1ZTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBhbGlhc2VzW2tleXNbaV1dO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9hbGlhc2VzW2tleXNbaV1dID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERldGVybWluZSB0aGUgcHJvcGVyIGl0ZW0gdGVtcGxhdGUgb3IgbWV0aG9kIG9mIGl0ZW0gdGVtcGxhdGUgc2VsZWN0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpdGVtVGVtcGxhdGUgVGhlIHByZS1ub3JtYWxpemVkIHByb3BlcnR5IGZvciBpbmRpY2F0aW5nIGVpdGhlciB0aGUgaXRlbSB0ZW1wbGF0ZSBvciB0aGVcclxuICAgICAgICAgKiBpdGVtIHRlbXBsYXRlIHNlbGVjdG9yLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpdGVtVGVtcGxhdGVLZXkgVGhlIG5vcm1hbGl6ZWQgcHJvcGVydHkgZm9yIGluZGljYXRpbmcgdGhlIGl0ZW0gdGVtcGxhdGUuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGhlYWRlclRlbXBsYXRlIFRoZSBwcm9wZXJ0eSBmb3IgaW5kaWNhdGluZyB0aGUgZ3JvdXAgaGVhZGVyIHRlbXBsYXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fZGV0ZXJtaW5lVGVtcGxhdGVzID0gZnVuY3Rpb24gKGl0ZW1UZW1wbGF0ZSwgaXRlbVRlbXBsYXRlS2V5LCBoZWFkZXJUZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICB2YXIgdXRpbHMgPSB0aGlzLnV0aWxzLCBiaW5kYWJsZVRlbXBsYXRlcyA9IHRoaXMuYmluZGFibGVUZW1wbGF0ZXMsIHRlbXBsYXRlcyA9IHRoaXMuX3RlbXBsYXRlcywgdGVtcGxhdGU7XHJcbiAgICAgICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhoZWFkZXJUZW1wbGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzR3JvdXBlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsIF9fUGxhdCArIFwiZ3JvdXBlZFwiKTtcclxuICAgICAgICAgICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGVzW2hlYWRlclRlbXBsYXRlXTtcclxuICAgICAgICAgICAgICAgIGlmICh1dGlscy5pc05vZGUodGVtcGxhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGVhZGVyVGVtcGxhdGUgPSBoZWFkZXJUZW1wbGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJpbmRhYmxlVGVtcGxhdGVzLmFkZChoZWFkZXJUZW1wbGF0ZSwgdGVtcGxhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0ZW1wbGF0ZXNbaGVhZGVyVGVtcGxhdGVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKF9fTGlzdHZpZXcgKyBcIiBncm91cCBoZWFkZXIgdGVtcGxhdGUgXFxcIlwiICsgaGVhZGVyVGVtcGxhdGUgKyBcIlxcXCIgd2FzIG5vdCBhIHRlbXBsYXRlIGRlZmluZWQgaW4gdGhlIERPTS5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFkZXJUZW1wbGF0ZVByb21pc2UgPSB0aGlzLl9jcmVhdGVHcm91cFRlbXBsYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZXNbaXRlbVRlbXBsYXRlS2V5XTtcclxuICAgICAgICAgICAgaWYgKHV0aWxzLmlzTm9kZSh0ZW1wbGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1UZW1wbGF0ZSA9IGl0ZW1UZW1wbGF0ZUtleTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmluZGFibGVUZW1wbGF0ZXMuYWRkKGl0ZW1UZW1wbGF0ZUtleSwgdGVtcGxhdGUpO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRlbXBsYXRlc1tpdGVtVGVtcGxhdGVLZXldO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjb250cm9sUHJvcGVydHkgPSB0aGlzLmZpbmRQcm9wZXJ0eShpdGVtVGVtcGxhdGUpIHx8IHt9O1xyXG4gICAgICAgICAgICBpZiAoIXV0aWxzLmlzRnVuY3Rpb24oY29udHJvbFByb3BlcnR5LnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKF9fTGlzdHZpZXcgKyBcIiBpdGVtIHRlbXBsYXRlIFxcXCJcIiArIGl0ZW1UZW1wbGF0ZSArIFwiXFxcIiB3YXMgbmVpdGhlciBhIHRlbXBsYXRlIGRlZmluZWQgaW4gdGhlIERPTSBub3IgYSB0ZW1wbGF0ZSBzZWxlY3RvciBmdW5jdGlvbiBpbiBpdHMgY29udHJvbCBoaWVhcmNoeS5cIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGVTZWxlY3RvciA9IGNvbnRyb2xQcm9wZXJ0eS52YWx1ZS5iaW5kKGNvbnRyb2xQcm9wZXJ0eS5jb250cm9sKTtcclxuICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGVTZWxlY3RvcktleXMgPSB7fTtcclxuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0ZW1wbGF0ZXMpLCBrZXk7XHJcbiAgICAgICAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGtleSA9IGtleXMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBiaW5kYWJsZVRlbXBsYXRlcy5hZGQoa2V5LCB0ZW1wbGF0ZXNba2V5XSk7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGVtcGxhdGVzW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdCB0aGUgZ3JvdXAgdGVtcGxhdGUgYW5kIGFkZCBpdCB0byBiaW5kYWJsZSB0ZW1wbGF0ZXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9jcmVhdGVHcm91cFRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgX2RvY3VtZW50ID0gdGhpcy5fZG9jdW1lbnQsIGJpbmRhYmxlVGVtcGxhdGVzID0gdGhpcy5iaW5kYWJsZVRlbXBsYXRlcywgaGVhZGVyVGVtcGxhdGUgPSB0aGlzLl9oZWFkZXJUZW1wbGF0ZSwgbGlzdHZpZXdHcm91cCA9IF9fTGlzdHZpZXcgKyBcIi1ncm91cFwiLCBncm91cCA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgaXRlbUNvbnRhaW5lciA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgaGVhZGVyUHJvbWlzZTtcclxuICAgICAgICAgICAgZ3JvdXAuY2xhc3NOYW1lID0gbGlzdHZpZXdHcm91cDtcclxuICAgICAgICAgICAgaXRlbUNvbnRhaW5lci5jbGFzc05hbWUgPSBfX0xpc3R2aWV3ICsgXCItaXRlbXNcIjtcclxuICAgICAgICAgICAgaWYgKHRoaXMudXRpbHMuaXNTdHJpbmcoaGVhZGVyVGVtcGxhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICBoZWFkZXJQcm9taXNlID0gYmluZGFibGVUZW1wbGF0ZXMudGVtcGxhdGVzW2hlYWRlclRlbXBsYXRlXS50aGVuKGZ1bmN0aW9uIChoZWFkZXJUZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLmluc2VydEJlZm9yZShoZWFkZXJUZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSksIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UucmVzb2x2ZShoZWFkZXJQcm9taXNlKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGdyb3VwLmluc2VydEJlZm9yZShpdGVtQ29udGFpbmVyLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIGJpbmRhYmxlVGVtcGxhdGVzLmFkZChsaXN0dmlld0dyb3VwLCBncm91cCk7XHJcbiAgICAgICAgICAgIH0pLnRoZW4obnVsbCwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmRlYnVnKF90aGlzLnR5cGUgKyBcIiBlcnJvcjogXCIgKyBlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBuZXcgZ3JvdXBzIHRvIHRoZSBjb250cm9sJ3MgZWxlbWVudCB3aGVuIGl0ZW1zIGFyZSBhZGRlZCB0b1xyXG4gICAgICAgICAqIHRoZSBjb250ZXh0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJPZkdyb3VwcyBUaGUgbnVtYmVyIG9mIGdyb3VwcyB0byBhZGQuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBwb2ludCBpbiB0aGUgYXJyYXkgdG8gc3RhcnQgYWRkaW5nIGdyb3Vwcy5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5pbWF0ZUl0ZW1zIFRoZSBudW1iZXIgb2YgZ3JvdXBzIHRvIGFuaW1hdGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9hZGRHcm91cHMgPSBmdW5jdGlvbiAobnVtYmVyT2ZHcm91cHMsIGluZGV4LCBhbmltYXRlSXRlbXMpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGluaXRpYWxJbmRleCA9IGluZGV4LCBtYXggPSArKGluZGV4ICsgbnVtYmVyT2ZHcm91cHMpLCBwcm9taXNlcyA9IFtdO1xyXG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBtYXgpIHtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fYmluZEdyb3VwKGluZGV4KyspKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKGZyYWdtZW50cykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGZyYWdtZW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FkZEdyb3VwKGkgKyBpbml0aWFsSW5kZXgsIGZyYWdtZW50c1tpXSwgaSA8IGFuaW1hdGVJdGVtcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBuZXcgZ3JvdXAgdG8gdGhlIGNvbnRyb2wncyBlbGVtZW50LlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGdyb3VwLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gZnJhZ21lbnQgVGhlIGdyb3VwIGZyYWdtZW50IHRvIGFkZCB0byB0aGUgRE9NLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYW5pbWF0ZSBXaGV0aGVyIG9yIG5vdCB0byBhbmltYXRlIHRoZSBncm91cC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX2FkZEdyb3VwID0gZnVuY3Rpb24gKGluZGV4LCBmcmFnbWVudCwgYW5pbWF0ZSkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgdXRpbHMgPSB0aGlzLnV0aWxzLCBjb250ZXh0ID0gdGhpcy5jb250ZXh0LCBncm91cHMgPSB0aGlzLl9ncm91cHMgfHwgKHRoaXMuX2dyb3VwcyA9IHt9KSwgZ3JvdXAgPSBjb250ZXh0W2luZGV4XSwgbmFtZSA9IGdyb3VwLmdyb3VwLCBncm91cENvbnRhaW5lciA9IGZyYWdtZW50LmNoaWxkTm9kZXNbMV0sIGl0ZW1Db250YWluZXIgPSBncm91cENvbnRhaW5lci5sYXN0RWxlbWVudENoaWxkLCBjb250cm9sID0gdGhpcy5jb250cm9sc1tpbmRleF0sIGdyb3VwSGFzaCA9IGdyb3Vwc1tuYW1lXSA9IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXHJcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBncm91cENvbnRhaW5lcixcclxuICAgICAgICAgICAgICAgIGl0ZW1Db250YWluZXI6IGl0ZW1Db250YWluZXIsXHJcbiAgICAgICAgICAgICAgICBjb250cm9sOiBjb250cm9sLFxyXG4gICAgICAgICAgICAgICAgaXRlbUNvdW50OiAwLFxyXG4gICAgICAgICAgICAgICAgYWRkUXVldWU6IFtdLFxyXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uUXVldWU6IFtdXHJcbiAgICAgICAgICAgIH0sIGl0ZW1zID0gJ2l0ZW1zJywgcmVtb3ZlQXJyYXlMaXN0ZW5lciwgcmVtb3ZlTXV0YXRpb25MaXN0ZW5lcjtcclxuICAgICAgICAgICAgY29udHJvbC5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwoX3RoaXMpO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGdyb3Vwc1tuYW1lXTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29udHJvbC5vYnNlcnZlKGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdOYW1lID0gbmV3VmFsdWUuZ3JvdXA7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3TmFtZSA9PT0gbmFtZSB8fCAhdXRpbHMuaXNPYmplY3QobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBncm91cHNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgZ3JvdXBzW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgdGVtcC5uYW1lID0gbmV3TmFtZTtcclxuICAgICAgICAgICAgICAgIGdyb3Vwc1tuZXdOYW1lXSA9IHRlbXA7XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gbmV3TmFtZTtcclxuICAgICAgICAgICAgICAgIHJlbW92ZUFycmF5TGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgIHJlbW92ZU11dGF0aW9uTGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgIHJlbW92ZUFycmF5TGlzdGVuZXIgPSBjb250cm9sLm9ic2VydmUoX3RoaXMuX2NoaWxkQ29udGV4dENoYW5nZWQuYmluZChfdGhpcywgbmFtZSksIGl0ZW1zKTtcclxuICAgICAgICAgICAgICAgIHJlbW92ZU11dGF0aW9uTGlzdGVuZXIgPSBjb250cm9sLm9ic2VydmVBcnJheShfdGhpcy5fZXhlY3V0ZUNoaWxkRXZlbnQuYmluZChfdGhpcywgbmFtZSksIGl0ZW1zKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJlbW92ZUFycmF5TGlzdGVuZXIgPSBjb250cm9sLm9ic2VydmUodGhpcy5fY2hpbGRDb250ZXh0Q2hhbmdlZC5iaW5kKHRoaXMsIG5hbWUpLCBpdGVtcyk7XHJcbiAgICAgICAgICAgIHJlbW92ZU11dGF0aW9uTGlzdGVuZXIgPSBjb250cm9sLm9ic2VydmVBcnJheSh0aGlzLl9leGVjdXRlQ2hpbGRFdmVudC5iaW5kKHRoaXMsIG5hbWUpLCBpdGVtcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUl0ZW1zKDAsIChncm91cC5pdGVtcyB8fCBbXSkubGVuZ3RoLCBncm91cEhhc2gsIDApO1xyXG4gICAgICAgICAgICBpZiAoYW5pbWF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvblF1ZXVlXzEgPSB0aGlzLl9kZWZhdWx0R3JvdXAuYW5pbWF0aW9uUXVldWUsIGFuaW1hdGlvbl8xID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogdGhpcy5fYW5pbWF0b3IuZW50ZXIoZnJhZ21lbnQsIF9fRW50ZXIsIHRoaXMuX2NvbnRhaW5lcikudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGFuaW1hdGlvblF1ZXVlXzEuaW5kZXhPZihhbmltYXRpb25fMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25RdWV1ZV8xLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKF90aGlzLl9zZXRHcm91cENvbnRhaW5lclBhZGRpbmcuYmluZChfdGhpcywgZ3JvdXBDb250YWluZXIpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICBvcDogbnVsbFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvblF1ZXVlXzEucHVzaChhbmltYXRpb25fMSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLmluc2VydEJlZm9yZShmcmFnbWVudCwgbnVsbCk7XHJcbiAgICAgICAgICAgIHV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9zZXRHcm91cENvbnRhaW5lclBhZGRpbmcuYmluZCh0aGlzLCBncm91cENvbnRhaW5lcikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSGFuZGxlIGJpbmRpbmcgb2YgYSBzaW5nbGUgZ3JvdXAuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgZ3JvdXAgaW4gY29udGV4dC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX2JpbmRHcm91cCA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaW5kYWJsZVRlbXBsYXRlcy5iaW5kKF9fTGlzdHZpZXcgKyBcIi1ncm91cFwiLCBpbmRleCwgdGhpcy5fZ2V0QWxpYXNlcyh0aGlzLmNvbnRleHQsIGluZGV4KSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgc3BlY2lmaWVkIG51bWJlciBvZiBpdGVtcy5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IHRvIHN0YXJ0IGNyZWF0aW5nIGl0ZW1zLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBUaGUgbnVtYmVyIG9mIGl0ZW1zIHRvIGNyZWF0ZS5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXR1aS5JR3JvdXBIYXNofSBncm91cCBUaGUgZ3JvdXAgZm9yIHdoaWNoIHdlJ3JlIGNyZWF0aW5nIGl0ZW1zLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmltYXRlSXRlbXMgVGhlIG51bWJlciBvZiBpdGVtcyB0byBhbmltYXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fY3JlYXRlSXRlbXMgPSBmdW5jdGlvbiAoaW5kZXgsIGNvdW50LCBncm91cCwgYW5pbWF0ZUl0ZW1zKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciB1dGlscyA9IHRoaXMudXRpbHMsIG9wR3JvdXAgPSBncm91cCB8fCB0aGlzLl9kZWZhdWx0R3JvdXAsIGNvbnRyb2wgPSBvcEdyb3VwLmNvbnRyb2wsIGlzVmVydGljYWwgPSB0aGlzLl9pc1ZlcnRpY2FsLCBpc0NvbnRyb2wgPSB0aGlzID09PSBjb250cm9sO1xyXG4gICAgICAgICAgICBpZiAoaXNDb250cm9sKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNHcm91cGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGVhZGVyVGVtcGxhdGVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWRkR3JvdXBzKGNvdW50LCBpbmRleCwgYW5pbWF0ZUl0ZW1zKTtcclxuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKG51bGwsIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmRlYnVnKF90aGlzLnR5cGUgKyBcIiBlcnJvcjogXCIgKyBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhZGRRdWV1ZSA9IG9wR3JvdXAuYWRkUXVldWUsIGFkZFByb21pc2UsIHBvc3RMb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4T2YgPSBhZGRRdWV1ZS5pbmRleE9mKGFkZFByb21pc2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4T2YgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkUXVldWUuc3BsaWNlKGluZGV4T2YsIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzQ29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9wR3JvdXAuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoX19IaWRlKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1ZlcnRpY2FsIHx8IGlzQ29udHJvbCB8fCAhX3RoaXMuX2lzR3JvdXBlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHNldCB3aWR0aCBmb3IgZmxleGJveCBjb250YWluZXIgXHJcbiAgICAgICAgICAgICAgICB1dGlscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3RoaXMuX3NldEdyb3VwQ29udGFpbmVyV2lkdGguYmluZChfdGhpcywgb3BHcm91cC5pdGVtQ29udGFpbmVyKSk7XHJcbiAgICAgICAgICAgIH0sIG9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuZGVidWcoX3RoaXMudHlwZSArIFwiIGVycm9yOiBcIiArICh1dGlscy5pc1N0cmluZyhlcnJvci5tZXNzYWdlKSA/IGVycm9yLm1lc3NhZ2UgOiBlcnJvcikpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbih0aGlzLl90ZW1wbGF0ZVNlbGVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XHJcbiAgICAgICAgICAgICAgICBvcEdyb3VwLml0ZW1Db3VudCArPSBjb3VudDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSwgKytpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fcmVuZGVyVXNpbmdGdW5jdGlvbihpbmRleCwgb3BHcm91cCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1zTG9hZGVkID0gdGhpcy5pdGVtc0xvYWRlZCA9IHRoaXMuX1Byb21pc2UuYWxsKHByb21pc2VzKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChub2Rlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBub2Rlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGxlbmd0aDsgKytpaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYXBwZW5kUmVuZGVyZWRJdGVtKG5vZGVzW2lpXSwgb3BHcm91cCwgaWkgPCBhbmltYXRlSXRlbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pLnRoZW4ocG9zdExvYWQsIG9uRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgYWRkUXVldWUucHVzaChpdGVtc0xvYWRlZCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuX2l0ZW1UZW1wbGF0ZTtcclxuICAgICAgICAgICAgaWYgKHV0aWxzLmlzVW5kZWZpbmVkKHRoaXMuYmluZGFibGVUZW1wbGF0ZXMudGVtcGxhdGVzW2tleV0pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZGlzcG9zZUZyb21JbmRleChpbmRleCwgb3BHcm91cCk7XHJcbiAgICAgICAgICAgIG9wR3JvdXAuaXRlbUNvdW50ICs9IGNvdW50O1xyXG4gICAgICAgICAgICBhZGRQcm9taXNlID0gdGhpcy5fYWRkSXRlbXMoaW5kZXgsIGNvdW50LCBvcEdyb3VwLCBhbmltYXRlSXRlbXMpLnRoZW4ocG9zdExvYWQsIG9uRXJyb3IpO1xyXG4gICAgICAgICAgICBhZGRRdWV1ZS5wdXNoKGFkZFByb21pc2UpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBuZXcgaXRlbXMgdG8gdGhlIGNvbnRyb2wncyBlbGVtZW50IHdoZW4gaXRlbXMgYXJlIGFkZGVkIHRvXHJcbiAgICAgICAgICogdGhlIGFycmF5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgcG9pbnQgaW4gdGhlIGFycmF5IHRvIHN0YXJ0IGFkZGluZyBpdGVtcy5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyT2ZJdGVtcyBUaGUgbnVtYmVyIG9mIGl0ZW1zIHRvIGFkZC5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXR1aS5JR3JvdXBIYXNofSBncm91cCBUaGUgZ3JvdXAgdGhhdCB3ZSdyZSBwZXJmb3JtaW5nIHRoaXMgb3BlcmF0aW9uIG9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmltYXRlSXRlbXMgVGhlIG51bWJlciBvZiBpdGVtcyB0byBhbmltYXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fYWRkSXRlbXMgPSBmdW5jdGlvbiAoaW5kZXgsIG51bWJlck9mSXRlbXMsIGdyb3VwLCBhbmltYXRlSXRlbXMpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIG9wR3JvdXAgPSBncm91cCB8fCB0aGlzLl9kZWZhdWx0R3JvdXAsIGNvbnRyb2wgPSBvcEdyb3VwLmNvbnRyb2wsIGNvbnRhaW5lciA9IG9wR3JvdXAuaXRlbUNvbnRhaW5lciwgbWF4ID0gKyhpbmRleCArIG51bWJlck9mSXRlbXMpLCBwcm9taXNlcyA9IFtdLCBpdGVtVGVtcGxhdGUgPSB0aGlzLl9pdGVtVGVtcGxhdGUsIGJpbmRhYmxlVGVtcGxhdGVzID0gY29udHJvbC5iaW5kYWJsZVRlbXBsYXRlcywgaW5pdGlhbEluZGV4ID0gaW5kZXgsIGlkZW50aWZpZXIsIGNvbnRleHQ7XHJcbiAgICAgICAgICAgIGlmICh0aGlzID09PSBjb250cm9sKSB7XHJcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyID0gJyc7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWRlbnRpZmllciA9ICdpdGVtcy4nO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRyb2wuY29udGV4dC5pdGVtcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBtYXgpIHtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goYmluZGFibGVUZW1wbGF0ZXMuYmluZChpdGVtVGVtcGxhdGUsIGlkZW50aWZpZXIgKyBpbmRleCwgdGhpcy5fZ2V0QWxpYXNlcyhjb250ZXh0LCBpbmRleCsrKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1zTG9hZGVkID0gdGhpcy5fUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKHRlbXBsYXRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRlSXRlbXMgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGhfMiA9IHRlbXBsYXRlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoXzI7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBhbmltYXRlSXRlbXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYXBwZW5kQW5pbWF0ZWRJdGVtKHRlbXBsYXRlc1tpXSwgb3BHcm91cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKHRlbXBsYXRlc1tpXSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hcHBlbmRJdGVtcyh0ZW1wbGF0ZXMsIGNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl91cGRhdGVSZXNvdXJjZShpbml0aWFsSW5kZXggLSAxLCBjb250cm9sKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMudXRpbHMuaXNGdW5jdGlvbihfdGhpcy5fX3Jlc29sdmVGbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19yZXNvbHZlRm4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19yZXNvbHZlRm4gPSBfdGhpcy5fX3JlamVjdEZuID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy51dGlscy5wb3N0cG9uZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuZGVidWcoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNMb2FkZWQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW5kZXIgaXRlbXMgdXNpbmcgYSBkZWZpbmVkIHJlbmRlciBmdW5jdGlvbiBzdGFydGluZyBhdCBhIGdpdmVuIGluZGV4IGFuZCBjb250aW51aW5nXHJcbiAgICAgICAgICogdGhyb3VnaCBmb3IgYSBzZXQgbnVtYmVyIG9mIGl0ZW1zLiBJZiB1bmRlZmluZWQgb3IgbnVsbCBpcyByZXR1cm5lZCBmcm9tIHRoZSBmdW5jdGlvbixcclxuICAgICAgICAgKiByZW5kZXJpbmcgd2lsbCBzdG9wLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgc3RhcnRpbmcgaW5kZXggdG8gcmVuZGVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdHVpLklHcm91cEhhc2h9IGdyb3VwPyBUaGUgZ3JvdXAgdGhhdCB3ZSdyZSBwZXJmb3JtaW5nIHRoaXMgb3BlcmF0aW9uIG9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fcmVuZGVyVXNpbmdGdW5jdGlvbiA9IGZ1bmN0aW9uIChpbmRleCwgZ3JvdXApIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIF9Qcm9taXNlID0gdGhpcy5fUHJvbWlzZSwgdXRpbHMgPSB0aGlzLnV0aWxzLCBvcEdyb3VwID0gZ3JvdXAgfHwgdGhpcy5fZGVmYXVsdEdyb3VwLCBjb250cm9sID0gb3BHcm91cC5jb250cm9sLCBpZGVudGlmaWVyLCBjb250ZXh0LCBncm91cE5hbWU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzID09PSBjb250cm9sKSB7XHJcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWRlbnRpZmllciA9IFwiaXRlbXMuXCIgKyBpbmRleDtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBjb250cm9sLmNvbnRleHQuaXRlbXM7XHJcbiAgICAgICAgICAgICAgICBncm91cE5hbWUgPSBvcEdyb3VwLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF9Qcm9taXNlLnJlc29sdmUodGhpcy5fdGVtcGxhdGVTZWxlY3RvclByb21pc2UpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl90ZW1wbGF0ZVNlbGVjdG9yUHJvbWlzZSA9IF9Qcm9taXNlLnJlc29sdmUoX3RoaXMuX3RlbXBsYXRlU2VsZWN0b3IoY29udGV4dFtpbmRleF0sIGluZGV4LCBncm91cE5hbWUpKTtcclxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoc2VsZWN0ZWRUZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJpbmRhYmxlVGVtcGxhdGVzID0gY29udHJvbC5iaW5kYWJsZVRlbXBsYXRlcywgdGVtcGxhdGVzID0gYmluZGFibGVUZW1wbGF0ZXMudGVtcGxhdGVzLCBjb250cm9scyA9IGNvbnRyb2wuY29udHJvbHMsIGtleSA9IF90aGlzLl9ub3JtYWxpemVUZW1wbGF0ZU5hbWUoc2VsZWN0ZWRUZW1wbGF0ZSksIG5hbWUgPSBvcEdyb3VwLm5hbWUsIHRlbXBsYXRlS2V5cyA9IF90aGlzLl90ZW1wbGF0ZVNlbGVjdG9yS2V5c1tuYW1lXSwgY29udHJvbEV4aXN0cyA9IGluZGV4IDwgY29udHJvbHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKHV0aWxzLmlzVW5kZWZpbmVkKHRlbXBsYXRlS2V5cykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZUtleXMgPSBfdGhpcy5fdGVtcGxhdGVTZWxlY3RvcktleXNbbmFtZV0gPSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQodGVtcGxhdGVzW2tleV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xFeGlzdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gdGVtcGxhdGVLZXlzW2luZGV4XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlS2V5c1tpbmRleF0gPSBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiaW5kYWJsZVRlbXBsYXRlcy5yZXBsYWNlKGluZGV4LCBrZXksIGlkZW50aWZpZXIsIF90aGlzLl9nZXRBbGlhc2VzKGNvbnRleHQsIGluZGV4KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlS2V5c1tpbmRleF0gPSBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpbmRhYmxlVGVtcGxhdGVzLmJpbmQoa2V5LCBpZGVudGlmaWVyLCBfdGhpcy5fZ2V0QWxpYXNlcyhjb250ZXh0LCBpbmRleCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5kZWJ1ZyhfdGhpcy50eXBlICsgXCIgdGVtcGxhdGUgXFxcIlwiICsgc2VsZWN0ZWRUZW1wbGF0ZSArIFwiXFxcIiB3YXMgbm90IGZvdW5kLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udHJvbEV4aXN0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fVGVtcGxhdGVDb250cm9sRmFjdG9yeS5kaXNwb3NlKGNvbnRyb2xzW2luZGV4XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGVuZHMgdGhlIHJlbmRlcmVkIGl0ZW0gZnJvbSB0aGUgZGVmaW5lZCByZW5kZXIgZnVuY3Rpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IG5vZGUgVGhlIG5vZGUgdG8gcGxhY2UgaW50byB0aGUgaXRlbSBjb250YWluZXIgaWYgYXZhaWxhYmxlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdHVpLklHcm91cEhhc2h9IGdyb3VwPyBUaGUgZ3JvdXAgdGhhdCB3ZSdyZSBwZXJmb3JtaW5nIHRoaXMgb3BlcmF0aW9uIG9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYW5pbWF0ZT8gV2hldGhlciBvciBub3QgdG8gYW5pbWF0ZSB0aGUgbmV3IGl0ZW0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9hcHBlbmRSZW5kZXJlZEl0ZW0gPSBmdW5jdGlvbiAobm9kZSwgZ3JvdXAsIGFuaW1hdGUpIHtcclxuICAgICAgICAgICAgdmFyIHV0aWxzID0gdGhpcy51dGlscywgb3BHcm91cCA9IGdyb3VwIHx8IHRoaXMuX2RlZmF1bHRHcm91cDtcclxuICAgICAgICAgICAgaWYgKHV0aWxzLmlzTnVsbChub2RlKSB8fCB1dGlscy5pc0FycmF5KG5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYW5pbWF0ZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvblF1ZXVlXzIgPSBvcEdyb3VwLmFuaW1hdGlvblF1ZXVlLCBhbmltYXRpb25fMiA9IHtcclxuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb246IHRoaXMuX2FuaW1hdG9yLmVudGVyKG5vZGUsIF9fRW50ZXIsIG9wR3JvdXAuaXRlbUNvbnRhaW5lcikudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25JbmRleCA9IGFuaW1hdGlvblF1ZXVlXzIuaW5kZXhPZihhbmltYXRpb25fMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25JbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25RdWV1ZV8yLnNwbGljZShhbmltYXRpb25JbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgb3A6IG51bGxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb25RdWV1ZV8yLnB1c2goYW5pbWF0aW9uXzIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3BHcm91cC5pdGVtQ29udGFpbmVyLmluc2VydEJlZm9yZShub2RlLCBudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbih0aGlzLl9fcmVzb2x2ZUZuKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3Jlc29sdmVGbigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3Jlc29sdmVGbiA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIGNvbnRyb2wncyBjaGlsZHJlbiByZXNvdXJjZSBvYmplY3RzIHdoZW5cclxuICAgICAgICAgKiB0aGUgYXJyYXkgY2hhbmdlcy5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXg/IFRoZSBpbmRleCB0byBiZWdpbiB1cGRhdGluZy5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY291bnQ/IFRoZSBudW1iZXIgb2YgcmVzb3VyY2VzIHRvIHVwZGF0ZS5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVGVtcGxhdGVDb250cm9sfSBjb250cm9sIFRoZSBjb250cm9sIHdob3NlIHJlc291cmNlcyBhcmUgdG8gYmUgdXBkYXRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX3VwZGF0ZVJlc291cmNlID0gZnVuY3Rpb24gKGluZGV4LCBjb250cm9sKSB7XHJcbiAgICAgICAgICAgIHZhciBjb250cm9scyA9IGNvbnRyb2wuY29udHJvbHM7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gY29udHJvbHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udHJvbHNbaW5kZXhdLnJlc291cmNlcy5hZGQodGhpcy5fZ2V0QWxpYXNlcyh0aGlzID09PSBjb250cm9sID8gdGhpcy5jb250ZXh0IDogY29udHJvbC5jb250ZXh0Lml0ZW1zLCBpbmRleCkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIHJlc291cmNlIGFsaWFzIG9iamVjdCBmb3IgYW4gaXRlbSBpbiB0aGUgYXJyYXkuIFRoZVxyXG4gICAgICAgICAqIHJlc291cmNlIG9iamVjdCBjb250YWlucyBpbmRleDpudW1iZXIsIGV2ZW46Ym9vbGVhbiwgb2RkOmJvb2xlYW4sXHJcbiAgICAgICAgICogZmlyc3Q6Ym9vbGVhbiwgYW5kIGxhc3Q6Ym9vbGVhbi5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gY29udGV4dCBUaGUgY29udGV4dCB0byBnZXQgdGhlIGFsaWFzZXMgZm9yLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggdXNlZCB0byBjcmVhdGUgdGhlIHJlc291cmNlIGFsaWFzZXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9nZXRBbGlhc2VzID0gZnVuY3Rpb24gKGNvbnRleHQsIGluZGV4KSB7XHJcbiAgICAgICAgICAgIHZhciBpc0V2ZW4gPSAoaW5kZXggJiAxKSA9PT0gMCwgYWxpYXNlcyA9IHt9LCBfYWxpYXNlcyA9IHRoaXMuX2FsaWFzZXMsIHR5cGUgPSBfX0xJVEVSQUxfUkVTT1VSQ0U7XHJcbiAgICAgICAgICAgIGFsaWFzZXNbX2FsaWFzZXMuaW5kZXhdID0ge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGluZGV4LFxyXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBhbGlhc2VzW19hbGlhc2VzLmV2ZW5dID0ge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGlzRXZlbixcclxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgYWxpYXNlc1tfYWxpYXNlcy5vZGRdID0ge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6ICFpc0V2ZW4sXHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGFsaWFzZXNbX2FsaWFzZXMuZmlyc3RdID0ge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGluZGV4ID09PSAwLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBhbGlhc2VzW19hbGlhc2VzLmxhc3RdID0ge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGluZGV4ID09PSAoY29udGV4dC5sZW5ndGggLSAxKSxcclxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIGFsaWFzZXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGFuIEFycmF5IG9mIGl0ZW1zIHRvIHRoZSBlbGVtZW50IHdpdGhvdXQgYW5pbWF0aW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8Tm9kZT59IGl0ZW1zIFRoZSBBcnJheSBvZiBpdGVtcyB0byBhZGQuXHJcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXIgVEhlIGNvbnRhaW5lciB0byBhZGQgdGhlIGl0ZW1zIHRvLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fYXBwZW5kSXRlbXMgPSBmdW5jdGlvbiAoaXRlbXMsIGNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZHJlbihpdGVtcywgY29udGFpbmVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYW4gaXRlbSB0byB0aGUgY29udHJvbCdzIGVsZW1lbnQgYW5pbWF0aW5nIGl0cyBlbGVtZW50cy5cclxuICAgICAgICAgKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IGl0ZW0gVGhlIEhUTUwgZnJhZ21lbnQgcmVwcmVzZW50aW5nIGEgc2luZ2xlIGl0ZW0uXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0dWkuSUdyb3VwSGFzaH0gZ3JvdXAgVGhlIGdyb3VwIGl0ZW1zIGFyZSBiZWluZyBhZGRlZCB0by5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX2FwcGVuZEFuaW1hdGVkSXRlbSA9IGZ1bmN0aW9uIChpdGVtLCBncm91cCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMudXRpbHMuaXNOb2RlKGl0ZW0pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGFuaW1hdGlvblF1ZXVlID0gZ3JvdXAuYW5pbWF0aW9uUXVldWUsIGFuaW1hdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogdGhpcy5fYW5pbWF0b3IuZW50ZXIoaXRlbSwgX19FbnRlciwgZ3JvdXAuaXRlbUNvbnRhaW5lcikudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYW5pbWF0aW9uUXVldWUuaW5kZXhPZihhbmltYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25RdWV1ZS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICBvcDogbnVsbFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBhbmltYXRpb25RdWV1ZS5wdXNoKGFuaW1hdGlvbik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGl0ZW1zIGZyb20gdGhlIGNvbnRyb2wncyBlbGVtZW50LlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggdG8gc3RhcnQgZGlzcG9zaW5nIGZyb20uXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlck9mSXRlbXMgVGhlIG51bWJlciBvZiBpdGVtcyB0byByZW1vdmUuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0dWkuSUdyb3VwSGFzaH0gZ3JvdXAgVGhlIGdyb3VwIGZvciB3aGljaCB3ZSdyZSBkaXNwb3NpbmcgaXRlbXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9yZW1vdmVJdGVtcyA9IGZ1bmN0aW9uIChpbmRleCwgbnVtYmVyT2ZJdGVtcywgZ3JvdXApIHtcclxuICAgICAgICAgICAgdmFyIGRpc3Bvc2UgPSB0aGlzLl9UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5LmRpc3Bvc2UsIGNvbnRyb2wgPSBncm91cC5jb250cm9sLCBjb250cm9scyA9IGNvbnRyb2wuY29udHJvbHMsIGxhc3QgPSBpbmRleCArIG51bWJlck9mSXRlbXMsIGNvbnRyb2xEaXNwb3NlZCA9IGxhc3QgPiBpbmRleDtcclxuICAgICAgICAgICAgd2hpbGUgKGxhc3QtLSA+IGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBkaXNwb3NlKGNvbnRyb2xzW2xhc3RdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVSZXNvdXJjZShjb250cm9scy5sZW5ndGggLSAxLCBjb250cm9sKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMgPT09IGNvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjb250cm9scy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGdyb3VwLmVsZW1lbnQuc2V0QXR0cmlidXRlKF9fSGlkZSwgJycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRyb2xEaXNwb3NlZCAmJiB0aGlzLl9pc0dyb3VwZWQgJiYgIXRoaXMuX2lzVmVydGljYWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXRpbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3NldEdyb3VwQ29udGFpbmVyV2lkdGguYmluZCh0aGlzLCBncm91cC5pdGVtQ29udGFpbmVyKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERpc3Bvc2Ugb2YgdGhlIGNvbnRyb2xzIGFuZCBET00gc3RhcnRpbmcgYXQgYSBnaXZlbiBpbmRleC5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIHN0YXJ0aW5nIGluZGV4IHRvIGRpc3Bvc2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0dWkuSUdyb3VwSGFzaH0gZ3JvdXA/IFRoZSBncm91cCBmb3Igd2hpY2ggd2UncmUgZGlzcG9zaW5nIGl0ZW1zLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fZGlzcG9zZUZyb21JbmRleCA9IGZ1bmN0aW9uIChpbmRleCwgZ3JvdXApIHtcclxuICAgICAgICAgICAgdmFyIG9wR3JvdXAgPSBncm91cCB8fCB0aGlzLl9kZWZhdWx0R3JvdXAsIGNvbnRyb2wgPSBvcEdyb3VwLmNvbnRyb2wsIGNvbnRyb2xzID0gY29udHJvbC5jb250cm9scywgZGlzcG9zZSA9IHRoaXMuX1RlbXBsYXRlQ29udHJvbEZhY3RvcnkuZGlzcG9zZSwgbGFzdCA9IGNvbnRyb2xzLmxlbmd0aCwgY29udHJvbERpc3Bvc2VkID0gbGFzdCA+IGluZGV4O1xyXG4gICAgICAgICAgICB3aGlsZSAobGFzdC0tID4gaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGRpc3Bvc2UoY29udHJvbHNbbGFzdF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzID09PSBjb250cm9sKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29udHJvbHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBncm91cC5lbGVtZW50LnNldEF0dHJpYnV0ZShfX0hpZGUsICcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjb250cm9sRGlzcG9zZWQgJiYgdGhpcy5faXNHcm91cGVkICYmICF0aGlzLl9pc1ZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9zZXRHcm91cENvbnRhaW5lcldpZHRoLmJpbmQodGhpcywgZ3JvdXAuaXRlbUNvbnRhaW5lcikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaW5kIGFuZCBkZXRlcm1pbmUgdGhlIHByb3BlciBsb2FkaW5nIGZ1bmN0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0SXRlbXMgVGhlIHByb3BlcnR5IGZvciBpbmRpY2F0aW5nIHRoZSBmdW5jdGlvbiBmb3IgcmVxdWVzdGluZyBtb3JlIGl0ZW1zLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGlkZVJpbmc/IFdoZXRoZXIgb3Igbm90IHRvIGhpZGUgdGhlIHByb2dyZXNzIHJpbmcgZm9yIFwiaW5jcmVtZW50YWxcIiBsb2FkaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fZGV0ZXJtaW5lTG9hZGluZyA9IGZ1bmN0aW9uIChyZXF1ZXN0SXRlbXMsIHNob3dSaW5nKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBjb250cm9sUHJvcGVydHkgPSB0aGlzLmZpbmRQcm9wZXJ0eShyZXF1ZXN0SXRlbXMpIHx8IHt9O1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMudXRpbHMuaXNGdW5jdGlvbihjb250cm9sUHJvcGVydHkudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoX19MaXN0dmlldyArIFwiIG9uSXRlbXNSZXF1ZXN0ZWQgZnVuY3Rpb24gXFxcIlwiICsgcmVxdWVzdEl0ZW1zICsgXCJcXFwiIHdhcyBub3QgZm91bmQuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RJdGVtcyA9IGNvbnRyb2xQcm9wZXJ0eS52YWx1ZS5iaW5kKGNvbnRyb2xQcm9wZXJ0eS5jb250cm9sKTtcclxuICAgICAgICAgICAgdmFyIHByb2dyZXNzUmluZ0NvbnRhaW5lcjtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9sb2FkaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdpbmZpbml0ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW92ZVNjcm9sbF8xLCByZW1vdmVSZXF1ZXN0XzEgPSBub29wO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZVNjcm9sbF8xID0gdGhpcy5hZGRFdmVudExpc3RlbmVyKHRoaXMuX3Njcm9sbENvbnRhaW5lciwgJ3Njcm9sbCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fc2Nyb2xsUmVhZHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2Nyb2xsUmVhZHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlUmVxdWVzdF8xID0gX3RoaXMudXRpbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9zY3JvbGxSZWFkeSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fb25TY3JvbGwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Njcm9sbFJlYWR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZVJlcXVlc3RfMSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVTY3JvbGxfMSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3dSaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzUmluZ0NvbnRhaW5lciA9IHRoaXMuX2xvYWRpbmdQcm9ncmVzc1JpbmcgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NSaW5nQ29udGFpbmVyLmNsYXNzTmFtZSA9IF9fUGxhdCArIFwiaW5maW5pdGVcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NSaW5nQ29udGFpbmVyLmluc2VydEJlZm9yZSh0aGlzLl9nZW5lcmF0ZVByb2dyZXNzUmluZygpLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtc0xvYWRlZC50aGVuKHRoaXMuX29uU2Nyb2xsLmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnaW5jcmVtZW50YWwnOlxyXG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzUmluZ0NvbnRhaW5lciA9IHRoaXMuX2xvYWRpbmdQcm9ncmVzc1JpbmcgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc1JpbmdDb250YWluZXIuY2xhc3NOYW1lID0gX19QbGF0ICsgXCJpbmNyZW1lbnRhbFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzUmluZ0NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoX19IaWRlLCAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NSaW5nQ29udGFpbmVyLmluc2VydEJlZm9yZSh0aGlzLl9nZW5lcmF0ZVByb2dyZXNzUmluZygpLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuaW5zZXJ0QmVmb3JlKHByb2dyZXNzUmluZ0NvbnRhaW5lciwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fb25TY3JvbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzY3JvbGxDb250YWluZXIgPSB0aGlzLl9zY3JvbGxDb250YWluZXIsIHNjcm9sbFBvcyA9IHRoaXMuX3Njcm9sbFBvc2l0aW9uLCBzY3JvbGxQb3NpdGlvbiA9IHRoaXMuX2lzVmVydGljYWwgP1xyXG4gICAgICAgICAgICAgICAgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCArIHNjcm9sbENvbnRhaW5lci5vZmZzZXRIZWlnaHQgOlxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQgKyBzY3JvbGxDb250YWluZXIub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgICAgIGlmIChzY3JvbGxQb3MgPiBzY3JvbGxQb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2Nyb2xsUG9zaXRpb24gPSBzY3JvbGxQb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzY3JvbGxQb3MgKyA1ID4gc2Nyb2xsUG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIC8vIGRlYm91bmNlIGV4Y2Vzc2l2ZSBzY3JvbGwgZXZlbnQgY2FsbHMgXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsUG9zaXRpb24gPSBzY3JvbGxQb3NpdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlU2Nyb2xsKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIHNjcm9sbGluZyBoYXMgaGl0IHRoZSBwcm9wZXIgdGhyZXNob2xkIGFuZCByZXF1ZXN0cyBtb3JlIGl0ZW1zIGlmIGl0IGhhcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX2hhbmRsZVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgLy8gaW5maW5pdGUgc2Nyb2xsaW5nIHNldCB0byBsb2FkIGl0ZW1zIGF0IDgwJSBvZiBzY3JvbGwgbGVuZ3RoIFxyXG4gICAgICAgICAgICB2YXIgc2Nyb2xsQ29udGFpbmVyID0gdGhpcy5fc2Nyb2xsQ29udGFpbmVyLCBzY3JvbGxMZW5ndGggPSAwLjggKiAodGhpcy5faXNWZXJ0aWNhbCA/IHNjcm9sbENvbnRhaW5lci5zY3JvbGxIZWlnaHQgOiBzY3JvbGxDb250YWluZXIuc2Nyb2xsV2lkdGgpO1xyXG4gICAgICAgICAgICBpZiAoc2Nyb2xsTGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc2Nyb2xsUG9zaXRpb24gPj0gc2Nyb2xsTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdXRpbHNfMiA9IHRoaXMudXRpbHMsIGl0ZW1zUmVtYWluID0gdGhpcy5fcmVxdWVzdEl0ZW1zKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbXNSZW1haW4gPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlU2Nyb2xsKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh1dGlsc18yLmlzUHJvbWlzZShpdGVtc1JlbWFpbikpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvZ3Jlc3NSaW5nXzEgPSB0aGlzLl9sb2FkaW5nUHJvZ3Jlc3NSaW5nLCBzaG93UHJvZ3Jlc3NfMSA9ICF1dGlsc18yLmlzTnVsbChwcm9ncmVzc1JpbmdfMSksIGNvbnRhaW5lcl8xID0gdGhpcy5fY29udGFpbmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbFJlYWR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3dQcm9ncmVzc18xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzXzIucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcl8xLmluc2VydEJlZm9yZShwcm9ncmVzc1JpbmdfMSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpdGVtc1JlbWFpbi50aGVuKGZ1bmN0aW9uIChtb3JlSXRlbXNSZW1haW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3dQcm9ncmVzc18xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsc18yLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyXzEucmVtb3ZlQ2hpbGQocHJvZ3Jlc3NSaW5nXzEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vcmVJdGVtc1JlbWFpbiA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2Nyb2xsUmVhZHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXRpbHNfMi5wb3N0cG9uZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLml0ZW1zTG9hZGVkLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9zY3JvbGxSZWFkeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9oYW5kbGVTY3JvbGwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpbmQgYW5kIGRldGVybWluZSB0aGUgcHVsbC10by1yZWZyZXNoIGZ1bmN0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWxsUmVmcmVzaCBUaGUgcHJvcGVydHkgZm9yIGluZGljYXRpbmcgdGhlIHB1bGwtdG8tcmVmcmVzaCBmdW5jdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX2luaXRpYWxpemVSZWZyZXNoID0gZnVuY3Rpb24gKHJlZnJlc2gpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRyb2xQcm9wZXJ0eSA9IHRoaXMuZmluZFByb3BlcnR5KHJlZnJlc2gpIHx8IHt9O1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMudXRpbHMuaXNGdW5jdGlvbihjb250cm9sUHJvcGVydHkudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoX19MaXN0dmlldyArIFwiIG9uUmVmcmVzaCBmdW5jdGlvbiBcXFwiXCIgKyByZWZyZXNoICsgXCJcXFwiIHdhcyBub3QgZm91bmQuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3JlZnJlc2ggPSBjb250cm9sUHJvcGVydHkudmFsdWUuYmluZChjb250cm9sUHJvcGVydHkuY29udHJvbCk7XHJcbiAgICAgICAgICAgIHZhciBwcm9ncmVzc1JpbmdDb250YWluZXIgPSB0aGlzLl9yZWZyZXNoUHJvZ3Jlc3NSaW5nID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIHByb2dyZXNzUmluZ0NvbnRhaW5lci5jbGFzc05hbWUgPSBfX1BsYXQgKyBcInJlZnJlc2hcIjtcclxuICAgICAgICAgICAgcHJvZ3Jlc3NSaW5nQ29udGFpbmVyLnNldEF0dHJpYnV0ZShfX0hpZGUsICcnKTtcclxuICAgICAgICAgICAgcHJvZ3Jlc3NSaW5nQ29udGFpbmVyLmluc2VydEJlZm9yZSh0aGlzLl9nZW5lcmF0ZVByb2dyZXNzUmluZygpLCBudWxsKTtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lmluc2VydEJlZm9yZShwcm9ncmVzc1JpbmdDb250YWluZXIsIG51bGwpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIHByb3BlciB0cmFja2luZyBldmVudHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBsb2FkaW5nIFdoZXRoZXIgb3Igbm90IHRvIGluaXRpYWxpemUgdGhlIGxvYWRpbmcgdHJhY2tpbmcgZXZlbnRzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVmcmVzaCBXaGV0aGVyIG9yIG5vdCB0byBpbml0aWFsaXplIHRoZSByZWZyZXNoIHRyYWNraW5nIGV2ZW50cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX2luaXRpYWxpemVUcmFja2luZyA9IGZ1bmN0aW9uIChsb2FkaW5nLCByZWZyZXNoKSB7XHJcbiAgICAgICAgICAgIGlmICghKGxvYWRpbmcgfHwgcmVmcmVzaCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zZXRUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgdmFyIHRyYWNrLCByZXZlcnNlVHJhY2s7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1ZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFjayA9IF9fJHRyYWNrICsgXCJkb3duXCI7XHJcbiAgICAgICAgICAgICAgICByZXZlcnNlVHJhY2sgPSBfXyR0cmFjayArIFwidXBcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRyYWNrID0gX18kdHJhY2sgKyBcInJpZ2h0XCI7XHJcbiAgICAgICAgICAgICAgICByZXZlcnNlVHJhY2sgPSBfXyR0cmFjayArIFwibGVmdFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB2aWV3cG9ydCA9IHRoaXMuX3ZpZXdwb3J0LCB0b3VjaEVuZCwgdHJhY2tGbjtcclxuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHZpZXdwb3J0LCBfXyR0b3VjaHN0YXJ0LCB0aGlzLl90b3VjaFN0YXJ0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGlmIChsb2FkaW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0b3VjaEVuZCA9IHRoaXMuX3RvdWNoRW5kTG9hZDtcclxuICAgICAgICAgICAgICAgIHRyYWNrRm4gPSB0aGlzLl90cmFja0xvYWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodmlld3BvcnQsIF9fJHRvdWNoZW5kLCB0b3VjaEVuZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHZpZXdwb3J0LCBfXyR0cmFja2VuZCwgdG91Y2hFbmQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih2aWV3cG9ydCwgX18kdG91Y2hjYW5jZWwsIHRvdWNoRW5kLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodmlld3BvcnQsIHRyYWNrLCB0cmFja0ZuLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodmlld3BvcnQsIHJldmVyc2VUcmFjaywgdHJhY2tGbiwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZWZyZXNoKSB7XHJcbiAgICAgICAgICAgICAgICB0b3VjaEVuZCA9IHRoaXMuX3RvdWNoRW5kUmVmcmVzaDtcclxuICAgICAgICAgICAgICAgIHRyYWNrRm4gPSB0aGlzLl90cmFja1JlZnJlc2g7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodmlld3BvcnQsIF9fJHRvdWNoZW5kLCB0b3VjaEVuZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHZpZXdwb3J0LCBfXyR0cmFja2VuZCwgdG91Y2hFbmQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih2aWV3cG9ydCwgX18kdG91Y2hjYW5jZWwsIHRvdWNoRW5kLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodmlld3BvcnQsIHRyYWNrLCB0cmFja0ZuLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodmlld3BvcnQsIHJldmVyc2VUcmFjaywgdHJhY2tGbiwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdG91Y2ggc3RhcnQgZXZlbnQgbGlzdGVuZXIgZm9yIHdoZW4gbG9va2luZyBmb3IgYSByZWZyZXNoLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JR2VzdHVyZUV2ZW50fSBldiBUaGUgJHRvdWNoc3RhcnQgZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fdG91Y2hTdGFydCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdG91Y2hTdGF0ZSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLl9pc1ZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gTWF0aC5jZWlsKGV2Lm9mZnNldFkpLCBcclxuICAgICAgICAgICAgICAgIC8vIHdlJ3JlIGdvaW5nIHRvIGRlY3JlYXNlIHRoZSB0aHJlc2hvbGQgYnkgMjAgdG8gYnVmZmVyIHRoZSBzY3JvbGxiYXIgXHJcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQgPSB0aGlzLl92aWV3cG9ydC5vZmZzZXRIZWlnaHQgLSAyMDtcclxuICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gdGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoU3RhdGUgPSAxO1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0VG91Y2ggPSB7XHJcbiAgICAgICAgICAgICAgICB4OiBldi5jbGllbnRYLFxyXG4gICAgICAgICAgICAgICAgeTogZXYuY2xpZW50WVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMudXRpbHMuaXNOdWxsKHRoaXMuX3RvdWNoQW5pbWF0aW9uVGhlbmFibGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b3VjaEFuaW1hdGlvblRoZW5hYmxlLmNhbmNlbCgpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl90b3VjaEFuaW1hdGlvblRoZW5hYmxlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdG91Y2hTdGF0ZSA9IDI7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90b3VjaFN0YXRlID0gMjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0b3VjaCBlbmQgZXZlbnQgbGlzdGVuZXIgZm9yIHdoZW4gbG9va2luZyBmb3IgYW4gaW5jcmVtZW50YWwgbG9hZC5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSUdlc3R1cmVFdmVudH0gZXYgVGhlICR0b3VjaGVuZCBldmVudCBvYmplY3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl90b3VjaEVuZExvYWQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgdmFyIGlzTG9hZGluZyA9IHRoaXMuX2lzTG9hZGluZztcclxuICAgICAgICAgICAgdGhpcy5faXNMb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmICghaXNMb2FkaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzUmVmcmVzaGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RvdWNoU3RhdGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzY3JvbGxDb250YWluZXIgPSB0aGlzLl9zY3JvbGxDb250YWluZXIsIHNjcm9sbExlbmd0aCwgdGhyZXNob2xkO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgc2Nyb2xsTGVuZ3RoID0gc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCArIHNjcm9sbENvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQgPSBzY3JvbGxDb250YWluZXIuc2Nyb2xsSGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2Nyb2xsTGVuZ3RoID0gc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQgKyBzY3JvbGxDb250YWluZXIub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQgPSBzY3JvbGxDb250YWluZXIuc2Nyb2xsV2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZG8gcGx1cyAxIGhlcmUgZm9yIGJyb3dzZXIgcGl4ZWwgaW5jb25zaXN0ZW5jeSBcclxuICAgICAgICAgICAgaWYgKHNjcm9sbExlbmd0aCArIDEgPCB0aHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RvdWNoU3RhdGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoRW5kKGV2LCBmYWxzZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdG91Y2ggZW5kIGV2ZW50IGxpc3RlbmVyIGZvciB3aGVuIGxvb2tpbmcgZm9yIGEgcmVmcmVzaC5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSUdlc3R1cmVFdmVudH0gZXYgVGhlICR0b3VjaGVuZCBldmVudCBvYmplY3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl90b3VjaEVuZFJlZnJlc2ggPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgdmFyIGlzUmVmcmVzaGluZyA9IHRoaXMuX2lzUmVmcmVzaGluZztcclxuICAgICAgICAgICAgdGhpcy5faXNSZWZyZXNoaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmICghaXNSZWZyZXNoaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzTG9hZGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RvdWNoU3RhdGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCh0aGlzLl9pc1ZlcnRpY2FsID8gdGhpcy5fc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCA6IHRoaXMuX3Njcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0KSA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RvdWNoU3RhdGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoRW5kKGV2LCB0cnVlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgY29tbW9uIHRvdWNoIGVuZCBldmVudCBsaXN0ZW5lciBmb3IgYm90aCByZWZyZXNoIGFuZCBpbmNyZW1lbnRhbCBsb2FkaW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JR2VzdHVyZUV2ZW50fSBldiBUaGUgJHRvdWNoZW5kIGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlZnJlc2hpbmcgV2hldGhlciB0aGlzIHRyYW5zbGF0aW9uIGlzIGZvciByZWZyZXNoIG9yIGluY3JlbWVudGFsIGxvYWRpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl90b3VjaEVuZCA9IGZ1bmN0aW9uIChldiwgcmVmcmVzaGluZykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl90b3VjaFN0YXRlLCBoYXNNb3ZlZCA9IHRoaXMuX2hhc01vdmVkO1xyXG4gICAgICAgICAgICB0aGlzLl9oYXNNb3ZlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUgPCAyIHx8ICFoYXNNb3ZlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhbmltYXRpb25PcHRpb25zID0ge30sIGRvbSA9IHRoaXMuZG9tLCB2aWV3cG9ydCA9IHRoaXMuX3ZpZXdwb3J0LCBwcm9ncmVzc1JpbmcgPSByZWZyZXNoaW5nID8gdGhpcy5fcmVmcmVzaFByb2dyZXNzUmluZyA6IHRoaXMuX2xvYWRpbmdQcm9ncmVzc1JpbmcsIGlzQWN0aW9uU3RhdGUgPSBzdGF0ZSA9PT0gMywgbmV4dFRyYW5zbGF0aW9uO1xyXG4gICAgICAgICAgICBpZiAoaXNBY3Rpb25TdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1ZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gcmVmcmVzaGluZyA/IHByb2dyZXNzUmluZy5vZmZzZXRIZWlnaHQgOiAtcHJvZ3Jlc3NSaW5nLm9mZnNldEhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0VHJhbnNsYXRpb24gPSBcInRyYW5zbGF0ZTNkKDAsXCIgKyBvZmZzZXQgKyBcInB4LDApXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSByZWZyZXNoaW5nID8gcHJvZ3Jlc3NSaW5nLm9mZnNldFdpZHRoIDogLXByb2dyZXNzUmluZy5vZmZzZXRXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0VHJhbnNsYXRpb24gPSBcInRyYW5zbGF0ZTNkKFwiICsgb2Zmc2V0ICsgXCJweCwwLDApXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0VHJhbnNsYXRpb24gPSB0aGlzLl9wcmVUcmFuc2Zvcm07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYW5pbWF0aW9uT3B0aW9uc1t0aGlzLl90cmFuc2Zvcm1dID0gbmV4dFRyYW5zbGF0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLl90b3VjaEFuaW1hdGlvblRoZW5hYmxlID0gdGhpcy5fYW5pbWF0b3IuYW5pbWF0ZSh2aWV3cG9ydCwgX19UcmFuc2l0aW9uLCB7XHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBhbmltYXRpb25PcHRpb25zXHJcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3RvdWNoU3RhdGUgPSA0O1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2hhc01vdmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fdG91Y2hBbmltYXRpb25UaGVuYWJsZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNBY3Rpb25TdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fUHJvbWlzZS5yZXNvbHZlKHJlZnJlc2hpbmcgPyBfdGhpcy5fcmVmcmVzaCgpIDogX3RoaXMuX3JlcXVlc3RJdGVtcygpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyh2aWV3cG9ydCwgX19QbGF0ICsgXCJtYW5pcHVsYXRpb24tcHJlcFwiKTtcclxuICAgICAgICAgICAgICAgIHByb2dyZXNzUmluZy5zZXRBdHRyaWJ1dGUoX19IaWRlLCAnJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX1Byb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNBY3Rpb25TdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl90b3VjaFN0YXRlID0gMDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MocHJvZ3Jlc3NSaW5nLCBfX1BsYXQgKyBcInBsYXlcIik7XHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb25PcHRpb25zW190aGlzLl90cmFuc2Zvcm1dID0gX3RoaXMuX3ByZVRyYW5zZm9ybTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fdG91Y2hBbmltYXRpb25UaGVuYWJsZSA9IF90aGlzLl9hbmltYXRvci5hbmltYXRlKHZpZXdwb3J0LCBfX1RyYW5zaXRpb24sIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBhbmltYXRpb25PcHRpb25zXHJcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdG91Y2hTdGF0ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RvdWNoQW5pbWF0aW9uVGhlbmFibGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyh2aWV3cG9ydCwgX19QbGF0ICsgXCJtYW5pcHVsYXRpb24tcHJlcFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc1Jpbmcuc2V0QXR0cmlidXRlKF9fSGlkZSwgJycpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pLnRoZW4obnVsbCwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fdG91Y2hTdGF0ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmRlYnVnKF90aGlzLnR5cGUgKyBcIiBlcnJvcjogXCIgKyBlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRyYWNraW5nIGV2ZW50IGxpc3RlbmVyIGZvciBsb29raW5nIGZvciBhIGxvYWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklHZXN0dXJlRXZlbnR9IGV2IFRoZSAkdHJhY2tbZGlyZWN0aW9uXSBldmVudCBvYmplY3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl90cmFja0xvYWQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzUmVmcmVzaGluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNMb2FkaW5nKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsQ29udGFpbmVyID0gdGhpcy5fc2Nyb2xsQ29udGFpbmVyLCBzY3JvbGxMZW5ndGggPSB2b2lkIDAsIHRocmVzaG9sZCA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1ZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2LmRpcmVjdGlvbi55ICE9PSAndXAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsTGVuZ3RoID0gc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCArIHNjcm9sbENvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyZXNob2xkID0gc2Nyb2xsQ29udGFpbmVyLnNjcm9sbEhlaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldi5kaXJlY3Rpb24ueCAhPT0gJ2xlZnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsTGVuZ3RoID0gc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQgKyBzY3JvbGxDb250YWluZXIub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyZXNob2xkID0gc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gZG8gcGx1cyAxIGhlcmUgZm9yIGJyb3dzZXIgcGl4ZWwgaW5jb25zaXN0ZW5jeSBcclxuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxMZW5ndGggKyAxIDwgdGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNMb2FkaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90cmFjayhldiwgZmFsc2UpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRyYWNraW5nIGV2ZW50IGxpc3RlbmVyIGZvciBsb29raW5nIGZvciBhIHJlZnJlc2guXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklHZXN0dXJlRXZlbnR9IGV2IFRoZSAkdHJhY2tbZGlyZWN0aW9uXSBldmVudCBvYmplY3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl90cmFja1JlZnJlc2ggPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzTG9hZGluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNSZWZyZXNoaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldi5kaXJlY3Rpb24ueSAhPT0gJ2Rvd24nIHx8IHRoaXMuX3Njcm9sbENvbnRhaW5lci5zY3JvbGxUb3AgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldi5kaXJlY3Rpb24ueCAhPT0gJ3JpZ2h0JyB8fCB0aGlzLl9zY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1JlZnJlc2hpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrKGV2LCB0cnVlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhhbmRsZXMgdGhlIHRyYW5zbGF0aW9uIG9mIHRoZSB2aWV3cG9ydCB3aGlsZSB0cmFja2luZy5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSUdlc3R1cmVFdmVudH0gZXYgVGhlICR0cmFja1tkaXJlY3Rpb25dIGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlZnJlc2hpbmcgV2hldGhlciB0aGlzIHRyYW5zbGF0aW9uIGlzIGZvciByZWZyZXNoIG9yIGluY3JlbWVudGFsIGxvYWRpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl90cmFjayA9IGZ1bmN0aW9uIChldiwgcmVmcmVzaGluZykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgdG91Y2hTdGF0ZSA9IHRoaXMuX3RvdWNoU3RhdGU7XHJcbiAgICAgICAgICAgIGlmICghKHRvdWNoU3RhdGUgPT09IDIgfHwgdG91Y2hTdGF0ZSA9PT0gMykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdHJhbnNsYXRpb24gPSB0aGlzLl9jYWxjdWxhdGVUcmFuc2xhdGlvbihldiwgcmVmcmVzaGluZyk7XHJcbiAgICAgICAgICAgIHRoaXMudXRpbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl92aWV3cG9ydC5zdHlsZVtfdGhpcy5fdHJhbnNmb3JtXSA9IHRyYW5zbGF0aW9uO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIHRyYW5zbGF0aW9uIHZhbHVlIGZvciBzZXR0aW5nIHRoZSB0cmFuc2Zvcm0gdmFsdWUgZHVyaW5nIHRyYWNraW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JR2VzdHVyZUV2ZW50fSBldiBUaGUgJHRyYWNraW5nIGV2ZW50LlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVmcmVzaGluZyBXaGV0aGVyIHRoaXMgdHJhbnNsYXRpb24gaXMgZm9yIHJlZnJlc2ggb3IgaW5jcmVtZW50YWwgbG9hZGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX2NhbGN1bGF0ZVRyYW5zbGF0aW9uID0gZnVuY3Rpb24gKGV2LCByZWZyZXNoaW5nKSB7XHJcbiAgICAgICAgICAgIHZhciBpc1ZlcnRpY2FsID0gdGhpcy5faXNWZXJ0aWNhbCwgcHJvZ3Jlc3NSaW5nID0gcmVmcmVzaGluZyA/IHRoaXMuX3JlZnJlc2hQcm9ncmVzc1JpbmcgOiB0aGlzLl9sb2FkaW5nUHJvZ3Jlc3NSaW5nLCBkaWZmLCB0aHJlc2hvbGQ7XHJcbiAgICAgICAgICAgIGlmIChpc1ZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICBkaWZmID0gZXYuY2xpZW50WSAtIHRoaXMuX2xhc3RUb3VjaC55O1xyXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkID0gcHJvZ3Jlc3NSaW5nLm9mZnNldEhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRpZmYgPSBldi5jbGllbnRYIC0gdGhpcy5fbGFzdFRvdWNoLng7XHJcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQgPSBwcm9ncmVzc1Jpbmcub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChyZWZyZXNoaW5nICYmIGRpZmYgPCAwKSB8fCAoIXJlZnJlc2hpbmcgJiYgZGlmZiA+IDApKSB7XHJcbiAgICAgICAgICAgICAgICBkaWZmID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5faGFzTW92ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhc01vdmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmFkZENsYXNzKHRoaXMuX3ZpZXdwb3J0LCBfX1BsYXQgKyBcIm1hbmlwdWxhdGlvbi1wcmVwXCIpO1xyXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NSaW5nLnJlbW92ZUF0dHJpYnV0ZShfX0hpZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKE1hdGguYWJzKGRpZmYpID49IHRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RvdWNoU3RhdGUgPCAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG91Y2hTdGF0ZSA9IDM7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uYWRkQ2xhc3MocHJvZ3Jlc3NSaW5nLCBfX1BsYXQgKyBcInBsYXlcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fdG91Y2hTdGF0ZSA9PT0gMykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdG91Y2hTdGF0ZSA9IDI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5yZW1vdmVDbGFzcyhwcm9ncmVzc1JpbmcsIF9fUGxhdCArIFwicGxheVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlM2QoMCxcIiArIGRpZmYgKyBcInB4LDApXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlM2QoXCIgKyBkaWZmICsgXCJweCwwLDApXCI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBPYnRhaW5zIHRoZSBjdXJyZW50IGJyb3dzZXIncyB0cmFuc2Zvcm0gcHJvcGVydHkgdmFsdWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuX3ZpZXdwb3J0LnN0eWxlLCBpc1VuZGVmaW5lZCA9IHRoaXMudXRpbHMuaXNVbmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHZhciB2ZW5kb3JQcmVmaXggPSB0aGlzLl9jb21wYXQudmVuZG9yUHJlZml4O1xyXG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX3ByZVRyYW5zZm9ybSA9IHN0eWxlWyh2ZW5kb3JQcmVmaXgubG93ZXJDYXNlICsgXCJUcmFuc2Zvcm1cIildKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtID0gdmVuZG9yUHJlZml4Lmxvd2VyQ2FzZSArIFwiVHJhbnNmb3JtXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX3ByZVRyYW5zZm9ybSA9IHN0eWxlWyh2ZW5kb3JQcmVmaXgudXBwZXJDYXNlICsgXCJUcmFuc2Zvcm1cIildKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtID0gdmVuZG9yUHJlZml4LnVwcGVyQ2FzZSArIFwiVHJhbnNmb3JtXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmVUcmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm07XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm0gPSAndHJhbnNmb3JtJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xvbmVzIGFuZCBwYXJzZXMgdGhlcyBpbm5lclRlbXBsYXRlIGFuZCBjcmVhdGVzIHRoZSB0ZW1wbGF0ZXMgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpdGVtVGVtcGxhdGUgVGhlIG5vcm1hbGl6ZWQgaXRlbSB0ZW1wbGF0ZSBuYW1lIGZyb20gdGhlIG9wdGlvbnMuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGhlYWRlclRlbXBsYXRlPyBUaGUgbm9ybWFsaXplZCBncm91cCBoZWFkZXIgdGVtcGxhdGUgbmFtZSBmcm9tIHRoZSBvcHRpb25zLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fcGFyc2VJbm5lclRlbXBsYXRlID0gZnVuY3Rpb24gKGl0ZW1UZW1wbGF0ZSwgaGVhZGVyVGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgdmFyIHRlbXBsYXRlcyA9IHRoaXMuX3RlbXBsYXRlcywgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UsIGFwcGVuZENoaWxkcmVuID0gdGhpcy5kb20uYXBwZW5kQ2hpbGRyZW4sIF9kb2N1bWVudCA9IHRoaXMuX2RvY3VtZW50LCB2YWxpZEdyb3VwVGVtcGxhdGUgPSAhdGhpcy51dGlscy5pc051bGwoaGVhZGVyVGVtcGxhdGUpLCBjaGlsZE5vZGVzID0gc2xpY2UuY2FsbCh0aGlzLmlubmVyVGVtcGxhdGUuY2hpbGROb2RlcyksIGNoaWxkTm9kZSwgdGVtcGxhdGVOYW1lLCBjb250YWluZXI7XHJcbiAgICAgICAgICAgIHdoaWxlIChjaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVOYW1lID0gdGhpcy5fbm9ybWFsaXplVGVtcGxhdGVOYW1lKGNoaWxkTm9kZS5ub2RlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsaWRHcm91cFRlbXBsYXRlICYmIHRlbXBsYXRlTmFtZSA9PT0gaGVhZGVyVGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIgPSBfZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmNsYXNzTmFtZSA9IF9fUGxhdCArIFwiaGVhZGVyXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIgPSBfZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXBwZW5kQ2hpbGRyZW4oY2hpbGROb2RlLmNoaWxkTm9kZXMsIGNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZXNbdGVtcGxhdGVOYW1lXSA9IGNvbnRhaW5lcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVjZWl2ZXMgYW4gZXZlbnQgd2hlbiBhIG1ldGhvZCBoYXMgYmVlbiBjYWxsZWQgb24gYW4gYXJyYXkgYW5kIG1hcHMgdGhlIGFycmF5XHJcbiAgICAgICAgICogbWV0aG9kIHRvIGl0cyBhc3NvY2lhdGVkIG1ldGhvZCBoYW5kbGVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8cGxhdC5vYnNlcnZhYmxlLklBcnJheUNoYW5nZXM8YW55Pj59IGNoYW5nZXMgVGhlIEFycmF5IG11dGF0aW9uIGV2ZW50IGluZm9ybWF0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fZXhlY3V0ZUV2ZW50ID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IFwiX1wiICsgY2hhbmdlc1swXS50eXBlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy51dGlscy5pc0Z1bmN0aW9uKHRoaXNbbWV0aG9kXSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kXShjaGFuZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBuZXcgZ3JvdXAgdG8gdGhlIGNvbnRyb2wncyBlbGVtZW50LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBncm91cE5hbWUgVGhlIGdyb3VwIG5hbWUgb2YgdGhlIGN1cnJlbnRseSBjaGFuZ2luZyBBcnJheS5cclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHBsYXQub2JzZXJ2YWJsZS5JQXJyYXlDaGFuZ2VzPGFueT4+fSBjaGFuZ2VzIFRoZSBBcnJheSBjaGFuZ2UgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9leGVjdXRlQ2hpbGRFdmVudCA9IGZ1bmN0aW9uIChncm91cE5hbWUsIGNoYW5nZXMpIHtcclxuICAgICAgICAgICAgdmFyIHV0aWxzID0gdGhpcy51dGlscywgbWV0aG9kID0gXCJfXCIgKyBjaGFuZ2VzWzBdLnR5cGU7XHJcbiAgICAgICAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKHRoaXNbbWV0aG9kXSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBncm91cCA9IHRoaXMuX2dyb3Vwc1tncm91cE5hbWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHV0aWxzLmlzTnVsbChncm91cCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzW21ldGhvZF0oY2hhbmdlcywgZ3JvdXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaXJzdCBjaGVja3MgaWYgdGhlIHB1c2ggd2lsbCBkbyBhbnl0aGluZywgdGhlbiBoYW5kbGVzIGl0ZW1zIGJlaW5nIHB1c2hlZCBpbnRvIHRoZSBhcnJheS5cclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHBsYXQub2JzZXJ2YWJsZS5JQXJyYXlDaGFuZ2VzPGFueT4+fSBjaGFuZ2VzIFRoZSBBcnJheSBjaGFuZ2UgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0dWkuSUdyb3VwSGFzaH0gZ3JvdXA/IFRoZSBncm91cCB0aGF0IHdlJ3JlIHBlcmZvcm1pbmcgdGhpcyBvcGVyYXRpb24gb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9wdXNoID0gZnVuY3Rpb24gKGNoYW5nZXMsIGdyb3VwKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzWzBdLCBhZGRlZENvdW50ID0gY2hhbmdlLmFkZGVkQ291bnQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUl0ZW1zKGNoYW5nZS5pbmRleCwgYWRkZWRDb3VudCwgZ3JvdXAsIHRoaXMuX2FuaW1hdGUgPyBhZGRlZENvdW50IDogMCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIYW5kbGVzIGl0ZW1zIGJlaW5nIHBvcHBlZCBvZmYgdGhlIGFycmF5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8cGxhdC5vYnNlcnZhYmxlLklBcnJheUNoYW5nZXM8YW55Pj59IGNoYW5nZXMgVGhlIEFycmF5IGNoYW5nZSBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXR1aS5JR3JvdXBIYXNofSBncm91cD8gVGhlIGdyb3VwIHRoYXQgd2UncmUgcGVyZm9ybWluZyB0aGlzIG9wZXJhdGlvbiBvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX3BvcCA9IGZ1bmN0aW9uIChjaGFuZ2VzLCBncm91cCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgb3BHcm91cCA9IGdyb3VwIHx8IHRoaXMuX2RlZmF1bHRHcm91cCwgYWRkUXVldWUgPSBvcEdyb3VwLmFkZFF1ZXVlLCBjaGFuZ2UgPSBjaGFuZ2VzWzBdLCBzdGFydCA9IGNoYW5nZS5vYmplY3QubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoY2hhbmdlLnJlbW92ZWQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJlbW92ZUluZGV4ID0gY2hhbmdlLm9iamVjdC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGlmIChvcEdyb3VwLml0ZW1Db3VudCA+IDApIHtcclxuICAgICAgICAgICAgICAgIG9wR3JvdXAuaXRlbUNvdW50LS07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fUHJvbWlzZS5hbGwoYWRkUXVldWUpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9hbmltYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FuaW1hdGVJdGVtcyhzdGFydCwgMSwgX19MZWF2ZSwgb3BHcm91cCwgJ2xlYXZlJywgZmFsc2UpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVtb3ZlSXRlbXMocmVtb3ZlSW5kZXgsIDEsIG9wR3JvdXApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLl9yZW1vdmVJdGVtcyhyZW1vdmVJbmRleCwgMSwgb3BHcm91cCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSGFuZGxlcyBpdGVtcyBiZWluZyB1bnNoaWZ0ZWQgaW50byB0aGUgYXJyYXkuXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxwbGF0Lm9ic2VydmFibGUuSUFycmF5Q2hhbmdlczxhbnk+Pn0gY2hhbmdlcyBUaGUgQXJyYXkgY2hhbmdlIGluZm9ybWF0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdHVpLklHcm91cEhhc2h9IGdyb3VwPyBUaGUgZ3JvdXAgdGhhdCB3ZSdyZSBwZXJmb3JtaW5nIHRoaXMgb3BlcmF0aW9uIG9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fdW5zaGlmdCA9IGZ1bmN0aW9uIChjaGFuZ2VzLCBncm91cCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy51dGlscy5pc0Z1bmN0aW9uKHRoaXMuX3RlbXBsYXRlU2VsZWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlcmVuZGVyKGdyb3VwKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgb3BHcm91cCA9IGdyb3VwIHx8IHRoaXMuX2RlZmF1bHRHcm91cCwgY2hhbmdlID0gY2hhbmdlc1swXSwgYWRkZWRDb3VudCA9IGNoYW5nZS5hZGRlZENvdW50O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fYW5pbWF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvblF1ZXVlID0gb3BHcm91cC5hbmltYXRpb25RdWV1ZSwgYW5pbWF0aW9uTGVuZ3RoID0gYW5pbWF0aW9uUXVldWUubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZUl0ZW1zKDAsIGFkZGVkQ291bnQsIF9fRW50ZXIsIG9wR3JvdXAsIG51bGwsIGFuaW1hdGlvbkxlbmd0aCA+IDAgJiYgYW5pbWF0aW9uUXVldWVbYW5pbWF0aW9uTGVuZ3RoIC0gMV0ub3AgPT09ICdjbG9uZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUl0ZW1zKGNoYW5nZS5vYmplY3QubGVuZ3RoIC0gYWRkZWRDb3VudCwgYWRkZWRDb3VudCwgb3BHcm91cCwgMCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIYW5kbGVzIGl0ZW1zIGJlaW5nIHNoaWZ0ZWQgb2ZmIHRoZSBhcnJheS5cclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHBsYXQub2JzZXJ2YWJsZS5JQXJyYXlDaGFuZ2VzPGFueT4+fSBjaGFuZ2VzIFRoZSBBcnJheSBjaGFuZ2UgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0dWkuSUdyb3VwSGFzaH0gZ3JvdXA/IFRoZSBncm91cCB0aGF0IHdlJ3JlIHBlcmZvcm1pbmcgdGhpcyBvcGVyYXRpb24gb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9zaGlmdCA9IGZ1bmN0aW9uIChjaGFuZ2VzLCBncm91cCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgb3BHcm91cCA9IGdyb3VwIHx8IHRoaXMuX2RlZmF1bHRHcm91cCwgYWRkUXVldWUgPSBvcEdyb3VwLmFkZFF1ZXVlLCBjaGFuZ2UgPSBjaGFuZ2VzWzBdO1xyXG4gICAgICAgICAgICBpZiAoY2hhbmdlLnJlbW92ZWQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fYW5pbWF0ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFkZFF1ZXVlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZFF1ZXVlID0gYWRkUXVldWUuY29uY2F0KFt0aGlzLl9hbmltYXRlSXRlbXMoMCwgMSwgX19MZWF2ZSwgb3BHcm91cCwgJ2Nsb25lJywgdHJ1ZSldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmVtb3ZlSW5kZXggPSBjaGFuZ2Uub2JqZWN0Lmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKG9wR3JvdXAuaXRlbUNvdW50ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgb3BHcm91cC5pdGVtQ291bnQtLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9Qcm9taXNlLmFsbChhZGRRdWV1ZSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVtb3ZlSXRlbXMocmVtb3ZlSW5kZXgsIDEsIG9wR3JvdXApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhhbmRsZXMgYWRkaW5nL3JlbW92aW5nIGl0ZW1zIHdoZW4gYW4gYXJyYXkgaXMgc3BsaWNlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHBsYXQub2JzZXJ2YWJsZS5JQXJyYXlDaGFuZ2VzPGFueT4+fSBjaGFuZ2VzIFRoZSBBcnJheSBjaGFuZ2UgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0dWkuSUdyb3VwSGFzaH0gZ3JvdXA/IFRoZSBncm91cCB0aGF0IHdlJ3JlIHBlcmZvcm1pbmcgdGhpcyBvcGVyYXRpb24gb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9zcGxpY2UgPSBmdW5jdGlvbiAoY2hhbmdlcywgZ3JvdXApIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIHV0aWxzID0gdGhpcy51dGlscywgY2hhbmdlID0gY2hhbmdlc1swXSwgb3BHcm91cCA9IGdyb3VwIHx8IHRoaXMuX2RlZmF1bHRHcm91cCwgYWRkQ291bnQgPSBjaGFuZ2UuYWRkZWRDb3VudCwgY3VycmVudExlbmd0aCA9IG9wR3JvdXAuaXRlbUNvdW50LCBjb250cm9sID0gb3BHcm91cC5jb250cm9sLCBhZGRRdWV1ZSA9IG9wR3JvdXAuYWRkUXVldWUsIGFuaW1hdGluZyA9IHRoaXMuX2FuaW1hdGU7XHJcbiAgICAgICAgICAgIGlmICh1dGlscy5pc051bGwoYWRkQ291bnQpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsQ3VycmVudEFuaW1hdGlvbnMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBuZXdMZW5ndGggPSBjaGFuZ2Uub2JqZWN0Lmxlbmd0aCwgaXRlbUNvdW50XzEgPSBjdXJyZW50TGVuZ3RoIC0gbmV3TGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0xlbmd0aCA+IGN1cnJlbnRMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbih0aGlzLl90ZW1wbGF0ZVNlbGVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXRpbHMuaXNOdWxsKGNoYW5nZS5pbmRleCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVyZW5kZXIob3BHcm91cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcihjaGFuZ2UuaW5kZXgsIGFkZENvdW50LCBvcEdyb3VwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0ZW1Db3VudCB3aWxsIGJlIG5lZ2F0aXZlIFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUl0ZW1zKGN1cnJlbnRMZW5ndGgsIC1pdGVtQ291bnRfMSwgb3BHcm91cCwgMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50TGVuZ3RoID4gbmV3TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wR3JvdXAuaXRlbUNvdW50ID49IGl0ZW1Db3VudF8xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wR3JvdXAuaXRlbUNvdW50IC09IGl0ZW1Db3VudF8xO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BHcm91cC5pdGVtQ291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9Qcm9taXNlLmFsbChhZGRRdWV1ZSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZW1vdmVJdGVtcyhjdXJyZW50TGVuZ3RoIC0gaXRlbUNvdW50XzEsIGl0ZW1Db3VudF8xLCBvcEdyb3VwKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmVtb3ZlQ291bnQgPSBjaGFuZ2UucmVtb3ZlZC5sZW5ndGgsIGFuaW1hdGlvblF1ZXVlID0gb3BHcm91cC5hbmltYXRpb25RdWV1ZTtcclxuICAgICAgICAgICAgaWYgKGFkZENvdW50ID4gcmVtb3ZlQ291bnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpdGVtQWRkQ291bnQgPSBhZGRDb3VudCAtIHJlbW92ZUNvdW50LCBhbmltYXRpb25Db3VudCA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKHRoaXMuX3RlbXBsYXRlU2VsZWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHV0aWxzLmlzTnVsbChjaGFuZ2UuaW5kZXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVyZW5kZXIob3BHcm91cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcihjaGFuZ2UuaW5kZXgsIGFkZENvdW50LCBvcEdyb3VwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkNvdW50ID0gYWRkQ291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbkxlbmd0aCA9IGFuaW1hdGlvblF1ZXVlLmxlbmd0aCwgc3RhcnRJbmRleCA9IGNoYW5nZS5pbmRleDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudExlbmd0aCA8IGFkZENvdW50IC0gc3RhcnRJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25Db3VudCA9IGN1cnJlbnRMZW5ndGggLSBzdGFydEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRlSXRlbXMoc3RhcnRJbmRleCwgYW5pbWF0aW9uQ291bnQsIF9fRW50ZXIsIG9wR3JvdXAsIG51bGwsIGFuaW1hdGlvbkxlbmd0aCA+IDAgJiYgYW5pbWF0aW9uUXVldWVbYW5pbWF0aW9uTGVuZ3RoIC0gMV0ub3AgPT09ICdjbG9uZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkNvdW50ID0gYWRkQ291bnQgLSBhbmltYXRpb25Db3VudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkNvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUl0ZW1zKGNoYW5nZS5vYmplY3QubGVuZ3RoIC0gaXRlbUFkZENvdW50LCBpdGVtQWRkQ291bnQsIG9wR3JvdXAsIGFuaW1hdGlvbkNvdW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChyZW1vdmVDb3VudCA+IGFkZENvdW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWRkaW5nXzEgPSBhZGRDb3VudCA+IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW5nICYmICFhZGRpbmdfMSAmJiBhZGRRdWV1ZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRRdWV1ZSA9IGFkZFF1ZXVlLmNvbmNhdChbdGhpcy5fYW5pbWF0ZUl0ZW1zKGNoYW5nZS5pbmRleCwgcmVtb3ZlQ291bnQsIF9fTGVhdmUsIG9wR3JvdXAsICdjbG9uZScsIHRydWUpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVsZXRlQ291bnRfMSA9IHJlbW92ZUNvdW50IC0gYWRkQ291bnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAob3BHcm91cC5pdGVtQ291bnQgPj0gZGVsZXRlQ291bnRfMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wR3JvdXAuaXRlbUNvdW50IC09IGRlbGV0ZUNvdW50XzE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvcEdyb3VwLml0ZW1Db3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9Qcm9taXNlLmFsbChhZGRRdWV1ZSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGluZyAmJiBhZGRpbmdfMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbUxlbmd0aCA9IGFuaW1hdGlvblF1ZXVlLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FuaW1hdGVJdGVtcyhjaGFuZ2UuaW5kZXgsIGFkZENvdW50LCBfX0VudGVyLCBvcEdyb3VwLCBudWxsLCBhbmltTGVuZ3RoID4gMCAmJiBhbmltYXRpb25RdWV1ZVthbmltTGVuZ3RoIC0gMV0ub3AgPT09ICdjbG9uZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVtb3ZlSXRlbXMoY3VycmVudExlbmd0aCAtIGRlbGV0ZUNvdW50XzEsIGRlbGV0ZUNvdW50XzEsIG9wR3JvdXApO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuaW1hdGVzIHRoZSBpbmRpY2F0ZWQgaXRlbXMuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggVGhlIHN0YXJ0aW5nIGluZGV4IG9mIGl0ZW1zIHRvIGFuaW1hdGUuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlck9mSXRlbXMgVGhlIG51bWJlciBvZiBjb25zZWN1dGl2ZSBpdGVtcyB0byBhbmltYXRlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGFuaW1hdGlvbiBrZXkvdHlwZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0lHcm91cEhhc2h9IGdyb3VwIFRoZSBncm91cCBwZXJmb3JtaW5nIHRoZSBhbmltYXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFuaW1hdGlvbk9wIERlbm90ZXMgYW5pbWF0aW9uIG9wZXJhdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNhbmNlbCBXaGV0aGVyIG9yIG5vdCB0byBjYW5jZWwgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGJlZm9yZSBiZWdpbm5pbmcgdGhpcyBvbmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9hbmltYXRlSXRlbXMgPSBmdW5jdGlvbiAoc3RhcnRJbmRleCwgbnVtYmVyT2ZJdGVtcywga2V5LCBncm91cCwgYW5pbWF0aW9uT3AsIGNhbmNlbCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGFuaW1hdGlvbk9wKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdjbG9uZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUNsb25lZENvbnRhaW5lckFuaW1hdGlvbih0aGlzLl9nZXRBbmltYXRlZE5vZGVzKHN0YXJ0SW5kZXgsIG51bWJlck9mSXRlbXMsIGdyb3VwKSwga2V5LCBncm91cCwgY2FuY2VsID09PSB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2xlYXZlJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlTGVhdmUodGhpcy5fZ2V0QW5pbWF0ZWROb2RlcyhzdGFydEluZGV4LCBudW1iZXJPZkl0ZW1zLCBncm91cCksIGtleSwgZ3JvdXApO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlU2ltcGxlQW5pbWF0aW9uKHRoaXMuX2dldEFuaW1hdGVkTm9kZXMoc3RhcnRJbmRleCwgbnVtYmVyT2ZJdGVtcywgZ3JvdXApLCBrZXksIGdyb3VwLCBjYW5jZWwgPT09IHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUcmFuc2xhdGVzIHRoZSBpdGVtcyB0byBiZSBhbmltYXRlZCBpbnRvIHRoZSBub2RlcyB0byBiZSBhbmltYXRlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleCBUaGUgc3RhcnRpbmcgaW5kZXggb2YgaXRlbXMgdG8gYW5pbWF0ZS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyT2ZJdGVtcyBUaGUgbnVtYmVyIG9mIGNvbnNlY3V0aXZlIGl0ZW1zIHRvIGFuaW1hdGUuXHJcbiAgICAgICAgICogQHBhcmFtIHtJR3JvdXBIYXNofSBncm91cCBUaGUgZ3JvdXAgcGVyZm9ybWluZyB0aGUgYW5pbWF0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fZ2V0QW5pbWF0ZWROb2RlcyA9IGZ1bmN0aW9uIChzdGFydEluZGV4LCBudW1iZXJPZkl0ZW1zLCBncm91cCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNHcm91cGVkICYmIGdyb3VwID09PSB0aGlzLl9kZWZhdWx0R3JvdXApIHtcclxuICAgICAgICAgICAgICAgIC8vIHdlIGFyZSBhbmltYXRpbmcgYSBncm91cCBzbyBibG9jayBsZW5ndGggPT09IDMgKG9uZSBlbGVtZW50IG5vZGUgYW5kIHR3byBjb21tZW50IG5vZGVzKSBcclxuICAgICAgICAgICAgICAgIHZhciBibG9ja0xlbmd0aCA9IDMsIHN0YXJ0ID0gc3RhcnRJbmRleCAqIGJsb2NrTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGdyb3VwLml0ZW1Db250YWluZXIuY2hpbGROb2Rlcywgc3RhcnQsIG51bWJlck9mSXRlbXMgKiBibG9ja0xlbmd0aCArIHN0YXJ0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdXRpbHMgPSB0aGlzLnV0aWxzLCBpc05vZGUgPSB1dGlscy5pc05vZGUsIG5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZ3JvdXAuaXRlbUNvbnRhaW5lci5jaGlsZE5vZGVzKSwgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgbnVtYmVyT2ZJdGVtcyAtIDEsIGNvbnRyb2xzID0gZ3JvdXAuY29udHJvbC5jb250cm9scztcclxuICAgICAgICAgICAgaWYgKGNvbnRyb2xzLmxlbmd0aCA8PSBlbmRJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgZW5kSW5kZXggPSBjb250cm9scy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzdGFydE5vZGUgPSBjb250cm9sc1tzdGFydEluZGV4XS5zdGFydE5vZGUsIGVuZE5vZGUgPSBjb250cm9sc1tlbmRJbmRleF0uZW5kTm9kZTtcclxuICAgICAgICAgICAgaWYgKCEoaXNOb2RlKHN0YXJ0Tm9kZSkgJiYgaXNOb2RlKGVuZE5vZGUpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzdGFydE5vZGVJbmRleCA9IG5vZGVzLmluZGV4T2Yoc3RhcnROb2RlKSwgZW5kTm9kZUluZGV4ID0gbm9kZXMuaW5kZXhPZihlbmROb2RlKTtcclxuICAgICAgICAgICAgaWYgKHN0YXJ0Tm9kZUluZGV4ID09PSAtMSB8fCBlbmROb2RlSW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzLnNsaWNlKHN0YXJ0Tm9kZUluZGV4LCBlbmROb2RlSW5kZXggKyAxKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhhbmRsZXMgYSBzaW1wbGUgYW5pbWF0aW9uIG9mIGEgYmxvY2sgb2YgZWxlbWVudHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxOb2RlPn0gbm9kZXMgVGhlIEFycmF5IG9mIG5vZGVzIHRvIGFuaW1hdGUuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgYW5pbWF0aW9uIGtleS90eXBlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7SUdyb3VwSGFzaH0gZ3JvdXAgVGhlIGdyb3VwIHBlcmZvcm1pbmcgdGhlIGFuaW1hdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNhbmNlbCBXaGV0aGVyIG9yIG5vdCB0byBjYW5jZWwgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGJlZm9yZSBiZWdpbm5pbmcgdGhpcyBvbmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9oYW5kbGVTaW1wbGVBbmltYXRpb24gPSBmdW5jdGlvbiAobm9kZXMsIGtleSwgZ3JvdXAsIGNhbmNlbCkge1xyXG4gICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGdyb3VwLml0ZW1Db250YWluZXIsIGFuaW1hdGlvblF1ZXVlID0gZ3JvdXAuYW5pbWF0aW9uUXVldWUsIGFuaW1hdGlvbkNyZWF0aW9uID0gdGhpcy5fYW5pbWF0b3IuY3JlYXRlKG5vZGVzLCBrZXkpLCBhbmltYXRpb24sIGFuaW1hdGlvblByb21pc2UgPSBhbmltYXRpb25DcmVhdGlvbi5jdXJyZW50LnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYW5pbWF0aW9uUXVldWUuaW5kZXhPZihhbmltYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvblF1ZXVlLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH0pLCBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbkNyZWF0aW9uLnByZXZpb3VzLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvblByb21pc2Uuc3RhcnQoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGlvblByb21pc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogYW5pbWF0aW9uUHJvbWlzZSxcclxuICAgICAgICAgICAgICAgIG9wOiBudWxsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChjYW5jZWwgJiYgYW5pbWF0aW9uUXVldWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNhbmNlbFByb21pc2UgPSB0aGlzLl9jYW5jZWxDdXJyZW50QW5pbWF0aW9ucygpLnRoZW4oY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uUXVldWUucHVzaChhbmltYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbmNlbFByb21pc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYW5pbWF0aW9uUXVldWUucHVzaChhbmltYXRpb24pO1xyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhhbmRsZXMgYSBzaW1wbGUgYW5pbWF0aW9uIG9mIGEgYmxvY2sgb2YgZWxlbWVudHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxOb2RlPn0gbm9kZXMgVGhlIEFycmF5IG9mIG5vZGVzIHRvIGFuaW1hdGUuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgYW5pbWF0aW9uIGtleS90eXBlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7SUdyb3VwSGFzaH0gZ3JvdXAgVGhlIGdyb3VwIHBlcmZvcm1pbmcgdGhlIGFuaW1hdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX2hhbmRsZUxlYXZlID0gZnVuY3Rpb24gKG5vZGVzLCBrZXksIGdyb3VwKSB7XHJcbiAgICAgICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZ3JvdXAuaXRlbUNvbnRhaW5lciwgYW5pbWF0aW9uUXVldWUgPSBncm91cC5hbmltYXRpb25RdWV1ZSwgYW5pbWF0aW9uLCBhbmltYXRpb25Qcm9taXNlID0gdGhpcy5fYW5pbWF0b3IubGVhdmUobm9kZXMsIGtleSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBhbmltYXRpb25RdWV1ZS5pbmRleE9mKGFuaW1hdGlvbik7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uUXVldWUuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogYW5pbWF0aW9uUHJvbWlzZSxcclxuICAgICAgICAgICAgICAgIG9wOiAnbGVhdmUnXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGFuaW1hdGlvblF1ZXVlLnB1c2goYW5pbWF0aW9uKTtcclxuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGlvblByb21pc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIYW5kbGVzIGEgc2ltcGxlIGFuaW1hdGlvbiBvZiBhIGJsb2NrIG9mIGVsZW1lbnRzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8Tm9kZT59IG5vZGVzIFRoZSBBcnJheSBvZiBub2RlcyB0byBhbmltYXRlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGFuaW1hdGlvbiBrZXkvdHlwZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0lHcm91cEhhc2h9IGdyb3VwIFRoZSBncm91cCBwZXJmb3JtaW5nIHRoZSBhbmltYXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBjYW5jZWwgV2hldGhlciBvciBub3QgdG8gY2FuY2VsIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBiZWZvcmUgYmVnaW5uaW5nIHRoaXMgb25lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5faGFuZGxlQ2xvbmVkQ29udGFpbmVyQW5pbWF0aW9uID0gZnVuY3Rpb24gKG5vZGVzLCBrZXksIGdyb3VwLCBjYW5jZWwpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBncm91cC5pdGVtQ29udGFpbmVyLCBjbG9uZWRDb250YWluZXIgPSBjb250YWluZXIuY2xvbmVOb2RlKHRydWUpLCBwYXJlbnROb2RlLCBhbmltYXRpb25RdWV1ZSA9IGdyb3VwLmFuaW1hdGlvblF1ZXVlLCBpc051bGwgPSB0aGlzLnV0aWxzLmlzTnVsbCwgYW5pbWF0aW9uQ3JlYXRpb24gPSB0aGlzLl9hbmltYXRvci5jcmVhdGUobm9kZXMsIGtleSksIGFuaW1hdGlvbiwgYW5pbWF0aW9uUHJvbWlzZSA9IGFuaW1hdGlvbkNyZWF0aW9uLmN1cnJlbnQudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBhbmltYXRpb25RdWV1ZS5pbmRleE9mKGFuaW1hdGlvbik7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvblF1ZXVlLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHBhcmVudE5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoY29udGFpbmVyLCBjbG9uZWRDb250YWluZXIpO1xyXG4gICAgICAgICAgICB9KSwgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlID0gY29udGFpbmVyLnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHBhcmVudE5vZGUpIHx8IGFuaW1hdGlvblByb21pc2UuaXNDYW5jZWxlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGlvblByb21pc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLnJlcGxhY2VDaGlsZChjbG9uZWRDb250YWluZXIsIGNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb25DcmVhdGlvbi5wcmV2aW91cy50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25Qcm9taXNlLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhbmltYXRpb25Qcm9taXNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBhbmltYXRpb24gPSB7XHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb246IGFuaW1hdGlvblByb21pc2UsXHJcbiAgICAgICAgICAgICAgICBvcDogJ2Nsb25lJ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoY2FuY2VsICYmIGFuaW1hdGlvblF1ZXVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciBjYW5jZWxQcm9taXNlID0gdGhpcy5fY2FuY2VsQ3VycmVudEFuaW1hdGlvbnMoKS50aGVuKGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvblF1ZXVlLnB1c2goYW5pbWF0aW9uKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYW5jZWxQcm9taXNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFuaW1hdGlvblF1ZXVlLnB1c2goYW5pbWF0aW9uKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYW5jZWxzIGFsbCBjdXJyZW50IGFuaW1hdGlvbnMuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0dWkuSUdyb3VwSGFzaH0gVGhlIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgZ3JvdXAuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9jYW5jZWxDdXJyZW50QW5pbWF0aW9ucyA9IGZ1bmN0aW9uIChncm91cCkge1xyXG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uUXVldWUgPSAoZ3JvdXAgfHwgdGhpcy5fZGVmYXVsdEdyb3VwKS5hbmltYXRpb25RdWV1ZSwgYW5pbWF0aW9ucyA9IFtdLCBsZW5ndGggPSBhbmltYXRpb25RdWV1ZS5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnMucHVzaChhbmltYXRpb25RdWV1ZVtpXS5hbmltYXRpb24uY2FuY2VsKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLmFsbChhbmltYXRpb25zKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE5vcm1hbGl6ZXMgdGVtcGxhdGUgbmFtZXMgYnkgcmVtb3Zpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZU5hbWUgVGhlIG5hbWUgdG8gbm9ybWFsaXplLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fbm9ybWFsaXplVGVtcGxhdGVOYW1lID0gZnVuY3Rpb24gKHRlbXBsYXRlTmFtZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy51dGlscy5pc1N0cmluZyh0ZW1wbGF0ZU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVtcGxhdGVOYW1lLnRvTG93ZXJDYXNlKCkucmVwbGFjZSh0aGlzLl9ub2RlTm9ybWFsaXplUmVnZXgsICcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIHByb2dyZXNzIHJpbmcgZWxlbWVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX2dlbmVyYXRlUHJvZ3Jlc3NSaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX2RvY3VtZW50ID0gdGhpcy5fZG9jdW1lbnQsIGNvbnRyb2wgPSBfZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIHJpbmcgPSBfZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIGNvbnRyb2wuY2xhc3NOYW1lID0gX19MaXN0dmlldyArIFwiLXJpbmcgXCIgKyBfX1BsYXQgKyBcInJpbmcgXCIgKyBfX1BsYXQgKyBcInJpbmctMFwiO1xyXG4gICAgICAgICAgICByaW5nLmNsYXNzTmFtZSA9IF9fUGxhdCArIFwiYW5pbWF0ZWQtcmluZ1wiO1xyXG4gICAgICAgICAgICBjb250cm9sLmluc2VydEJlZm9yZShyaW5nLCBudWxsKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2w7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBjb250cm9sIGFuZCBlbnN1cmVzIGl0IGlzIHZhbGlkLlxyXG4gICAgICAgICAqIFdpbGwgZGVmYXVsdCB0byBcImhvcml6b250YWxcIiBpZiBpbnZhbGlkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcmllbnRhdGlvbiBUaGUgZWxlbWVudCB0byBiYXNlIHRoZSBsZW5ndGggb2ZmIG9mLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fdmFsaWRhdGVPcmllbnRhdGlvbiA9IGZ1bmN0aW9uIChvcmllbnRhdGlvbikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy51dGlscy5pc1VuZGVmaW5lZChvcmllbnRhdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAndmVydGljYWwnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB2YWxpZE9yaWVudGF0aW9uO1xyXG4gICAgICAgICAgICBpZiAob3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcclxuICAgICAgICAgICAgICAgIHZhbGlkT3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZE9yaWVudGF0aW9uID0gb3JpZW50YXRpb247XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1ZlcnRpY2FsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoXCJJbnZhbGlkIG9yaWVudGF0aW9uIFxcXCJcIiArIG9yaWVudGF0aW9uICsgXCJcXFwiIGZvciBcIiArIHRoaXMudHlwZSArIFwiLiBEZWZhdWx0aW5nIHRvIFxcXCJ2ZXJ0aWNhbC5cXFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFsaWRPcmllbnRhdGlvbiA9ICd2ZXJ0aWNhbCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkT3JpZW50YXRpb247XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBoZWlnaHQgb2YgYSBob3Jpem9udGFsbHkgZ3JvdXBlZCBMaXN0dmlldydzIGNvbnRhaW5lci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX3NldENvbnRhaW5lckhlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzVmVydGljYWwgfHwgIXRoaXMuX2lzR3JvdXBlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LCBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcclxuICAgICAgICAgICAgaWYgKCFoZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFZpc2liaWxpdHlMaXN0ZW5lcih0aGlzLl9zZXRDb250YWluZXJIZWlnaHQuYmluZCh0aGlzKSwgZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYWNjb3VudCBmb3Igc2Nyb2xsIGJhciBoZWlnaHQgZXZlbiBpZiBzY3JvbGwgYmFyIGlzbid0IHZpc2libGUgXHJcbiAgICAgICAgICAgIC8vIGFsbG93cyBmb3IgdHJhbnNpdGlvbiBvZiBzY3JvbGwgYmFyIGluIGFuZCBvdXQgb2YgcGFnZSBpbiBicm93c2VycyB3aGVyZSBzY3JvbGwgYmFyIGFmZmVjdHMgaGVpZ2h0IFxyXG4gICAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgLSB0aGlzLl9nZXRTY3JvbGxCYXJXaWR0aCgpO1xyXG4gICAgICAgICAgICBpZiAoaGVpZ2h0IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgd2lkdGggb2YgYSBncm91cCBjb250YWluZXIgYmFzZWQgb24gdGhlIHNjcm9sbCB3aWR0aCBvZiB0aGUgZ3JvdXAncyBpdGVtIGNvbnRhaW5lci5cclxuICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpdGVtQ29udGFpbmVyIFRoZSBpdGVtIGNvbnRhaW5lciBlbGVtZW50IHdob3NlIHBhcmVudCB3ZSdyZSBnb2luZyB0byBzZXQgaXRzIHNjcm9sbCB3aWR0aCBvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX3NldEdyb3VwQ29udGFpbmVyV2lkdGggPSBmdW5jdGlvbiAoaXRlbUNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBpdGVtQ29udGFpbmVyLnNjcm9sbFdpZHRoO1xyXG4gICAgICAgICAgICBpZiAoIXdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRWaXNpYmlsaXR5TGlzdGVuZXIodGhpcy5fc2V0R3JvdXBDb250YWluZXJXaWR0aC5iaW5kKHRoaXMsIGl0ZW1Db250YWluZXIpLCBpdGVtQ29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpdGVtQ29udGFpbmVyLnBhcmVudEVsZW1lbnQuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIHBhZGRpbmcgb2YgYSBncm91cCdzIGVsZW1lbnQuXHJcbiAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgZ3JvdXAgY29udGFpbmVyIGVsZW1lbnQgd2hvIHdlJ3JlIHNldHRpbmcgcGFkZGluZyBvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX3NldEdyb3VwQ29udGFpbmVyUGFkZGluZyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50SGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgIGlmICghZWxlbWVudEhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkVmlzaWJpbGl0eUxpc3RlbmVyKHRoaXMuX3NldEdyb3VwQ29udGFpbmVyUGFkZGluZy5iaW5kKHRoaXMsIGVsZW1lbnQpLCBlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaGVhZGVyID0gZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCwgaGVhZGVySGVpZ2h0ID0gaGVhZGVyLm9mZnNldEhlaWdodDtcclxuICAgICAgICAgICAgaWYgKCFoZWFkZXJIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFZpc2liaWxpdHlMaXN0ZW5lcih0aGlzLl9zZXRHcm91cENvbnRhaW5lclBhZGRpbmcuYmluZCh0aGlzLCBlbGVtZW50KSwgaGVhZGVyKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLnBhZGRpbmdUb3AgPSBoZWFkZXJIZWlnaHQgKyBcInB4XCI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxjdWF0ZXMgdGhlIHdpZHRoIG9mIHRoZSBob3Jpem9udGFsIHNjcm9sbCBiYXIgaW4gdGhlIGN1cnJlbnQgYnJvd3Nlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX2dldFNjcm9sbEJhcldpZHRoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX2RvY3VtZW50ID0gdGhpcy5fZG9jdW1lbnQsIGJvZHkgPSBfZG9jdW1lbnQuYm9keSwgaW5uZXIgPSBfZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIG91dGVyID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLCBpbm5lclN0eWxlID0gaW5uZXIuc3R5bGUsIG91dGVyU3R5bGUgPSBvdXRlci5zdHlsZTtcclxuICAgICAgICAgICAgaW5uZXJTdHlsZS53aWR0aCA9IGlubmVyU3R5bGUuaGVpZ2h0ID0gb3V0ZXJTdHlsZS5oZWlnaHQgPSAnMTAwcHgnO1xyXG4gICAgICAgICAgICBvdXRlclN0eWxlLndpZHRoID0gJzUwcHgnO1xyXG4gICAgICAgICAgICBvdXRlclN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgICAgICAgICAgb3V0ZXJTdHlsZS50b3AgPSBvdXRlclN0eWxlLmxlZnQgPSAnMHB4JztcclxuICAgICAgICAgICAgb3V0ZXJTdHlsZS52aXNpYmlsaXR5ID0gb3V0ZXJTdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xyXG4gICAgICAgICAgICBvdXRlci5pbnNlcnRCZWZvcmUoaW5uZXIsIG51bGwpO1xyXG4gICAgICAgICAgICBib2R5Lmluc2VydEJlZm9yZShvdXRlciwgbnVsbCk7XHJcbiAgICAgICAgICAgIHZhciB3MSA9IGlubmVyLm9mZnNldEhlaWdodDtcclxuICAgICAgICAgICAgb3V0ZXJTdHlsZS5vdmVyZmxvdyA9ICdzY3JvbGwnO1xyXG4gICAgICAgICAgICB2YXIgdzIgPSBpbm5lci5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgIGlmICh3MSA9PT0gdzIpIHtcclxuICAgICAgICAgICAgICAgIHcyID0gb3V0ZXIuY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJvZHkucmVtb3ZlQ2hpbGQob3V0ZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gKHcxIC0gdzIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIHZpc2liaWxpdHkgbGlzdGVuZXIgYW5kIGhpZGVzIGFuZCBzaG93cyBlbGVtZW50IGFjY29yZGluZ2x5XHJcbiAgICAgICAgICogQHBhcmFtIHsoKSA9PiB2b2lkfSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gZmlyZSB3aGVuIHZpc2libGUuXHJcbiAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBsaXN0ZW4gZm9yIHZpc2liaWxpdHkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9hZGRWaXNpYmlsaXR5TGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIHZpc2liaWxpdHlSZW1vdmVycyA9IHRoaXMuX3Zpc2liaWxpdHlSZW1vdmVMaXN0ZW5lcnMsIHJlbW92ZSwgY2IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSB2aXNpYmlsaXR5UmVtb3ZlcnMuaW5kZXhPZihyZW1vdmUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eVJlbW92ZXJzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh2aXNpYmlsaXR5UmVtb3ZlcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoX19IaWRkZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZW1vdmUgPSB0aGlzLmRvbS53aGVuVmlzaWJsZSh0aGlzLnV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHRoaXMsIGNiKSwgZWxlbWVudCk7XHJcbiAgICAgICAgICAgIGlmICh2aXNpYmlsaXR5UmVtb3ZlcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKF9fSGlkZGVuLCAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmlzaWJpbGl0eVJlbW92ZXJzLnB1c2gocmVtb3ZlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIExpc3R2aWV3Ll9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgIF9kb2N1bWVudDogX19Eb2N1bWVudCxcclxuICAgICAgICAgICAgX3dpbmRvdzogX19XaW5kb3csXHJcbiAgICAgICAgICAgIF9jb21wYXQ6IF9fQ29tcGF0LFxyXG4gICAgICAgICAgICBfYW5pbWF0b3I6IF9fQW5pbWF0b3IsXHJcbiAgICAgICAgICAgIF9Qcm9taXNlOiBfX1Byb21pc2UsXHJcbiAgICAgICAgICAgIF9UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5OiBfX1RlbXBsYXRlQ29udHJvbEZhY3RvcnlcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBMaXN0dmlldztcclxuICAgIH0ocGxhdC51aS5UZW1wbGF0ZUNvbnRyb2wpKTtcclxuICAgIHBsYXR1aS5MaXN0dmlldyA9IExpc3R2aWV3O1xyXG4gICAgcGxhdC5yZWdpc3Rlci5jb250cm9sKF9fTGlzdHZpZXcsIExpc3R2aWV3KTtcclxuICAgIC8qKlxyXG4gICAgICogQW4gSVRlbXBsYXRlQ29udHJvbCB0aGF0IGFjdHMgYXMgYSBnbG9iYWwgbmF2aWdhdGlvbiBiYXIgdGhhdCBkZWZpbmVzIGl0cyBvd24gY29udGV4dC5cclxuICAgICAqL1xyXG4gICAgdmFyIE5hdmJhciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKE5hdmJhciwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBOYXZiYXIoKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIEhUTUwgdGVtcGxhdGUgcmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlU3RyaW5nID0gJzxkaXYgY2xhc3M9XCJwbGF0LW5hdmJhci1sZWZ0XCI+XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnICAgIDxkaXYgY2xhc3M9XCJwbGF0LW5hdmJhci1pdGVtc1wiIHBsYXQtY29udHJvbD1cIicgKyBfX0ZvckVhY2ggKyAnXCIgcGxhdC1jb250ZXh0PVwibGVmdFwiPlxcbicgK1xyXG4gICAgICAgICAgICAgICAgJyAgICAgICAgPGRpdiBjbGFzcz1cInBsYXQtbmF2YmFyLWl0ZW1cIiBwbGF0LWNvbnRyb2w9XCInICsgX19IdG1sICsgJ1wiIHBsYXQtb3B0aW9ucz1cInsgaHRtbDogY29udGVudCwgY29tcGlsZTogdHJ1ZSB9XCIgcGxhdC10YXA9XCJsZWZ0QWN0aW9uKEBpbmRleClcIj48L2Rpdj5cXG4nICtcclxuICAgICAgICAgICAgICAgICcgICAgPC9kaXY+XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnPC9kaXY+XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInBsYXQtbmF2YmFyLWNlbnRlclwiPlxcbicgK1xyXG4gICAgICAgICAgICAgICAgJyAgICA8ZGl2IGNsYXNzPVwicGxhdC1uYXZiYXItaXRlbXNcIiBwbGF0LWNvbnRyb2w9XCInICsgX19Gb3JFYWNoICsgJ1wiIHBsYXQtY29udGV4dD1cImNlbnRlclwiPlxcbicgK1xyXG4gICAgICAgICAgICAgICAgJyAgICAgICAgPGRpdiBjbGFzcz1cInBsYXQtbmF2YmFyLWl0ZW1cIiBwbGF0LWNvbnRyb2w9XCInICsgX19IdG1sICsgJ1wiIHBsYXQtb3B0aW9ucz1cInsgaHRtbDogY29udGVudCwgY29tcGlsZTogdHJ1ZSB9XCIgcGxhdC10YXA9XCJjZW50ZXJBY3Rpb24oQGluZGV4KVwiPjwvZGl2PlxcbicgK1xyXG4gICAgICAgICAgICAgICAgJyAgICA8L2Rpdj5cXG4nICtcclxuICAgICAgICAgICAgICAgICc8L2Rpdj5cXG4nICtcclxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwicGxhdC1uYXZiYXItcmlnaHRcIj5cXG4nICtcclxuICAgICAgICAgICAgICAgICcgICAgPGRpdiBjbGFzcz1cInBsYXQtbmF2YmFyLWl0ZW1zXCIgcGxhdC1jb250cm9sPVwiJyArIF9fRm9yRWFjaCArICdcIiBwbGF0LWNvbnRleHQ9XCJyaWdodFwiPlxcbicgK1xyXG4gICAgICAgICAgICAgICAgJyAgICAgICAgPGRpdiBjbGFzcz1cInBsYXQtbmF2YmFyLWl0ZW1cIiBwbGF0LWNvbnRyb2w9XCInICsgX19IdG1sICsgJ1wiIHBsYXQtb3B0aW9ucz1cInsgaHRtbDogY29udGVudCwgY29tcGlsZTogdHJ1ZSB9XCIgcGxhdC10YXA9XCJyaWdodEFjdGlvbihAaW5kZXgpXCI+PC9kaXY+XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnICAgIDwvZGl2PlxcbicgK1xyXG4gICAgICAgICAgICAgICAgJzwvZGl2Plxcbic7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgTmF2YmFyIGNvbnRyb2wncyBjb250ZXh0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0ge1xyXG4gICAgICAgICAgICAgICAgbGVmdDogW3tcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogbm9vcFxyXG4gICAgICAgICAgICAgICAgICAgIH1dLFxyXG4gICAgICAgICAgICAgICAgY2VudGVyOiBbe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBub29wXHJcbiAgICAgICAgICAgICAgICAgICAgfV0sXHJcbiAgICAgICAgICAgICAgICByaWdodDogW3tcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogbm9vcFxyXG4gICAgICAgICAgICAgICAgICAgIH1dXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTcGVjaWZpZXMgdGhhdCB0aGUgTmF2YmFyIGRlZmluZXMgaXQncyBvd24gY29udGV4dC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuaGFzT3duQ29udGV4dCA9IHRydWU7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBbiBvYmplY3Qgc3BlY2lmeWluZyB3aGV0aGVyIGEgcGFydGljdWxhciBzZWN0aW9uIG9mIHRoZSBOYXZiYXJcclxuICAgICAgICAgICAgICogaGFzIGJlZW4gb3ZlcnJpZGRlbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX292ZXJyaWRlcyA9IHtcclxuICAgICAgICAgICAgICAgIGxlZnQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY2VudGVyOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHJpZ2h0OiBmYWxzZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBjbGFzc2VzIG9uIHRoZSBwcm9wZXIgZWxlbWVudHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZT8gQW4gb3B0aW9uYWwsIGFkZGl0aW9uYWwgY2xhc3MgbmFtZSBvciBjbGFzcyBuYW1lcyB0byBzZXQgb24gdGhlIGNvbnRyb2xcclxuICAgICAgICAgKiBpbiBhZGRpdGlvbiB0byBpdHMgc3RhbmRhcmQgc2V0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudD8gVGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBjbGFzcyBuYW1lIG9uLiBTaG91bGQgZGVmYXVsdCB0b1xyXG4gICAgICAgICAqIHRoZSBjb250cm9sJ3MgZWxlbWVudCBpZiBub3Qgc3BlY2lmaWVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5hdmJhci5wcm90b3R5cGUuc2V0Q2xhc3NlcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5kb20uYWRkQ2xhc3MoZWxlbWVudCB8fCB0aGlzLmVsZW1lbnQsIF9fTmF2YmFyICsgXCIgXCIgKyAoY2xhc3NOYW1lIHx8ICcnKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdGhlIGNsYXNzIG5hbWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTmF2YmFyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldENsYXNzZXMoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExvb2tzIGZvciBhbmQgYXBwbGllcyBvdmVyd3JpdHRlbiBjb21wb25lbnRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5hdmJhci5wcm90b3R5cGUuc2V0VGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBpc051bGwgPSB0aGlzLnV0aWxzLmlzTnVsbCwgaW5uZXJUZW1wbGF0ZSA9IHRoaXMuaW5uZXJUZW1wbGF0ZTtcclxuICAgICAgICAgICAgaWYgKGlzTnVsbChpbm5lclRlbXBsYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBkb2MgPSB0aGlzLl9kb2N1bWVudCwgb3ZlcnJpZGVzID0gdGhpcy5fb3ZlcnJpZGVzLCBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZSwgYXBwZW5kQ2hpbGRyZW4gPSB0aGlzLmRvbS5hcHBlbmRDaGlsZHJlbiwgY2hpbGROb2RlcyA9IHNsaWNlLmNhbGwoaW5uZXJUZW1wbGF0ZS5jaGlsZE5vZGVzKSwgY2hpbGROb2RlLCBuZXdOb2RlLCBlbGVtZW50ID0gdGhpcy5lbGVtZW50LCBlbGVtZW50Tm9kZXMgPSBzbGljZS5jYWxsKGVsZW1lbnQuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB3aGlsZSAoY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChjaGlsZE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXMubGVmdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUuY2xhc3NOYW1lID0gX19OYXZiYXIgKyBcIi1sZWZ0XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUuc2V0QXR0cmlidXRlKF9fQ29udGV4dCwgJ2xlZnQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZXBsYWNlQ2hpbGQoYXBwZW5kQ2hpbGRyZW4oc2xpY2UuY2FsbChjaGlsZE5vZGUuY2hpbGROb2RlcyksIG5ld05vZGUpLCBlbGVtZW50Tm9kZXNbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjZW50ZXInOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXMuY2VudGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5jbGFzc05hbWUgPSBfX05hdmJhciArIFwiLWNlbnRlclwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLnNldEF0dHJpYnV0ZShfX0NvbnRleHQsICdjZW50ZXInKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZXBsYWNlQ2hpbGQoYXBwZW5kQ2hpbGRyZW4oc2xpY2UuY2FsbChjaGlsZE5vZGUuY2hpbGROb2RlcyksIG5ld05vZGUpLCBlbGVtZW50Tm9kZXNbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlcy5yaWdodCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUuY2xhc3NOYW1lID0gX19OYXZiYXIgKyBcIi1yaWdodFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLnNldEF0dHJpYnV0ZShfX0NvbnRleHQsICdyaWdodCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlcGxhY2VDaGlsZChhcHBlbmRDaGlsZHJlbihzbGljZS5jYWxsKGNoaWxkTm9kZS5jaGlsZE5vZGVzKSwgbmV3Tm9kZSksIGVsZW1lbnROb2Rlc1syXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbml0aWFsaXplcyBhbGwgb3B0aW9ucy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBOYXZiYXIucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbk9iaiA9IHRoaXMub3B0aW9ucyB8fCB7fSwgb3B0aW9ucyA9IG9wdGlvbk9iai52YWx1ZSB8fCB7fSwgcG9zaXRpb24gPSB0aGlzLnV0aWxzLmlzU3RyaW5nKG9wdGlvbnMucG9zaXRpb24pICYmIG9wdGlvbnMucG9zaXRpb24udG9Mb3dlckNhc2UoKSA9PT0gJ2JvdHRvbScgPyAnLWJvdHRvbScgOiAnLXRvcCc7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZENsYXNzKHRoaXMuZWxlbWVudCwgX19OYXZiYXIgKyBwb3NpdGlvbik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBOYXZiYXIucHJvdG90eXBlLnNldExlZnQgPSBmdW5jdGlvbiAoY29tcG9uZW50cykge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRDb21wb25lbnQoJ2xlZnQnLCBjb21wb25lbnRzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE5hdmJhci5wcm90b3R5cGUuc2V0Q2VudGVyID0gZnVuY3Rpb24gKGNvbXBvbmVudHMpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0Q29tcG9uZW50KCdjZW50ZXInLCBjb21wb25lbnRzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE5hdmJhci5wcm90b3R5cGUuc2V0UmlnaHQgPSBmdW5jdGlvbiAoY29tcG9uZW50cykge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRDb21wb25lbnQoJ3JpZ2h0JywgY29tcG9uZW50cyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZGVmaW5lZCBhY3Rpb24gb2YgdGhlIGxlZnQgcGFydCBvZiB0aGUgTmF2YmFyIHdoZW4gdGFwcGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleD8gVGhlIGluZGV4IG9mIHRoZSBhY3Rpb24gdGFwcGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JR2VzdHVyZUV2ZW50fSBldj8gVGhlIFwiJHRhcFwiIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5hdmJhci5wcm90b3R5cGUubGVmdEFjdGlvbiA9IGZ1bmN0aW9uIChpbmRleCwgZXYpIHtcclxuICAgICAgICAgICAgdGhpcy5fZXhlY3V0ZUFjdGlvbihldiwgJ2xlZnQnLCBpbmRleCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZGVmaW5lZCBhY3Rpb24gb2YgdGhlIGNlbnRlciBwYXJ0IG9mIHRoZSBOYXZiYXIgd2hlbiB0YXBwZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4PyBUaGUgaW5kZXggb2YgdGhlIGFjdGlvbiB0YXBwZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklHZXN0dXJlRXZlbnR9IGV2PyBUaGUgXCIkdGFwXCIgZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTmF2YmFyLnByb3RvdHlwZS5jZW50ZXJBY3Rpb24gPSBmdW5jdGlvbiAoaW5kZXgsIGV2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2V4ZWN1dGVBY3Rpb24oZXYsICdjZW50ZXInLCBpbmRleCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZGVmaW5lZCBhY3Rpb24gb2YgdGhlIHJpZ2h0IHBhcnQgb2YgdGhlIE5hdmJhciB3aGVuIHRhcHBlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXg/IFRoZSBpbmRleCBvZiB0aGUgYWN0aW9uIHRhcHBlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSUdlc3R1cmVFdmVudH0gZXY/IFRoZSBcIiR0YXBcIiBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBOYXZiYXIucHJvdG90eXBlLnJpZ2h0QWN0aW9uID0gZnVuY3Rpb24gKGluZGV4LCBldikge1xyXG4gICAgICAgICAgICB0aGlzLl9leGVjdXRlQWN0aW9uKGV2LCAncmlnaHQnLCBpbmRleCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBOYXZiYXIucHJvdG90eXBlLl9zZXRDb21wb25lbnQgPSBmdW5jdGlvbiAocG9zaXRpb24sIGNvbXBvbmVudHMpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy51dGlscy5pc0FycmF5KGNvbXBvbmVudHMpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3ZlcnJpZGVzW3Bvc2l0aW9uXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlQ29tcG9uZW50KGNvbXBvbmVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRbcG9zaXRpb25dID0gY29tcG9uZW50cztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzID0gW2NvbXBvbmVudHNdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjdXJyID0gY29tcG9uZW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHdoaWxlIChjdXJyLS0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUNvbXBvbmVudChjb21wb25lbnRzW2N1cnJdLCBjb250ZXh0W3Bvc2l0aW9uXVtjdXJyXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGV4dFtwb3NpdGlvbl0gPSBjb21wb25lbnRzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyBkZWZhdWx0IGNvbXBvbmVudCBwYXJhbWV0ZXJzIGFuZCBncmFicyBjdXN0b20gYWN0aW9ucyBmcm9tIGl0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdHVpLklOYXZiYXJDb21wb25lbnR9IG5ld0NvbXBvbmVudCBUaGUgbmV3IElOYXZiYXJDb21wb25lbnRcclxuICAgICAgICAgKiB0byBwYXJzZS5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXR1aS5JTmF2YmFyQ29tcG9uZW50fSBvbGRDb21wb25lbnQ/IFRoZSBvbGQgSU5hdmJhckNvbXBvbmVudFxyXG4gICAgICAgICAqIHdob3NlIHBsYWNlIGlzIGJlaW5nIHRha2VuLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5hdmJhci5wcm90b3R5cGUuX3BhcnNlQ29tcG9uZW50ID0gZnVuY3Rpb24gKG5ld0NvbXBvbmVudCwgb2xkQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIHZhciB1dGlscyA9IHRoaXMudXRpbHMsIGlzT2JqZWN0ID0gdXRpbHMuaXNPYmplY3QsIG9sZENvbXBvbmVudEV4aXN0cyA9IGlzT2JqZWN0KG9sZENvbXBvbmVudCksIGN1c3RvbUFjdGlvbnMsIGtleXMsIGtleSwgY3VycktleTtcclxuICAgICAgICAgICAgaWYgKG9sZENvbXBvbmVudEV4aXN0cyAmJiB1dGlscy5pc1VuZGVmaW5lZChuZXdDb21wb25lbnQuY29udGVudCkpIHtcclxuICAgICAgICAgICAgICAgIG5ld0NvbXBvbmVudC5jb250ZW50ID0gb2xkQ29tcG9uZW50LmNvbnRlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF1dGlscy5pc0Z1bmN0aW9uKG5ld0NvbXBvbmVudC5hY3Rpb24pKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdDb21wb25lbnQuYWN0aW9uID0gb2xkQ29tcG9uZW50RXhpc3RzID8gb2xkQ29tcG9uZW50LmFjdGlvbiA6IG5vb3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VzdG9tQWN0aW9ucyA9IG5ld0NvbXBvbmVudC5jdXN0b21BY3Rpb25zO1xyXG4gICAgICAgICAgICBpZiAoaXNPYmplY3QoY3VzdG9tQWN0aW9ucykpIHtcclxuICAgICAgICAgICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhjdXN0b21BY3Rpb25zKTtcclxuICAgICAgICAgICAgICAgIGN1cnJLZXkgPSBrZXlzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJyS2V5LS0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5c1tjdXJyS2V5XTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSBjdXN0b21BY3Rpb25zW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEV4ZWN1dGVzIHRoZSBwcm9wZXIgYWN0aW9uIGFzc29jaWF0ZWQgd2l0aCBhIE5hdmJhciBjb21wb25lbnQuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklHZXN0dXJlRXZlbnR9IGV2IFRoZSBleGVjdXRlZCBldmVudC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcG9zaXRpb24gVGhlIHBhcnQgb2YgdGhlIE5hdmJhciB3aG9zZSBhY3Rpb24gaXMgYmVpbmcgZXhlY3V0ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IHByb3BlcnR5PyBUaGUgaW5kZXhpbmcgcHJvcGVydHkuIFdpbGwgYnkgZGVmYXVsdCBiZSBhbiBpbmRleCBpbnRvIHRoZSBjb21wb25lbnQgQXJyYXkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTmF2YmFyLnByb3RvdHlwZS5fZXhlY3V0ZUFjdGlvbiA9IGZ1bmN0aW9uIChldiwgcG9zaXRpb24sIHByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgIHZhciB1dGlscyA9IHRoaXMudXRpbHMsIGNvbXBvbmVudCA9IHRoaXMuY29udGV4dFtwb3NpdGlvbl07XHJcbiAgICAgICAgICAgIGlmICh1dGlscy5pc0FycmF5KGNvbXBvbmVudCkgJiYgIXV0aWxzLmlzTnVsbChwcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudFtwcm9wZXJ0eV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24oY29tcG9uZW50LmFjdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5hY3Rpb24oZXYpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhcIkFuIGFjdGlvbiBmdW5jdGlvbiBpcyBub3QgZGVmaW5lZCBmb3IgdGhlIGNvbXBvbmVudCBcIiArIGNvbXBvbmVudCArIFwiLlwiKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE5hdmJhci5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICBfZG9jdW1lbnQ6IF9fRG9jdW1lbnRcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBOYXZiYXI7XHJcbiAgICB9KHBsYXQudWkuVGVtcGxhdGVDb250cm9sKSk7XHJcbiAgICBwbGF0dWkuTmF2YmFyID0gTmF2YmFyO1xyXG4gICAgcGxhdC5yZWdpc3Rlci5jb250cm9sKF9fTmF2YmFyLCBOYXZiYXIsIG51bGwsIHRydWUpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBUZW1wbGF0ZUNvbnRyb2wgdGhhdCBrZWVwcyB0cmFjayBvZiBhIGxvYWRpbmcgaW1hZ2UuXHJcbiAgICAgKi9cclxuICAgIHZhciBJbWFnZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEltYWdlLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEltYWdlKCkge1xyXG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBIVE1MIHRlbXBsYXRlIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZVN0cmluZyA9ICc8ZGl2IHBsYXQtY29udHJvbD1cIicgKyBfX1Byb2dyZXNzUmluZyArICdcIiBjbGFzcz1cInBsYXQtaW1hZ2UtcmluZ1wiPjwvZGl2Plxcbic7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgaW1hZ2UgaXMgYSBDU1MgYmFja2dyb3VuZCBpbWFnZS4gRGVmYXVsdHMgdG8gZmFsc2UuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9pc0JhY2tncm91bmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBIVE1MSW1hZ2VFbGVtZW50IHVzZSB0byBzb3VyY2UgdGhlIGltYWdlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5faW1nID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGNsYXNzZXMgb24gdGhlIHByb3BlciBlbGVtZW50cy5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lPyBBbiBvcHRpb25hbCwgYWRkaXRpb25hbCBjbGFzcyBuYW1lIG9yIGNsYXNzIG5hbWVzIHRvIHNldCBvbiB0aGUgY29udHJvbFxyXG4gICAgICAgICAqIGluIGFkZGl0aW9uIHRvIGl0cyBzdGFuZGFyZCBzZXQuXHJcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50PyBUaGUgZWxlbWVudCB0byBzZXQgdGhlIGNsYXNzIG5hbWUgb24uIFNob3VsZCBkZWZhdWx0IHRvXHJcbiAgICAgICAgICogdGhlIGNvbnRyb2wncyBlbGVtZW50IGlmIG5vdCBzcGVjaWZpZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgSW1hZ2UucHJvdG90eXBlLnNldENsYXNzZXMgPSBmdW5jdGlvbiAoY2xhc3NOYW1lLCBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZENsYXNzKGVsZW1lbnQgfHwgdGhpcy5lbGVtZW50LCBfX0ltYWdlICsgXCIgXCIgKyAoY2xhc3NOYW1lIHx8ICcnKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdGhlIGNsYXNzIG5hbWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgSW1hZ2UucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0Q2xhc3NlcygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IHRoZSBzdHlsZSBhbmQgaW5pdGlhbGl6ZSB0aGUgYWN0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEltYWdlLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LCB1dGlscyA9IHRoaXMudXRpbHMsIGlzU3RyaW5nID0gdXRpbHMuaXNTdHJpbmcsIGlzT2JqZWN0ID0gdXRpbHMuaXNPYmplY3QsIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXMsIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsIHVybDtcclxuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKHVybCA9IGF0dHJpYnV0ZXNbX19DYW1lbFNyY10pKSB7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLm9ic2VydmUodGhpcy5fc2V0U3JjLCBfX0NhbWVsU3JjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1N0cmluZyh1cmwgPSBhdHRyaWJ1dGVzW19fc3JjXSkpIHtcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMub2JzZXJ2ZSh0aGlzLl9zZXRTcmMsIF9fc3JjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykgJiYgaXNPYmplY3Qob3B0aW9ucy52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzQmFja2dyb3VuZCA9IG9wdGlvbnMudmFsdWUuaXNCYWNrZ3JvdW5kID09PSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0JhY2tncm91bmQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmFkZENsYXNzKGVsZW1lbnQsIF9fUGxhdCArIFwiYmFja2dyb3VuZFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9sb2FkZXIgPSBlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fTm9kZU1hbmFnZXJTdGF0aWMuaGFzTWFya3VwKHVybCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zZXRTcmModXJsKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgYW5kIHNvdXJjZXMgdGhlIGltYWdlIHRvIGRpc3BsYXkuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgc291cmNlIFVSTCB0byBkaXNwbGF5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvbGRVcmw/IFRoZSBvbGQgc291cmNlIFVSTCB0aGF0IHdhcyBiZWluZyBkaXNwbGF5ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgSW1hZ2UucHJvdG90eXBlLl9zZXRTcmMgPSBmdW5jdGlvbiAodXJsLCBvbGRVcmwpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGltZyA9IHRoaXMuX2ltZywgZWxlbWVudCA9IHRoaXMuZWxlbWVudCwgZG9tID0gdGhpcy5kb20sIGltYWdlTG9hZCA9IF9fUGxhdCArIFwibG9hZC1pbWFnZVwiLCBpbWFnZUVycm9yID0gX19JbWFnZSArIFwiLWVycm9yXCIsIGxvYWRlciA9IHRoaXMuX2xvYWRlcjtcclxuICAgICAgICAgICAgZG9tLmFkZENsYXNzKGltZywgaW1hZ2VMb2FkKTtcclxuICAgICAgICAgICAgaW1nLnNyYyA9IHVybDtcclxuICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGVycm9yIGNsYXNzIGluIGNhc2UgaW1hZ2UgZmFpbGVkIGFuZCB0aGVuIGRlY2lkZXMgdG8gbG9hZCBcclxuICAgICAgICAgICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoZWxlbWVudCwgaW1hZ2VFcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9pc0JhY2tncm91bmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBcInVybChcXFwiXCIgKyB1cmwgKyBcIlxcXCIpXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmNvbnRhaW5zKGltZykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoaW1nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5jb250YWlucyhsb2FkZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUNoaWxkKGxvYWRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoaW1nLCBpbWFnZUxvYWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmNvbnRhaW5zKGxvYWRlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVDaGlsZChsb2FkZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpbWcub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9tLmFkZENsYXNzKGVsZW1lbnQsIGltYWdlRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmNvbnRhaW5zKGltZykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVDaGlsZChpbWcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5jb250YWlucyhsb2FkZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQobG9hZGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZWxlbWVudC5pbnNlcnRCZWZvcmUobG9hZGVyLCBudWxsKTtcclxuICAgICAgICAgICAgZWxlbWVudC5pbnNlcnRCZWZvcmUoaW1nLCBudWxsKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEltYWdlLl9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgIF9jb21wYXQ6IF9fQ29tcGF0LFxyXG4gICAgICAgICAgICBfZG9jdW1lbnQ6IF9fRG9jdW1lbnQsXHJcbiAgICAgICAgICAgIF9Ob2RlTWFuYWdlclN0YXRpYzogX19Ob2RlTWFuYWdlclN0YXRpY1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEltYWdlO1xyXG4gICAgfShwbGF0LnVpLlRlbXBsYXRlQ29udHJvbCkpO1xyXG4gICAgcGxhdHVpLkltYWdlID0gSW1hZ2U7XHJcbiAgICBwbGF0LnJlZ2lzdGVyLmNvbnRyb2woX19JbWFnZSwgSW1hZ2UpO1xyXG59KShwbGF0dWkgfHwgKHBsYXR1aSA9IHt9KSk7XHJcbm1vZHVsZS5leHBvcnRzID0gcGxhdHVpO1xyXG4iXX0=
